import { c as G, m as ie, a as Se, h as oe, b as Me, d as Ve, l as An, t as er, s as Zo, e as Gc } from "./index-d653805f.js";
import { b as yn, a as _n, r as $c, s as Kc, c as zc, d as Qo } from "./index-005ea00d.js";
import { b as tt, t as Yc, a as Xc } from "./index-a345f105.js";
import { b as Fo } from "./index-8e30cada.js";
function xc(e, n) {
  for (var c = 0; c < n.length; c++) {
    const i = n[c];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in e)) {
          const u = Object.getOwnPropertyDescriptor(i, r);
          u && Object.defineProperty(e, r, u.get ? u : {
            enumerable: !0,
            get: () => i[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Bd = {}, nr = {}, Lr = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(M, V, D, b) {
    b === void 0 && (b = D);
    var h = Object.getOwnPropertyDescriptor(V, D);
    (!h || ("get" in h ? !V.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return V[D];
    } }), Object.defineProperty(M, b, h);
  } : function(M, V, D, b) {
    b === void 0 && (b = D), M[b] = V[D];
  }), c = G && G.__setModuleDefault || (Object.create ? function(M, V) {
    Object.defineProperty(M, "default", { enumerable: !0, value: V });
  } : function(M, V) {
    M.default = V;
  }), i = G && G.__importStar || function(M) {
    if (M && M.__esModule)
      return M;
    var V = {};
    if (M != null)
      for (var D in M)
        D !== "default" && Object.prototype.hasOwnProperty.call(M, D) && n(V, M, D);
    return c(V, M), V;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.ModuleCredential = e.ModuleAccount = e.BaseAccount = e.protobufPackage = void 0;
  const r = Se, u = oe, f = i(ie);
  e.protobufPackage = "cosmos.auth.v1beta1";
  function O() {
    return {
      address: "",
      pubKey: void 0,
      accountNumber: u.Long.UZERO,
      sequence: u.Long.UZERO
    };
  }
  e.BaseAccount = {
    encode(M, V = f.Writer.create()) {
      return M.address !== "" && V.uint32(10).string(M.address), M.pubKey !== void 0 && r.Any.encode(M.pubKey, V.uint32(18).fork()).ldelim(), M.accountNumber.isZero() || V.uint32(24).uint64(M.accountNumber), M.sequence.isZero() || V.uint32(32).uint64(M.sequence), V;
    },
    decode(M, V) {
      const D = M instanceof f.Reader ? M : new f.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = O();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.address = D.string();
            break;
          case 2:
            h.pubKey = r.Any.decode(D, D.uint32());
            break;
          case 3:
            h.accountNumber = D.uint64();
            break;
          case 4:
            h.sequence = D.uint64();
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        address: (0, u.isSet)(M.address) ? String(M.address) : "",
        pubKey: (0, u.isSet)(M.pubKey) ? r.Any.fromJSON(M.pubKey) : void 0,
        accountNumber: (0, u.isSet)(M.accountNumber) ? u.Long.fromValue(M.accountNumber) : u.Long.UZERO,
        sequence: (0, u.isSet)(M.sequence) ? u.Long.fromValue(M.sequence) : u.Long.UZERO
      };
    },
    toJSON(M) {
      const V = {};
      return M.address !== void 0 && (V.address = M.address), M.pubKey !== void 0 && (V.pubKey = M.pubKey ? r.Any.toJSON(M.pubKey) : void 0), M.accountNumber !== void 0 && (V.accountNumber = (M.accountNumber || u.Long.UZERO).toString()), M.sequence !== void 0 && (V.sequence = (M.sequence || u.Long.UZERO).toString()), V;
    },
    fromPartial(M) {
      const V = O();
      return V.address = M.address ?? "", V.pubKey = M.pubKey !== void 0 && M.pubKey !== null ? r.Any.fromPartial(M.pubKey) : void 0, V.accountNumber = M.accountNumber !== void 0 && M.accountNumber !== null ? u.Long.fromValue(M.accountNumber) : u.Long.UZERO, V.sequence = M.sequence !== void 0 && M.sequence !== null ? u.Long.fromValue(M.sequence) : u.Long.UZERO, V;
    }
  };
  function A() {
    return {
      baseAccount: void 0,
      name: "",
      permissions: []
    };
  }
  e.ModuleAccount = {
    encode(M, V = f.Writer.create()) {
      M.baseAccount !== void 0 && e.BaseAccount.encode(M.baseAccount, V.uint32(10).fork()).ldelim(), M.name !== "" && V.uint32(18).string(M.name);
      for (const D of M.permissions)
        V.uint32(26).string(D);
      return V;
    },
    decode(M, V) {
      const D = M instanceof f.Reader ? M : new f.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = A();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.baseAccount = e.BaseAccount.decode(D, D.uint32());
            break;
          case 2:
            h.name = D.string();
            break;
          case 3:
            h.permissions.push(D.string());
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        baseAccount: (0, u.isSet)(M.baseAccount) ? e.BaseAccount.fromJSON(M.baseAccount) : void 0,
        name: (0, u.isSet)(M.name) ? String(M.name) : "",
        permissions: Array.isArray(M == null ? void 0 : M.permissions) ? M.permissions.map((V) => String(V)) : []
      };
    },
    toJSON(M) {
      const V = {};
      return M.baseAccount !== void 0 && (V.baseAccount = M.baseAccount ? e.BaseAccount.toJSON(M.baseAccount) : void 0), M.name !== void 0 && (V.name = M.name), M.permissions ? V.permissions = M.permissions.map((D) => D) : V.permissions = [], V;
    },
    fromPartial(M) {
      var D;
      const V = A();
      return V.baseAccount = M.baseAccount !== void 0 && M.baseAccount !== null ? e.BaseAccount.fromPartial(M.baseAccount) : void 0, V.name = M.name ?? "", V.permissions = ((D = M.permissions) == null ? void 0 : D.map((b) => b)) || [], V;
    }
  };
  function T() {
    return {
      moduleName: "",
      derivationKeys: []
    };
  }
  e.ModuleCredential = {
    encode(M, V = f.Writer.create()) {
      M.moduleName !== "" && V.uint32(10).string(M.moduleName);
      for (const D of M.derivationKeys)
        V.uint32(18).bytes(D);
      return V;
    },
    decode(M, V) {
      const D = M instanceof f.Reader ? M : new f.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = T();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.moduleName = D.string();
            break;
          case 2:
            h.derivationKeys.push(D.bytes());
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        moduleName: (0, u.isSet)(M.moduleName) ? String(M.moduleName) : "",
        derivationKeys: Array.isArray(M == null ? void 0 : M.derivationKeys) ? M.derivationKeys.map((V) => (0, u.bytesFromBase64)(V)) : []
      };
    },
    toJSON(M) {
      const V = {};
      return M.moduleName !== void 0 && (V.moduleName = M.moduleName), M.derivationKeys ? V.derivationKeys = M.derivationKeys.map((D) => (0, u.base64FromBytes)(D !== void 0 ? D : new Uint8Array())) : V.derivationKeys = [], V;
    },
    fromPartial(M) {
      var D;
      const V = T();
      return V.moduleName = M.moduleName ?? "", V.derivationKeys = ((D = M.derivationKeys) == null ? void 0 : D.map((b) => b)) || [], V;
    }
  };
  function L() {
    return {
      maxMemoCharacters: u.Long.UZERO,
      txSigLimit: u.Long.UZERO,
      txSizeCostPerByte: u.Long.UZERO,
      sigVerifyCostEd25519: u.Long.UZERO,
      sigVerifyCostSecp256k1: u.Long.UZERO
    };
  }
  e.Params = {
    encode(M, V = f.Writer.create()) {
      return M.maxMemoCharacters.isZero() || V.uint32(8).uint64(M.maxMemoCharacters), M.txSigLimit.isZero() || V.uint32(16).uint64(M.txSigLimit), M.txSizeCostPerByte.isZero() || V.uint32(24).uint64(M.txSizeCostPerByte), M.sigVerifyCostEd25519.isZero() || V.uint32(32).uint64(M.sigVerifyCostEd25519), M.sigVerifyCostSecp256k1.isZero() || V.uint32(40).uint64(M.sigVerifyCostSecp256k1), V;
    },
    decode(M, V) {
      const D = M instanceof f.Reader ? M : new f.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = L();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.maxMemoCharacters = D.uint64();
            break;
          case 2:
            h.txSigLimit = D.uint64();
            break;
          case 3:
            h.txSizeCostPerByte = D.uint64();
            break;
          case 4:
            h.sigVerifyCostEd25519 = D.uint64();
            break;
          case 5:
            h.sigVerifyCostSecp256k1 = D.uint64();
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        maxMemoCharacters: (0, u.isSet)(M.maxMemoCharacters) ? u.Long.fromValue(M.maxMemoCharacters) : u.Long.UZERO,
        txSigLimit: (0, u.isSet)(M.txSigLimit) ? u.Long.fromValue(M.txSigLimit) : u.Long.UZERO,
        txSizeCostPerByte: (0, u.isSet)(M.txSizeCostPerByte) ? u.Long.fromValue(M.txSizeCostPerByte) : u.Long.UZERO,
        sigVerifyCostEd25519: (0, u.isSet)(M.sigVerifyCostEd25519) ? u.Long.fromValue(M.sigVerifyCostEd25519) : u.Long.UZERO,
        sigVerifyCostSecp256k1: (0, u.isSet)(M.sigVerifyCostSecp256k1) ? u.Long.fromValue(M.sigVerifyCostSecp256k1) : u.Long.UZERO
      };
    },
    toJSON(M) {
      const V = {};
      return M.maxMemoCharacters !== void 0 && (V.maxMemoCharacters = (M.maxMemoCharacters || u.Long.UZERO).toString()), M.txSigLimit !== void 0 && (V.txSigLimit = (M.txSigLimit || u.Long.UZERO).toString()), M.txSizeCostPerByte !== void 0 && (V.txSizeCostPerByte = (M.txSizeCostPerByte || u.Long.UZERO).toString()), M.sigVerifyCostEd25519 !== void 0 && (V.sigVerifyCostEd25519 = (M.sigVerifyCostEd25519 || u.Long.UZERO).toString()), M.sigVerifyCostSecp256k1 !== void 0 && (V.sigVerifyCostSecp256k1 = (M.sigVerifyCostSecp256k1 || u.Long.UZERO).toString()), V;
    },
    fromPartial(M) {
      const V = L();
      return V.maxMemoCharacters = M.maxMemoCharacters !== void 0 && M.maxMemoCharacters !== null ? u.Long.fromValue(M.maxMemoCharacters) : u.Long.UZERO, V.txSigLimit = M.txSigLimit !== void 0 && M.txSigLimit !== null ? u.Long.fromValue(M.txSigLimit) : u.Long.UZERO, V.txSizeCostPerByte = M.txSizeCostPerByte !== void 0 && M.txSizeCostPerByte !== null ? u.Long.fromValue(M.txSizeCostPerByte) : u.Long.UZERO, V.sigVerifyCostEd25519 = M.sigVerifyCostEd25519 !== void 0 && M.sigVerifyCostEd25519 !== null ? u.Long.fromValue(M.sigVerifyCostEd25519) : u.Long.UZERO, V.sigVerifyCostSecp256k1 = M.sigVerifyCostSecp256k1 !== void 0 && M.sigVerifyCostSecp256k1 !== null ? u.Long.fromValue(M.sigVerifyCostSecp256k1) : u.Long.UZERO, V;
    }
  };
})(Lr);
var Go = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(b, h, S, _) {
    _ === void 0 && (_ = S);
    var d = Object.getOwnPropertyDescriptor(h, S);
    (!d || ("get" in d ? !h.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return h[S];
    } }), Object.defineProperty(b, _, d);
  } : function(b, h, S, _) {
    _ === void 0 && (_ = S), b[_] = h[S];
  }), c = G && G.__setModuleDefault || (Object.create ? function(b, h) {
    Object.defineProperty(b, "default", { enumerable: !0, value: h });
  } : function(b, h) {
    b.default = h;
  }), i = G && G.__importStar || function(b) {
    if (b && b.__esModule)
      return b;
    var h = {};
    if (b != null)
      for (var S in b)
        S !== "default" && Object.prototype.hasOwnProperty.call(b, S) && n(h, b, S);
    return c(h, b), h;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.PermanentLockedAccount = e.PeriodicVestingAccount = e.Period = e.DelayedVestingAccount = e.ContinuousVestingAccount = e.BaseVestingAccount = e.protobufPackage = void 0;
  const r = Lr, u = Me, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function A() {
    return {
      baseAccount: void 0,
      originalVesting: [],
      delegatedFree: [],
      delegatedVesting: [],
      endTime: f.Long.ZERO
    };
  }
  e.BaseVestingAccount = {
    encode(b, h = O.Writer.create()) {
      b.baseAccount !== void 0 && r.BaseAccount.encode(b.baseAccount, h.uint32(10).fork()).ldelim();
      for (const S of b.originalVesting)
        u.Coin.encode(S, h.uint32(18).fork()).ldelim();
      for (const S of b.delegatedFree)
        u.Coin.encode(S, h.uint32(26).fork()).ldelim();
      for (const S of b.delegatedVesting)
        u.Coin.encode(S, h.uint32(34).fork()).ldelim();
      return b.endTime.isZero() || h.uint32(40).int64(b.endTime), h;
    },
    decode(b, h) {
      const S = b instanceof O.Reader ? b : new O.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = A();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseAccount = r.BaseAccount.decode(S, S.uint32());
            break;
          case 2:
            d.originalVesting.push(u.Coin.decode(S, S.uint32()));
            break;
          case 3:
            d.delegatedFree.push(u.Coin.decode(S, S.uint32()));
            break;
          case 4:
            d.delegatedVesting.push(u.Coin.decode(S, S.uint32()));
            break;
          case 5:
            d.endTime = S.int64();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        baseAccount: (0, f.isSet)(b.baseAccount) ? r.BaseAccount.fromJSON(b.baseAccount) : void 0,
        originalVesting: Array.isArray(b == null ? void 0 : b.originalVesting) ? b.originalVesting.map((h) => u.Coin.fromJSON(h)) : [],
        delegatedFree: Array.isArray(b == null ? void 0 : b.delegatedFree) ? b.delegatedFree.map((h) => u.Coin.fromJSON(h)) : [],
        delegatedVesting: Array.isArray(b == null ? void 0 : b.delegatedVesting) ? b.delegatedVesting.map((h) => u.Coin.fromJSON(h)) : [],
        endTime: (0, f.isSet)(b.endTime) ? f.Long.fromValue(b.endTime) : f.Long.ZERO
      };
    },
    toJSON(b) {
      const h = {};
      return b.baseAccount !== void 0 && (h.baseAccount = b.baseAccount ? r.BaseAccount.toJSON(b.baseAccount) : void 0), b.originalVesting ? h.originalVesting = b.originalVesting.map((S) => S ? u.Coin.toJSON(S) : void 0) : h.originalVesting = [], b.delegatedFree ? h.delegatedFree = b.delegatedFree.map((S) => S ? u.Coin.toJSON(S) : void 0) : h.delegatedFree = [], b.delegatedVesting ? h.delegatedVesting = b.delegatedVesting.map((S) => S ? u.Coin.toJSON(S) : void 0) : h.delegatedVesting = [], b.endTime !== void 0 && (h.endTime = (b.endTime || f.Long.ZERO).toString()), h;
    },
    fromPartial(b) {
      var S, _, d;
      const h = A();
      return h.baseAccount = b.baseAccount !== void 0 && b.baseAccount !== null ? r.BaseAccount.fromPartial(b.baseAccount) : void 0, h.originalVesting = ((S = b.originalVesting) == null ? void 0 : S.map((p) => u.Coin.fromPartial(p))) || [], h.delegatedFree = ((_ = b.delegatedFree) == null ? void 0 : _.map((p) => u.Coin.fromPartial(p))) || [], h.delegatedVesting = ((d = b.delegatedVesting) == null ? void 0 : d.map((p) => u.Coin.fromPartial(p))) || [], h.endTime = b.endTime !== void 0 && b.endTime !== null ? f.Long.fromValue(b.endTime) : f.Long.ZERO, h;
    }
  };
  function T() {
    return {
      baseVestingAccount: void 0,
      startTime: f.Long.ZERO
    };
  }
  e.ContinuousVestingAccount = {
    encode(b, h = O.Writer.create()) {
      return b.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(b.baseVestingAccount, h.uint32(10).fork()).ldelim(), b.startTime.isZero() || h.uint32(16).int64(b.startTime), h;
    },
    decode(b, h) {
      const S = b instanceof O.Reader ? b : new O.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = T();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          case 2:
            d.startTime = S.int64();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        baseVestingAccount: (0, f.isSet)(b.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(b.baseVestingAccount) : void 0,
        startTime: (0, f.isSet)(b.startTime) ? f.Long.fromValue(b.startTime) : f.Long.ZERO
      };
    },
    toJSON(b) {
      const h = {};
      return b.baseVestingAccount !== void 0 && (h.baseVestingAccount = b.baseVestingAccount ? e.BaseVestingAccount.toJSON(b.baseVestingAccount) : void 0), b.startTime !== void 0 && (h.startTime = (b.startTime || f.Long.ZERO).toString()), h;
    },
    fromPartial(b) {
      const h = T();
      return h.baseVestingAccount = b.baseVestingAccount !== void 0 && b.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(b.baseVestingAccount) : void 0, h.startTime = b.startTime !== void 0 && b.startTime !== null ? f.Long.fromValue(b.startTime) : f.Long.ZERO, h;
    }
  };
  function L() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.DelayedVestingAccount = {
    encode(b, h = O.Writer.create()) {
      return b.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(b.baseVestingAccount, h.uint32(10).fork()).ldelim(), h;
    },
    decode(b, h) {
      const S = b instanceof O.Reader ? b : new O.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = L();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        baseVestingAccount: (0, f.isSet)(b.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(b.baseVestingAccount) : void 0
      };
    },
    toJSON(b) {
      const h = {};
      return b.baseVestingAccount !== void 0 && (h.baseVestingAccount = b.baseVestingAccount ? e.BaseVestingAccount.toJSON(b.baseVestingAccount) : void 0), h;
    },
    fromPartial(b) {
      const h = L();
      return h.baseVestingAccount = b.baseVestingAccount !== void 0 && b.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(b.baseVestingAccount) : void 0, h;
    }
  };
  function M() {
    return {
      length: f.Long.ZERO,
      amount: []
    };
  }
  e.Period = {
    encode(b, h = O.Writer.create()) {
      b.length.isZero() || h.uint32(8).int64(b.length);
      for (const S of b.amount)
        u.Coin.encode(S, h.uint32(18).fork()).ldelim();
      return h;
    },
    decode(b, h) {
      const S = b instanceof O.Reader ? b : new O.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = M();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.length = S.int64();
            break;
          case 2:
            d.amount.push(u.Coin.decode(S, S.uint32()));
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        length: (0, f.isSet)(b.length) ? f.Long.fromValue(b.length) : f.Long.ZERO,
        amount: Array.isArray(b == null ? void 0 : b.amount) ? b.amount.map((h) => u.Coin.fromJSON(h)) : []
      };
    },
    toJSON(b) {
      const h = {};
      return b.length !== void 0 && (h.length = (b.length || f.Long.ZERO).toString()), b.amount ? h.amount = b.amount.map((S) => S ? u.Coin.toJSON(S) : void 0) : h.amount = [], h;
    },
    fromPartial(b) {
      var S;
      const h = M();
      return h.length = b.length !== void 0 && b.length !== null ? f.Long.fromValue(b.length) : f.Long.ZERO, h.amount = ((S = b.amount) == null ? void 0 : S.map((_) => u.Coin.fromPartial(_))) || [], h;
    }
  };
  function V() {
    return {
      baseVestingAccount: void 0,
      startTime: f.Long.ZERO,
      vestingPeriods: []
    };
  }
  e.PeriodicVestingAccount = {
    encode(b, h = O.Writer.create()) {
      b.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(b.baseVestingAccount, h.uint32(10).fork()).ldelim(), b.startTime.isZero() || h.uint32(16).int64(b.startTime);
      for (const S of b.vestingPeriods)
        e.Period.encode(S, h.uint32(26).fork()).ldelim();
      return h;
    },
    decode(b, h) {
      const S = b instanceof O.Reader ? b : new O.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = V();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          case 2:
            d.startTime = S.int64();
            break;
          case 3:
            d.vestingPeriods.push(e.Period.decode(S, S.uint32()));
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        baseVestingAccount: (0, f.isSet)(b.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(b.baseVestingAccount) : void 0,
        startTime: (0, f.isSet)(b.startTime) ? f.Long.fromValue(b.startTime) : f.Long.ZERO,
        vestingPeriods: Array.isArray(b == null ? void 0 : b.vestingPeriods) ? b.vestingPeriods.map((h) => e.Period.fromJSON(h)) : []
      };
    },
    toJSON(b) {
      const h = {};
      return b.baseVestingAccount !== void 0 && (h.baseVestingAccount = b.baseVestingAccount ? e.BaseVestingAccount.toJSON(b.baseVestingAccount) : void 0), b.startTime !== void 0 && (h.startTime = (b.startTime || f.Long.ZERO).toString()), b.vestingPeriods ? h.vestingPeriods = b.vestingPeriods.map((S) => S ? e.Period.toJSON(S) : void 0) : h.vestingPeriods = [], h;
    },
    fromPartial(b) {
      var S;
      const h = V();
      return h.baseVestingAccount = b.baseVestingAccount !== void 0 && b.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(b.baseVestingAccount) : void 0, h.startTime = b.startTime !== void 0 && b.startTime !== null ? f.Long.fromValue(b.startTime) : f.Long.ZERO, h.vestingPeriods = ((S = b.vestingPeriods) == null ? void 0 : S.map((_) => e.Period.fromPartial(_))) || [], h;
    }
  };
  function D() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.PermanentLockedAccount = {
    encode(b, h = O.Writer.create()) {
      return b.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(b.baseVestingAccount, h.uint32(10).fork()).ldelim(), h;
    },
    decode(b, h) {
      const S = b instanceof O.Reader ? b : new O.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = D();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        baseVestingAccount: (0, f.isSet)(b.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(b.baseVestingAccount) : void 0
      };
    },
    toJSON(b) {
      const h = {};
      return b.baseVestingAccount !== void 0 && (h.baseVestingAccount = b.baseVestingAccount ? e.BaseVestingAccount.toJSON(b.baseVestingAccount) : void 0), h;
    },
    fromPartial(b) {
      const h = D();
      return h.baseVestingAccount = b.baseVestingAccount !== void 0 && b.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(b.baseVestingAccount) : void 0, h;
    }
  };
})(Go);
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.accountFromAny = void 0;
const jc = _n, el = tt, Ht = yn, es = Lr, cr = Go;
function ns(e) {
  return jc.Uint64.fromString(e.toString());
}
function dt(e) {
  const { address: n, pubKey: c, accountNumber: i, sequence: r } = e, u = c ? (0, el.decodePubkey)(c) : null;
  return {
    address: n,
    pubkey: u,
    accountNumber: ns(i).toNumber(),
    sequence: ns(r).toNumber()
  };
}
function nl(e) {
  var i, r, u, f, O, A, T;
  const { typeUrl: n, value: c } = e;
  switch (n) {
    case "/cosmos.auth.v1beta1.BaseAccount":
      return dt(es.BaseAccount.decode(c));
    case "/cosmos.auth.v1beta1.ModuleAccount": {
      const L = es.ModuleAccount.decode(c).baseAccount;
      return (0, Ht.assert)(L), dt(L);
    }
    case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
      const L = (i = cr.BaseVestingAccount.decode(c)) == null ? void 0 : i.baseAccount;
      return (0, Ht.assert)(L), dt(L);
    }
    case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
      const L = (u = (r = cr.ContinuousVestingAccount.decode(c)) == null ? void 0 : r.baseVestingAccount) == null ? void 0 : u.baseAccount;
      return (0, Ht.assert)(L), dt(L);
    }
    case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
      const L = (O = (f = cr.DelayedVestingAccount.decode(c)) == null ? void 0 : f.baseVestingAccount) == null ? void 0 : O.baseAccount;
      return (0, Ht.assert)(L), dt(L);
    }
    case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
      const L = (T = (A = cr.PeriodicVestingAccount.decode(c)) == null ? void 0 : A.baseVestingAccount) == null ? void 0 : T.baseAccount;
      return (0, Ht.assert)(L), dt(L);
    }
    default:
      throw new Error(`Unsupported type: '${n}'`);
  }
}
nr.accountFromAny = nl;
var tr = {};
Object.defineProperty(tr, "__esModule", { value: !0 });
tr.AminoTypes = void 0;
class tl {
  constructor(n) {
    this.register = n;
  }
  toAmino({ typeUrl: n, value: c }) {
    const i = this.register[n];
    if (!i)
      throw new Error(`Type URL '${n}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
    return {
      type: i.aminoType,
      value: i.toAmino(c)
    };
  }
  fromAmino({ type: n, value: c }) {
    const i = Object.entries(this.register).filter(([r, { aminoType: u }]) => u === n);
    switch (i.length) {
      case 0:
        throw new Error(`Amino type identifier '${n}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
      case 1: {
        const [r, u] = i[0];
        return {
          typeUrl: r,
          value: u.fromAmino(c)
        };
      }
      default:
        throw new Error(`Multiple types are registered with Amino type identifier '${n}': '` + i.map(([r, u]) => r).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
    }
  }
}
tr.AminoTypes = tl;
var rr = {};
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.fromTendermintEvent = void 0;
const ts = Ve;
function rl(e) {
  return {
    type: e.type,
    attributes: e.attributes.map((n) => ({
      key: typeof n.key == "string" ? n.key : (0, ts.fromUtf8)(n.key, !0),
      value: typeof n.value == "string" ? n.value : (0, ts.fromUtf8)(n.value, !0)
    }))
  };
}
rr.fromTendermintEvent = rl;
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.calculateFee = xn.GasPrice = void 0;
const Jd = _n, il = tt;
function ol(e) {
  if (e.length < 3 || e.length > 128)
    throw new Error("Denom must be between 3 and 128 characters");
}
class Hr {
  constructor(n, c) {
    this.amount = n, this.denom = c;
  }
  /**
   * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
   *
   * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
   * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
   *
   * Separators are not yet supported.
   */
  static fromString(n) {
    const c = n.match(/^([0-9.]+)([a-z][a-z0-9]*)$/i);
    if (!c)
      throw new Error("Invalid gas price string");
    const [i, r, u] = c;
    ol(u);
    const f = 18, O = Jd.Decimal.fromUserInput(r, f);
    return new Hr(O, u);
  }
  /**
   * Returns a string representation of this gas price, e.g. "0.025uatom".
   * This can be used as an input to `GasPrice.fromString`.
   */
  toString() {
    return this.amount.toString() + this.denom;
  }
}
xn.GasPrice = Hr;
function al(e, n) {
  const c = typeof n == "string" ? Hr.fromString(n) : n, { denom: i, amount: r } = c, u = r.multiply(new Jd.Uint53(e)).ceil().toString();
  return {
    amount: (0, il.coins)(u, i),
    gas: e.toString()
  };
}
xn.calculateFee = al;
var Fe = {};
Object.defineProperty(Fe, "__esModule", { value: !0 });
Fe.findAttribute = Fe.parseRawLog = Fe.parseLogs = Fe.parseLog = Fe.parseEvent = Fe.parseAttribute = void 0;
const $o = yn;
function Dd(e) {
  if (!(0, $o.isNonNullObject)(e))
    throw new Error("Attribute must be a non-null object");
  const { key: n, value: c } = e;
  if (typeof n != "string" || !n)
    throw new Error("Attribute's key must be a non-empty string");
  if (typeof c != "string" && typeof c < "u")
    throw new Error("Attribute's value must be a string or unset");
  return {
    key: n,
    value: c || ""
  };
}
Fe.parseAttribute = Dd;
function Ud(e) {
  if (!(0, $o.isNonNullObject)(e))
    throw new Error("Event must be a non-null object");
  const { type: n, attributes: c } = e;
  if (typeof n != "string" || n === "")
    throw new Error("Event type must be a non-empty string");
  if (!Array.isArray(c))
    throw new Error("Event's attributes must be an array");
  return {
    type: n,
    attributes: c.map(Dd)
  };
}
Fe.parseEvent = Ud;
function Md(e) {
  if (!(0, $o.isNonNullObject)(e))
    throw new Error("Log must be a non-null object");
  const { msg_index: n, log: c, events: i } = e;
  if (typeof n != "number")
    throw new Error("Log's msg_index must be a number");
  if (typeof c != "string")
    throw new Error("Log's log must be a string");
  if (!Array.isArray(i))
    throw new Error("Log's events must be an array");
  return {
    msg_index: n,
    log: c,
    events: i.map(Ud)
  };
}
Fe.parseLog = Md;
function Vd(e) {
  if (!Array.isArray(e))
    throw new Error("Logs must be an array");
  return e.map(Md);
}
Fe.parseLogs = Vd;
function sl(e = "[]") {
  const n = JSON.parse(e).map(({ events: c }, i) => ({
    msg_index: i,
    events: c,
    log: ""
  }));
  return Vd(n);
}
Fe.parseRawLog = sl;
function dl(e, n, c) {
  var u;
  const i = e.find(() => !0), r = (u = i == null ? void 0 : i.events.find((f) => f.type === n)) == null ? void 0 : u.attributes.find((f) => f.key === c);
  if (!r)
    throw new Error(`Could not find attribute '${c}' in first event of type '${n}' in first log.`);
  return r;
}
Fe.findAttribute = dl;
var Xt = {}, qr = {}, Ld = {}, Re = {}, ul = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), cl = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), ll = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && ul(n, e, c);
  return cl(n, e), n;
};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.PageResponse = Re.PageRequest = Re.protobufPackage = void 0;
const me = oe, gt = ll(ie);
Re.protobufPackage = "cosmos.base.query.v1beta1";
function rs() {
  return {
    key: new Uint8Array(),
    offset: me.Long.UZERO,
    limit: me.Long.UZERO,
    countTotal: !1,
    reverse: !1
  };
}
Re.PageRequest = {
  encode(e, n = gt.Writer.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), e.offset.isZero() || n.uint32(16).uint64(e.offset), e.limit.isZero() || n.uint32(24).uint64(e.limit), e.countTotal === !0 && n.uint32(32).bool(e.countTotal), e.reverse === !0 && n.uint32(40).bool(e.reverse), n;
  },
  decode(e, n) {
    const c = e instanceof gt.Reader ? e : new gt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = rs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.key = c.bytes();
          break;
        case 2:
          r.offset = c.uint64();
          break;
        case 3:
          r.limit = c.uint64();
          break;
        case 4:
          r.countTotal = c.bool();
          break;
        case 5:
          r.reverse = c.bool();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      key: (0, me.isSet)(e.key) ? (0, me.bytesFromBase64)(e.key) : new Uint8Array(),
      offset: (0, me.isSet)(e.offset) ? me.Long.fromValue(e.offset) : me.Long.UZERO,
      limit: (0, me.isSet)(e.limit) ? me.Long.fromValue(e.limit) : me.Long.UZERO,
      countTotal: (0, me.isSet)(e.countTotal) ? !!e.countTotal : !1,
      reverse: (0, me.isSet)(e.reverse) ? !!e.reverse : !1
    };
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, me.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), e.offset !== void 0 && (n.offset = (e.offset || me.Long.UZERO).toString()), e.limit !== void 0 && (n.limit = (e.limit || me.Long.UZERO).toString()), e.countTotal !== void 0 && (n.countTotal = e.countTotal), e.reverse !== void 0 && (n.reverse = e.reverse), n;
  },
  fromPartial(e) {
    const n = rs();
    return n.key = e.key ?? new Uint8Array(), n.offset = e.offset !== void 0 && e.offset !== null ? me.Long.fromValue(e.offset) : me.Long.UZERO, n.limit = e.limit !== void 0 && e.limit !== null ? me.Long.fromValue(e.limit) : me.Long.UZERO, n.countTotal = e.countTotal ?? !1, n.reverse = e.reverse ?? !1, n;
  }
};
function is() {
  return {
    nextKey: new Uint8Array(),
    total: me.Long.UZERO
  };
}
Re.PageResponse = {
  encode(e, n = gt.Writer.create()) {
    return e.nextKey.length !== 0 && n.uint32(10).bytes(e.nextKey), e.total.isZero() || n.uint32(16).uint64(e.total), n;
  },
  decode(e, n) {
    const c = e instanceof gt.Reader ? e : new gt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = is();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.nextKey = c.bytes();
          break;
        case 2:
          r.total = c.uint64();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      nextKey: (0, me.isSet)(e.nextKey) ? (0, me.bytesFromBase64)(e.nextKey) : new Uint8Array(),
      total: (0, me.isSet)(e.total) ? me.Long.fromValue(e.total) : me.Long.UZERO
    };
  },
  toJSON(e) {
    const n = {};
    return e.nextKey !== void 0 && (n.nextKey = (0, me.base64FromBytes)(e.nextKey !== void 0 ? e.nextKey : new Uint8Array())), e.total !== void 0 && (n.total = (e.total || me.Long.UZERO).toString()), n;
  },
  fromPartial(e) {
    const n = is();
    return n.nextKey = e.nextKey ?? new Uint8Array(), n.total = e.total !== void 0 && e.total !== null ? me.Long.fromValue(e.total) : me.Long.UZERO, n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(l, C, v, k) {
    k === void 0 && (k = v);
    var U = Object.getOwnPropertyDescriptor(C, v);
    (!U || ("get" in U ? !C.__esModule : U.writable || U.configurable)) && (U = { enumerable: !0, get: function() {
      return C[v];
    } }), Object.defineProperty(l, k, U);
  } : function(l, C, v, k) {
    k === void 0 && (k = v), l[k] = C[v];
  }), c = G && G.__setModuleDefault || (Object.create ? function(l, C) {
    Object.defineProperty(l, "default", { enumerable: !0, value: C });
  } : function(l, C) {
    l.default = C;
  }), i = G && G.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var C = {};
    if (l != null)
      for (var v in l)
        v !== "default" && Object.prototype.hasOwnProperty.call(l, v) && n(C, l, v);
    return c(C, l), C;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAccountInfoResponse = e.QueryAccountInfoRequest = e.QueryAccountAddressByIDResponse = e.QueryAccountAddressByIDRequest = e.AddressStringToBytesResponse = e.AddressStringToBytesRequest = e.AddressBytesToStringResponse = e.AddressBytesToStringRequest = e.Bech32PrefixResponse = e.Bech32PrefixRequest = e.QueryModuleAccountByNameResponse = e.QueryModuleAccountByNameRequest = e.QueryModuleAccountsResponse = e.QueryModuleAccountsRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryAccountResponse = e.QueryAccountRequest = e.QueryAccountsResponse = e.QueryAccountsRequest = e.protobufPackage = void 0;
  const r = Re, u = Se, f = Lr, O = oe, A = i(ie);
  e.protobufPackage = "cosmos.auth.v1beta1";
  function T() {
    return {
      pagination: void 0
    };
  }
  e.QueryAccountsRequest = {
    encode(l, C = A.Writer.create()) {
      return l.pagination !== void 0 && r.PageRequest.encode(l.pagination, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = T();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.pagination = r.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        pagination: (0, O.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.pagination !== void 0 && (C.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), C;
    },
    fromPartial(l) {
      const C = T();
      return C.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, C;
    }
  };
  function L() {
    return {
      accounts: [],
      pagination: void 0
    };
  }
  e.QueryAccountsResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.accounts)
        u.Any.encode(v, C.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, C.uint32(18).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = L();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.accounts.push(u.Any.decode(v, v.uint32()));
            break;
          case 2:
            U.pagination = r.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        accounts: Array.isArray(l == null ? void 0 : l.accounts) ? l.accounts.map((C) => u.Any.fromJSON(C)) : [],
        pagination: (0, O.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.accounts ? C.accounts = l.accounts.map((v) => v ? u.Any.toJSON(v) : void 0) : C.accounts = [], l.pagination !== void 0 && (C.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), C;
    },
    fromPartial(l) {
      var v;
      const C = L();
      return C.accounts = ((v = l.accounts) == null ? void 0 : v.map((k) => u.Any.fromPartial(k))) || [], C.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, C;
    }
  };
  function M() {
    return {
      address: ""
    };
  }
  e.QueryAccountRequest = {
    encode(l, C = A.Writer.create()) {
      return l.address !== "" && C.uint32(10).string(l.address), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = M();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.address = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        address: (0, O.isSet)(l.address) ? String(l.address) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.address !== void 0 && (C.address = l.address), C;
    },
    fromPartial(l) {
      const C = M();
      return C.address = l.address ?? "", C;
    }
  };
  function V() {
    return {
      account: void 0
    };
  }
  e.QueryAccountResponse = {
    encode(l, C = A.Writer.create()) {
      return l.account !== void 0 && u.Any.encode(l.account, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = V();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.account = u.Any.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        account: (0, O.isSet)(l.account) ? u.Any.fromJSON(l.account) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.account !== void 0 && (C.account = l.account ? u.Any.toJSON(l.account) : void 0), C;
    },
    fromPartial(l) {
      const C = V();
      return C.account = l.account !== void 0 && l.account !== null ? u.Any.fromPartial(l.account) : void 0, C;
    }
  };
  function D() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(l, C = A.Writer.create()) {
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = D();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return D();
    }
  };
  function b() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(l, C = A.Writer.create()) {
      return l.params !== void 0 && f.Params.encode(l.params, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = b();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.params = f.Params.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        params: (0, O.isSet)(l.params) ? f.Params.fromJSON(l.params) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.params !== void 0 && (C.params = l.params ? f.Params.toJSON(l.params) : void 0), C;
    },
    fromPartial(l) {
      const C = b();
      return C.params = l.params !== void 0 && l.params !== null ? f.Params.fromPartial(l.params) : void 0, C;
    }
  };
  function h() {
    return {};
  }
  e.QueryModuleAccountsRequest = {
    encode(l, C = A.Writer.create()) {
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = h();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return h();
    }
  };
  function S() {
    return {
      accounts: []
    };
  }
  e.QueryModuleAccountsResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.accounts)
        u.Any.encode(v, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = S();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.accounts.push(u.Any.decode(v, v.uint32()));
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        accounts: Array.isArray(l == null ? void 0 : l.accounts) ? l.accounts.map((C) => u.Any.fromJSON(C)) : []
      };
    },
    toJSON(l) {
      const C = {};
      return l.accounts ? C.accounts = l.accounts.map((v) => v ? u.Any.toJSON(v) : void 0) : C.accounts = [], C;
    },
    fromPartial(l) {
      var v;
      const C = S();
      return C.accounts = ((v = l.accounts) == null ? void 0 : v.map((k) => u.Any.fromPartial(k))) || [], C;
    }
  };
  function _() {
    return {
      name: ""
    };
  }
  e.QueryModuleAccountByNameRequest = {
    encode(l, C = A.Writer.create()) {
      return l.name !== "" && C.uint32(10).string(l.name), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = _();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.name = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        name: (0, O.isSet)(l.name) ? String(l.name) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.name !== void 0 && (C.name = l.name), C;
    },
    fromPartial(l) {
      const C = _();
      return C.name = l.name ?? "", C;
    }
  };
  function d() {
    return {
      account: void 0
    };
  }
  e.QueryModuleAccountByNameResponse = {
    encode(l, C = A.Writer.create()) {
      return l.account !== void 0 && u.Any.encode(l.account, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = d();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.account = u.Any.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        account: (0, O.isSet)(l.account) ? u.Any.fromJSON(l.account) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.account !== void 0 && (C.account = l.account ? u.Any.toJSON(l.account) : void 0), C;
    },
    fromPartial(l) {
      const C = d();
      return C.account = l.account !== void 0 && l.account !== null ? u.Any.fromPartial(l.account) : void 0, C;
    }
  };
  function p() {
    return {};
  }
  e.Bech32PrefixRequest = {
    encode(l, C = A.Writer.create()) {
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = p();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return p();
    }
  };
  function g() {
    return {
      bech32Prefix: ""
    };
  }
  e.Bech32PrefixResponse = {
    encode(l, C = A.Writer.create()) {
      return l.bech32Prefix !== "" && C.uint32(10).string(l.bech32Prefix), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = g();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.bech32Prefix = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        bech32Prefix: (0, O.isSet)(l.bech32Prefix) ? String(l.bech32Prefix) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.bech32Prefix !== void 0 && (C.bech32Prefix = l.bech32Prefix), C;
    },
    fromPartial(l) {
      const C = g();
      return C.bech32Prefix = l.bech32Prefix ?? "", C;
    }
  };
  function J() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressBytesToStringRequest = {
    encode(l, C = A.Writer.create()) {
      return l.addressBytes.length !== 0 && C.uint32(10).bytes(l.addressBytes), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = J();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.addressBytes = v.bytes();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        addressBytes: (0, O.isSet)(l.addressBytes) ? (0, O.bytesFromBase64)(l.addressBytes) : new Uint8Array()
      };
    },
    toJSON(l) {
      const C = {};
      return l.addressBytes !== void 0 && (C.addressBytes = (0, O.base64FromBytes)(l.addressBytes !== void 0 ? l.addressBytes : new Uint8Array())), C;
    },
    fromPartial(l) {
      const C = J();
      return C.addressBytes = l.addressBytes ?? new Uint8Array(), C;
    }
  };
  function B() {
    return {
      addressString: ""
    };
  }
  e.AddressBytesToStringResponse = {
    encode(l, C = A.Writer.create()) {
      return l.addressString !== "" && C.uint32(10).string(l.addressString), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = B();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.addressString = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        addressString: (0, O.isSet)(l.addressString) ? String(l.addressString) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.addressString !== void 0 && (C.addressString = l.addressString), C;
    },
    fromPartial(l) {
      const C = B();
      return C.addressString = l.addressString ?? "", C;
    }
  };
  function I() {
    return {
      addressString: ""
    };
  }
  e.AddressStringToBytesRequest = {
    encode(l, C = A.Writer.create()) {
      return l.addressString !== "" && C.uint32(10).string(l.addressString), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = I();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.addressString = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        addressString: (0, O.isSet)(l.addressString) ? String(l.addressString) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.addressString !== void 0 && (C.addressString = l.addressString), C;
    },
    fromPartial(l) {
      const C = I();
      return C.addressString = l.addressString ?? "", C;
    }
  };
  function Z() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressStringToBytesResponse = {
    encode(l, C = A.Writer.create()) {
      return l.addressBytes.length !== 0 && C.uint32(10).bytes(l.addressBytes), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = Z();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.addressBytes = v.bytes();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        addressBytes: (0, O.isSet)(l.addressBytes) ? (0, O.bytesFromBase64)(l.addressBytes) : new Uint8Array()
      };
    },
    toJSON(l) {
      const C = {};
      return l.addressBytes !== void 0 && (C.addressBytes = (0, O.base64FromBytes)(l.addressBytes !== void 0 ? l.addressBytes : new Uint8Array())), C;
    },
    fromPartial(l) {
      const C = Z();
      return C.addressBytes = l.addressBytes ?? new Uint8Array(), C;
    }
  };
  function t() {
    return {
      id: O.Long.ZERO,
      accountId: O.Long.UZERO
    };
  }
  e.QueryAccountAddressByIDRequest = {
    encode(l, C = A.Writer.create()) {
      return l.id.isZero() || C.uint32(8).int64(l.id), l.accountId.isZero() || C.uint32(16).uint64(l.accountId), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = t();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.id = v.int64();
            break;
          case 2:
            U.accountId = v.uint64();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        id: (0, O.isSet)(l.id) ? O.Long.fromValue(l.id) : O.Long.ZERO,
        accountId: (0, O.isSet)(l.accountId) ? O.Long.fromValue(l.accountId) : O.Long.UZERO
      };
    },
    toJSON(l) {
      const C = {};
      return l.id !== void 0 && (C.id = (l.id || O.Long.ZERO).toString()), l.accountId !== void 0 && (C.accountId = (l.accountId || O.Long.UZERO).toString()), C;
    },
    fromPartial(l) {
      const C = t();
      return C.id = l.id !== void 0 && l.id !== null ? O.Long.fromValue(l.id) : O.Long.ZERO, C.accountId = l.accountId !== void 0 && l.accountId !== null ? O.Long.fromValue(l.accountId) : O.Long.UZERO, C;
    }
  };
  function y() {
    return {
      accountAddress: ""
    };
  }
  e.QueryAccountAddressByIDResponse = {
    encode(l, C = A.Writer.create()) {
      return l.accountAddress !== "" && C.uint32(10).string(l.accountAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = y();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.accountAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        accountAddress: (0, O.isSet)(l.accountAddress) ? String(l.accountAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.accountAddress !== void 0 && (C.accountAddress = l.accountAddress), C;
    },
    fromPartial(l) {
      const C = y();
      return C.accountAddress = l.accountAddress ?? "", C;
    }
  };
  function E() {
    return {
      address: ""
    };
  }
  e.QueryAccountInfoRequest = {
    encode(l, C = A.Writer.create()) {
      return l.address !== "" && C.uint32(10).string(l.address), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = E();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.address = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        address: (0, O.isSet)(l.address) ? String(l.address) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.address !== void 0 && (C.address = l.address), C;
    },
    fromPartial(l) {
      const C = E();
      return C.address = l.address ?? "", C;
    }
  };
  function H() {
    return {
      info: void 0
    };
  }
  e.QueryAccountInfoResponse = {
    encode(l, C = A.Writer.create()) {
      return l.info !== void 0 && f.BaseAccount.encode(l.info, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = H();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.info = f.BaseAccount.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        info: (0, O.isSet)(l.info) ? f.BaseAccount.fromJSON(l.info) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.info !== void 0 && (C.info = l.info ? f.BaseAccount.toJSON(l.info) : void 0), C;
    },
    fromPartial(l) {
      const C = H();
      return C.info = l.info !== void 0 && l.info !== null ? f.BaseAccount.fromPartial(l.info) : void 0, C;
    }
  };
  class a {
    constructor(C) {
      this.rpc = C, this.Accounts = this.Accounts.bind(this), this.Account = this.Account.bind(this), this.AccountAddressByID = this.AccountAddressByID.bind(this), this.Params = this.Params.bind(this), this.ModuleAccounts = this.ModuleAccounts.bind(this), this.ModuleAccountByName = this.ModuleAccountByName.bind(this), this.Bech32Prefix = this.Bech32Prefix.bind(this), this.AddressBytesToString = this.AddressBytesToString.bind(this), this.AddressStringToBytes = this.AddressStringToBytes.bind(this), this.AccountInfo = this.AccountInfo.bind(this);
    }
    Accounts(C = {
      pagination: void 0
    }) {
      const v = e.QueryAccountsRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", v).then((U) => e.QueryAccountsResponse.decode(new A.Reader(U)));
    }
    Account(C) {
      const v = e.QueryAccountRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Account", v).then((U) => e.QueryAccountResponse.decode(new A.Reader(U)));
    }
    AccountAddressByID(C) {
      const v = e.QueryAccountAddressByIDRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", v).then((U) => e.QueryAccountAddressByIDResponse.decode(new A.Reader(U)));
    }
    Params(C = {}) {
      const v = e.QueryParamsRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Params", v).then((U) => e.QueryParamsResponse.decode(new A.Reader(U)));
    }
    ModuleAccounts(C = {}) {
      const v = e.QueryModuleAccountsRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", v).then((U) => e.QueryModuleAccountsResponse.decode(new A.Reader(U)));
    }
    ModuleAccountByName(C) {
      const v = e.QueryModuleAccountByNameRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", v).then((U) => e.QueryModuleAccountByNameResponse.decode(new A.Reader(U)));
    }
    Bech32Prefix(C = {}) {
      const v = e.Bech32PrefixRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", v).then((U) => e.Bech32PrefixResponse.decode(new A.Reader(U)));
    }
    AddressBytesToString(C) {
      const v = e.AddressBytesToStringRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", v).then((U) => e.AddressBytesToStringResponse.decode(new A.Reader(U)));
    }
    AddressStringToBytes(C) {
      const v = e.AddressStringToBytesRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", v).then((U) => e.AddressStringToBytesResponse.decode(new A.Reader(U)));
    }
    AccountInfo(C) {
      const v = e.QueryAccountInfoRequest.encode(C).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", v).then((U) => e.QueryAccountInfoResponse.decode(new A.Reader(U)));
    }
  }
  e.QueryClientImpl = a;
})(Ld);
var Le = {}, Wr = {}, Hd = {}, ke = ie, ae = ke.Reader, Ye = ke.Writer, te = ke.util, X = ke.roots.default || (ke.roots.default = {});
X.ics23 = function() {
  var e = {};
  return e.HashOp = function() {
    var n = {}, c = Object.create(n);
    return c[n[0] = "NO_HASH"] = 0, c[n[1] = "SHA256"] = 1, c[n[2] = "SHA512"] = 2, c[n[3] = "KECCAK"] = 3, c[n[4] = "RIPEMD160"] = 4, c[n[5] = "BITCOIN"] = 5, c[n[6] = "SHA512_256"] = 6, c;
  }(), e.LengthOp = function() {
    var n = {}, c = Object.create(n);
    return c[n[0] = "NO_PREFIX"] = 0, c[n[1] = "VAR_PROTO"] = 1, c[n[2] = "VAR_RLP"] = 2, c[n[3] = "FIXED32_BIG"] = 3, c[n[4] = "FIXED32_LITTLE"] = 4, c[n[5] = "FIXED64_BIG"] = 5, c[n[6] = "FIXED64_LITTLE"] = 6, c[n[7] = "REQUIRE_32_BYTES"] = 7, c[n[8] = "REQUIRE_64_BYTES"] = 8, c;
  }(), e.ExistenceProof = function() {
    function n(c) {
      if (this.path = [], c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.value = te.newBuffer([]), n.prototype.leaf = null, n.prototype.path = te.emptyArray, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      if (r || (r = Ye.create()), i.key != null && i.hasOwnProperty("key") && r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(i.key), i.value != null && i.hasOwnProperty("value") && r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(i.value), i.leaf != null && i.hasOwnProperty("leaf") && X.ics23.LeafOp.encode(i.leaf, r.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i.path != null && i.path.length)
        for (var u = 0; u < i.path.length; ++u)
          X.ics23.InnerOp.encode(i.path[u], r.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
      return r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.ExistenceProof(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.key = i.bytes();
            break;
          case 2:
            f.value = i.bytes();
            break;
          case 3:
            f.leaf = X.ics23.LeafOp.decode(i, i.uint32());
            break;
          case 4:
            f.path && f.path.length || (f.path = []), f.path.push(X.ics23.InnerOp.decode(i, i.uint32()));
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.key != null && i.hasOwnProperty("key") && !(i.key && typeof i.key.length == "number" || te.isString(i.key)))
        return "key: buffer expected";
      if (i.value != null && i.hasOwnProperty("value") && !(i.value && typeof i.value.length == "number" || te.isString(i.value)))
        return "value: buffer expected";
      if (i.leaf != null && i.hasOwnProperty("leaf")) {
        var r = X.ics23.LeafOp.verify(i.leaf);
        if (r)
          return "leaf." + r;
      }
      if (i.path != null && i.hasOwnProperty("path")) {
        if (!Array.isArray(i.path))
          return "path: array expected";
        for (var u = 0; u < i.path.length; ++u) {
          var r = X.ics23.InnerOp.verify(i.path[u]);
          if (r)
            return "path." + r;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.ExistenceProof)
        return i;
      var r = new X.ics23.ExistenceProof();
      if (i.key != null && (typeof i.key == "string" ? te.base64.decode(i.key, r.key = te.newBuffer(te.base64.length(i.key)), 0) : i.key.length && (r.key = i.key)), i.value != null && (typeof i.value == "string" ? te.base64.decode(i.value, r.value = te.newBuffer(te.base64.length(i.value)), 0) : i.value.length && (r.value = i.value)), i.leaf != null) {
        if (typeof i.leaf != "object")
          throw TypeError(".ics23.ExistenceProof.leaf: object expected");
        r.leaf = X.ics23.LeafOp.fromObject(i.leaf);
      }
      if (i.path) {
        if (!Array.isArray(i.path))
          throw TypeError(".ics23.ExistenceProof.path: array expected");
        r.path = [];
        for (var u = 0; u < i.path.length; ++u) {
          if (typeof i.path[u] != "object")
            throw TypeError(".ics23.ExistenceProof.path: object expected");
          r.path[u] = X.ics23.InnerOp.fromObject(i.path[u]);
        }
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      if ((r.arrays || r.defaults) && (u.path = []), r.defaults && (r.bytes === String ? u.key = "" : (u.key = [], r.bytes !== Array && (u.key = te.newBuffer(u.key))), r.bytes === String ? u.value = "" : (u.value = [], r.bytes !== Array && (u.value = te.newBuffer(u.value))), u.leaf = null), i.key != null && i.hasOwnProperty("key") && (u.key = r.bytes === String ? te.base64.encode(i.key, 0, i.key.length) : r.bytes === Array ? Array.prototype.slice.call(i.key) : i.key), i.value != null && i.hasOwnProperty("value") && (u.value = r.bytes === String ? te.base64.encode(i.value, 0, i.value.length) : r.bytes === Array ? Array.prototype.slice.call(i.value) : i.value), i.leaf != null && i.hasOwnProperty("leaf") && (u.leaf = X.ics23.LeafOp.toObject(i.leaf, r)), i.path && i.path.length) {
        u.path = [];
        for (var f = 0; f < i.path.length; ++f)
          u.path[f] = X.ics23.InnerOp.toObject(i.path[f], r);
      }
      return u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.NonExistenceProof = function() {
    function n(c) {
      if (c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.left = null, n.prototype.right = null, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      return r || (r = Ye.create()), i.key != null && i.hasOwnProperty("key") && r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(i.key), i.left != null && i.hasOwnProperty("left") && X.ics23.ExistenceProof.encode(i.left, r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), i.right != null && i.hasOwnProperty("right") && X.ics23.ExistenceProof.encode(i.right, r.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.NonExistenceProof(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.key = i.bytes();
            break;
          case 2:
            f.left = X.ics23.ExistenceProof.decode(i, i.uint32());
            break;
          case 3:
            f.right = X.ics23.ExistenceProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.key != null && i.hasOwnProperty("key") && !(i.key && typeof i.key.length == "number" || te.isString(i.key)))
        return "key: buffer expected";
      if (i.left != null && i.hasOwnProperty("left")) {
        var r = X.ics23.ExistenceProof.verify(i.left);
        if (r)
          return "left." + r;
      }
      if (i.right != null && i.hasOwnProperty("right")) {
        var r = X.ics23.ExistenceProof.verify(i.right);
        if (r)
          return "right." + r;
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.NonExistenceProof)
        return i;
      var r = new X.ics23.NonExistenceProof();
      if (i.key != null && (typeof i.key == "string" ? te.base64.decode(i.key, r.key = te.newBuffer(te.base64.length(i.key)), 0) : i.key.length && (r.key = i.key)), i.left != null) {
        if (typeof i.left != "object")
          throw TypeError(".ics23.NonExistenceProof.left: object expected");
        r.left = X.ics23.ExistenceProof.fromObject(i.left);
      }
      if (i.right != null) {
        if (typeof i.right != "object")
          throw TypeError(".ics23.NonExistenceProof.right: object expected");
        r.right = X.ics23.ExistenceProof.fromObject(i.right);
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      return r.defaults && (r.bytes === String ? u.key = "" : (u.key = [], r.bytes !== Array && (u.key = te.newBuffer(u.key))), u.left = null, u.right = null), i.key != null && i.hasOwnProperty("key") && (u.key = r.bytes === String ? te.base64.encode(i.key, 0, i.key.length) : r.bytes === Array ? Array.prototype.slice.call(i.key) : i.key), i.left != null && i.hasOwnProperty("left") && (u.left = X.ics23.ExistenceProof.toObject(i.left, r)), i.right != null && i.hasOwnProperty("right") && (u.right = X.ics23.ExistenceProof.toObject(i.right, r)), u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.CommitmentProof = function() {
    function n(i) {
      if (i)
        for (var r = Object.keys(i), u = 0; u < r.length; ++u)
          i[r[u]] != null && (this[r[u]] = i[r[u]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null, n.prototype.batch = null, n.prototype.compressed = null;
    var c;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(c = ["exist", "nonexist", "batch", "compressed"]),
      set: te.oneOfSetter(c)
    }), n.create = function(r) {
      return new n(r);
    }, n.encode = function(r, u) {
      return u || (u = Ye.create()), r.exist != null && r.hasOwnProperty("exist") && X.ics23.ExistenceProof.encode(r.exist, u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), r.nonexist != null && r.hasOwnProperty("nonexist") && X.ics23.NonExistenceProof.encode(r.nonexist, u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), r.batch != null && r.hasOwnProperty("batch") && X.ics23.BatchProof.encode(r.batch, u.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), r.compressed != null && r.hasOwnProperty("compressed") && X.ics23.CompressedBatchProof.encode(r.compressed, u.uint32(
        /* id 4, wireType 2 =*/
        34
      ).fork()).ldelim(), u;
    }, n.encodeDelimited = function(r, u) {
      return this.encode(r, u).ldelim();
    }, n.decode = function(r, u) {
      r instanceof ae || (r = ae.create(r));
      for (var f = u === void 0 ? r.len : r.pos + u, O = new X.ics23.CommitmentProof(); r.pos < f; ) {
        var A = r.uint32();
        switch (A >>> 3) {
          case 1:
            O.exist = X.ics23.ExistenceProof.decode(r, r.uint32());
            break;
          case 2:
            O.nonexist = X.ics23.NonExistenceProof.decode(r, r.uint32());
            break;
          case 3:
            O.batch = X.ics23.BatchProof.decode(r, r.uint32());
            break;
          case 4:
            O.compressed = X.ics23.CompressedBatchProof.decode(r, r.uint32());
            break;
          default:
            r.skipType(A & 7);
            break;
        }
      }
      return O;
    }, n.decodeDelimited = function(r) {
      return r instanceof ae || (r = new ae(r)), this.decode(r, r.uint32());
    }, n.verify = function(r) {
      if (typeof r != "object" || r === null)
        return "object expected";
      var u = {};
      if (r.exist != null && r.hasOwnProperty("exist")) {
        u.proof = 1;
        {
          var f = X.ics23.ExistenceProof.verify(r.exist);
          if (f)
            return "exist." + f;
        }
      }
      if (r.nonexist != null && r.hasOwnProperty("nonexist")) {
        if (u.proof === 1)
          return "proof: multiple values";
        u.proof = 1;
        {
          var f = X.ics23.NonExistenceProof.verify(r.nonexist);
          if (f)
            return "nonexist." + f;
        }
      }
      if (r.batch != null && r.hasOwnProperty("batch")) {
        if (u.proof === 1)
          return "proof: multiple values";
        u.proof = 1;
        {
          var f = X.ics23.BatchProof.verify(r.batch);
          if (f)
            return "batch." + f;
        }
      }
      if (r.compressed != null && r.hasOwnProperty("compressed")) {
        if (u.proof === 1)
          return "proof: multiple values";
        u.proof = 1;
        {
          var f = X.ics23.CompressedBatchProof.verify(r.compressed);
          if (f)
            return "compressed." + f;
        }
      }
      return null;
    }, n.fromObject = function(r) {
      if (r instanceof X.ics23.CommitmentProof)
        return r;
      var u = new X.ics23.CommitmentProof();
      if (r.exist != null) {
        if (typeof r.exist != "object")
          throw TypeError(".ics23.CommitmentProof.exist: object expected");
        u.exist = X.ics23.ExistenceProof.fromObject(r.exist);
      }
      if (r.nonexist != null) {
        if (typeof r.nonexist != "object")
          throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
        u.nonexist = X.ics23.NonExistenceProof.fromObject(r.nonexist);
      }
      if (r.batch != null) {
        if (typeof r.batch != "object")
          throw TypeError(".ics23.CommitmentProof.batch: object expected");
        u.batch = X.ics23.BatchProof.fromObject(r.batch);
      }
      if (r.compressed != null) {
        if (typeof r.compressed != "object")
          throw TypeError(".ics23.CommitmentProof.compressed: object expected");
        u.compressed = X.ics23.CompressedBatchProof.fromObject(r.compressed);
      }
      return u;
    }, n.toObject = function(r, u) {
      u || (u = {});
      var f = {};
      return r.exist != null && r.hasOwnProperty("exist") && (f.exist = X.ics23.ExistenceProof.toObject(r.exist, u), u.oneofs && (f.proof = "exist")), r.nonexist != null && r.hasOwnProperty("nonexist") && (f.nonexist = X.ics23.NonExistenceProof.toObject(r.nonexist, u), u.oneofs && (f.proof = "nonexist")), r.batch != null && r.hasOwnProperty("batch") && (f.batch = X.ics23.BatchProof.toObject(r.batch, u), u.oneofs && (f.proof = "batch")), r.compressed != null && r.hasOwnProperty("compressed") && (f.compressed = X.ics23.CompressedBatchProof.toObject(r.compressed, u), u.oneofs && (f.proof = "compressed")), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.LeafOp = function() {
    function n(c) {
      if (c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.hash = 0, n.prototype.prehashKey = 0, n.prototype.prehashValue = 0, n.prototype.length = 0, n.prototype.prefix = te.newBuffer([]), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      return r || (r = Ye.create()), i.hash != null && i.hasOwnProperty("hash") && r.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(i.hash), i.prehashKey != null && i.hasOwnProperty("prehashKey") && r.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(i.prehashKey), i.prehashValue != null && i.hasOwnProperty("prehashValue") && r.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(i.prehashValue), i.length != null && i.hasOwnProperty("length") && r.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(i.length), i.prefix != null && i.hasOwnProperty("prefix") && r.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(i.prefix), r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.LeafOp(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.hash = i.int32();
            break;
          case 2:
            f.prehashKey = i.int32();
            break;
          case 3:
            f.prehashValue = i.int32();
            break;
          case 4:
            f.length = i.int32();
            break;
          case 5:
            f.prefix = i.bytes();
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.hash != null && i.hasOwnProperty("hash"))
        switch (i.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (i.prehashKey != null && i.hasOwnProperty("prehashKey"))
        switch (i.prehashKey) {
          default:
            return "prehashKey: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (i.prehashValue != null && i.hasOwnProperty("prehashValue"))
        switch (i.prehashValue) {
          default:
            return "prehashValue: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (i.length != null && i.hasOwnProperty("length"))
        switch (i.length) {
          default:
            return "length: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            break;
        }
      return i.prefix != null && i.hasOwnProperty("prefix") && !(i.prefix && typeof i.prefix.length == "number" || te.isString(i.prefix)) ? "prefix: buffer expected" : null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.LeafOp)
        return i;
      var r = new X.ics23.LeafOp();
      switch (i.hash) {
        case "NO_HASH":
        case 0:
          r.hash = 0;
          break;
        case "SHA256":
        case 1:
          r.hash = 1;
          break;
        case "SHA512":
        case 2:
          r.hash = 2;
          break;
        case "KECCAK":
        case 3:
          r.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          r.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          r.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          r.hash = 6;
          break;
      }
      switch (i.prehashKey) {
        case "NO_HASH":
        case 0:
          r.prehashKey = 0;
          break;
        case "SHA256":
        case 1:
          r.prehashKey = 1;
          break;
        case "SHA512":
        case 2:
          r.prehashKey = 2;
          break;
        case "KECCAK":
        case 3:
          r.prehashKey = 3;
          break;
        case "RIPEMD160":
        case 4:
          r.prehashKey = 4;
          break;
        case "BITCOIN":
        case 5:
          r.prehashKey = 5;
          break;
        case "SHA512_256":
        case 6:
          r.prehashKey = 6;
          break;
      }
      switch (i.prehashValue) {
        case "NO_HASH":
        case 0:
          r.prehashValue = 0;
          break;
        case "SHA256":
        case 1:
          r.prehashValue = 1;
          break;
        case "SHA512":
        case 2:
          r.prehashValue = 2;
          break;
        case "KECCAK":
        case 3:
          r.prehashValue = 3;
          break;
        case "RIPEMD160":
        case 4:
          r.prehashValue = 4;
          break;
        case "BITCOIN":
        case 5:
          r.prehashValue = 5;
          break;
        case "SHA512_256":
        case 6:
          r.prehashValue = 6;
          break;
      }
      switch (i.length) {
        case "NO_PREFIX":
        case 0:
          r.length = 0;
          break;
        case "VAR_PROTO":
        case 1:
          r.length = 1;
          break;
        case "VAR_RLP":
        case 2:
          r.length = 2;
          break;
        case "FIXED32_BIG":
        case 3:
          r.length = 3;
          break;
        case "FIXED32_LITTLE":
        case 4:
          r.length = 4;
          break;
        case "FIXED64_BIG":
        case 5:
          r.length = 5;
          break;
        case "FIXED64_LITTLE":
        case 6:
          r.length = 6;
          break;
        case "REQUIRE_32_BYTES":
        case 7:
          r.length = 7;
          break;
        case "REQUIRE_64_BYTES":
        case 8:
          r.length = 8;
          break;
      }
      return i.prefix != null && (typeof i.prefix == "string" ? te.base64.decode(i.prefix, r.prefix = te.newBuffer(te.base64.length(i.prefix)), 0) : i.prefix.length && (r.prefix = i.prefix)), r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      return r.defaults && (u.hash = r.enums === String ? "NO_HASH" : 0, u.prehashKey = r.enums === String ? "NO_HASH" : 0, u.prehashValue = r.enums === String ? "NO_HASH" : 0, u.length = r.enums === String ? "NO_PREFIX" : 0, r.bytes === String ? u.prefix = "" : (u.prefix = [], r.bytes !== Array && (u.prefix = te.newBuffer(u.prefix)))), i.hash != null && i.hasOwnProperty("hash") && (u.hash = r.enums === String ? X.ics23.HashOp[i.hash] : i.hash), i.prehashKey != null && i.hasOwnProperty("prehashKey") && (u.prehashKey = r.enums === String ? X.ics23.HashOp[i.prehashKey] : i.prehashKey), i.prehashValue != null && i.hasOwnProperty("prehashValue") && (u.prehashValue = r.enums === String ? X.ics23.HashOp[i.prehashValue] : i.prehashValue), i.length != null && i.hasOwnProperty("length") && (u.length = r.enums === String ? X.ics23.LengthOp[i.length] : i.length), i.prefix != null && i.hasOwnProperty("prefix") && (u.prefix = r.bytes === String ? te.base64.encode(i.prefix, 0, i.prefix.length) : r.bytes === Array ? Array.prototype.slice.call(i.prefix) : i.prefix), u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.InnerOp = function() {
    function n(c) {
      if (c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.hash = 0, n.prototype.prefix = te.newBuffer([]), n.prototype.suffix = te.newBuffer([]), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      return r || (r = Ye.create()), i.hash != null && i.hasOwnProperty("hash") && r.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(i.hash), i.prefix != null && i.hasOwnProperty("prefix") && r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(i.prefix), i.suffix != null && i.hasOwnProperty("suffix") && r.uint32(
        /* id 3, wireType 2 =*/
        26
      ).bytes(i.suffix), r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.InnerOp(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.hash = i.int32();
            break;
          case 2:
            f.prefix = i.bytes();
            break;
          case 3:
            f.suffix = i.bytes();
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.hash != null && i.hasOwnProperty("hash"))
        switch (i.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return i.prefix != null && i.hasOwnProperty("prefix") && !(i.prefix && typeof i.prefix.length == "number" || te.isString(i.prefix)) ? "prefix: buffer expected" : i.suffix != null && i.hasOwnProperty("suffix") && !(i.suffix && typeof i.suffix.length == "number" || te.isString(i.suffix)) ? "suffix: buffer expected" : null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.InnerOp)
        return i;
      var r = new X.ics23.InnerOp();
      switch (i.hash) {
        case "NO_HASH":
        case 0:
          r.hash = 0;
          break;
        case "SHA256":
        case 1:
          r.hash = 1;
          break;
        case "SHA512":
        case 2:
          r.hash = 2;
          break;
        case "KECCAK":
        case 3:
          r.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          r.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          r.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          r.hash = 6;
          break;
      }
      return i.prefix != null && (typeof i.prefix == "string" ? te.base64.decode(i.prefix, r.prefix = te.newBuffer(te.base64.length(i.prefix)), 0) : i.prefix.length && (r.prefix = i.prefix)), i.suffix != null && (typeof i.suffix == "string" ? te.base64.decode(i.suffix, r.suffix = te.newBuffer(te.base64.length(i.suffix)), 0) : i.suffix.length && (r.suffix = i.suffix)), r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      return r.defaults && (u.hash = r.enums === String ? "NO_HASH" : 0, r.bytes === String ? u.prefix = "" : (u.prefix = [], r.bytes !== Array && (u.prefix = te.newBuffer(u.prefix))), r.bytes === String ? u.suffix = "" : (u.suffix = [], r.bytes !== Array && (u.suffix = te.newBuffer(u.suffix)))), i.hash != null && i.hasOwnProperty("hash") && (u.hash = r.enums === String ? X.ics23.HashOp[i.hash] : i.hash), i.prefix != null && i.hasOwnProperty("prefix") && (u.prefix = r.bytes === String ? te.base64.encode(i.prefix, 0, i.prefix.length) : r.bytes === Array ? Array.prototype.slice.call(i.prefix) : i.prefix), i.suffix != null && i.hasOwnProperty("suffix") && (u.suffix = r.bytes === String ? te.base64.encode(i.suffix, 0, i.suffix.length) : r.bytes === Array ? Array.prototype.slice.call(i.suffix) : i.suffix), u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.ProofSpec = function() {
    function n(c) {
      if (c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.leafSpec = null, n.prototype.innerSpec = null, n.prototype.maxDepth = 0, n.prototype.minDepth = 0, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      return r || (r = Ye.create()), i.leafSpec != null && i.hasOwnProperty("leafSpec") && X.ics23.LeafOp.encode(i.leafSpec, r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.innerSpec != null && i.hasOwnProperty("innerSpec") && X.ics23.InnerSpec.encode(i.innerSpec, r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), i.maxDepth != null && i.hasOwnProperty("maxDepth") && r.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(i.maxDepth), i.minDepth != null && i.hasOwnProperty("minDepth") && r.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(i.minDepth), r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.ProofSpec(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.leafSpec = X.ics23.LeafOp.decode(i, i.uint32());
            break;
          case 2:
            f.innerSpec = X.ics23.InnerSpec.decode(i, i.uint32());
            break;
          case 3:
            f.maxDepth = i.int32();
            break;
          case 4:
            f.minDepth = i.int32();
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.leafSpec != null && i.hasOwnProperty("leafSpec")) {
        var r = X.ics23.LeafOp.verify(i.leafSpec);
        if (r)
          return "leafSpec." + r;
      }
      if (i.innerSpec != null && i.hasOwnProperty("innerSpec")) {
        var r = X.ics23.InnerSpec.verify(i.innerSpec);
        if (r)
          return "innerSpec." + r;
      }
      return i.maxDepth != null && i.hasOwnProperty("maxDepth") && !te.isInteger(i.maxDepth) ? "maxDepth: integer expected" : i.minDepth != null && i.hasOwnProperty("minDepth") && !te.isInteger(i.minDepth) ? "minDepth: integer expected" : null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.ProofSpec)
        return i;
      var r = new X.ics23.ProofSpec();
      if (i.leafSpec != null) {
        if (typeof i.leafSpec != "object")
          throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
        r.leafSpec = X.ics23.LeafOp.fromObject(i.leafSpec);
      }
      if (i.innerSpec != null) {
        if (typeof i.innerSpec != "object")
          throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
        r.innerSpec = X.ics23.InnerSpec.fromObject(i.innerSpec);
      }
      return i.maxDepth != null && (r.maxDepth = i.maxDepth | 0), i.minDepth != null && (r.minDepth = i.minDepth | 0), r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      return r.defaults && (u.leafSpec = null, u.innerSpec = null, u.maxDepth = 0, u.minDepth = 0), i.leafSpec != null && i.hasOwnProperty("leafSpec") && (u.leafSpec = X.ics23.LeafOp.toObject(i.leafSpec, r)), i.innerSpec != null && i.hasOwnProperty("innerSpec") && (u.innerSpec = X.ics23.InnerSpec.toObject(i.innerSpec, r)), i.maxDepth != null && i.hasOwnProperty("maxDepth") && (u.maxDepth = i.maxDepth), i.minDepth != null && i.hasOwnProperty("minDepth") && (u.minDepth = i.minDepth), u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.InnerSpec = function() {
    function n(c) {
      if (this.childOrder = [], c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.childOrder = te.emptyArray, n.prototype.childSize = 0, n.prototype.minPrefixLength = 0, n.prototype.maxPrefixLength = 0, n.prototype.emptyChild = te.newBuffer([]), n.prototype.hash = 0, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      if (r || (r = Ye.create()), i.childOrder != null && i.childOrder.length) {
        r.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork();
        for (var u = 0; u < i.childOrder.length; ++u)
          r.int32(i.childOrder[u]);
        r.ldelim();
      }
      return i.childSize != null && i.hasOwnProperty("childSize") && r.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(i.childSize), i.minPrefixLength != null && i.hasOwnProperty("minPrefixLength") && r.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(i.minPrefixLength), i.maxPrefixLength != null && i.hasOwnProperty("maxPrefixLength") && r.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(i.maxPrefixLength), i.emptyChild != null && i.hasOwnProperty("emptyChild") && r.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(i.emptyChild), i.hash != null && i.hasOwnProperty("hash") && r.uint32(
        /* id 6, wireType 0 =*/
        48
      ).int32(i.hash), r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.InnerSpec(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            if (f.childOrder && f.childOrder.length || (f.childOrder = []), (O & 7) === 2)
              for (var A = i.uint32() + i.pos; i.pos < A; )
                f.childOrder.push(i.int32());
            else
              f.childOrder.push(i.int32());
            break;
          case 2:
            f.childSize = i.int32();
            break;
          case 3:
            f.minPrefixLength = i.int32();
            break;
          case 4:
            f.maxPrefixLength = i.int32();
            break;
          case 5:
            f.emptyChild = i.bytes();
            break;
          case 6:
            f.hash = i.int32();
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.childOrder != null && i.hasOwnProperty("childOrder")) {
        if (!Array.isArray(i.childOrder))
          return "childOrder: array expected";
        for (var r = 0; r < i.childOrder.length; ++r)
          if (!te.isInteger(i.childOrder[r]))
            return "childOrder: integer[] expected";
      }
      if (i.childSize != null && i.hasOwnProperty("childSize") && !te.isInteger(i.childSize))
        return "childSize: integer expected";
      if (i.minPrefixLength != null && i.hasOwnProperty("minPrefixLength") && !te.isInteger(i.minPrefixLength))
        return "minPrefixLength: integer expected";
      if (i.maxPrefixLength != null && i.hasOwnProperty("maxPrefixLength") && !te.isInteger(i.maxPrefixLength))
        return "maxPrefixLength: integer expected";
      if (i.emptyChild != null && i.hasOwnProperty("emptyChild") && !(i.emptyChild && typeof i.emptyChild.length == "number" || te.isString(i.emptyChild)))
        return "emptyChild: buffer expected";
      if (i.hash != null && i.hasOwnProperty("hash"))
        switch (i.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.InnerSpec)
        return i;
      var r = new X.ics23.InnerSpec();
      if (i.childOrder) {
        if (!Array.isArray(i.childOrder))
          throw TypeError(".ics23.InnerSpec.childOrder: array expected");
        r.childOrder = [];
        for (var u = 0; u < i.childOrder.length; ++u)
          r.childOrder[u] = i.childOrder[u] | 0;
      }
      switch (i.childSize != null && (r.childSize = i.childSize | 0), i.minPrefixLength != null && (r.minPrefixLength = i.minPrefixLength | 0), i.maxPrefixLength != null && (r.maxPrefixLength = i.maxPrefixLength | 0), i.emptyChild != null && (typeof i.emptyChild == "string" ? te.base64.decode(i.emptyChild, r.emptyChild = te.newBuffer(te.base64.length(i.emptyChild)), 0) : i.emptyChild.length && (r.emptyChild = i.emptyChild)), i.hash) {
        case "NO_HASH":
        case 0:
          r.hash = 0;
          break;
        case "SHA256":
        case 1:
          r.hash = 1;
          break;
        case "SHA512":
        case 2:
          r.hash = 2;
          break;
        case "KECCAK":
        case 3:
          r.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          r.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          r.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          r.hash = 6;
          break;
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      if ((r.arrays || r.defaults) && (u.childOrder = []), r.defaults && (u.childSize = 0, u.minPrefixLength = 0, u.maxPrefixLength = 0, r.bytes === String ? u.emptyChild = "" : (u.emptyChild = [], r.bytes !== Array && (u.emptyChild = te.newBuffer(u.emptyChild))), u.hash = r.enums === String ? "NO_HASH" : 0), i.childOrder && i.childOrder.length) {
        u.childOrder = [];
        for (var f = 0; f < i.childOrder.length; ++f)
          u.childOrder[f] = i.childOrder[f];
      }
      return i.childSize != null && i.hasOwnProperty("childSize") && (u.childSize = i.childSize), i.minPrefixLength != null && i.hasOwnProperty("minPrefixLength") && (u.minPrefixLength = i.minPrefixLength), i.maxPrefixLength != null && i.hasOwnProperty("maxPrefixLength") && (u.maxPrefixLength = i.maxPrefixLength), i.emptyChild != null && i.hasOwnProperty("emptyChild") && (u.emptyChild = r.bytes === String ? te.base64.encode(i.emptyChild, 0, i.emptyChild.length) : r.bytes === Array ? Array.prototype.slice.call(i.emptyChild) : i.emptyChild), i.hash != null && i.hasOwnProperty("hash") && (u.hash = r.enums === String ? X.ics23.HashOp[i.hash] : i.hash), u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.BatchProof = function() {
    function n(c) {
      if (this.entries = [], c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.entries = te.emptyArray, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      if (r || (r = Ye.create()), i.entries != null && i.entries.length)
        for (var u = 0; u < i.entries.length; ++u)
          X.ics23.BatchEntry.encode(i.entries[u], r.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      return r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.BatchProof(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.entries && f.entries.length || (f.entries = []), f.entries.push(X.ics23.BatchEntry.decode(i, i.uint32()));
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.entries != null && i.hasOwnProperty("entries")) {
        if (!Array.isArray(i.entries))
          return "entries: array expected";
        for (var r = 0; r < i.entries.length; ++r) {
          var u = X.ics23.BatchEntry.verify(i.entries[r]);
          if (u)
            return "entries." + u;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.BatchProof)
        return i;
      var r = new X.ics23.BatchProof();
      if (i.entries) {
        if (!Array.isArray(i.entries))
          throw TypeError(".ics23.BatchProof.entries: array expected");
        r.entries = [];
        for (var u = 0; u < i.entries.length; ++u) {
          if (typeof i.entries[u] != "object")
            throw TypeError(".ics23.BatchProof.entries: object expected");
          r.entries[u] = X.ics23.BatchEntry.fromObject(i.entries[u]);
        }
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      if ((r.arrays || r.defaults) && (u.entries = []), i.entries && i.entries.length) {
        u.entries = [];
        for (var f = 0; f < i.entries.length; ++f)
          u.entries[f] = X.ics23.BatchEntry.toObject(i.entries[f], r);
      }
      return u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.BatchEntry = function() {
    function n(i) {
      if (i)
        for (var r = Object.keys(i), u = 0; u < r.length; ++u)
          i[r[u]] != null && (this[r[u]] = i[r[u]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null;
    var c;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(c = ["exist", "nonexist"]),
      set: te.oneOfSetter(c)
    }), n.create = function(r) {
      return new n(r);
    }, n.encode = function(r, u) {
      return u || (u = Ye.create()), r.exist != null && r.hasOwnProperty("exist") && X.ics23.ExistenceProof.encode(r.exist, u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), r.nonexist != null && r.hasOwnProperty("nonexist") && X.ics23.NonExistenceProof.encode(r.nonexist, u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), u;
    }, n.encodeDelimited = function(r, u) {
      return this.encode(r, u).ldelim();
    }, n.decode = function(r, u) {
      r instanceof ae || (r = ae.create(r));
      for (var f = u === void 0 ? r.len : r.pos + u, O = new X.ics23.BatchEntry(); r.pos < f; ) {
        var A = r.uint32();
        switch (A >>> 3) {
          case 1:
            O.exist = X.ics23.ExistenceProof.decode(r, r.uint32());
            break;
          case 2:
            O.nonexist = X.ics23.NonExistenceProof.decode(r, r.uint32());
            break;
          default:
            r.skipType(A & 7);
            break;
        }
      }
      return O;
    }, n.decodeDelimited = function(r) {
      return r instanceof ae || (r = new ae(r)), this.decode(r, r.uint32());
    }, n.verify = function(r) {
      if (typeof r != "object" || r === null)
        return "object expected";
      var u = {};
      if (r.exist != null && r.hasOwnProperty("exist")) {
        u.proof = 1;
        {
          var f = X.ics23.ExistenceProof.verify(r.exist);
          if (f)
            return "exist." + f;
        }
      }
      if (r.nonexist != null && r.hasOwnProperty("nonexist")) {
        if (u.proof === 1)
          return "proof: multiple values";
        u.proof = 1;
        {
          var f = X.ics23.NonExistenceProof.verify(r.nonexist);
          if (f)
            return "nonexist." + f;
        }
      }
      return null;
    }, n.fromObject = function(r) {
      if (r instanceof X.ics23.BatchEntry)
        return r;
      var u = new X.ics23.BatchEntry();
      if (r.exist != null) {
        if (typeof r.exist != "object")
          throw TypeError(".ics23.BatchEntry.exist: object expected");
        u.exist = X.ics23.ExistenceProof.fromObject(r.exist);
      }
      if (r.nonexist != null) {
        if (typeof r.nonexist != "object")
          throw TypeError(".ics23.BatchEntry.nonexist: object expected");
        u.nonexist = X.ics23.NonExistenceProof.fromObject(r.nonexist);
      }
      return u;
    }, n.toObject = function(r, u) {
      u || (u = {});
      var f = {};
      return r.exist != null && r.hasOwnProperty("exist") && (f.exist = X.ics23.ExistenceProof.toObject(r.exist, u), u.oneofs && (f.proof = "exist")), r.nonexist != null && r.hasOwnProperty("nonexist") && (f.nonexist = X.ics23.NonExistenceProof.toObject(r.nonexist, u), u.oneofs && (f.proof = "nonexist")), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.CompressedBatchProof = function() {
    function n(c) {
      if (this.entries = [], this.lookupInners = [], c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.entries = te.emptyArray, n.prototype.lookupInners = te.emptyArray, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      if (r || (r = Ye.create()), i.entries != null && i.entries.length)
        for (var u = 0; u < i.entries.length; ++u)
          X.ics23.CompressedBatchEntry.encode(i.entries[u], r.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      if (i.lookupInners != null && i.lookupInners.length)
        for (var u = 0; u < i.lookupInners.length; ++u)
          X.ics23.InnerOp.encode(i.lookupInners[u], r.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
      return r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.CompressedBatchProof(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.entries && f.entries.length || (f.entries = []), f.entries.push(X.ics23.CompressedBatchEntry.decode(i, i.uint32()));
            break;
          case 2:
            f.lookupInners && f.lookupInners.length || (f.lookupInners = []), f.lookupInners.push(X.ics23.InnerOp.decode(i, i.uint32()));
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.entries != null && i.hasOwnProperty("entries")) {
        if (!Array.isArray(i.entries))
          return "entries: array expected";
        for (var r = 0; r < i.entries.length; ++r) {
          var u = X.ics23.CompressedBatchEntry.verify(i.entries[r]);
          if (u)
            return "entries." + u;
        }
      }
      if (i.lookupInners != null && i.hasOwnProperty("lookupInners")) {
        if (!Array.isArray(i.lookupInners))
          return "lookupInners: array expected";
        for (var r = 0; r < i.lookupInners.length; ++r) {
          var u = X.ics23.InnerOp.verify(i.lookupInners[r]);
          if (u)
            return "lookupInners." + u;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.CompressedBatchProof)
        return i;
      var r = new X.ics23.CompressedBatchProof();
      if (i.entries) {
        if (!Array.isArray(i.entries))
          throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
        r.entries = [];
        for (var u = 0; u < i.entries.length; ++u) {
          if (typeof i.entries[u] != "object")
            throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
          r.entries[u] = X.ics23.CompressedBatchEntry.fromObject(i.entries[u]);
        }
      }
      if (i.lookupInners) {
        if (!Array.isArray(i.lookupInners))
          throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
        r.lookupInners = [];
        for (var u = 0; u < i.lookupInners.length; ++u) {
          if (typeof i.lookupInners[u] != "object")
            throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
          r.lookupInners[u] = X.ics23.InnerOp.fromObject(i.lookupInners[u]);
        }
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      if ((r.arrays || r.defaults) && (u.entries = [], u.lookupInners = []), i.entries && i.entries.length) {
        u.entries = [];
        for (var f = 0; f < i.entries.length; ++f)
          u.entries[f] = X.ics23.CompressedBatchEntry.toObject(i.entries[f], r);
      }
      if (i.lookupInners && i.lookupInners.length) {
        u.lookupInners = [];
        for (var f = 0; f < i.lookupInners.length; ++f)
          u.lookupInners[f] = X.ics23.InnerOp.toObject(i.lookupInners[f], r);
      }
      return u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.CompressedBatchEntry = function() {
    function n(i) {
      if (i)
        for (var r = Object.keys(i), u = 0; u < r.length; ++u)
          i[r[u]] != null && (this[r[u]] = i[r[u]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null;
    var c;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(c = ["exist", "nonexist"]),
      set: te.oneOfSetter(c)
    }), n.create = function(r) {
      return new n(r);
    }, n.encode = function(r, u) {
      return u || (u = Ye.create()), r.exist != null && r.hasOwnProperty("exist") && X.ics23.CompressedExistenceProof.encode(r.exist, u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), r.nonexist != null && r.hasOwnProperty("nonexist") && X.ics23.CompressedNonExistenceProof.encode(r.nonexist, u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), u;
    }, n.encodeDelimited = function(r, u) {
      return this.encode(r, u).ldelim();
    }, n.decode = function(r, u) {
      r instanceof ae || (r = ae.create(r));
      for (var f = u === void 0 ? r.len : r.pos + u, O = new X.ics23.CompressedBatchEntry(); r.pos < f; ) {
        var A = r.uint32();
        switch (A >>> 3) {
          case 1:
            O.exist = X.ics23.CompressedExistenceProof.decode(r, r.uint32());
            break;
          case 2:
            O.nonexist = X.ics23.CompressedNonExistenceProof.decode(r, r.uint32());
            break;
          default:
            r.skipType(A & 7);
            break;
        }
      }
      return O;
    }, n.decodeDelimited = function(r) {
      return r instanceof ae || (r = new ae(r)), this.decode(r, r.uint32());
    }, n.verify = function(r) {
      if (typeof r != "object" || r === null)
        return "object expected";
      var u = {};
      if (r.exist != null && r.hasOwnProperty("exist")) {
        u.proof = 1;
        {
          var f = X.ics23.CompressedExistenceProof.verify(r.exist);
          if (f)
            return "exist." + f;
        }
      }
      if (r.nonexist != null && r.hasOwnProperty("nonexist")) {
        if (u.proof === 1)
          return "proof: multiple values";
        u.proof = 1;
        {
          var f = X.ics23.CompressedNonExistenceProof.verify(r.nonexist);
          if (f)
            return "nonexist." + f;
        }
      }
      return null;
    }, n.fromObject = function(r) {
      if (r instanceof X.ics23.CompressedBatchEntry)
        return r;
      var u = new X.ics23.CompressedBatchEntry();
      if (r.exist != null) {
        if (typeof r.exist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
        u.exist = X.ics23.CompressedExistenceProof.fromObject(r.exist);
      }
      if (r.nonexist != null) {
        if (typeof r.nonexist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
        u.nonexist = X.ics23.CompressedNonExistenceProof.fromObject(r.nonexist);
      }
      return u;
    }, n.toObject = function(r, u) {
      u || (u = {});
      var f = {};
      return r.exist != null && r.hasOwnProperty("exist") && (f.exist = X.ics23.CompressedExistenceProof.toObject(r.exist, u), u.oneofs && (f.proof = "exist")), r.nonexist != null && r.hasOwnProperty("nonexist") && (f.nonexist = X.ics23.CompressedNonExistenceProof.toObject(r.nonexist, u), u.oneofs && (f.proof = "nonexist")), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.CompressedExistenceProof = function() {
    function n(c) {
      if (this.path = [], c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.value = te.newBuffer([]), n.prototype.leaf = null, n.prototype.path = te.emptyArray, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      if (r || (r = Ye.create()), i.key != null && i.hasOwnProperty("key") && r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(i.key), i.value != null && i.hasOwnProperty("value") && r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(i.value), i.leaf != null && i.hasOwnProperty("leaf") && X.ics23.LeafOp.encode(i.leaf, r.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i.path != null && i.path.length) {
        r.uint32(
          /* id 4, wireType 2 =*/
          34
        ).fork();
        for (var u = 0; u < i.path.length; ++u)
          r.int32(i.path[u]);
        r.ldelim();
      }
      return r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.CompressedExistenceProof(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.key = i.bytes();
            break;
          case 2:
            f.value = i.bytes();
            break;
          case 3:
            f.leaf = X.ics23.LeafOp.decode(i, i.uint32());
            break;
          case 4:
            if (f.path && f.path.length || (f.path = []), (O & 7) === 2)
              for (var A = i.uint32() + i.pos; i.pos < A; )
                f.path.push(i.int32());
            else
              f.path.push(i.int32());
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.key != null && i.hasOwnProperty("key") && !(i.key && typeof i.key.length == "number" || te.isString(i.key)))
        return "key: buffer expected";
      if (i.value != null && i.hasOwnProperty("value") && !(i.value && typeof i.value.length == "number" || te.isString(i.value)))
        return "value: buffer expected";
      if (i.leaf != null && i.hasOwnProperty("leaf")) {
        var r = X.ics23.LeafOp.verify(i.leaf);
        if (r)
          return "leaf." + r;
      }
      if (i.path != null && i.hasOwnProperty("path")) {
        if (!Array.isArray(i.path))
          return "path: array expected";
        for (var u = 0; u < i.path.length; ++u)
          if (!te.isInteger(i.path[u]))
            return "path: integer[] expected";
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.CompressedExistenceProof)
        return i;
      var r = new X.ics23.CompressedExistenceProof();
      if (i.key != null && (typeof i.key == "string" ? te.base64.decode(i.key, r.key = te.newBuffer(te.base64.length(i.key)), 0) : i.key.length && (r.key = i.key)), i.value != null && (typeof i.value == "string" ? te.base64.decode(i.value, r.value = te.newBuffer(te.base64.length(i.value)), 0) : i.value.length && (r.value = i.value)), i.leaf != null) {
        if (typeof i.leaf != "object")
          throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
        r.leaf = X.ics23.LeafOp.fromObject(i.leaf);
      }
      if (i.path) {
        if (!Array.isArray(i.path))
          throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
        r.path = [];
        for (var u = 0; u < i.path.length; ++u)
          r.path[u] = i.path[u] | 0;
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      if ((r.arrays || r.defaults) && (u.path = []), r.defaults && (r.bytes === String ? u.key = "" : (u.key = [], r.bytes !== Array && (u.key = te.newBuffer(u.key))), r.bytes === String ? u.value = "" : (u.value = [], r.bytes !== Array && (u.value = te.newBuffer(u.value))), u.leaf = null), i.key != null && i.hasOwnProperty("key") && (u.key = r.bytes === String ? te.base64.encode(i.key, 0, i.key.length) : r.bytes === Array ? Array.prototype.slice.call(i.key) : i.key), i.value != null && i.hasOwnProperty("value") && (u.value = r.bytes === String ? te.base64.encode(i.value, 0, i.value.length) : r.bytes === Array ? Array.prototype.slice.call(i.value) : i.value), i.leaf != null && i.hasOwnProperty("leaf") && (u.leaf = X.ics23.LeafOp.toObject(i.leaf, r)), i.path && i.path.length) {
        u.path = [];
        for (var f = 0; f < i.path.length; ++f)
          u.path[f] = i.path[f];
      }
      return u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e.CompressedNonExistenceProof = function() {
    function n(c) {
      if (c)
        for (var i = Object.keys(c), r = 0; r < i.length; ++r)
          c[i[r]] != null && (this[i[r]] = c[i[r]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.left = null, n.prototype.right = null, n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, r) {
      return r || (r = Ye.create()), i.key != null && i.hasOwnProperty("key") && r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(i.key), i.left != null && i.hasOwnProperty("left") && X.ics23.CompressedExistenceProof.encode(i.left, r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), i.right != null && i.hasOwnProperty("right") && X.ics23.CompressedExistenceProof.encode(i.right, r.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), r;
    }, n.encodeDelimited = function(i, r) {
      return this.encode(i, r).ldelim();
    }, n.decode = function(i, r) {
      i instanceof ae || (i = ae.create(i));
      for (var u = r === void 0 ? i.len : i.pos + r, f = new X.ics23.CompressedNonExistenceProof(); i.pos < u; ) {
        var O = i.uint32();
        switch (O >>> 3) {
          case 1:
            f.key = i.bytes();
            break;
          case 2:
            f.left = X.ics23.CompressedExistenceProof.decode(i, i.uint32());
            break;
          case 3:
            f.right = X.ics23.CompressedExistenceProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(O & 7);
            break;
        }
      }
      return f;
    }, n.decodeDelimited = function(i) {
      return i instanceof ae || (i = new ae(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      if (i.key != null && i.hasOwnProperty("key") && !(i.key && typeof i.key.length == "number" || te.isString(i.key)))
        return "key: buffer expected";
      if (i.left != null && i.hasOwnProperty("left")) {
        var r = X.ics23.CompressedExistenceProof.verify(i.left);
        if (r)
          return "left." + r;
      }
      if (i.right != null && i.hasOwnProperty("right")) {
        var r = X.ics23.CompressedExistenceProof.verify(i.right);
        if (r)
          return "right." + r;
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof X.ics23.CompressedNonExistenceProof)
        return i;
      var r = new X.ics23.CompressedNonExistenceProof();
      if (i.key != null && (typeof i.key == "string" ? te.base64.decode(i.key, r.key = te.newBuffer(te.base64.length(i.key)), 0) : i.key.length && (r.key = i.key)), i.left != null) {
        if (typeof i.left != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
        r.left = X.ics23.CompressedExistenceProof.fromObject(i.left);
      }
      if (i.right != null) {
        if (typeof i.right != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
        r.right = X.ics23.CompressedExistenceProof.fromObject(i.right);
      }
      return r;
    }, n.toObject = function(i, r) {
      r || (r = {});
      var u = {};
      return r.defaults && (r.bytes === String ? u.key = "" : (u.key = [], r.bytes !== Array && (u.key = te.newBuffer(u.key))), u.left = null, u.right = null), i.key != null && i.hasOwnProperty("key") && (u.key = r.bytes === String ? te.base64.encode(i.key, 0, i.key.length) : r.bytes === Array ? Array.prototype.slice.call(i.key) : i.key), i.left != null && i.hasOwnProperty("left") && (u.left = X.ics23.CompressedExistenceProof.toObject(i.left, r)), i.right != null && i.hasOwnProperty("right") && (u.right = X.ics23.CompressedExistenceProof.toObject(i.right, r)), u;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, ke.util.toJSONOptions);
    }, n;
  }(), e;
}();
var Zr = X, Pn = {}, At = {};
Object.defineProperty(At, "__esModule", { value: !0 });
At.decompress = At.compress = void 0;
const fl = Zr;
function pl(e) {
  return e.batch ? { compressed: ml(e.batch) } : e;
}
At.compress = pl;
function hl(e) {
  return e.compressed ? { batch: gl(e.compressed) } : e;
}
At.decompress = hl;
function ml(e) {
  const n = [], c = [], i = /* @__PURE__ */ new Map();
  for (const r of e.entries)
    if (r.exist) {
      const u = { exist: Wi(r.exist, c, i) };
      n.push(u);
    } else if (r.nonexist) {
      const u = r.nonexist, f = {
        nonexist: {
          key: u.key,
          left: Wi(u.left, c, i),
          right: Wi(u.right, c, i)
        }
      };
      n.push(f);
    } else
      throw new Error("Unexpected batch entry during compress");
  return {
    entries: n,
    lookupInners: c
  };
}
function Wi(e, n, c) {
  if (!e)
    return;
  const i = e.path.map((r) => {
    const u = fl.ics23.InnerOp.encode(r).finish();
    let f = c.get(u);
    return f === void 0 && (f = n.length, n.push(r), c.set(u, f)), f;
  });
  return {
    key: e.key,
    value: e.value,
    leaf: e.leaf,
    path: i
  };
}
function gl(e) {
  const n = e.lookupInners;
  return {
    entries: e.entries.map((i) => {
      if (i.exist)
        return { exist: Zi(i.exist, n) };
      if (i.nonexist) {
        const r = i.nonexist;
        return {
          nonexist: {
            key: r.key,
            left: Zi(r.left, n),
            right: Zi(r.right, n)
          }
        };
      } else
        throw new Error("Unexpected batch entry during compress");
    })
  };
}
function Zi(e, n) {
  if (!e)
    return;
  const { key: c, value: i, leaf: r, path: u } = e, f = (u || []).map((O) => n[O]);
  return { key: c, value: i, leaf: r, path: f };
}
var ve = {}, Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.doHash = Un.applyInner = Un.applyLeaf = void 0;
const os = $c, as = Kc, ss = zc, Xe = Zr;
function yl(e, n, c) {
  if (n.length === 0)
    throw new Error("Missing key");
  if (c.length === 0)
    throw new Error("Missing value");
  const i = us(Ar(e.prehashKey), ds(e.length), n), r = us(Ar(e.prehashValue), ds(e.length), c), u = new Uint8Array([
    ...Co(e.prefix),
    ...i,
    ...r
  ]);
  return Qr(Ar(e.hash), u);
}
Un.applyLeaf = yl;
function Sl(e, n) {
  if (n.length === 0)
    throw new Error("Inner op needs child value");
  const c = new Uint8Array([
    ...Co(e.prefix),
    ...n,
    ...Co(e.suffix)
  ]);
  return Qr(Ar(e.hash), c);
}
Un.applyInner = Sl;
function Ko(e, n) {
  return e ?? n;
}
const Ar = (e) => Ko(e, Xe.ics23.HashOp.NO_HASH), ds = (e) => Ko(e, Xe.ics23.LengthOp.NO_PREFIX), Co = (e) => Ko(e, new Uint8Array([]));
function us(e, n, c) {
  const i = Ol(e, c);
  return Rl(n, i);
}
function Ol(e, n) {
  return e === Xe.ics23.HashOp.NO_HASH ? n : Qr(e, n);
}
function Qr(e, n) {
  switch (e) {
    case Xe.ics23.HashOp.SHA256:
      return (0, as.sha256)(n);
    case Xe.ics23.HashOp.SHA512:
      return (0, ss.sha512)(n);
    case Xe.ics23.HashOp.RIPEMD160:
      return (0, os.ripemd160)(n);
    case Xe.ics23.HashOp.BITCOIN:
      return (0, os.ripemd160)((0, as.sha256)(n));
    case Xe.ics23.HashOp.SHA512_256:
      return (0, ss.sha512_256)(n);
  }
  throw new Error(`Unsupported hashop: ${e}`);
}
Un.doHash = Qr;
function Rl(e, n) {
  switch (e) {
    case Xe.ics23.LengthOp.NO_PREFIX:
      return n;
    case Xe.ics23.LengthOp.VAR_PROTO:
      return new Uint8Array([...Pl(n.length), ...n]);
    case Xe.ics23.LengthOp.REQUIRE_32_BYTES:
      if (n.length !== 32)
        throw new Error(`Length is ${n.length}, not 32 bytes`);
      return n;
    case Xe.ics23.LengthOp.REQUIRE_64_BYTES:
      if (n.length !== 64)
        throw new Error(`Length is ${n.length}, not 64 bytes`);
      return n;
    case Xe.ics23.LengthOp.FIXED32_LITTLE:
      return new Uint8Array([...vl(n.length), ...n]);
  }
  throw new Error(`Unsupported lengthop: ${e}`);
}
function Pl(e) {
  let n = [], c = e;
  for (; c >= 128; ) {
    const i = c % 128 + 128;
    n = [...n, i], c = c / 128;
  }
  return n = [...n, c], new Uint8Array(n);
}
function vl(e) {
  const n = new Uint8Array(4);
  let c = e;
  for (let i = n.length; i > 0; i--)
    n[Math.abs(i - n.length)] = c % 256, c = Math.floor(c / 256);
  return n;
}
var De = {};
Object.defineProperty(De, "__esModule", { value: !0 });
De.bytesBefore = De.ensureBytesBefore = De.bytesEqual = De.ensureBytesEqual = De.ensureInner = De.ensureLeaf = void 0;
function kl(e, n) {
  if (e.hash !== n.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (e.prehashKey !== n.prehashKey)
    throw new Error(`Unexpected prehashKey: ${e.prehashKey}`);
  if (e.prehashValue !== n.prehashValue)
    throw new Error(`Unexpected prehashValue: ${e.prehashValue}`);
  if (e.length !== n.length)
    throw new Error(`Unexpected length op: ${e.length}`);
  _l(e.prefix, n.prefix);
}
De.ensureLeaf = kl;
function Al(e, n, c) {
  if (e.hash !== c.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (!e.prefix)
    throw new Error("No prefix set for inner node");
  if (Tl(e.prefix, n))
    throw new Error("Inner node has leaf prefix");
  if (e.prefix.length < (c.minPrefixLength || 0))
    throw new Error(`Prefix too short: ${e.prefix.length} bytes`);
  const i = (c.childOrder.length - 1) * c.childSize;
  if (e.prefix.length > (c.maxPrefixLength || 0) + i)
    throw new Error(`Prefix too long: ${e.prefix.length} bytes`);
}
De.ensureInner = Al;
function _l(e, n) {
  if (!(!n || n.length === 0)) {
    if (!e)
      throw new Error("Target bytes missing");
    qd(n, e.slice(0, n.length));
  }
}
function qd(e, n) {
  if (e.length !== n.length)
    throw new Error(`Different lengths ${e.length} vs ${n.length}`);
  for (let c = 0; c < e.length; c++)
    if (e[c] !== n[c])
      throw new Error(`Arrays differ at index ${c}: ${e[c]} vs ${n[c]}`);
}
De.ensureBytesEqual = qd;
function Nl(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let c = 0; c < e.length; c++)
    if (e[c] !== n[c])
      return !1;
  return !0;
}
De.bytesEqual = Nl;
function Tl(e, n) {
  if (!n || n.length === 0 || !e || e.length <= n.length)
    return !1;
  for (let c = 0; c < n.length; c++)
    if (e[c] !== n[c])
      return !1;
  throw !0;
}
function El(e, n) {
  if (!Wd(e, n))
    throw new Error("first is after last");
}
De.ensureBytesBefore = El;
function Wd(e, n) {
  const c = e.length < n.length ? e.length : n.length;
  for (let i = 0; i < c; i++) {
    if (e[i] < n[i])
      return !0;
    if (e[i] > n[i])
      return !1;
  }
  return e.length < n.length;
}
De.bytesBefore = Wd;
Object.defineProperty(ve, "__esModule", { value: !0 });
ve.ensureLeftNeighbor = ve.ensureSpec = ve.calculateExistenceRoot = ve.verifyNonExistence = ve.verifyExistence = ve.smtSpec = ve.tendermintSpec = ve.iavlSpec = void 0;
const Ue = Zr, cs = Un, Tn = De;
ve.iavlSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: Ue.ics23.HashOp.SHA256,
    prehashValue: Ue.ics23.HashOp.SHA256,
    prehashKey: Ue.ics23.HashOp.NO_HASH,
    length: Ue.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 4,
    maxPrefixLength: 12,
    childSize: 33,
    hash: Ue.ics23.HashOp.SHA256
  }
};
ve.tendermintSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: Ue.ics23.HashOp.SHA256,
    prehashValue: Ue.ics23.HashOp.SHA256,
    prehashKey: Ue.ics23.HashOp.NO_HASH,
    length: Ue.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 1,
    maxPrefixLength: 1,
    childSize: 32,
    hash: Ue.ics23.HashOp.SHA256
  }
};
ve.smtSpec = {
  leafSpec: {
    hash: Ue.ics23.HashOp.SHA256,
    prehashKey: Ue.ics23.HashOp.NO_HASH,
    prehashValue: Ue.ics23.HashOp.SHA256,
    length: Ue.ics23.LengthOp.NO_PREFIX,
    prefix: Uint8Array.from([0])
  },
  innerSpec: {
    childOrder: [0, 1],
    childSize: 32,
    minPrefixLength: 1,
    maxPrefixLength: 1,
    emptyChild: new Uint8Array(32),
    hash: Ue.ics23.HashOp.SHA256
  },
  maxDepth: 256
};
function Io(e, n, c, i, r) {
  Qd(e, n);
  const u = Zd(e);
  (0, Tn.ensureBytesEqual)(u, c), (0, Tn.ensureBytesEqual)(i, e.key), (0, Tn.ensureBytesEqual)(r, e.value);
}
ve.verifyExistence = Io;
function Cl(e, n, c, i) {
  let r, u;
  if (e.left && (Io(e.left, n, c, e.left.key, e.left.value), r = e.left.key), e.right && (Io(e.right, n, c, e.right.key, e.right.value), u = e.right.key), !r && !u)
    throw new Error("neither left nor right proof defined");
  if (r && (0, Tn.ensureBytesBefore)(r, i), u && (0, Tn.ensureBytesBefore)(i, u), !n.innerSpec)
    throw new Error("no inner spec");
  r ? u ? $d(n.innerSpec, e.left.path, e.right.path) : Gd(n.innerSpec, e.left.path) : Fd(n.innerSpec, e.right.path);
}
ve.verifyNonExistence = Cl;
function Zd(e) {
  if (!e.key || !e.value)
    throw new Error("Existence proof needs key and value set");
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  const n = e.path || [];
  let c = (0, cs.applyLeaf)(e.leaf, e.key, e.value);
  for (const i of n)
    c = (0, cs.applyInner)(i, c);
  return c;
}
ve.calculateExistenceRoot = Zd;
function Qd(e, n) {
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  if (!n.leafSpec)
    throw new Error("Spec must include leafSpec");
  if (!n.innerSpec)
    throw new Error("Spec must include innerSpec");
  (0, Tn.ensureLeaf)(e.leaf, n.leafSpec);
  const c = e.path || [];
  if (n.minDepth && c.length < n.minDepth)
    throw new Error(`Too few inner nodes ${c.length}`);
  if (n.maxDepth && c.length > n.maxDepth)
    throw new Error(`Too many inner nodes ${c.length}`);
  for (const i of c)
    (0, Tn.ensureInner)(i, n.leafSpec.prefix, n.innerSpec);
}
ve.ensureSpec = Qd;
function Fd(e, n) {
  const { minPrefix: c, maxPrefix: i, suffix: r } = Yo(e, 0);
  for (const u of n)
    if (!zo(u, c, i, r))
      throw new Error("Step not leftmost");
}
function Gd(e, n) {
  const c = e.childOrder.length - 1, { minPrefix: i, maxPrefix: r, suffix: u } = Yo(e, c);
  for (const f of n)
    if (!zo(f, i, r, u))
      throw new Error("Step not leftmost");
}
function $d(e, n, c) {
  const i = [...n], r = [...c];
  let u = i.pop(), f = r.pop();
  for (; (0, Tn.bytesEqual)(u.prefix, f.prefix) && (0, Tn.bytesEqual)(u.suffix, f.suffix); )
    u = i.pop(), f = r.pop();
  if (!Il(e, u, f))
    throw new Error("Not left neightbor at first divergent step");
  Gd(e, i), Fd(e, r);
}
ve.ensureLeftNeighbor = $d;
function Il(e, n, c) {
  const i = ls(e, n);
  return ls(e, c) === i + 1;
}
function ls(e, n) {
  for (let c = 0; c < e.childOrder.length; c++) {
    const { minPrefix: i, maxPrefix: r, suffix: u } = Yo(e, c);
    if (zo(n, i, r, u))
      return c;
  }
  throw new Error("Cannot find any valid spacing for this node");
}
function zo(e, n, c, i) {
  return (e.prefix || []).length < n || (e.prefix || []).length > c ? !1 : (e.suffix || []).length === i;
}
function Yo(e, n) {
  const c = wl(e.childOrder, n), i = c * e.childSize, r = i + e.minPrefixLength, u = i + e.maxPrefixLength, f = (e.childOrder.length - 1 - c) * e.childSize;
  return { minPrefix: r, maxPrefix: u, suffix: f };
}
function wl(e, n) {
  if (n < 0 || n >= e.length)
    throw new Error(`Invalid branch: ${n}`);
  return e.findIndex((c) => c === n);
}
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.batchVerifyNonMembership = Pn.batchVerifyMembership = Pn.verifyNonMembership = Pn.verifyMembership = void 0;
const Fr = At, Kd = ve, wo = De;
function zd(e, n, c, i, r) {
  const u = (0, Fr.decompress)(e), f = Jl(u, i);
  if (!f)
    return !1;
  try {
    return (0, Kd.verifyExistence)(f, n, c, i, r), !0;
  } catch {
    return !1;
  }
}
Pn.verifyMembership = zd;
function Yd(e, n, c, i) {
  const r = (0, Fr.decompress)(e), u = Dl(r, i);
  if (!u)
    return !1;
  try {
    return (0, Kd.verifyNonExistence)(u, n, c, i), !0;
  } catch {
    return !1;
  }
}
Pn.verifyNonMembership = Yd;
function bl(e, n, c, i) {
  const r = (0, Fr.decompress)(e);
  for (const [u, f] of i.entries())
    if (!zd(r, n, c, u, f))
      return !1;
  return !0;
}
Pn.batchVerifyMembership = bl;
function Bl(e, n, c, i) {
  const r = (0, Fr.decompress)(e);
  for (const u of i)
    if (!Yd(r, n, c, u))
      return !1;
  return !0;
}
Pn.batchVerifyNonMembership = Bl;
function Jl(e, n) {
  const c = (i) => !!i && (0, wo.bytesEqual)(n, i.key);
  if (c(e.exist))
    return e.exist;
  if (e.batch)
    return e.batch.entries.map((i) => i.exist || null).find(c);
}
function Dl(e, n) {
  const c = (i) => !!i && (!i.left || (0, wo.bytesBefore)(i.left.key, n)) && (!i.right || (0, wo.bytesBefore)(n, i.right.key));
  if (c(e.nonexist))
    return e.nonexist;
  if (e.batch)
    return e.batch.entries.map((i) => i.nonexist || null).find(c);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.verifyNonExistence = e.verifyExistence = e.tendermintSpec = e.iavlSpec = e.calculateExistenceRoot = e.verifyNonMembership = e.verifyMembership = e.ics23 = void 0;
  var n = Zr;
  Object.defineProperty(e, "ics23", { enumerable: !0, get: function() {
    return n.ics23;
  } });
  var c = Pn;
  Object.defineProperty(e, "verifyMembership", { enumerable: !0, get: function() {
    return c.verifyMembership;
  } }), Object.defineProperty(e, "verifyNonMembership", { enumerable: !0, get: function() {
    return c.verifyNonMembership;
  } });
  var i = ve;
  Object.defineProperty(e, "calculateExistenceRoot", { enumerable: !0, get: function() {
    return i.calculateExistenceRoot;
  } }), Object.defineProperty(e, "iavlSpec", { enumerable: !0, get: function() {
    return i.iavlSpec;
  } }), Object.defineProperty(e, "tendermintSpec", { enumerable: !0, get: function() {
    return i.tendermintSpec;
  } }), Object.defineProperty(e, "verifyExistence", { enumerable: !0, get: function() {
    return i.verifyExistence;
  } }), Object.defineProperty(e, "verifyNonExistence", { enumerable: !0, get: function() {
    return i.verifyNonExistence;
  } });
})(Hd);
var ir = {}, Gr = {}, Ee = {}, Xd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = n;
  function n(c) {
    var i, r = c.Symbol;
    if (typeof r == "function")
      if (r.observable)
        i = r.observable;
      else {
        i = r.for("https://github.com/benlesh/symbol-observable");
        try {
          r.observable = i;
        } catch {
        }
      }
    else
      i = "@@observable";
    return i;
  }
})(Xd);
var Ul = Xd, fs = Object.prototype.toString, xd = function(n) {
  var c = fs.call(n), i = c === "[object Arguments]";
  return i || (i = c !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && fs.call(n.callee) === "[object Function]"), i;
}, Qi, ps;
function Ml() {
  if (ps)
    return Qi;
  ps = 1;
  var e;
  if (!Object.keys) {
    var n = Object.prototype.hasOwnProperty, c = Object.prototype.toString, i = xd, r = Object.prototype.propertyIsEnumerable, u = !r.call({ toString: null }, "toString"), f = r.call(function() {
    }, "prototype"), O = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], A = function(V) {
      var D = V.constructor;
      return D && D.prototype === V;
    }, T = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, L = function() {
      if (typeof window > "u")
        return !1;
      for (var V in window)
        try {
          if (!T["$" + V] && n.call(window, V) && window[V] !== null && typeof window[V] == "object")
            try {
              A(window[V]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), M = function(V) {
      if (typeof window > "u" || !L)
        return A(V);
      try {
        return A(V);
      } catch {
        return !1;
      }
    };
    e = function(D) {
      var b = D !== null && typeof D == "object", h = c.call(D) === "[object Function]", S = i(D), _ = b && c.call(D) === "[object String]", d = [];
      if (!b && !h && !S)
        throw new TypeError("Object.keys called on a non-object");
      var p = f && h;
      if (_ && D.length > 0 && !n.call(D, 0))
        for (var g = 0; g < D.length; ++g)
          d.push(String(g));
      if (S && D.length > 0)
        for (var J = 0; J < D.length; ++J)
          d.push(String(J));
      else
        for (var B in D)
          !(p && B === "prototype") && n.call(D, B) && d.push(String(B));
      if (u)
        for (var I = M(D), Z = 0; Z < O.length; ++Z)
          !(I && O[Z] === "constructor") && n.call(D, O[Z]) && d.push(O[Z]);
      return d;
    };
  }
  return Qi = e, Qi;
}
var Vl = Array.prototype.slice, Ll = xd, hs = Object.keys, _r = hs ? function(n) {
  return hs(n);
} : Ml(), ms = Object.keys;
_r.shim = function() {
  if (Object.keys) {
    var n = function() {
      var c = Object.keys(arguments);
      return c && c.length === arguments.length;
    }(1, 2);
    n || (Object.keys = function(i) {
      return Ll(i) ? ms(Vl.call(i)) : ms(i);
    });
  } else
    Object.keys = _r;
  return Object.keys || _r;
};
var Hl = _r, ql = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var n = {}, c = Symbol("test"), i = Object(c);
  if (typeof c == "string" || Object.prototype.toString.call(c) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var r = 42;
  n[c] = r;
  for (c in n)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(n).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(n).length !== 0)
    return !1;
  var u = Object.getOwnPropertySymbols(n);
  if (u.length !== 1 || u[0] !== c || !Object.prototype.propertyIsEnumerable.call(n, c))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var f = Object.getOwnPropertyDescriptor(n, c);
    if (f.value !== r || f.enumerable !== !0)
      return !1;
  }
  return !0;
}, gs = typeof Symbol < "u" && Symbol, Wl = ql, Zl = function() {
  return typeof gs != "function" || typeof Symbol != "function" || typeof gs("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : Wl();
}, ys = {
  foo: {}
}, Ql = Object, Fl = function() {
  return { __proto__: ys }.foo === ys.foo && !({ __proto__: null } instanceof Ql);
}, Gl = "Function.prototype.bind called on incompatible ", Fi = Array.prototype.slice, $l = Object.prototype.toString, Kl = "[object Function]", zl = function(n) {
  var c = this;
  if (typeof c != "function" || $l.call(c) !== Kl)
    throw new TypeError(Gl + c);
  for (var i = Fi.call(arguments, 1), r, u = function() {
    if (this instanceof r) {
      var L = c.apply(
        this,
        i.concat(Fi.call(arguments))
      );
      return Object(L) === L ? L : this;
    } else
      return c.apply(
        n,
        i.concat(Fi.call(arguments))
      );
  }, f = Math.max(0, c.length - i.length), O = [], A = 0; A < f; A++)
    O.push("$" + A);
  if (r = Function("binder", "return function (" + O.join(",") + "){ return binder.apply(this,arguments); }")(u), c.prototype) {
    var T = function() {
    };
    T.prototype = c.prototype, r.prototype = new T(), T.prototype = null;
  }
  return r;
}, Yl = zl, jd = Function.prototype.bind || Yl, Xl = jd, xl = Xl.call(Function.call, Object.prototype.hasOwnProperty), fe, _t = SyntaxError, eu = Function, yt = TypeError, Gi = function(e) {
  try {
    return eu('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Yn = Object.getOwnPropertyDescriptor;
if (Yn)
  try {
    Yn({}, "");
  } catch {
    Yn = null;
  }
var $i = function() {
  throw new yt();
}, jl = Yn ? function() {
  try {
    return arguments.callee, $i;
  } catch {
    try {
      return Yn(arguments, "callee").get;
    } catch {
      return $i;
    }
  }
}() : $i, ut = Zl(), ef = Fl(), Ae = Object.getPrototypeOf || (ef ? function(e) {
  return e.__proto__;
} : null), ht = {}, nf = typeof Uint8Array > "u" || !Ae ? fe : Ae(Uint8Array), Xn = {
  "%AggregateError%": typeof AggregateError > "u" ? fe : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? fe : ArrayBuffer,
  "%ArrayIteratorPrototype%": ut && Ae ? Ae([][Symbol.iterator]()) : fe,
  "%AsyncFromSyncIteratorPrototype%": fe,
  "%AsyncFunction%": ht,
  "%AsyncGenerator%": ht,
  "%AsyncGeneratorFunction%": ht,
  "%AsyncIteratorPrototype%": ht,
  "%Atomics%": typeof Atomics > "u" ? fe : Atomics,
  "%BigInt%": typeof BigInt > "u" ? fe : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? fe : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? fe : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? fe : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? fe : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? fe : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? fe : FinalizationRegistry,
  "%Function%": eu,
  "%GeneratorFunction%": ht,
  "%Int8Array%": typeof Int8Array > "u" ? fe : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? fe : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? fe : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": ut && Ae ? Ae(Ae([][Symbol.iterator]())) : fe,
  "%JSON%": typeof JSON == "object" ? JSON : fe,
  "%Map%": typeof Map > "u" ? fe : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !ut || !Ae ? fe : Ae((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? fe : Promise,
  "%Proxy%": typeof Proxy > "u" ? fe : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? fe : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? fe : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !ut || !Ae ? fe : Ae((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? fe : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": ut && Ae ? Ae(""[Symbol.iterator]()) : fe,
  "%Symbol%": ut ? Symbol : fe,
  "%SyntaxError%": _t,
  "%ThrowTypeError%": jl,
  "%TypedArray%": nf,
  "%TypeError%": yt,
  "%Uint8Array%": typeof Uint8Array > "u" ? fe : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? fe : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? fe : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? fe : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? fe : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? fe : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? fe : WeakSet
};
if (Ae)
  try {
    null.error;
  } catch (e) {
    var tf = Ae(Ae(e));
    Xn["%Error.prototype%"] = tf;
  }
var rf = function e(n) {
  var c;
  if (n === "%AsyncFunction%")
    c = Gi("async function () {}");
  else if (n === "%GeneratorFunction%")
    c = Gi("function* () {}");
  else if (n === "%AsyncGeneratorFunction%")
    c = Gi("async function* () {}");
  else if (n === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (c = i.prototype);
  } else if (n === "%AsyncIteratorPrototype%") {
    var r = e("%AsyncGenerator%");
    r && Ae && (c = Ae(r.prototype));
  }
  return Xn[n] = c, c;
}, Ss = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, or = jd, wr = xl, of = or.call(Function.call, Array.prototype.concat), af = or.call(Function.apply, Array.prototype.splice), Os = or.call(Function.call, String.prototype.replace), br = or.call(Function.call, String.prototype.slice), sf = or.call(Function.call, RegExp.prototype.exec), df = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, uf = /\\(\\)?/g, cf = function(n) {
  var c = br(n, 0, 1), i = br(n, -1);
  if (c === "%" && i !== "%")
    throw new _t("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && c !== "%")
    throw new _t("invalid intrinsic syntax, expected opening `%`");
  var r = [];
  return Os(n, df, function(u, f, O, A) {
    r[r.length] = O ? Os(A, uf, "$1") : f || u;
  }), r;
}, lf = function(n, c) {
  var i = n, r;
  if (wr(Ss, i) && (r = Ss[i], i = "%" + r[0] + "%"), wr(Xn, i)) {
    var u = Xn[i];
    if (u === ht && (u = rf(i)), typeof u > "u" && !c)
      throw new yt("intrinsic " + n + " exists, but is not available. Please file an issue!");
    return {
      alias: r,
      name: i,
      value: u
    };
  }
  throw new _t("intrinsic " + n + " does not exist!");
}, ff = function(n, c) {
  if (typeof n != "string" || n.length === 0)
    throw new yt("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof c != "boolean")
    throw new yt('"allowMissing" argument must be a boolean');
  if (sf(/^%?[^%]*%?$/, n) === null)
    throw new _t("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = cf(n), r = i.length > 0 ? i[0] : "", u = lf("%" + r + "%", c), f = u.name, O = u.value, A = !1, T = u.alias;
  T && (r = T[0], af(i, of([0, 1], T)));
  for (var L = 1, M = !0; L < i.length; L += 1) {
    var V = i[L], D = br(V, 0, 1), b = br(V, -1);
    if ((D === '"' || D === "'" || D === "`" || b === '"' || b === "'" || b === "`") && D !== b)
      throw new _t("property names with quotes must have matching quotes");
    if ((V === "constructor" || !M) && (A = !0), r += "." + V, f = "%" + r + "%", wr(Xn, f))
      O = Xn[f];
    else if (O != null) {
      if (!(V in O)) {
        if (!c)
          throw new yt("base intrinsic for " + n + " exists, but the property is not available.");
        return;
      }
      if (Yn && L + 1 >= i.length) {
        var h = Yn(O, V);
        M = !!h, M && "get" in h && !("originalValue" in h.get) ? O = h.get : O = O[V];
      } else
        M = wr(O, V), O = O[V];
      M && !A && (Xn[f] = O);
    }
  }
  return O;
}, pf = ff, bo = pf("%Object.defineProperty%", !0), Bo = function() {
  if (bo)
    try {
      return bo({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
Bo.hasArrayLengthDefineBug = function() {
  if (!Bo())
    return null;
  try {
    return bo([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hf = Bo, mf = Hl, gf = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", yf = Object.prototype.toString, Sf = Array.prototype.concat, nu = Object.defineProperty, Of = function(e) {
  return typeof e == "function" && yf.call(e) === "[object Function]";
}, Rf = hf(), tu = nu && Rf, Pf = function(e, n, c, i) {
  if (n in e) {
    if (i === !0) {
      if (e[n] === c)
        return;
    } else if (!Of(i) || !i())
      return;
  }
  tu ? nu(e, n, {
    configurable: !0,
    enumerable: !1,
    value: c,
    writable: !0
  }) : e[n] = c;
}, ru = function(e, n) {
  var c = arguments.length > 2 ? arguments[2] : {}, i = mf(n);
  gf && (i = Sf.call(i, Object.getOwnPropertySymbols(n)));
  for (var r = 0; r < i.length; r += 1)
    Pf(e, i[r], n[i[r]], c[i[r]]);
};
ru.supportsDescriptors = !!tu;
var iu = ru, Nr = { exports: {} };
typeof self < "u" ? Nr.exports = self : typeof window < "u" ? Nr.exports = window : Nr.exports = Function("return this")();
var ou = Nr.exports, vf = ou, au = function() {
  return typeof G != "object" || !G || G.Math !== Math || G.Array !== Array ? vf : G;
}, kf = iu, Af = au, _f = function() {
  var n = Af();
  if (kf.supportsDescriptors) {
    var c = Object.getOwnPropertyDescriptor(n, "globalThis");
    (!c || c.configurable && (c.enumerable || !c.writable || globalThis !== n)) && Object.defineProperty(n, "globalThis", {
      configurable: !0,
      enumerable: !1,
      value: n,
      writable: !0
    });
  } else
    (typeof globalThis != "object" || globalThis !== n) && (n.globalThis = n);
  return n;
}, Nf = iu, Tf = ou, su = au, Ef = _f, Cf = su(), du = function() {
  return Cf;
};
Nf(du, {
  getPolyfill: su,
  implementation: Tf,
  shim: Ef
});
var If = du, wf = G && G.__extends || function() {
  var e = function(n, c) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var u in r)
        r.hasOwnProperty(u) && (i[u] = r[u]);
    }, e(n, c);
  };
  return function(n, c) {
    e(n, c);
    function i() {
      this.constructor = n;
    }
    n.prototype = c === null ? Object.create(c) : (i.prototype = c.prototype, new i());
  };
}();
Object.defineProperty(Ee, "__esModule", { value: !0 });
Ee.NO_IL = Ee.NO = Ee.MemoryStream = Ee.Stream = void 0;
var bf = Ul, Bf = If, lr = bf.default(Bf.getPolyfill()), ne = {};
Ee.NO = ne;
function be() {
}
function Tr(e) {
  for (var n = e.length, c = Array(n), i = 0; i < n; ++i)
    c[i] = e[i];
  return c;
}
function Jf(e, n) {
  return function(i) {
    return e(i) && n(i);
  };
}
function Xo(e, n, c) {
  try {
    return e.f(n);
  } catch (i) {
    return c._e(i), ne;
  }
}
var zn = {
  _n: be,
  _e: be,
  _c: be
};
Ee.NO_IL = zn;
function Rs(e) {
  e._start = function(c) {
    c.next = c._n, c.error = c._e, c.complete = c._c, this.start(c);
  }, e._stop = e.stop;
}
var Df = (
  /** @class */
  function() {
    function e(n, c) {
      this._stream = n, this._listener = c;
    }
    return e.prototype.unsubscribe = function() {
      this._stream._remove(this._listener);
    }, e;
  }()
), Uf = (
  /** @class */
  function() {
    function e(n) {
      this._listener = n;
    }
    return e.prototype.next = function(n) {
      this._listener._n(n);
    }, e.prototype.error = function(n) {
      this._listener._e(n);
    }, e.prototype.complete = function() {
      this._listener._c();
    }, e;
  }()
), Mf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromObservable", this.ins = n, this.active = !1;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.active = !0, this._sub = this.ins.subscribe(new Uf(n)), this.active || this._sub.unsubscribe();
    }, e.prototype._stop = function() {
      this._sub && this._sub.unsubscribe(), this.active = !1;
    }, e;
  }()
), Vf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "merge", this.insArr = n, this.out = ne, this.ac = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n;
      var c = this.insArr, i = c.length;
      this.ac = i;
      for (var r = 0; r < i; r++)
        c[r]._add(this);
    }, e.prototype._stop = function() {
      for (var n = this.insArr, c = n.length, i = 0; i < c; i++)
        n[i]._remove(this);
      this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      c !== ne && c._n(n);
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      if (--this.ac <= 0) {
        var n = this.out;
        if (n === ne)
          return;
        n._c();
      }
    }, e;
  }()
), Lf = (
  /** @class */
  function() {
    function e(n, c, i) {
      this.i = n, this.out = c, this.p = i, i.ils.push(this);
    }
    return e.prototype._n = function(n) {
      var c = this.p, i = this.out;
      if (i !== ne && c.up(n, this.i)) {
        var r = Tr(c.vals);
        i._n(r);
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.p;
      n.out !== ne && --n.Nc === 0 && n.out._c();
    }, e;
  }()
), Hf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "combine", this.insArr = n, this.out = ne, this.ils = [], this.Nc = this.Nn = 0, this.vals = [];
    }
    return e.prototype.up = function(n, c) {
      var i = this.vals[c], r = this.Nn ? i === ne ? --this.Nn : this.Nn : 0;
      return this.vals[c] = n, r === 0;
    }, e.prototype._start = function(n) {
      this.out = n;
      var c = this.insArr, i = this.Nc = this.Nn = c.length, r = this.vals = new Array(i);
      if (i === 0)
        n._n([]), n._c();
      else
        for (var u = 0; u < i; u++)
          r[u] = ne, c[u]._add(new Lf(u, n, this));
    }, e.prototype._stop = function() {
      for (var n = this.insArr, c = n.length, i = this.ils, r = 0; r < c; r++)
        n[r]._remove(i[r]);
      this.out = ne, this.ils = [], this.vals = [];
    }, e;
  }()
), qf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromArray", this.a = n;
    }
    return e.prototype._start = function(n) {
      for (var c = this.a, i = 0, r = c.length; i < r; i++)
        n._n(c[i]);
      n._c();
    }, e.prototype._stop = function() {
    }, e;
  }()
), Wf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromPromise", this.on = !1, this.p = n;
    }
    return e.prototype._start = function(n) {
      var c = this;
      this.on = !0, this.p.then(function(i) {
        c.on && (n._n(i), n._c());
      }, function(i) {
        n._e(i);
      }).then(be, function(i) {
        setTimeout(function() {
          throw i;
        });
      });
    }, e.prototype._stop = function() {
      this.on = !1;
    }, e;
  }()
), Zf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "periodic", this.period = n, this.intervalID = -1, this.i = 0;
    }
    return e.prototype._start = function(n) {
      var c = this;
      function i() {
        n._n(c.i++);
      }
      this.intervalID = setInterval(i, this.period);
    }, e.prototype._stop = function() {
      this.intervalID !== -1 && clearInterval(this.intervalID), this.intervalID = -1, this.i = 0;
    }, e;
  }()
), Qf = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "debug", this.ins = n, this.out = ne, this.s = be, this.l = "", typeof c == "string" ? this.l = c : typeof c == "function" && (this.s = c);
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      if (c !== ne) {
        var i = this.s, r = this.l;
        if (i !== be)
          try {
            i(n);
          } catch (u) {
            c._e(u);
          }
        else
          r ? console.log(r + ":", n) : console.log(n);
        c._n(n);
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), Ff = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "drop", this.ins = c, this.out = ne, this.max = n, this.dropped = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.dropped = 0, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      c !== ne && this.dropped++ >= this.max && c._n(n);
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), Gf = (
  /** @class */
  function() {
    function e(n, c) {
      this.out = n, this.op = c;
    }
    return e.prototype._n = function() {
      this.op.end();
    }, e.prototype._e = function(n) {
      this.out._e(n);
    }, e.prototype._c = function() {
      this.op.end();
    }, e;
  }()
), $f = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "endWhen", this.ins = c, this.out = ne, this.o = n, this.oil = zn;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.o._add(this.oil = new Gf(n, this)), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.o._remove(this.oil), this.out = ne, this.oil = zn;
    }, e.prototype.end = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e.prototype._n = function(n) {
      var c = this.out;
      c !== ne && c._n(n);
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      this.end();
    }, e;
  }()
), Ki = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "filter", this.ins = c, this.out = ne, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      if (c !== ne) {
        var i = Xo(this, n, c);
        i === ne || !i || c._n(n);
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), Kf = (
  /** @class */
  function() {
    function e(n, c) {
      this.out = n, this.op = c;
    }
    return e.prototype._n = function(n) {
      this.out._n(n);
    }, e.prototype._e = function(n) {
      this.out._e(n);
    }, e.prototype._c = function() {
      this.op.inner = ne, this.op.less();
    }, e;
  }()
), zf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "flatten", this.ins = n, this.out = ne, this.open = !0, this.inner = ne, this.il = zn;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.open = !0, this.inner = ne, this.il = zn, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.inner !== ne && this.inner._remove(this.il), this.out = ne, this.open = !0, this.inner = ne, this.il = zn;
    }, e.prototype.less = function() {
      var n = this.out;
      n !== ne && !this.open && this.inner === ne && n._c();
    }, e.prototype._n = function(n) {
      var c = this.out;
      if (c !== ne) {
        var i = this, r = i.inner, u = i.il;
        r !== ne && u !== zn && r._remove(u), (this.inner = n)._add(this.il = new Kf(c, this));
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      this.open = !1, this.less();
    }, e;
  }()
), Yf = (
  /** @class */
  function() {
    function e(n, c, i) {
      var r = this;
      this.type = "fold", this.ins = i, this.out = ne, this.f = function(u) {
        return n(r.acc, u);
      }, this.acc = this.seed = c;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.acc = this.seed, n._n(this.acc), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne, this.acc = this.seed;
    }, e.prototype._n = function(n) {
      var c = this.out;
      if (c !== ne) {
        var i = Xo(this, n, c);
        i !== ne && c._n(this.acc = i);
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), Xf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "last", this.ins = n, this.out = ne, this.has = !1, this.val = ne;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.has = !1, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne, this.val = ne;
    }, e.prototype._n = function(n) {
      this.has = !0, this.val = n;
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && (this.has ? (n._n(this.val), n._c()) : n._e(new Error("last() failed because input stream completed")));
    }, e;
  }()
), xf = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "map", this.ins = c, this.out = ne, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      if (c !== ne) {
        var i = Xo(this, n, c);
        i !== ne && c._n(i);
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), jf = (
  /** @class */
  function() {
    function e(n) {
      this.type = "remember", this.ins = n, this.out = ne;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(n);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = ne;
    }, e;
  }()
), ep = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "replaceError", this.ins = c, this.out = ne, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      c !== ne && c._n(n);
    }, e.prototype._e = function(n) {
      var c = this.out;
      if (c !== ne)
        try {
          this.ins._remove(this), (this.ins = this.f(n))._add(this);
        } catch (i) {
          c._e(i);
        }
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), np = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "startWith", this.ins = n, this.out = ne, this.val = c;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.out._n(this.val), this.ins._add(n);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = ne;
    }, e;
  }()
), tp = (
  /** @class */
  function() {
    function e(n, c) {
      this.type = "take", this.ins = c, this.out = ne, this.max = n, this.taken = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.taken = 0, this.max <= 0 ? n._c() : this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ne;
    }, e.prototype._n = function(n) {
      var c = this.out;
      if (c !== ne) {
        var i = ++this.taken;
        i < this.max ? c._n(n) : i === this.max && (c._n(n), c._c());
      }
    }, e.prototype._e = function(n) {
      var c = this.out;
      c !== ne && c._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ne && n._c();
    }, e;
  }()
), xo = (
  /** @class */
  function() {
    function e(n) {
      this._prod = n || ne, this._ils = [], this._stopID = ne, this._dl = ne, this._d = !1, this._target = null, this._err = ne;
    }
    return e.prototype._n = function(n) {
      var c = this._ils, i = c.length;
      if (this._d && this._dl._n(n), i == 1)
        c[0]._n(n);
      else {
        if (i == 0)
          return;
        for (var r = Tr(c), u = 0; u < i; u++)
          r[u]._n(n);
      }
    }, e.prototype._e = function(n) {
      if (this._err === ne) {
        this._err = n;
        var c = this._ils, i = c.length;
        if (this._x(), this._d && this._dl._e(n), i == 1)
          c[0]._e(n);
        else {
          if (i == 0)
            return;
          for (var r = Tr(c), u = 0; u < i; u++)
            r[u]._e(n);
        }
        if (!this._d && i == 0)
          throw this._err;
      }
    }, e.prototype._c = function() {
      var n = this._ils, c = n.length;
      if (this._x(), this._d && this._dl._c(), c == 1)
        n[0]._c();
      else {
        if (c == 0)
          return;
        for (var i = Tr(n), r = 0; r < c; r++)
          i[r]._c();
      }
    }, e.prototype._x = function() {
      this._ils.length !== 0 && (this._prod !== ne && this._prod._stop(), this._err = ne, this._ils = []);
    }, e.prototype._stopNow = function() {
      this._prod._stop(), this._err = ne, this._stopID = ne;
    }, e.prototype._add = function(n) {
      var c = this._target;
      if (c)
        return c._add(n);
      var i = this._ils;
      if (i.push(n), !(i.length > 1))
        if (this._stopID !== ne)
          clearTimeout(this._stopID), this._stopID = ne;
        else {
          var r = this._prod;
          r !== ne && r._start(this);
        }
    }, e.prototype._remove = function(n) {
      var c = this, i = this._target;
      if (i)
        return i._remove(n);
      var r = this._ils, u = r.indexOf(n);
      u > -1 && (r.splice(u, 1), this._prod !== ne && r.length <= 0 ? (this._err = ne, this._stopID = setTimeout(function() {
        return c._stopNow();
      })) : r.length === 1 && this._pruneCycles());
    }, e.prototype._pruneCycles = function() {
      this._hasNoSinks(this, []) && this._remove(this._ils[0]);
    }, e.prototype._hasNoSinks = function(n, c) {
      if (c.indexOf(n) !== -1)
        return !0;
      if (n.out === this)
        return !0;
      if (n.out && n.out !== ne)
        return this._hasNoSinks(n.out, c.concat(n));
      if (n._ils) {
        for (var i = 0, r = n._ils.length; i < r; i++)
          if (!this._hasNoSinks(n._ils[i], c.concat(n)))
            return !1;
        return !0;
      } else
        return !1;
    }, e.prototype.ctor = function() {
      return this instanceof Bn ? Bn : e;
    }, e.prototype.addListener = function(n) {
      n._n = n.next || be, n._e = n.error || be, n._c = n.complete || be, this._add(n);
    }, e.prototype.removeListener = function(n) {
      this._remove(n);
    }, e.prototype.subscribe = function(n) {
      return this.addListener(n), new Df(this, n);
    }, e.prototype[lr] = function() {
      return this;
    }, e.create = function(n) {
      if (n) {
        if (typeof n.start != "function" || typeof n.stop != "function")
          throw new Error("producer requires both start and stop functions");
        Rs(n);
      }
      return new e(n);
    }, e.createWithMemory = function(n) {
      return n && Rs(n), new Bn(n);
    }, e.never = function() {
      return new e({ _start: be, _stop: be });
    }, e.empty = function() {
      return new e({
        _start: function(n) {
          n._c();
        },
        _stop: be
      });
    }, e.throw = function(n) {
      return new e({
        _start: function(c) {
          c._e(n);
        },
        _stop: be
      });
    }, e.from = function(n) {
      if (typeof n[lr] == "function")
        return e.fromObservable(n);
      if (typeof n.then == "function")
        return e.fromPromise(n);
      if (Array.isArray(n))
        return e.fromArray(n);
      throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    }, e.of = function() {
      for (var n = [], c = 0; c < arguments.length; c++)
        n[c] = arguments[c];
      return e.fromArray(n);
    }, e.fromArray = function(n) {
      return new e(new qf(n));
    }, e.fromPromise = function(n) {
      return new e(new Wf(n));
    }, e.fromObservable = function(n) {
      if (n.endWhen !== void 0)
        return n;
      var c = typeof n[lr] == "function" ? n[lr]() : n;
      return new e(new Mf(c));
    }, e.periodic = function(n) {
      return new e(new Zf(n));
    }, e.prototype._map = function(n) {
      return new (this.ctor())(new xf(n, this));
    }, e.prototype.map = function(n) {
      return this._map(n);
    }, e.prototype.mapTo = function(n) {
      var c = this.map(function() {
        return n;
      }), i = c._prod;
      return i.type = "mapTo", c;
    }, e.prototype.filter = function(n) {
      var c = this._prod;
      return c instanceof Ki ? new e(new Ki(Jf(c.f, n), c.ins)) : new e(new Ki(n, this));
    }, e.prototype.take = function(n) {
      return new (this.ctor())(new tp(n, this));
    }, e.prototype.drop = function(n) {
      return new e(new Ff(n, this));
    }, e.prototype.last = function() {
      return new e(new Xf(this));
    }, e.prototype.startWith = function(n) {
      return new Bn(new np(this, n));
    }, e.prototype.endWhen = function(n) {
      return new (this.ctor())(new $f(n, this));
    }, e.prototype.fold = function(n, c) {
      return new Bn(new Yf(n, c, this));
    }, e.prototype.replaceError = function(n) {
      return new (this.ctor())(new ep(n, this));
    }, e.prototype.flatten = function() {
      return new e(new zf(this));
    }, e.prototype.compose = function(n) {
      return n(this);
    }, e.prototype.remember = function() {
      return new Bn(new jf(this));
    }, e.prototype.debug = function(n) {
      return new (this.ctor())(new Qf(this, n));
    }, e.prototype.imitate = function(n) {
      if (n instanceof Bn)
        throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
      this._target = n;
      for (var c = this._ils, i = c.length, r = 0; r < i; r++)
        n._add(c[r]);
      this._ils = [];
    }, e.prototype.shamefullySendNext = function(n) {
      this._n(n);
    }, e.prototype.shamefullySendError = function(n) {
      this._e(n);
    }, e.prototype.shamefullySendComplete = function() {
      this._c();
    }, e.prototype.setDebugListener = function(n) {
      n ? (this._d = !0, n._n = n.next || be, n._e = n.error || be, n._c = n.complete || be, this._dl = n) : (this._d = !1, this._dl = ne);
    }, e.merge = function() {
      for (var c = [], i = 0; i < arguments.length; i++)
        c[i] = arguments[i];
      return new e(new Vf(c));
    }, e.combine = function() {
      for (var c = [], i = 0; i < arguments.length; i++)
        c[i] = arguments[i];
      return new e(new Hf(c));
    }, e;
  }()
);
Ee.Stream = xo;
var Bn = (
  /** @class */
  function(e) {
    wf(n, e);
    function n(c) {
      var i = e.call(this, c) || this;
      return i._has = !1, i;
    }
    return n.prototype._n = function(c) {
      this._v = c, this._has = !0, e.prototype._n.call(this, c);
    }, n.prototype._add = function(c) {
      var i = this._target;
      if (i)
        return i._add(c);
      var r = this._ils;
      if (r.push(c), r.length > 1) {
        this._has && c._n(this._v);
        return;
      }
      if (this._stopID !== ne)
        this._has && c._n(this._v), clearTimeout(this._stopID), this._stopID = ne;
      else if (this._has)
        c._n(this._v);
      else {
        var u = this._prod;
        u !== ne && u._start(this);
      }
    }, n.prototype._stopNow = function() {
      this._has = !1, e.prototype._stopNow.call(this);
    }, n.prototype._x = function() {
      this._has = !1, e.prototype._x.call(this);
    }, n.prototype.map = function(c) {
      return this._map(c);
    }, n.prototype.mapTo = function(c) {
      return e.prototype.mapTo.call(this, c);
    }, n.prototype.take = function(c) {
      return e.prototype.take.call(this, c);
    }, n.prototype.endWhen = function(c) {
      return e.prototype.endWhen.call(this, c);
    }, n.prototype.replaceError = function(c) {
      return e.prototype.replaceError.call(this, c);
    }, n.prototype.remember = function() {
      return this;
    }, n.prototype.debug = function(c) {
      return e.prototype.debug.call(this, c);
    }, n;
  }(xo)
);
Ee.MemoryStream = Bn;
var rp = xo;
Ee.default = rp;
Object.defineProperty(Gr, "__esModule", { value: !0 });
Gr.concat = void 0;
const ip = Ee;
function op(...e) {
  const n = new Array(), c = new Array(), i = /* @__PURE__ */ new Set();
  let r = 0;
  function u() {
    for (; n.length > 0; )
      n.shift().unsubscribe();
    c.length = 0, i.clear(), r = 0;
  }
  const f = {
    start: (O) => {
      e.forEach((L) => c.push([]));
      function A(L) {
        for (; ; ) {
          const M = c[L].shift();
          if (M === void 0)
            return;
          O.next(M);
        }
      }
      function T() {
        return r >= e.length;
      }
      if (T()) {
        O.complete();
        return;
      }
      e.forEach((L, M) => {
        n.push(L.subscribe({
          next: (V) => {
            M === r ? O.next(V) : c[M].push(V);
          },
          complete: () => {
            for (i.add(M); i.has(r); )
              A(r), r++;
            T() ? O.complete() : A(r);
          },
          error: (V) => {
            O.error(V), u();
          }
        }));
      });
    },
    stop: () => {
      u();
    }
  };
  return ip.Stream.create(f);
}
Gr.concat = op;
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.DefaultValueProducer = void 0;
class ap {
  get value() {
    return this.internalValue;
  }
  constructor(n, c) {
    this.callbacks = c, this.internalValue = n;
  }
  /**
   * Update the current value.
   *
   * If producer is active (i.e. someone is listening), this emits an event.
   * If not, just the current value is updated.
   */
  update(n) {
    this.internalValue = n, this.listener && this.listener.next(n);
  }
  /**
   * Produce an error
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  error(n) {
    this.listener && this.listener.error(n);
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  start(n) {
    this.listener = n, n.next(this.internalValue), this.callbacks && this.callbacks.onStarted();
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  stop() {
    this.callbacks && this.callbacks.onStop(), this.listener = void 0;
  }
}
$r.DefaultValueProducer = ap;
var Kr = {};
Object.defineProperty(Kr, "__esModule", { value: !0 });
Kr.dropDuplicates = void 0;
function sp(e) {
  return (c) => {
    const i = /* @__PURE__ */ new Set();
    return c.filter((u) => !i.has(e(u))).debug((u) => i.add(e(u)));
  };
}
Kr.dropDuplicates = sp;
var Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.firstEvent = Mn.toListPromise = Mn.fromListPromise = void 0;
const dp = Ee;
function up(e) {
  const n = {
    start: (c) => {
      e.then((i) => {
        for (const r of i)
          c.next(r);
        c.complete();
      }).catch((i) => c.error(i));
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stop: () => {
    }
  };
  return dp.Stream.create(n);
}
Mn.fromListPromise = up;
async function uu(e, n) {
  return new Promise((c, i) => {
    if (n === 0) {
      c([]);
      return;
    }
    const r = new Array();
    e.take(n).subscribe({
      next: (u) => {
        r.push(u), r.length === n && c(r);
      },
      complete: () => {
        i(`Stream completed before all events could be collected. Collected ${r.length}, expected ${n}`);
      },
      error: (u) => i(u)
    });
  });
}
Mn.toListPromise = uu;
async function cp(e) {
  return (await uu(e, 1))[0];
}
Mn.firstEvent = cp;
var vn = {};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.lastValue = vn.asArray = vn.countStream = vn.Reducer = void 0;
class zr {
  constructor(n, c, i) {
    this.stream = n, this.reducer = c, this.state = i, this.completed = new Promise((r, u) => {
      const f = this.stream.subscribe({
        next: (O) => {
          this.state = this.reducer(this.state, O);
        },
        complete: () => {
          r(), f.unsubscribe();
        },
        error: (O) => {
          u(O), f.unsubscribe();
        }
      });
    });
  }
  // value returns current materialized state
  value() {
    return this.state;
  }
  // finished resolves on completed stream, rejects on stream error
  async finished() {
    return this.completed;
  }
}
vn.Reducer = zr;
function lp(e, n) {
  return e + 1;
}
function fp(e) {
  return new zr(e, lp, 0);
}
vn.countStream = fp;
function pp(e, n) {
  return [...e, n];
}
function hp(e) {
  return new zr(e, pp, []);
}
vn.asArray = hp;
function mp(e, n) {
  return n;
}
function gp(e) {
  return new zr(e, mp, void 0);
}
vn.lastValue = gp;
var Yr = {};
Object.defineProperty(Yr, "__esModule", { value: !0 });
Yr.ValueAndUpdates = void 0;
const yp = Ee;
class Sp {
  get value() {
    return this.producer.value;
  }
  constructor(n) {
    this.producer = n, this.updates = yp.MemoryStream.createWithMemory(this.producer);
  }
  /**
   * Resolves as soon as search value is found.
   *
   * @param search either a value or a function that must return true when found
   * @returns the value of the update that caused the search match
   */
  async waitFor(n) {
    const c = typeof n == "function" ? n : (i) => i === n;
    return new Promise((i, r) => {
      const u = this.updates.subscribe({
        next: (f) => {
          c(f) && (i(f), setTimeout(() => u.unsubscribe(), 0));
        },
        complete: () => {
          u.unsubscribe(), r("Update stream completed without expected value");
        },
        error: (f) => {
          r(f);
        }
      });
    });
  }
}
Yr.ValueAndUpdates = Sp;
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(A, T, L, M) {
    M === void 0 && (M = L);
    var V = Object.getOwnPropertyDescriptor(T, L);
    (!V || ("get" in V ? !T.__esModule : V.writable || V.configurable)) && (V = { enumerable: !0, get: function() {
      return T[L];
    } }), Object.defineProperty(A, M, V);
  } : function(A, T, L, M) {
    M === void 0 && (M = L), A[M] = T[L];
  }), c = G && G.__exportStar || function(A, T) {
    for (var L in A)
      L !== "default" && !Object.prototype.hasOwnProperty.call(T, L) && n(T, A, L);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueAndUpdates = e.toListPromise = e.fromListPromise = e.firstEvent = e.dropDuplicates = e.DefaultValueProducer = e.concat = void 0;
  var i = Gr;
  Object.defineProperty(e, "concat", { enumerable: !0, get: function() {
    return i.concat;
  } });
  var r = $r;
  Object.defineProperty(e, "DefaultValueProducer", { enumerable: !0, get: function() {
    return r.DefaultValueProducer;
  } });
  var u = Kr;
  Object.defineProperty(e, "dropDuplicates", { enumerable: !0, get: function() {
    return u.dropDuplicates;
  } });
  var f = Mn;
  Object.defineProperty(e, "firstEvent", { enumerable: !0, get: function() {
    return f.firstEvent;
  } }), Object.defineProperty(e, "fromListPromise", { enumerable: !0, get: function() {
    return f.fromListPromise;
  } }), Object.defineProperty(e, "toListPromise", { enumerable: !0, get: function() {
    return f.toListPromise;
  } }), c(vn, e);
  var O = Yr;
  Object.defineProperty(e, "ValueAndUpdates", { enumerable: !0, get: function() {
    return O.ValueAndUpdates;
  } });
})(ir);
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.QueryClient = void 0;
const $n = Hd, Kn = Ve, Op = ir, Ze = yn;
function fr(e, n, c) {
  if (e.type !== n)
    throw new Error(`Op expected to be ${n}, got "${e.type}`);
  if (!(0, Ze.arrayContentEquals)(c, e.key))
    throw new Error(`Proven key different than queried key.
Query: ${(0, Kn.toHex)(c)}
Proven: ${(0, Kn.toHex)(e.key)}`);
  return $n.ics23.CommitmentProof.decode(e.data);
}
class jo {
  static withExtensions(n, ...c) {
    const i = new jo(n), r = c.map((u) => u(i));
    for (const u of r) {
      (0, Ze.assert)((0, Ze.isNonNullObject)(u), "Extension must be a non-null object");
      for (const [f, O] of Object.entries(u)) {
        (0, Ze.assert)((0, Ze.isNonNullObject)(O), `Module must be a non-null object. Found type ${typeof O} for module "${f}".`);
        const A = i[f] || {};
        i[f] = {
          ...A,
          ...O
        };
      }
    }
    return i;
  }
  constructor(n) {
    this.tmClient = n;
  }
  /**
   * Queries the database store with a proof, which is then verified.
   *
   * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
   */
  async queryStoreVerified(n, c, i) {
    const { height: r, proof: u, key: f, value: O } = await this.queryRawProof(n, c, i), A = fr(u.ops[0], "ics23:iavl", c), T = fr(u.ops[1], "ics23:simple", (0, Kn.toAscii)(n));
    (0, Ze.assert)(T.exist), (0, Ze.assert)(T.exist.value), !O || O.length === 0 ? ((0, Ze.assert)(A.nonexist), (0, $n.verifyNonExistence)(A.nonexist, $n.iavlSpec, T.exist.value, c)) : ((0, Ze.assert)(A.exist), (0, Ze.assert)(A.exist.value), (0, $n.verifyExistence)(A.exist, $n.iavlSpec, T.exist.value, c, O));
    const L = await this.getNextHeader(r);
    return (0, $n.verifyExistence)(T.exist, $n.tendermintSpec, L.appHash, (0, Kn.toAscii)(n), T.exist.value), { key: f, value: O, height: r };
  }
  async queryRawProof(n, c, i) {
    const { key: r, value: u, height: f, proof: O, code: A, log: T } = await this.tmClient.abciQuery({
      // we need the StoreKey for the module, not the module name
      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
      path: `/store/${n}/key`,
      data: c,
      prove: !0,
      height: i
    });
    if (A)
      throw new Error(`Query failed with (${A}): ${T}`);
    if (!(0, Ze.arrayContentEquals)(c, r))
      throw new Error(`Response key ${(0, Kn.toHex)(r)} doesn't match query key ${(0, Kn.toHex)(c)}`);
    if (!f)
      throw new Error("No query height returned");
    if (!O || O.ops.length !== 2)
      throw new Error(`Expected 2 proof ops, got ${(O == null ? void 0 : O.ops.length) ?? 0}. Are you using stargate?`);
    return fr(O.ops[0], "ics23:iavl", r), fr(O.ops[1], "ics23:simple", (0, Kn.toAscii)(n)), {
      key: r,
      value: u,
      height: f,
      // need to clone this: readonly input / writeable output
      proof: {
        ops: [...O.ops]
      }
    };
  }
  /**
   * Performs an ABCI query to Tendermint without requesting a proof.
   *
   * If the `desiredHeight` is set, a particular height is requested. Otherwise
   * the latest height is requested. The response contains the actual height of
   * the query.
   */
  async queryAbci(n, c, i) {
    const r = await this.tmClient.abciQuery({
      path: n,
      data: c,
      prove: !1,
      height: i
    });
    if (r.code)
      throw new Error(`Query failed with (${r.code}): ${r.log}`);
    if (!r.height)
      throw new Error("No query height returned");
    return {
      value: r.value,
      height: r.height
    };
  }
  // this must return the header for height+1
  // throws an error if height is 0 or undefined
  async getNextHeader(n) {
    if ((0, Ze.assertDefined)(n), n === 0)
      throw new Error("Query returned height 0, cannot prove it");
    const c = n + 1;
    let i, r;
    try {
      r = this.tmClient.subscribeNewBlockHeader();
    } catch {
    }
    if (r) {
      const u = await (0, Op.firstEvent)(r);
      u.height === c && (i = u);
    }
    for (; !i; ) {
      const u = (await this.tmClient.blockchain(n, c)).blockMetas.map((f) => f.header).find((f) => f.height === c);
      u ? i = u : await (0, Ze.sleep)(1e3);
    }
    return (0, Ze.assert)(i.height === c, "Got wrong header. This is a bug in the logic above."), i;
  }
}
Wr.QueryClient = jo;
var tn = {}, Rp = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.decodeCosmosSdkDecFromProto = tn.longify = tn.createProtobufRpcClient = tn.createPagination = tn.toAccAddress = void 0;
const cu = Ve, lu = _n, Pp = Re, vp = Rp(An);
function kp(e) {
  return (0, cu.fromBech32)(e).data;
}
tn.toAccAddress = kp;
function Ap(e) {
  return e ? Pp.PageRequest.fromPartial({ key: e }) : void 0;
}
tn.createPagination = Ap;
function _p(e) {
  return {
    request: async (n, c, i) => {
      const r = `/${n}/${c}`;
      return (await e.queryAbci(r, i, void 0)).value;
    }
  };
}
tn.createProtobufRpcClient = _p;
function Np(e) {
  const n = lu.Uint64.fromString(e.toString());
  return vp.default.fromBytesBE([...n.toBytesBigEndian()], !0);
}
tn.longify = Np;
function Tp(e) {
  const n = typeof e == "string" ? e : (0, cu.fromAscii)(e);
  return lu.Decimal.fromAtomics(n, 18);
}
tn.decodeCosmosSdkDecFromProto = Tp;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.longify = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.QueryClient = void 0;
  var n = Wr;
  Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return n.QueryClient;
  } });
  var c = tn;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return c.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return c.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return c.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "longify", { enumerable: !0, get: function() {
    return c.longify;
  } });
})(Le);
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.setupAuthExtension = void 0;
const Ep = Ld, Cp = Le;
function Ip(e) {
  const n = (0, Cp.createProtobufRpcClient)(e), c = new Ep.QueryClientImpl(n);
  return {
    auth: {
      account: async (i) => {
        const { account: r } = await c.Account({ address: i });
        return r ?? null;
      }
    }
  };
}
qr.setupAuthExtension = Ip;
var Xr = {};
Object.defineProperty(Xr, "__esModule", { value: !0 });
Xr.createAuthzAminoConverters = void 0;
function wp() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
  };
}
Xr.createAuthzAminoConverters = wp;
var xr = {}, fu = {}, xe = {}, _e = {}, bp = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), Bp = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Jp = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && bp(n, e, c);
  return Bp(n, e), n;
};
Object.defineProperty(_e, "__esModule", { value: !0 });
_e.Timestamp = _e.protobufPackage = void 0;
const Jn = oe, zi = Jp(ie);
_e.protobufPackage = "google.protobuf";
function Ps() {
  return {
    seconds: Jn.Long.ZERO,
    nanos: 0
  };
}
_e.Timestamp = {
  encode(e, n = zi.Writer.create()) {
    return e.seconds.isZero() || n.uint32(8).int64(e.seconds), e.nanos !== 0 && n.uint32(16).int32(e.nanos), n;
  },
  decode(e, n) {
    const c = e instanceof zi.Reader ? e : new zi.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Ps();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.seconds = c.int64();
          break;
        case 2:
          r.nanos = c.int32();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      seconds: (0, Jn.isSet)(e.seconds) ? Jn.Long.fromValue(e.seconds) : Jn.Long.ZERO,
      nanos: (0, Jn.isSet)(e.nanos) ? Number(e.nanos) : 0
    };
  },
  toJSON(e) {
    const n = {};
    return e.seconds !== void 0 && (n.seconds = (e.seconds || Jn.Long.ZERO).toString()), e.nanos !== void 0 && (n.nanos = Math.round(e.nanos)), n;
  },
  fromPartial(e) {
    const n = Ps();
    return n.seconds = e.seconds !== void 0 && e.seconds !== null ? Jn.Long.fromValue(e.seconds) : Jn.Long.ZERO, n.nanos = e.nanos ?? 0, n;
  }
};
var Dp = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), Up = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Mp = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && Dp(n, e, c);
  return Up(n, e), n;
};
Object.defineProperty(xe, "__esModule", { value: !0 });
xe.GrantQueueItem = xe.GrantAuthorization = xe.Grant = xe.GenericAuthorization = xe.protobufPackage = void 0;
const Rn = Se, St = _e, cn = Mp(ie), fn = oe;
xe.protobufPackage = "cosmos.authz.v1beta1";
function vs() {
  return {
    msg: ""
  };
}
xe.GenericAuthorization = {
  encode(e, n = cn.Writer.create()) {
    return e.msg !== "" && n.uint32(10).string(e.msg), n;
  },
  decode(e, n) {
    const c = e instanceof cn.Reader ? e : new cn.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = vs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.msg = c.string();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      msg: (0, fn.isSet)(e.msg) ? String(e.msg) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.msg !== void 0 && (n.msg = e.msg), n;
  },
  fromPartial(e) {
    const n = vs();
    return n.msg = e.msg ?? "", n;
  }
};
function ks() {
  return {
    authorization: void 0,
    expiration: void 0
  };
}
xe.Grant = {
  encode(e, n = cn.Writer.create()) {
    return e.authorization !== void 0 && Rn.Any.encode(e.authorization, n.uint32(10).fork()).ldelim(), e.expiration !== void 0 && St.Timestamp.encode(e.expiration, n.uint32(18).fork()).ldelim(), n;
  },
  decode(e, n) {
    const c = e instanceof cn.Reader ? e : new cn.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = ks();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.authorization = Rn.Any.decode(c, c.uint32());
          break;
        case 2:
          r.expiration = St.Timestamp.decode(c, c.uint32());
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      authorization: (0, fn.isSet)(e.authorization) ? Rn.Any.fromJSON(e.authorization) : void 0,
      expiration: (0, fn.isSet)(e.expiration) ? (0, fn.fromJsonTimestamp)(e.expiration) : void 0
    };
  },
  toJSON(e) {
    const n = {};
    return e.authorization !== void 0 && (n.authorization = e.authorization ? Rn.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (n.expiration = (0, fn.fromTimestamp)(e.expiration).toISOString()), n;
  },
  fromPartial(e) {
    const n = ks();
    return n.authorization = e.authorization !== void 0 && e.authorization !== null ? Rn.Any.fromPartial(e.authorization) : void 0, n.expiration = e.expiration !== void 0 && e.expiration !== null ? St.Timestamp.fromPartial(e.expiration) : void 0, n;
  }
};
function As() {
  return {
    granter: "",
    grantee: "",
    authorization: void 0,
    expiration: void 0
  };
}
xe.GrantAuthorization = {
  encode(e, n = cn.Writer.create()) {
    return e.granter !== "" && n.uint32(10).string(e.granter), e.grantee !== "" && n.uint32(18).string(e.grantee), e.authorization !== void 0 && Rn.Any.encode(e.authorization, n.uint32(26).fork()).ldelim(), e.expiration !== void 0 && St.Timestamp.encode(e.expiration, n.uint32(34).fork()).ldelim(), n;
  },
  decode(e, n) {
    const c = e instanceof cn.Reader ? e : new cn.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = As();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.granter = c.string();
          break;
        case 2:
          r.grantee = c.string();
          break;
        case 3:
          r.authorization = Rn.Any.decode(c, c.uint32());
          break;
        case 4:
          r.expiration = St.Timestamp.decode(c, c.uint32());
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      granter: (0, fn.isSet)(e.granter) ? String(e.granter) : "",
      grantee: (0, fn.isSet)(e.grantee) ? String(e.grantee) : "",
      authorization: (0, fn.isSet)(e.authorization) ? Rn.Any.fromJSON(e.authorization) : void 0,
      expiration: (0, fn.isSet)(e.expiration) ? (0, fn.fromJsonTimestamp)(e.expiration) : void 0
    };
  },
  toJSON(e) {
    const n = {};
    return e.granter !== void 0 && (n.granter = e.granter), e.grantee !== void 0 && (n.grantee = e.grantee), e.authorization !== void 0 && (n.authorization = e.authorization ? Rn.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (n.expiration = (0, fn.fromTimestamp)(e.expiration).toISOString()), n;
  },
  fromPartial(e) {
    const n = As();
    return n.granter = e.granter ?? "", n.grantee = e.grantee ?? "", n.authorization = e.authorization !== void 0 && e.authorization !== null ? Rn.Any.fromPartial(e.authorization) : void 0, n.expiration = e.expiration !== void 0 && e.expiration !== null ? St.Timestamp.fromPartial(e.expiration) : void 0, n;
  }
};
function _s() {
  return {
    msgTypeUrls: []
  };
}
xe.GrantQueueItem = {
  encode(e, n = cn.Writer.create()) {
    for (const c of e.msgTypeUrls)
      n.uint32(10).string(c);
    return n;
  },
  decode(e, n) {
    const c = e instanceof cn.Reader ? e : new cn.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = _s();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.msgTypeUrls.push(c.string());
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      msgTypeUrls: Array.isArray(e == null ? void 0 : e.msgTypeUrls) ? e.msgTypeUrls.map((n) => String(n)) : []
    };
  },
  toJSON(e) {
    const n = {};
    return e.msgTypeUrls ? n.msgTypeUrls = e.msgTypeUrls.map((c) => c) : n.msgTypeUrls = [], n;
  },
  fromPartial(e) {
    var c;
    const n = _s();
    return n.msgTypeUrls = ((c = e.msgTypeUrls) == null ? void 0 : c.map((i) => i)) || [], n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(h, S, _, d) {
    d === void 0 && (d = _);
    var p = Object.getOwnPropertyDescriptor(S, _);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[_];
    } }), Object.defineProperty(h, d, p);
  } : function(h, S, _, d) {
    d === void 0 && (d = _), h[d] = S[_];
  }), c = G && G.__setModuleDefault || (Object.create ? function(h, S) {
    Object.defineProperty(h, "default", { enumerable: !0, value: S });
  } : function(h, S) {
    h.default = S;
  }), i = G && G.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var S = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && n(S, h, _);
    return c(S, h), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeResponse = e.MsgRevoke = e.MsgGrantResponse = e.MsgExec = e.MsgExecResponse = e.MsgGrant = e.protobufPackage = void 0;
  const r = xe, u = Se, f = i(ie), O = oe;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function A() {
    return {
      granter: "",
      grantee: "",
      grant: void 0
    };
  }
  e.MsgGrant = {
    encode(h, S = f.Writer.create()) {
      return h.granter !== "" && S.uint32(10).string(h.granter), h.grantee !== "" && S.uint32(18).string(h.grantee), h.grant !== void 0 && r.Grant.encode(h.grant, S.uint32(26).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = A();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.granter = _.string();
            break;
          case 2:
            p.grantee = _.string();
            break;
          case 3:
            p.grant = r.Grant.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        granter: (0, O.isSet)(h.granter) ? String(h.granter) : "",
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : "",
        grant: (0, O.isSet)(h.grant) ? r.Grant.fromJSON(h.grant) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.granter !== void 0 && (S.granter = h.granter), h.grantee !== void 0 && (S.grantee = h.grantee), h.grant !== void 0 && (S.grant = h.grant ? r.Grant.toJSON(h.grant) : void 0), S;
    },
    fromPartial(h) {
      const S = A();
      return S.granter = h.granter ?? "", S.grantee = h.grantee ?? "", S.grant = h.grant !== void 0 && h.grant !== null ? r.Grant.fromPartial(h.grant) : void 0, S;
    }
  };
  function T() {
    return {
      results: []
    };
  }
  e.MsgExecResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.results)
        S.uint32(10).bytes(_);
      return S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = T();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.results.push(_.bytes());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        results: Array.isArray(h == null ? void 0 : h.results) ? h.results.map((S) => (0, O.bytesFromBase64)(S)) : []
      };
    },
    toJSON(h) {
      const S = {};
      return h.results ? S.results = h.results.map((_) => (0, O.base64FromBytes)(_ !== void 0 ? _ : new Uint8Array())) : S.results = [], S;
    },
    fromPartial(h) {
      var _;
      const S = T();
      return S.results = ((_ = h.results) == null ? void 0 : _.map((d) => d)) || [], S;
    }
  };
  function L() {
    return {
      grantee: "",
      msgs: []
    };
  }
  e.MsgExec = {
    encode(h, S = f.Writer.create()) {
      h.grantee !== "" && S.uint32(10).string(h.grantee);
      for (const _ of h.msgs)
        u.Any.encode(_, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = L();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.grantee = _.string();
            break;
          case 2:
            p.msgs.push(u.Any.decode(_, _.uint32()));
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : "",
        msgs: Array.isArray(h == null ? void 0 : h.msgs) ? h.msgs.map((S) => u.Any.fromJSON(S)) : []
      };
    },
    toJSON(h) {
      const S = {};
      return h.grantee !== void 0 && (S.grantee = h.grantee), h.msgs ? S.msgs = h.msgs.map((_) => _ ? u.Any.toJSON(_) : void 0) : S.msgs = [], S;
    },
    fromPartial(h) {
      var _;
      const S = L();
      return S.grantee = h.grantee ?? "", S.msgs = ((_ = h.msgs) == null ? void 0 : _.map((d) => u.Any.fromPartial(d))) || [], S;
    }
  };
  function M() {
    return {};
  }
  e.MsgGrantResponse = {
    encode(h, S = f.Writer.create()) {
      return S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = M();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {};
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return M();
    }
  };
  function V() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: ""
    };
  }
  e.MsgRevoke = {
    encode(h, S = f.Writer.create()) {
      return h.granter !== "" && S.uint32(10).string(h.granter), h.grantee !== "" && S.uint32(18).string(h.grantee), h.msgTypeUrl !== "" && S.uint32(26).string(h.msgTypeUrl), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = V();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.granter = _.string();
            break;
          case 2:
            p.grantee = _.string();
            break;
          case 3:
            p.msgTypeUrl = _.string();
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        granter: (0, O.isSet)(h.granter) ? String(h.granter) : "",
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : "",
        msgTypeUrl: (0, O.isSet)(h.msgTypeUrl) ? String(h.msgTypeUrl) : ""
      };
    },
    toJSON(h) {
      const S = {};
      return h.granter !== void 0 && (S.granter = h.granter), h.grantee !== void 0 && (S.grantee = h.grantee), h.msgTypeUrl !== void 0 && (S.msgTypeUrl = h.msgTypeUrl), S;
    },
    fromPartial(h) {
      const S = V();
      return S.granter = h.granter ?? "", S.grantee = h.grantee ?? "", S.msgTypeUrl = h.msgTypeUrl ?? "", S;
    }
  };
  function D() {
    return {};
  }
  e.MsgRevokeResponse = {
    encode(h, S = f.Writer.create()) {
      return S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = D();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {};
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return D();
    }
  };
  class b {
    constructor(S) {
      this.rpc = S, this.Grant = this.Grant.bind(this), this.Exec = this.Exec.bind(this), this.Revoke = this.Revoke.bind(this);
    }
    Grant(S) {
      const _ = e.MsgGrant.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", _).then((p) => e.MsgGrantResponse.decode(new f.Reader(p)));
    }
    Exec(S) {
      const _ = e.MsgExec.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", _).then((p) => e.MsgExecResponse.decode(new f.Reader(p)));
    }
    Revoke(S) {
      const _ = e.MsgRevoke.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", _).then((p) => e.MsgRevokeResponse.decode(new f.Reader(p)));
    }
  }
  e.MsgClientImpl = b;
})(fu);
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.authzTypes = void 0;
const Yi = fu;
xr.authzTypes = [
  ["/cosmos.authz.v1beta1.MsgExec", Yi.MsgExec],
  ["/cosmos.authz.v1beta1.MsgGrant", Yi.MsgGrant],
  ["/cosmos.authz.v1beta1.MsgRevoke", Yi.MsgRevoke]
];
var jr = {}, pu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(h, S, _, d) {
    d === void 0 && (d = _);
    var p = Object.getOwnPropertyDescriptor(S, _);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[_];
    } }), Object.defineProperty(h, d, p);
  } : function(h, S, _, d) {
    d === void 0 && (d = _), h[d] = S[_];
  }), c = G && G.__setModuleDefault || (Object.create ? function(h, S) {
    Object.defineProperty(h, "default", { enumerable: !0, value: S });
  } : function(h, S) {
    h.default = S;
  }), i = G && G.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var S = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && n(S, h, _);
    return c(S, h), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryGranteeGrantsResponse = e.QueryGranteeGrantsRequest = e.QueryGranterGrantsResponse = e.QueryGranterGrantsRequest = e.QueryGrantsResponse = e.QueryGrantsRequest = e.protobufPackage = void 0;
  const r = Re, u = xe, f = i(ie), O = oe;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function A() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: "",
      pagination: void 0
    };
  }
  e.QueryGrantsRequest = {
    encode(h, S = f.Writer.create()) {
      return h.granter !== "" && S.uint32(10).string(h.granter), h.grantee !== "" && S.uint32(18).string(h.grantee), h.msgTypeUrl !== "" && S.uint32(26).string(h.msgTypeUrl), h.pagination !== void 0 && r.PageRequest.encode(h.pagination, S.uint32(34).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = A();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.granter = _.string();
            break;
          case 2:
            p.grantee = _.string();
            break;
          case 3:
            p.msgTypeUrl = _.string();
            break;
          case 4:
            p.pagination = r.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        granter: (0, O.isSet)(h.granter) ? String(h.granter) : "",
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : "",
        msgTypeUrl: (0, O.isSet)(h.msgTypeUrl) ? String(h.msgTypeUrl) : "",
        pagination: (0, O.isSet)(h.pagination) ? r.PageRequest.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.granter !== void 0 && (S.granter = h.granter), h.grantee !== void 0 && (S.grantee = h.grantee), h.msgTypeUrl !== void 0 && (S.msgTypeUrl = h.msgTypeUrl), h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageRequest.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      const S = A();
      return S.granter = h.granter ?? "", S.grantee = h.grantee ?? "", S.msgTypeUrl = h.msgTypeUrl ?? "", S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageRequest.fromPartial(h.pagination) : void 0, S;
    }
  };
  function T() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGrantsResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.grants)
        u.Grant.encode(_, S.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && r.PageResponse.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = T();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.grants.push(u.Grant.decode(_, _.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        grants: Array.isArray(h == null ? void 0 : h.grants) ? h.grants.map((S) => u.Grant.fromJSON(S)) : [],
        pagination: (0, O.isSet)(h.pagination) ? r.PageResponse.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.grants ? S.grants = h.grants.map((_) => _ ? u.Grant.toJSON(_) : void 0) : S.grants = [], h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageResponse.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      var _;
      const S = T();
      return S.grants = ((_ = h.grants) == null ? void 0 : _.map((d) => u.Grant.fromPartial(d))) || [], S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageResponse.fromPartial(h.pagination) : void 0, S;
    }
  };
  function L() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryGranterGrantsRequest = {
    encode(h, S = f.Writer.create()) {
      return h.granter !== "" && S.uint32(10).string(h.granter), h.pagination !== void 0 && r.PageRequest.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = L();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.granter = _.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        granter: (0, O.isSet)(h.granter) ? String(h.granter) : "",
        pagination: (0, O.isSet)(h.pagination) ? r.PageRequest.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.granter !== void 0 && (S.granter = h.granter), h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageRequest.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      const S = L();
      return S.granter = h.granter ?? "", S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageRequest.fromPartial(h.pagination) : void 0, S;
    }
  };
  function M() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranterGrantsResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.grants)
        u.GrantAuthorization.encode(_, S.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && r.PageResponse.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = M();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.grants.push(u.GrantAuthorization.decode(_, _.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        grants: Array.isArray(h == null ? void 0 : h.grants) ? h.grants.map((S) => u.GrantAuthorization.fromJSON(S)) : [],
        pagination: (0, O.isSet)(h.pagination) ? r.PageResponse.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.grants ? S.grants = h.grants.map((_) => _ ? u.GrantAuthorization.toJSON(_) : void 0) : S.grants = [], h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageResponse.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      var _;
      const S = M();
      return S.grants = ((_ = h.grants) == null ? void 0 : _.map((d) => u.GrantAuthorization.fromPartial(d))) || [], S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageResponse.fromPartial(h.pagination) : void 0, S;
    }
  };
  function V() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsRequest = {
    encode(h, S = f.Writer.create()) {
      return h.grantee !== "" && S.uint32(10).string(h.grantee), h.pagination !== void 0 && r.PageRequest.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = V();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.grantee = _.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : "",
        pagination: (0, O.isSet)(h.pagination) ? r.PageRequest.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.grantee !== void 0 && (S.grantee = h.grantee), h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageRequest.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      const S = V();
      return S.grantee = h.grantee ?? "", S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageRequest.fromPartial(h.pagination) : void 0, S;
    }
  };
  function D() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.grants)
        u.GrantAuthorization.encode(_, S.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && r.PageResponse.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = D();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.grants.push(u.GrantAuthorization.decode(_, _.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        grants: Array.isArray(h == null ? void 0 : h.grants) ? h.grants.map((S) => u.GrantAuthorization.fromJSON(S)) : [],
        pagination: (0, O.isSet)(h.pagination) ? r.PageResponse.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.grants ? S.grants = h.grants.map((_) => _ ? u.GrantAuthorization.toJSON(_) : void 0) : S.grants = [], h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageResponse.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      var _;
      const S = D();
      return S.grants = ((_ = h.grants) == null ? void 0 : _.map((d) => u.GrantAuthorization.fromPartial(d))) || [], S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageResponse.fromPartial(h.pagination) : void 0, S;
    }
  };
  class b {
    constructor(S) {
      this.rpc = S, this.Grants = this.Grants.bind(this), this.GranterGrants = this.GranterGrants.bind(this), this.GranteeGrants = this.GranteeGrants.bind(this);
    }
    Grants(S) {
      const _ = e.QueryGrantsRequest.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", _).then((p) => e.QueryGrantsResponse.decode(new f.Reader(p)));
    }
    GranterGrants(S) {
      const _ = e.QueryGranterGrantsRequest.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", _).then((p) => e.QueryGranterGrantsResponse.decode(new f.Reader(p)));
    }
    GranteeGrants(S) {
      const _ = e.QueryGranteeGrantsRequest.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", _).then((p) => e.QueryGranteeGrantsResponse.decode(new f.Reader(p)));
    }
  }
  e.QueryClientImpl = b;
})(pu);
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.setupAuthzExtension = void 0;
const Vp = pu, pr = Le;
function Lp(e) {
  const n = (0, pr.createProtobufRpcClient)(e), c = new Vp.QueryClientImpl(n);
  return {
    authz: {
      grants: async (i, r, u, f) => await c.Grants({
        granter: i,
        grantee: r,
        msgTypeUrl: u,
        pagination: (0, pr.createPagination)(f)
      }),
      granteeGrants: async (i, r) => await c.GranteeGrants({
        grantee: i,
        pagination: (0, pr.createPagination)(r)
      }),
      granterGrants: async (i, r) => await c.GranterGrants({
        granter: i,
        pagination: (0, pr.createPagination)(r)
      })
    }
  };
}
jr.setupAuthzExtension = Lp;
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.createBankAminoConverters = Vn.isAminoMsgMultiSend = Vn.isAminoMsgSend = void 0;
function Hp(e) {
  return e.type === "cosmos-sdk/MsgSend";
}
Vn.isAminoMsgSend = Hp;
function qp(e) {
  return e.type === "cosmos-sdk/MsgMultiSend";
}
Vn.isAminoMsgMultiSend = qp;
function Wp() {
  return {
    "/cosmos.bank.v1beta1.MsgSend": {
      aminoType: "cosmos-sdk/MsgSend",
      toAmino: ({ fromAddress: e, toAddress: n, amount: c }) => ({
        from_address: e,
        to_address: n,
        amount: [...c]
      }),
      fromAmino: ({ from_address: e, to_address: n, amount: c }) => ({
        fromAddress: e,
        toAddress: n,
        amount: [...c]
      })
    },
    "/cosmos.bank.v1beta1.MsgMultiSend": {
      aminoType: "cosmos-sdk/MsgMultiSend",
      toAmino: ({ inputs: e, outputs: n }) => ({
        inputs: e.map((c) => ({
          address: c.address,
          coins: [...c.coins]
        })),
        outputs: n.map((c) => ({
          address: c.address,
          coins: [...c.coins]
        }))
      }),
      fromAmino: ({ inputs: e, outputs: n }) => ({
        inputs: e.map((c) => ({
          address: c.address,
          coins: [...c.coins]
        })),
        outputs: n.map((c) => ({
          address: c.address,
          coins: [...c.coins]
        }))
      })
    }
  };
}
Vn.createBankAminoConverters = Wp;
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.isMsgSendEncodeObject = Nt.bankTypes = void 0;
const Ns = Yc;
Nt.bankTypes = [
  ["/cosmos.bank.v1beta1.MsgMultiSend", Ns.MsgMultiSend],
  ["/cosmos.bank.v1beta1.MsgSend", Ns.MsgSend]
];
function Zp(e) {
  return e.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
}
Nt.isMsgSendEncodeObject = Zp;
var ei = {}, hu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(k, U, F, q) {
    q === void 0 && (q = F);
    var o = Object.getOwnPropertyDescriptor(U, F);
    (!o || ("get" in o ? !U.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return U[F];
    } }), Object.defineProperty(k, q, o);
  } : function(k, U, F, q) {
    q === void 0 && (q = F), k[q] = U[F];
  }), c = G && G.__setModuleDefault || (Object.create ? function(k, U) {
    Object.defineProperty(k, "default", { enumerable: !0, value: U });
  } : function(k, U) {
    k.default = U;
  }), i = G && G.__importStar || function(k) {
    if (k && k.__esModule)
      return k;
    var U = {};
    if (k != null)
      for (var F in k)
        F !== "default" && Object.prototype.hasOwnProperty.call(k, F) && n(U, k, F);
    return c(U, k), U;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySendEnabledResponse = e.QuerySendEnabledRequest = e.QueryDenomOwnersResponse = e.DenomOwner = e.QueryDenomOwnersRequest = e.QueryDenomMetadataResponse = e.QueryDenomMetadataRequest = e.QueryDenomsMetadataResponse = e.QueryDenomsMetadataRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QuerySupplyOfResponse = e.QuerySupplyOfRequest = e.QueryTotalSupplyResponse = e.QueryTotalSupplyRequest = e.QuerySpendableBalanceByDenomResponse = e.QuerySpendableBalanceByDenomRequest = e.QuerySpendableBalancesResponse = e.QuerySpendableBalancesRequest = e.QueryAllBalancesResponse = e.QueryAllBalancesRequest = e.QueryBalanceResponse = e.QueryBalanceRequest = e.protobufPackage = void 0;
  const r = Re, u = Me, f = Xc, O = i(ie), A = oe;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function T() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QueryBalanceRequest = {
    encode(k, U = O.Writer.create()) {
      return k.address !== "" && U.uint32(10).string(k.address), k.denom !== "" && U.uint32(18).string(k.denom), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = T();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.address = F.string();
            break;
          case 2:
            o.denom = F.string();
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        address: (0, A.isSet)(k.address) ? String(k.address) : "",
        denom: (0, A.isSet)(k.denom) ? String(k.denom) : ""
      };
    },
    toJSON(k) {
      const U = {};
      return k.address !== void 0 && (U.address = k.address), k.denom !== void 0 && (U.denom = k.denom), U;
    },
    fromPartial(k) {
      const U = T();
      return U.address = k.address ?? "", U.denom = k.denom ?? "", U;
    }
  };
  function L() {
    return {
      balance: void 0
    };
  }
  e.QueryBalanceResponse = {
    encode(k, U = O.Writer.create()) {
      return k.balance !== void 0 && u.Coin.encode(k.balance, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = L();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.balance = u.Coin.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        balance: (0, A.isSet)(k.balance) ? u.Coin.fromJSON(k.balance) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.balance !== void 0 && (U.balance = k.balance ? u.Coin.toJSON(k.balance) : void 0), U;
    },
    fromPartial(k) {
      const U = L();
      return U.balance = k.balance !== void 0 && k.balance !== null ? u.Coin.fromPartial(k.balance) : void 0, U;
    }
  };
  function M() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QueryAllBalancesRequest = {
    encode(k, U = O.Writer.create()) {
      return k.address !== "" && U.uint32(10).string(k.address), k.pagination !== void 0 && r.PageRequest.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = M();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.address = F.string();
            break;
          case 2:
            o.pagination = r.PageRequest.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        address: (0, A.isSet)(k.address) ? String(k.address) : "",
        pagination: (0, A.isSet)(k.pagination) ? r.PageRequest.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.address !== void 0 && (U.address = k.address), k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageRequest.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      const U = M();
      return U.address = k.address ?? "", U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageRequest.fromPartial(k.pagination) : void 0, U;
    }
  };
  function V() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QueryAllBalancesResponse = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.balances)
        u.Coin.encode(F, U.uint32(10).fork()).ldelim();
      return k.pagination !== void 0 && r.PageResponse.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = V();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.balances.push(u.Coin.decode(F, F.uint32()));
            break;
          case 2:
            o.pagination = r.PageResponse.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        balances: Array.isArray(k == null ? void 0 : k.balances) ? k.balances.map((U) => u.Coin.fromJSON(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageResponse.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.balances ? U.balances = k.balances.map((F) => F ? u.Coin.toJSON(F) : void 0) : U.balances = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageResponse.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = V();
      return U.balances = ((F = k.balances) == null ? void 0 : F.map((q) => u.Coin.fromPartial(q))) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageResponse.fromPartial(k.pagination) : void 0, U;
    }
  };
  function D() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesRequest = {
    encode(k, U = O.Writer.create()) {
      return k.address !== "" && U.uint32(10).string(k.address), k.pagination !== void 0 && r.PageRequest.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = D();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.address = F.string();
            break;
          case 2:
            o.pagination = r.PageRequest.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        address: (0, A.isSet)(k.address) ? String(k.address) : "",
        pagination: (0, A.isSet)(k.pagination) ? r.PageRequest.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.address !== void 0 && (U.address = k.address), k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageRequest.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      const U = D();
      return U.address = k.address ?? "", U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageRequest.fromPartial(k.pagination) : void 0, U;
    }
  };
  function b() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesResponse = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.balances)
        u.Coin.encode(F, U.uint32(10).fork()).ldelim();
      return k.pagination !== void 0 && r.PageResponse.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = b();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.balances.push(u.Coin.decode(F, F.uint32()));
            break;
          case 2:
            o.pagination = r.PageResponse.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        balances: Array.isArray(k == null ? void 0 : k.balances) ? k.balances.map((U) => u.Coin.fromJSON(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageResponse.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.balances ? U.balances = k.balances.map((F) => F ? u.Coin.toJSON(F) : void 0) : U.balances = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageResponse.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = b();
      return U.balances = ((F = k.balances) == null ? void 0 : F.map((q) => u.Coin.fromPartial(q))) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageResponse.fromPartial(k.pagination) : void 0, U;
    }
  };
  function h() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QuerySpendableBalanceByDenomRequest = {
    encode(k, U = O.Writer.create()) {
      return k.address !== "" && U.uint32(10).string(k.address), k.denom !== "" && U.uint32(18).string(k.denom), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = h();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.address = F.string();
            break;
          case 2:
            o.denom = F.string();
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        address: (0, A.isSet)(k.address) ? String(k.address) : "",
        denom: (0, A.isSet)(k.denom) ? String(k.denom) : ""
      };
    },
    toJSON(k) {
      const U = {};
      return k.address !== void 0 && (U.address = k.address), k.denom !== void 0 && (U.denom = k.denom), U;
    },
    fromPartial(k) {
      const U = h();
      return U.address = k.address ?? "", U.denom = k.denom ?? "", U;
    }
  };
  function S() {
    return {
      balance: void 0
    };
  }
  e.QuerySpendableBalanceByDenomResponse = {
    encode(k, U = O.Writer.create()) {
      return k.balance !== void 0 && u.Coin.encode(k.balance, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = S();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.balance = u.Coin.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        balance: (0, A.isSet)(k.balance) ? u.Coin.fromJSON(k.balance) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.balance !== void 0 && (U.balance = k.balance ? u.Coin.toJSON(k.balance) : void 0), U;
    },
    fromPartial(k) {
      const U = S();
      return U.balance = k.balance !== void 0 && k.balance !== null ? u.Coin.fromPartial(k.balance) : void 0, U;
    }
  };
  function _() {
    return {
      pagination: void 0
    };
  }
  e.QueryTotalSupplyRequest = {
    encode(k, U = O.Writer.create()) {
      return k.pagination !== void 0 && r.PageRequest.encode(k.pagination, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = _();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.pagination = r.PageRequest.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        pagination: (0, A.isSet)(k.pagination) ? r.PageRequest.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageRequest.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      const U = _();
      return U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageRequest.fromPartial(k.pagination) : void 0, U;
    }
  };
  function d() {
    return {
      supply: [],
      pagination: void 0
    };
  }
  e.QueryTotalSupplyResponse = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.supply)
        u.Coin.encode(F, U.uint32(10).fork()).ldelim();
      return k.pagination !== void 0 && r.PageResponse.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = d();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.supply.push(u.Coin.decode(F, F.uint32()));
            break;
          case 2:
            o.pagination = r.PageResponse.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        supply: Array.isArray(k == null ? void 0 : k.supply) ? k.supply.map((U) => u.Coin.fromJSON(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageResponse.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.supply ? U.supply = k.supply.map((F) => F ? u.Coin.toJSON(F) : void 0) : U.supply = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageResponse.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = d();
      return U.supply = ((F = k.supply) == null ? void 0 : F.map((q) => u.Coin.fromPartial(q))) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageResponse.fromPartial(k.pagination) : void 0, U;
    }
  };
  function p() {
    return {
      denom: ""
    };
  }
  e.QuerySupplyOfRequest = {
    encode(k, U = O.Writer.create()) {
      return k.denom !== "" && U.uint32(10).string(k.denom), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = p();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.denom = F.string();
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        denom: (0, A.isSet)(k.denom) ? String(k.denom) : ""
      };
    },
    toJSON(k) {
      const U = {};
      return k.denom !== void 0 && (U.denom = k.denom), U;
    },
    fromPartial(k) {
      const U = p();
      return U.denom = k.denom ?? "", U;
    }
  };
  function g() {
    return {
      amount: void 0
    };
  }
  e.QuerySupplyOfResponse = {
    encode(k, U = O.Writer.create()) {
      return k.amount !== void 0 && u.Coin.encode(k.amount, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = g();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.amount = u.Coin.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        amount: (0, A.isSet)(k.amount) ? u.Coin.fromJSON(k.amount) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.amount !== void 0 && (U.amount = k.amount ? u.Coin.toJSON(k.amount) : void 0), U;
    },
    fromPartial(k) {
      const U = g();
      return U.amount = k.amount !== void 0 && k.amount !== null ? u.Coin.fromPartial(k.amount) : void 0, U;
    }
  };
  function J() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(k, U = O.Writer.create()) {
      return U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = J();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {};
    },
    toJSON(k) {
      return {};
    },
    fromPartial(k) {
      return J();
    }
  };
  function B() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(k, U = O.Writer.create()) {
      return k.params !== void 0 && f.Params.encode(k.params, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = B();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.params = f.Params.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        params: (0, A.isSet)(k.params) ? f.Params.fromJSON(k.params) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.params !== void 0 && (U.params = k.params ? f.Params.toJSON(k.params) : void 0), U;
    },
    fromPartial(k) {
      const U = B();
      return U.params = k.params !== void 0 && k.params !== null ? f.Params.fromPartial(k.params) : void 0, U;
    }
  };
  function I() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataRequest = {
    encode(k, U = O.Writer.create()) {
      return k.pagination !== void 0 && r.PageRequest.encode(k.pagination, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = I();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.pagination = r.PageRequest.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        pagination: (0, A.isSet)(k.pagination) ? r.PageRequest.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageRequest.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      const U = I();
      return U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageRequest.fromPartial(k.pagination) : void 0, U;
    }
  };
  function Z() {
    return {
      metadatas: [],
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataResponse = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.metadatas)
        f.Metadata.encode(F, U.uint32(10).fork()).ldelim();
      return k.pagination !== void 0 && r.PageResponse.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = Z();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.metadatas.push(f.Metadata.decode(F, F.uint32()));
            break;
          case 2:
            o.pagination = r.PageResponse.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        metadatas: Array.isArray(k == null ? void 0 : k.metadatas) ? k.metadatas.map((U) => f.Metadata.fromJSON(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageResponse.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.metadatas ? U.metadatas = k.metadatas.map((F) => F ? f.Metadata.toJSON(F) : void 0) : U.metadatas = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageResponse.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = Z();
      return U.metadatas = ((F = k.metadatas) == null ? void 0 : F.map((q) => f.Metadata.fromPartial(q))) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageResponse.fromPartial(k.pagination) : void 0, U;
    }
  };
  function t() {
    return {
      denom: ""
    };
  }
  e.QueryDenomMetadataRequest = {
    encode(k, U = O.Writer.create()) {
      return k.denom !== "" && U.uint32(10).string(k.denom), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = t();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.denom = F.string();
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        denom: (0, A.isSet)(k.denom) ? String(k.denom) : ""
      };
    },
    toJSON(k) {
      const U = {};
      return k.denom !== void 0 && (U.denom = k.denom), U;
    },
    fromPartial(k) {
      const U = t();
      return U.denom = k.denom ?? "", U;
    }
  };
  function y() {
    return {
      metadata: void 0
    };
  }
  e.QueryDenomMetadataResponse = {
    encode(k, U = O.Writer.create()) {
      return k.metadata !== void 0 && f.Metadata.encode(k.metadata, U.uint32(10).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = y();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.metadata = f.Metadata.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        metadata: (0, A.isSet)(k.metadata) ? f.Metadata.fromJSON(k.metadata) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.metadata !== void 0 && (U.metadata = k.metadata ? f.Metadata.toJSON(k.metadata) : void 0), U;
    },
    fromPartial(k) {
      const U = y();
      return U.metadata = k.metadata !== void 0 && k.metadata !== null ? f.Metadata.fromPartial(k.metadata) : void 0, U;
    }
  };
  function E() {
    return {
      denom: "",
      pagination: void 0
    };
  }
  e.QueryDenomOwnersRequest = {
    encode(k, U = O.Writer.create()) {
      return k.denom !== "" && U.uint32(10).string(k.denom), k.pagination !== void 0 && r.PageRequest.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = E();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.denom = F.string();
            break;
          case 2:
            o.pagination = r.PageRequest.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        denom: (0, A.isSet)(k.denom) ? String(k.denom) : "",
        pagination: (0, A.isSet)(k.pagination) ? r.PageRequest.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.denom !== void 0 && (U.denom = k.denom), k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageRequest.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      const U = E();
      return U.denom = k.denom ?? "", U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageRequest.fromPartial(k.pagination) : void 0, U;
    }
  };
  function H() {
    return {
      address: "",
      balance: void 0
    };
  }
  e.DenomOwner = {
    encode(k, U = O.Writer.create()) {
      return k.address !== "" && U.uint32(10).string(k.address), k.balance !== void 0 && u.Coin.encode(k.balance, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = H();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.address = F.string();
            break;
          case 2:
            o.balance = u.Coin.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        address: (0, A.isSet)(k.address) ? String(k.address) : "",
        balance: (0, A.isSet)(k.balance) ? u.Coin.fromJSON(k.balance) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.address !== void 0 && (U.address = k.address), k.balance !== void 0 && (U.balance = k.balance ? u.Coin.toJSON(k.balance) : void 0), U;
    },
    fromPartial(k) {
      const U = H();
      return U.address = k.address ?? "", U.balance = k.balance !== void 0 && k.balance !== null ? u.Coin.fromPartial(k.balance) : void 0, U;
    }
  };
  function a() {
    return {
      denomOwners: [],
      pagination: void 0
    };
  }
  e.QueryDenomOwnersResponse = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.denomOwners)
        e.DenomOwner.encode(F, U.uint32(10).fork()).ldelim();
      return k.pagination !== void 0 && r.PageResponse.encode(k.pagination, U.uint32(18).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = a();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.denomOwners.push(e.DenomOwner.decode(F, F.uint32()));
            break;
          case 2:
            o.pagination = r.PageResponse.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        denomOwners: Array.isArray(k == null ? void 0 : k.denomOwners) ? k.denomOwners.map((U) => e.DenomOwner.fromJSON(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageResponse.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.denomOwners ? U.denomOwners = k.denomOwners.map((F) => F ? e.DenomOwner.toJSON(F) : void 0) : U.denomOwners = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageResponse.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = a();
      return U.denomOwners = ((F = k.denomOwners) == null ? void 0 : F.map((q) => e.DenomOwner.fromPartial(q))) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageResponse.fromPartial(k.pagination) : void 0, U;
    }
  };
  function l() {
    return {
      denoms: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledRequest = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.denoms)
        U.uint32(10).string(F);
      return k.pagination !== void 0 && r.PageRequest.encode(k.pagination, U.uint32(794).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = l();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.denoms.push(F.string());
            break;
          case 99:
            o.pagination = r.PageRequest.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        denoms: Array.isArray(k == null ? void 0 : k.denoms) ? k.denoms.map((U) => String(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageRequest.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.denoms ? U.denoms = k.denoms.map((F) => F) : U.denoms = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageRequest.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = l();
      return U.denoms = ((F = k.denoms) == null ? void 0 : F.map((q) => q)) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageRequest.fromPartial(k.pagination) : void 0, U;
    }
  };
  function C() {
    return {
      sendEnabled: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledResponse = {
    encode(k, U = O.Writer.create()) {
      for (const F of k.sendEnabled)
        f.SendEnabled.encode(F, U.uint32(10).fork()).ldelim();
      return k.pagination !== void 0 && r.PageResponse.encode(k.pagination, U.uint32(794).fork()).ldelim(), U;
    },
    decode(k, U) {
      const F = k instanceof O.Reader ? k : new O.Reader(k);
      let q = U === void 0 ? F.len : F.pos + U;
      const o = C();
      for (; F.pos < q; ) {
        const P = F.uint32();
        switch (P >>> 3) {
          case 1:
            o.sendEnabled.push(f.SendEnabled.decode(F, F.uint32()));
            break;
          case 99:
            o.pagination = r.PageResponse.decode(F, F.uint32());
            break;
          default:
            F.skipType(P & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(k) {
      return {
        sendEnabled: Array.isArray(k == null ? void 0 : k.sendEnabled) ? k.sendEnabled.map((U) => f.SendEnabled.fromJSON(U)) : [],
        pagination: (0, A.isSet)(k.pagination) ? r.PageResponse.fromJSON(k.pagination) : void 0
      };
    },
    toJSON(k) {
      const U = {};
      return k.sendEnabled ? U.sendEnabled = k.sendEnabled.map((F) => F ? f.SendEnabled.toJSON(F) : void 0) : U.sendEnabled = [], k.pagination !== void 0 && (U.pagination = k.pagination ? r.PageResponse.toJSON(k.pagination) : void 0), U;
    },
    fromPartial(k) {
      var F;
      const U = C();
      return U.sendEnabled = ((F = k.sendEnabled) == null ? void 0 : F.map((q) => f.SendEnabled.fromPartial(q))) || [], U.pagination = k.pagination !== void 0 && k.pagination !== null ? r.PageResponse.fromPartial(k.pagination) : void 0, U;
    }
  };
  class v {
    constructor(U) {
      this.rpc = U, this.Balance = this.Balance.bind(this), this.AllBalances = this.AllBalances.bind(this), this.SpendableBalances = this.SpendableBalances.bind(this), this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this), this.TotalSupply = this.TotalSupply.bind(this), this.SupplyOf = this.SupplyOf.bind(this), this.Params = this.Params.bind(this), this.DenomMetadata = this.DenomMetadata.bind(this), this.DenomsMetadata = this.DenomsMetadata.bind(this), this.DenomOwners = this.DenomOwners.bind(this), this.SendEnabled = this.SendEnabled.bind(this);
    }
    Balance(U) {
      const F = e.QueryBalanceRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", F).then((o) => e.QueryBalanceResponse.decode(new O.Reader(o)));
    }
    AllBalances(U) {
      const F = e.QueryAllBalancesRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", F).then((o) => e.QueryAllBalancesResponse.decode(new O.Reader(o)));
    }
    SpendableBalances(U) {
      const F = e.QuerySpendableBalancesRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", F).then((o) => e.QuerySpendableBalancesResponse.decode(new O.Reader(o)));
    }
    SpendableBalanceByDenom(U) {
      const F = e.QuerySpendableBalanceByDenomRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", F).then((o) => e.QuerySpendableBalanceByDenomResponse.decode(new O.Reader(o)));
    }
    TotalSupply(U = {
      pagination: void 0
    }) {
      const F = e.QueryTotalSupplyRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", F).then((o) => e.QueryTotalSupplyResponse.decode(new O.Reader(o)));
    }
    SupplyOf(U) {
      const F = e.QuerySupplyOfRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", F).then((o) => e.QuerySupplyOfResponse.decode(new O.Reader(o)));
    }
    Params(U = {}) {
      const F = e.QueryParamsRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Params", F).then((o) => e.QueryParamsResponse.decode(new O.Reader(o)));
    }
    DenomMetadata(U) {
      const F = e.QueryDenomMetadataRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", F).then((o) => e.QueryDenomMetadataResponse.decode(new O.Reader(o)));
    }
    DenomsMetadata(U = {
      pagination: void 0
    }) {
      const F = e.QueryDenomsMetadataRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", F).then((o) => e.QueryDenomsMetadataResponse.decode(new O.Reader(o)));
    }
    DenomOwners(U) {
      const F = e.QueryDenomOwnersRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", F).then((o) => e.QueryDenomOwnersResponse.decode(new O.Reader(o)));
    }
    SendEnabled(U) {
      const F = e.QuerySendEnabledRequest.encode(U).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", F).then((o) => e.QuerySendEnabledResponse.decode(new O.Reader(o)));
    }
  }
  e.QueryClientImpl = v;
})(hu);
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.setupBankExtension = void 0;
const Xi = yn, Qp = hu, Ts = Le;
function Fp(e) {
  const n = (0, Ts.createProtobufRpcClient)(e), c = new Qp.QueryClientImpl(n);
  return {
    bank: {
      balance: async (i, r) => {
        const { balance: u } = await c.Balance({ address: i, denom: r });
        return (0, Xi.assert)(u), u;
      },
      allBalances: async (i) => {
        const { balances: r } = await c.AllBalances({ address: i });
        return r;
      },
      totalSupply: async (i) => await c.TotalSupply({
        pagination: (0, Ts.createPagination)(i)
      }),
      supplyOf: async (i) => {
        const { amount: r } = await c.SupplyOf({ denom: i });
        return (0, Xi.assert)(r), r;
      },
      denomMetadata: async (i) => {
        const { metadata: r } = await c.DenomMetadata({ denom: i });
        return (0, Xi.assert)(r), r;
      },
      denomsMetadata: async () => {
        const { metadatas: i } = await c.DenomsMetadata({
          pagination: void 0
          // Not implemented
        });
        return i;
      }
    }
  };
}
ei.setupBankExtension = Fp;
var Tt = {};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.createCrysisAminoConverters = Tt.isAminoMsgVerifyInvariant = void 0;
function Gp(e) {
  return e.type === "cosmos-sdk/MsgVerifyInvariant";
}
Tt.isAminoMsgVerifyInvariant = Gp;
function $p() {
  throw new Error("Not implemented");
}
Tt.createCrysisAminoConverters = $p;
var rn = {};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.createDistributionAminoConverters = rn.isAminoMsgFundCommunityPool = rn.isAminoMsgWithdrawValidatorCommission = rn.isAminoMsgWithdrawDelegatorReward = rn.isAminoMsgSetWithdrawAddress = void 0;
function Kp(e) {
  return e.type === "cosmos-sdk/MsgModifyWithdrawAddress";
}
rn.isAminoMsgSetWithdrawAddress = Kp;
function zp(e) {
  return e.type === "cosmos-sdk/MsgWithdrawDelegationReward";
}
rn.isAminoMsgWithdrawDelegatorReward = zp;
function Yp(e) {
  return e.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
}
rn.isAminoMsgWithdrawValidatorCommission = Yp;
function Xp(e) {
  return e.type === "cosmos-sdk/MsgFundCommunityPool";
}
rn.isAminoMsgFundCommunityPool = Xp;
function xp() {
  return {
    "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
      aminoType: "cosmos-sdk/MsgFundCommunityPool",
      toAmino: ({ amount: e, depositor: n }) => ({
        amount: [...e],
        depositor: n
      }),
      fromAmino: ({ amount: e, depositor: n }) => ({
        amount: [...e],
        depositor: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
      aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
      toAmino: ({ delegatorAddress: e, withdrawAddress: n }) => ({
        delegator_address: e,
        withdraw_address: n
      }),
      fromAmino: ({ delegator_address: e, withdraw_address: n }) => ({
        delegatorAddress: e,
        withdrawAddress: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
      aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
      toAmino: ({ delegatorAddress: e, validatorAddress: n }) => ({
        delegator_address: e,
        validator_address: n
      }),
      fromAmino: ({ delegator_address: e, validator_address: n }) => ({
        delegatorAddress: e,
        validatorAddress: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
      aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
      toAmino: ({ validatorAddress: e }) => ({
        validator_address: e
      }),
      fromAmino: ({ validator_address: e }) => ({
        validatorAddress: e
      })
    }
  };
}
rn.createDistributionAminoConverters = xp;
var Et = {}, ea = {}, na = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(p, g, J, B) {
    B === void 0 && (B = J);
    var I = Object.getOwnPropertyDescriptor(g, J);
    (!I || ("get" in I ? !g.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return g[J];
    } }), Object.defineProperty(p, B, I);
  } : function(p, g, J, B) {
    B === void 0 && (B = J), p[B] = g[J];
  }), c = G && G.__setModuleDefault || (Object.create ? function(p, g) {
    Object.defineProperty(p, "default", { enumerable: !0, value: g });
  } : function(p, g) {
    p.default = g;
  }), i = G && G.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var g = {};
    if (p != null)
      for (var J in p)
        J !== "default" && Object.prototype.hasOwnProperty.call(p, J) && n(g, p, J);
    return c(g, p), g;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CommunityPoolSpendProposalWithDeposit = e.DelegationDelegatorReward = e.DelegatorStartingInfo = e.CommunityPoolSpendProposal = e.FeePool = e.ValidatorSlashEvents = e.ValidatorSlashEvent = e.ValidatorOutstandingRewards = e.ValidatorAccumulatedCommission = e.ValidatorCurrentRewards = e.ValidatorHistoricalRewards = e.Params = e.protobufPackage = void 0;
  const r = Me, u = oe, f = i(ie);
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function O() {
    return {
      communityTax: "",
      baseProposerReward: "",
      bonusProposerReward: "",
      withdrawAddrEnabled: !1
    };
  }
  e.Params = {
    encode(p, g = f.Writer.create()) {
      return p.communityTax !== "" && g.uint32(10).string(p.communityTax), p.baseProposerReward !== "" && g.uint32(18).string(p.baseProposerReward), p.bonusProposerReward !== "" && g.uint32(26).string(p.bonusProposerReward), p.withdrawAddrEnabled === !0 && g.uint32(32).bool(p.withdrawAddrEnabled), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = O();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.communityTax = J.string();
            break;
          case 2:
            I.baseProposerReward = J.string();
            break;
          case 3:
            I.bonusProposerReward = J.string();
            break;
          case 4:
            I.withdrawAddrEnabled = J.bool();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        communityTax: (0, u.isSet)(p.communityTax) ? String(p.communityTax) : "",
        baseProposerReward: (0, u.isSet)(p.baseProposerReward) ? String(p.baseProposerReward) : "",
        bonusProposerReward: (0, u.isSet)(p.bonusProposerReward) ? String(p.bonusProposerReward) : "",
        withdrawAddrEnabled: (0, u.isSet)(p.withdrawAddrEnabled) ? !!p.withdrawAddrEnabled : !1
      };
    },
    toJSON(p) {
      const g = {};
      return p.communityTax !== void 0 && (g.communityTax = p.communityTax), p.baseProposerReward !== void 0 && (g.baseProposerReward = p.baseProposerReward), p.bonusProposerReward !== void 0 && (g.bonusProposerReward = p.bonusProposerReward), p.withdrawAddrEnabled !== void 0 && (g.withdrawAddrEnabled = p.withdrawAddrEnabled), g;
    },
    fromPartial(p) {
      const g = O();
      return g.communityTax = p.communityTax ?? "", g.baseProposerReward = p.baseProposerReward ?? "", g.bonusProposerReward = p.bonusProposerReward ?? "", g.withdrawAddrEnabled = p.withdrawAddrEnabled ?? !1, g;
    }
  };
  function A() {
    return {
      cumulativeRewardRatio: [],
      referenceCount: 0
    };
  }
  e.ValidatorHistoricalRewards = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.cumulativeRewardRatio)
        r.DecCoin.encode(J, g.uint32(10).fork()).ldelim();
      return p.referenceCount !== 0 && g.uint32(16).uint32(p.referenceCount), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = A();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.cumulativeRewardRatio.push(r.DecCoin.decode(J, J.uint32()));
            break;
          case 2:
            I.referenceCount = J.uint32();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        cumulativeRewardRatio: Array.isArray(p == null ? void 0 : p.cumulativeRewardRatio) ? p.cumulativeRewardRatio.map((g) => r.DecCoin.fromJSON(g)) : [],
        referenceCount: (0, u.isSet)(p.referenceCount) ? Number(p.referenceCount) : 0
      };
    },
    toJSON(p) {
      const g = {};
      return p.cumulativeRewardRatio ? g.cumulativeRewardRatio = p.cumulativeRewardRatio.map((J) => J ? r.DecCoin.toJSON(J) : void 0) : g.cumulativeRewardRatio = [], p.referenceCount !== void 0 && (g.referenceCount = Math.round(p.referenceCount)), g;
    },
    fromPartial(p) {
      var J;
      const g = A();
      return g.cumulativeRewardRatio = ((J = p.cumulativeRewardRatio) == null ? void 0 : J.map((B) => r.DecCoin.fromPartial(B))) || [], g.referenceCount = p.referenceCount ?? 0, g;
    }
  };
  function T() {
    return {
      rewards: [],
      period: u.Long.UZERO
    };
  }
  e.ValidatorCurrentRewards = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.rewards)
        r.DecCoin.encode(J, g.uint32(10).fork()).ldelim();
      return p.period.isZero() || g.uint32(16).uint64(p.period), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = T();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.rewards.push(r.DecCoin.decode(J, J.uint32()));
            break;
          case 2:
            I.period = J.uint64();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        rewards: Array.isArray(p == null ? void 0 : p.rewards) ? p.rewards.map((g) => r.DecCoin.fromJSON(g)) : [],
        period: (0, u.isSet)(p.period) ? u.Long.fromValue(p.period) : u.Long.UZERO
      };
    },
    toJSON(p) {
      const g = {};
      return p.rewards ? g.rewards = p.rewards.map((J) => J ? r.DecCoin.toJSON(J) : void 0) : g.rewards = [], p.period !== void 0 && (g.period = (p.period || u.Long.UZERO).toString()), g;
    },
    fromPartial(p) {
      var J;
      const g = T();
      return g.rewards = ((J = p.rewards) == null ? void 0 : J.map((B) => r.DecCoin.fromPartial(B))) || [], g.period = p.period !== void 0 && p.period !== null ? u.Long.fromValue(p.period) : u.Long.UZERO, g;
    }
  };
  function L() {
    return {
      commission: []
    };
  }
  e.ValidatorAccumulatedCommission = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.commission)
        r.DecCoin.encode(J, g.uint32(10).fork()).ldelim();
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = L();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.commission.push(r.DecCoin.decode(J, J.uint32()));
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        commission: Array.isArray(p == null ? void 0 : p.commission) ? p.commission.map((g) => r.DecCoin.fromJSON(g)) : []
      };
    },
    toJSON(p) {
      const g = {};
      return p.commission ? g.commission = p.commission.map((J) => J ? r.DecCoin.toJSON(J) : void 0) : g.commission = [], g;
    },
    fromPartial(p) {
      var J;
      const g = L();
      return g.commission = ((J = p.commission) == null ? void 0 : J.map((B) => r.DecCoin.fromPartial(B))) || [], g;
    }
  };
  function M() {
    return {
      rewards: []
    };
  }
  e.ValidatorOutstandingRewards = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.rewards)
        r.DecCoin.encode(J, g.uint32(10).fork()).ldelim();
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = M();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.rewards.push(r.DecCoin.decode(J, J.uint32()));
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        rewards: Array.isArray(p == null ? void 0 : p.rewards) ? p.rewards.map((g) => r.DecCoin.fromJSON(g)) : []
      };
    },
    toJSON(p) {
      const g = {};
      return p.rewards ? g.rewards = p.rewards.map((J) => J ? r.DecCoin.toJSON(J) : void 0) : g.rewards = [], g;
    },
    fromPartial(p) {
      var J;
      const g = M();
      return g.rewards = ((J = p.rewards) == null ? void 0 : J.map((B) => r.DecCoin.fromPartial(B))) || [], g;
    }
  };
  function V() {
    return {
      validatorPeriod: u.Long.UZERO,
      fraction: ""
    };
  }
  e.ValidatorSlashEvent = {
    encode(p, g = f.Writer.create()) {
      return p.validatorPeriod.isZero() || g.uint32(8).uint64(p.validatorPeriod), p.fraction !== "" && g.uint32(18).string(p.fraction), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = V();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.validatorPeriod = J.uint64();
            break;
          case 2:
            I.fraction = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        validatorPeriod: (0, u.isSet)(p.validatorPeriod) ? u.Long.fromValue(p.validatorPeriod) : u.Long.UZERO,
        fraction: (0, u.isSet)(p.fraction) ? String(p.fraction) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.validatorPeriod !== void 0 && (g.validatorPeriod = (p.validatorPeriod || u.Long.UZERO).toString()), p.fraction !== void 0 && (g.fraction = p.fraction), g;
    },
    fromPartial(p) {
      const g = V();
      return g.validatorPeriod = p.validatorPeriod !== void 0 && p.validatorPeriod !== null ? u.Long.fromValue(p.validatorPeriod) : u.Long.UZERO, g.fraction = p.fraction ?? "", g;
    }
  };
  function D() {
    return {
      validatorSlashEvents: []
    };
  }
  e.ValidatorSlashEvents = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.validatorSlashEvents)
        e.ValidatorSlashEvent.encode(J, g.uint32(10).fork()).ldelim();
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = D();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.validatorSlashEvents.push(e.ValidatorSlashEvent.decode(J, J.uint32()));
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        validatorSlashEvents: Array.isArray(p == null ? void 0 : p.validatorSlashEvents) ? p.validatorSlashEvents.map((g) => e.ValidatorSlashEvent.fromJSON(g)) : []
      };
    },
    toJSON(p) {
      const g = {};
      return p.validatorSlashEvents ? g.validatorSlashEvents = p.validatorSlashEvents.map((J) => J ? e.ValidatorSlashEvent.toJSON(J) : void 0) : g.validatorSlashEvents = [], g;
    },
    fromPartial(p) {
      var J;
      const g = D();
      return g.validatorSlashEvents = ((J = p.validatorSlashEvents) == null ? void 0 : J.map((B) => e.ValidatorSlashEvent.fromPartial(B))) || [], g;
    }
  };
  function b() {
    return {
      communityPool: []
    };
  }
  e.FeePool = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.communityPool)
        r.DecCoin.encode(J, g.uint32(10).fork()).ldelim();
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = b();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.communityPool.push(r.DecCoin.decode(J, J.uint32()));
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        communityPool: Array.isArray(p == null ? void 0 : p.communityPool) ? p.communityPool.map((g) => r.DecCoin.fromJSON(g)) : []
      };
    },
    toJSON(p) {
      const g = {};
      return p.communityPool ? g.communityPool = p.communityPool.map((J) => J ? r.DecCoin.toJSON(J) : void 0) : g.communityPool = [], g;
    },
    fromPartial(p) {
      var J;
      const g = b();
      return g.communityPool = ((J = p.communityPool) == null ? void 0 : J.map((B) => r.DecCoin.fromPartial(B))) || [], g;
    }
  };
  function h() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: []
    };
  }
  e.CommunityPoolSpendProposal = {
    encode(p, g = f.Writer.create()) {
      p.title !== "" && g.uint32(10).string(p.title), p.description !== "" && g.uint32(18).string(p.description), p.recipient !== "" && g.uint32(26).string(p.recipient);
      for (const J of p.amount)
        r.Coin.encode(J, g.uint32(34).fork()).ldelim();
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = h();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.title = J.string();
            break;
          case 2:
            I.description = J.string();
            break;
          case 3:
            I.recipient = J.string();
            break;
          case 4:
            I.amount.push(r.Coin.decode(J, J.uint32()));
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        title: (0, u.isSet)(p.title) ? String(p.title) : "",
        description: (0, u.isSet)(p.description) ? String(p.description) : "",
        recipient: (0, u.isSet)(p.recipient) ? String(p.recipient) : "",
        amount: Array.isArray(p == null ? void 0 : p.amount) ? p.amount.map((g) => r.Coin.fromJSON(g)) : []
      };
    },
    toJSON(p) {
      const g = {};
      return p.title !== void 0 && (g.title = p.title), p.description !== void 0 && (g.description = p.description), p.recipient !== void 0 && (g.recipient = p.recipient), p.amount ? g.amount = p.amount.map((J) => J ? r.Coin.toJSON(J) : void 0) : g.amount = [], g;
    },
    fromPartial(p) {
      var J;
      const g = h();
      return g.title = p.title ?? "", g.description = p.description ?? "", g.recipient = p.recipient ?? "", g.amount = ((J = p.amount) == null ? void 0 : J.map((B) => r.Coin.fromPartial(B))) || [], g;
    }
  };
  function S() {
    return {
      previousPeriod: u.Long.UZERO,
      stake: "",
      height: u.Long.UZERO
    };
  }
  e.DelegatorStartingInfo = {
    encode(p, g = f.Writer.create()) {
      return p.previousPeriod.isZero() || g.uint32(8).uint64(p.previousPeriod), p.stake !== "" && g.uint32(18).string(p.stake), p.height.isZero() || g.uint32(24).uint64(p.height), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = S();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.previousPeriod = J.uint64();
            break;
          case 2:
            I.stake = J.string();
            break;
          case 3:
            I.height = J.uint64();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        previousPeriod: (0, u.isSet)(p.previousPeriod) ? u.Long.fromValue(p.previousPeriod) : u.Long.UZERO,
        stake: (0, u.isSet)(p.stake) ? String(p.stake) : "",
        height: (0, u.isSet)(p.height) ? u.Long.fromValue(p.height) : u.Long.UZERO
      };
    },
    toJSON(p) {
      const g = {};
      return p.previousPeriod !== void 0 && (g.previousPeriod = (p.previousPeriod || u.Long.UZERO).toString()), p.stake !== void 0 && (g.stake = p.stake), p.height !== void 0 && (g.height = (p.height || u.Long.UZERO).toString()), g;
    },
    fromPartial(p) {
      const g = S();
      return g.previousPeriod = p.previousPeriod !== void 0 && p.previousPeriod !== null ? u.Long.fromValue(p.previousPeriod) : u.Long.UZERO, g.stake = p.stake ?? "", g.height = p.height !== void 0 && p.height !== null ? u.Long.fromValue(p.height) : u.Long.UZERO, g;
    }
  };
  function _() {
    return {
      validatorAddress: "",
      reward: []
    };
  }
  e.DelegationDelegatorReward = {
    encode(p, g = f.Writer.create()) {
      p.validatorAddress !== "" && g.uint32(10).string(p.validatorAddress);
      for (const J of p.reward)
        r.DecCoin.encode(J, g.uint32(18).fork()).ldelim();
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = _();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.validatorAddress = J.string();
            break;
          case 2:
            I.reward.push(r.DecCoin.decode(J, J.uint32()));
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        validatorAddress: (0, u.isSet)(p.validatorAddress) ? String(p.validatorAddress) : "",
        reward: Array.isArray(p == null ? void 0 : p.reward) ? p.reward.map((g) => r.DecCoin.fromJSON(g)) : []
      };
    },
    toJSON(p) {
      const g = {};
      return p.validatorAddress !== void 0 && (g.validatorAddress = p.validatorAddress), p.reward ? g.reward = p.reward.map((J) => J ? r.DecCoin.toJSON(J) : void 0) : g.reward = [], g;
    },
    fromPartial(p) {
      var J;
      const g = _();
      return g.validatorAddress = p.validatorAddress ?? "", g.reward = ((J = p.reward) == null ? void 0 : J.map((B) => r.DecCoin.fromPartial(B))) || [], g;
    }
  };
  function d() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: "",
      deposit: ""
    };
  }
  e.CommunityPoolSpendProposalWithDeposit = {
    encode(p, g = f.Writer.create()) {
      return p.title !== "" && g.uint32(10).string(p.title), p.description !== "" && g.uint32(18).string(p.description), p.recipient !== "" && g.uint32(26).string(p.recipient), p.amount !== "" && g.uint32(34).string(p.amount), p.deposit !== "" && g.uint32(42).string(p.deposit), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = d();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.title = J.string();
            break;
          case 2:
            I.description = J.string();
            break;
          case 3:
            I.recipient = J.string();
            break;
          case 4:
            I.amount = J.string();
            break;
          case 5:
            I.deposit = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        title: (0, u.isSet)(p.title) ? String(p.title) : "",
        description: (0, u.isSet)(p.description) ? String(p.description) : "",
        recipient: (0, u.isSet)(p.recipient) ? String(p.recipient) : "",
        amount: (0, u.isSet)(p.amount) ? String(p.amount) : "",
        deposit: (0, u.isSet)(p.deposit) ? String(p.deposit) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.title !== void 0 && (g.title = p.title), p.description !== void 0 && (g.description = p.description), p.recipient !== void 0 && (g.recipient = p.recipient), p.amount !== void 0 && (g.amount = p.amount), p.deposit !== void 0 && (g.deposit = p.deposit), g;
    },
    fromPartial(p) {
      const g = d();
      return g.title = p.title ?? "", g.description = p.description ?? "", g.recipient = p.recipient ?? "", g.amount = p.amount ?? "", g.deposit = p.deposit ?? "", g;
    }
  };
})(na);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(J, B, I, Z) {
    Z === void 0 && (Z = I);
    var t = Object.getOwnPropertyDescriptor(B, I);
    (!t || ("get" in t ? !B.__esModule : t.writable || t.configurable)) && (t = { enumerable: !0, get: function() {
      return B[I];
    } }), Object.defineProperty(J, Z, t);
  } : function(J, B, I, Z) {
    Z === void 0 && (Z = I), J[Z] = B[I];
  }), c = G && G.__setModuleDefault || (Object.create ? function(J, B) {
    Object.defineProperty(J, "default", { enumerable: !0, value: B });
  } : function(J, B) {
    J.default = B;
  }), i = G && G.__importStar || function(J) {
    if (J && J.__esModule)
      return J;
    var B = {};
    if (J != null)
      for (var I in J)
        I !== "default" && Object.prototype.hasOwnProperty.call(J, I) && n(B, J, I);
    return c(B, J), B;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCommunityPoolSpendResponse = e.MsgCommunityPoolSpend = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgFundCommunityPoolResponse = e.MsgFundCommunityPool = e.MsgWithdrawValidatorCommissionResponse = e.MsgWithdrawValidatorCommission = e.MsgWithdrawDelegatorRewardResponse = e.MsgWithdrawDelegatorReward = e.MsgSetWithdrawAddressResponse = e.MsgSetWithdrawAddress = e.protobufPackage = void 0;
  const r = Me, u = na, f = i(ie), O = oe;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function A() {
    return {
      delegatorAddress: "",
      withdrawAddress: ""
    };
  }
  e.MsgSetWithdrawAddress = {
    encode(J, B = f.Writer.create()) {
      return J.delegatorAddress !== "" && B.uint32(10).string(J.delegatorAddress), J.withdrawAddress !== "" && B.uint32(18).string(J.withdrawAddress), B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = A();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.delegatorAddress = I.string();
            break;
          case 2:
            t.withdrawAddress = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        delegatorAddress: (0, O.isSet)(J.delegatorAddress) ? String(J.delegatorAddress) : "",
        withdrawAddress: (0, O.isSet)(J.withdrawAddress) ? String(J.withdrawAddress) : ""
      };
    },
    toJSON(J) {
      const B = {};
      return J.delegatorAddress !== void 0 && (B.delegatorAddress = J.delegatorAddress), J.withdrawAddress !== void 0 && (B.withdrawAddress = J.withdrawAddress), B;
    },
    fromPartial(J) {
      const B = A();
      return B.delegatorAddress = J.delegatorAddress ?? "", B.withdrawAddress = J.withdrawAddress ?? "", B;
    }
  };
  function T() {
    return {};
  }
  e.MsgSetWithdrawAddressResponse = {
    encode(J, B = f.Writer.create()) {
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = T();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {};
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return T();
    }
  };
  function L() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.MsgWithdrawDelegatorReward = {
    encode(J, B = f.Writer.create()) {
      return J.delegatorAddress !== "" && B.uint32(10).string(J.delegatorAddress), J.validatorAddress !== "" && B.uint32(18).string(J.validatorAddress), B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = L();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.delegatorAddress = I.string();
            break;
          case 2:
            t.validatorAddress = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        delegatorAddress: (0, O.isSet)(J.delegatorAddress) ? String(J.delegatorAddress) : "",
        validatorAddress: (0, O.isSet)(J.validatorAddress) ? String(J.validatorAddress) : ""
      };
    },
    toJSON(J) {
      const B = {};
      return J.delegatorAddress !== void 0 && (B.delegatorAddress = J.delegatorAddress), J.validatorAddress !== void 0 && (B.validatorAddress = J.validatorAddress), B;
    },
    fromPartial(J) {
      const B = L();
      return B.delegatorAddress = J.delegatorAddress ?? "", B.validatorAddress = J.validatorAddress ?? "", B;
    }
  };
  function M() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawDelegatorRewardResponse = {
    encode(J, B = f.Writer.create()) {
      for (const I of J.amount)
        r.Coin.encode(I, B.uint32(10).fork()).ldelim();
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = M();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        amount: Array.isArray(J == null ? void 0 : J.amount) ? J.amount.map((B) => r.Coin.fromJSON(B)) : []
      };
    },
    toJSON(J) {
      const B = {};
      return J.amount ? B.amount = J.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : B.amount = [], B;
    },
    fromPartial(J) {
      var I;
      const B = M();
      return B.amount = ((I = J.amount) == null ? void 0 : I.map((Z) => r.Coin.fromPartial(Z))) || [], B;
    }
  };
  function V() {
    return {
      validatorAddress: ""
    };
  }
  e.MsgWithdrawValidatorCommission = {
    encode(J, B = f.Writer.create()) {
      return J.validatorAddress !== "" && B.uint32(10).string(J.validatorAddress), B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = V();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.validatorAddress = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        validatorAddress: (0, O.isSet)(J.validatorAddress) ? String(J.validatorAddress) : ""
      };
    },
    toJSON(J) {
      const B = {};
      return J.validatorAddress !== void 0 && (B.validatorAddress = J.validatorAddress), B;
    },
    fromPartial(J) {
      const B = V();
      return B.validatorAddress = J.validatorAddress ?? "", B;
    }
  };
  function D() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawValidatorCommissionResponse = {
    encode(J, B = f.Writer.create()) {
      for (const I of J.amount)
        r.Coin.encode(I, B.uint32(10).fork()).ldelim();
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = D();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        amount: Array.isArray(J == null ? void 0 : J.amount) ? J.amount.map((B) => r.Coin.fromJSON(B)) : []
      };
    },
    toJSON(J) {
      const B = {};
      return J.amount ? B.amount = J.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : B.amount = [], B;
    },
    fromPartial(J) {
      var I;
      const B = D();
      return B.amount = ((I = J.amount) == null ? void 0 : I.map((Z) => r.Coin.fromPartial(Z))) || [], B;
    }
  };
  function b() {
    return {
      amount: [],
      depositor: ""
    };
  }
  e.MsgFundCommunityPool = {
    encode(J, B = f.Writer.create()) {
      for (const I of J.amount)
        r.Coin.encode(I, B.uint32(10).fork()).ldelim();
      return J.depositor !== "" && B.uint32(18).string(J.depositor), B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = b();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          case 2:
            t.depositor = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        amount: Array.isArray(J == null ? void 0 : J.amount) ? J.amount.map((B) => r.Coin.fromJSON(B)) : [],
        depositor: (0, O.isSet)(J.depositor) ? String(J.depositor) : ""
      };
    },
    toJSON(J) {
      const B = {};
      return J.amount ? B.amount = J.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : B.amount = [], J.depositor !== void 0 && (B.depositor = J.depositor), B;
    },
    fromPartial(J) {
      var I;
      const B = b();
      return B.amount = ((I = J.amount) == null ? void 0 : I.map((Z) => r.Coin.fromPartial(Z))) || [], B.depositor = J.depositor ?? "", B;
    }
  };
  function h() {
    return {};
  }
  e.MsgFundCommunityPoolResponse = {
    encode(J, B = f.Writer.create()) {
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = h();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {};
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return h();
    }
  };
  function S() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(J, B = f.Writer.create()) {
      return J.authority !== "" && B.uint32(10).string(J.authority), J.params !== void 0 && u.Params.encode(J.params, B.uint32(18).fork()).ldelim(), B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = S();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.authority = I.string();
            break;
          case 2:
            t.params = u.Params.decode(I, I.uint32());
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        authority: (0, O.isSet)(J.authority) ? String(J.authority) : "",
        params: (0, O.isSet)(J.params) ? u.Params.fromJSON(J.params) : void 0
      };
    },
    toJSON(J) {
      const B = {};
      return J.authority !== void 0 && (B.authority = J.authority), J.params !== void 0 && (B.params = J.params ? u.Params.toJSON(J.params) : void 0), B;
    },
    fromPartial(J) {
      const B = S();
      return B.authority = J.authority ?? "", B.params = J.params !== void 0 && J.params !== null ? u.Params.fromPartial(J.params) : void 0, B;
    }
  };
  function _() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(J, B = f.Writer.create()) {
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = _();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {};
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return _();
    }
  };
  function d() {
    return {
      authority: "",
      recipient: "",
      amount: []
    };
  }
  e.MsgCommunityPoolSpend = {
    encode(J, B = f.Writer.create()) {
      J.authority !== "" && B.uint32(10).string(J.authority), J.recipient !== "" && B.uint32(18).string(J.recipient);
      for (const I of J.amount)
        r.Coin.encode(I, B.uint32(26).fork()).ldelim();
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = d();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            t.authority = I.string();
            break;
          case 2:
            t.recipient = I.string();
            break;
          case 3:
            t.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {
        authority: (0, O.isSet)(J.authority) ? String(J.authority) : "",
        recipient: (0, O.isSet)(J.recipient) ? String(J.recipient) : "",
        amount: Array.isArray(J == null ? void 0 : J.amount) ? J.amount.map((B) => r.Coin.fromJSON(B)) : []
      };
    },
    toJSON(J) {
      const B = {};
      return J.authority !== void 0 && (B.authority = J.authority), J.recipient !== void 0 && (B.recipient = J.recipient), J.amount ? B.amount = J.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : B.amount = [], B;
    },
    fromPartial(J) {
      var I;
      const B = d();
      return B.authority = J.authority ?? "", B.recipient = J.recipient ?? "", B.amount = ((I = J.amount) == null ? void 0 : I.map((Z) => r.Coin.fromPartial(Z))) || [], B;
    }
  };
  function p() {
    return {};
  }
  e.MsgCommunityPoolSpendResponse = {
    encode(J, B = f.Writer.create()) {
      return B;
    },
    decode(J, B) {
      const I = J instanceof f.Reader ? J : new f.Reader(J);
      let Z = B === void 0 ? I.len : I.pos + B;
      const t = p();
      for (; I.pos < Z; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return t;
    },
    fromJSON(J) {
      return {};
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return p();
    }
  };
  class g {
    constructor(B) {
      this.rpc = B, this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this), this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this), this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this), this.FundCommunityPool = this.FundCommunityPool.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
    }
    SetWithdrawAddress(B) {
      const I = e.MsgSetWithdrawAddress.encode(B).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", I).then((t) => e.MsgSetWithdrawAddressResponse.decode(new f.Reader(t)));
    }
    WithdrawDelegatorReward(B) {
      const I = e.MsgWithdrawDelegatorReward.encode(B).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", I).then((t) => e.MsgWithdrawDelegatorRewardResponse.decode(new f.Reader(t)));
    }
    WithdrawValidatorCommission(B) {
      const I = e.MsgWithdrawValidatorCommission.encode(B).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", I).then((t) => e.MsgWithdrawValidatorCommissionResponse.decode(new f.Reader(t)));
    }
    FundCommunityPool(B) {
      const I = e.MsgFundCommunityPool.encode(B).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", I).then((t) => e.MsgFundCommunityPoolResponse.decode(new f.Reader(t)));
    }
    UpdateParams(B) {
      const I = e.MsgUpdateParams.encode(B).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", I).then((t) => e.MsgUpdateParamsResponse.decode(new f.Reader(t)));
    }
    CommunityPoolSpend(B) {
      const I = e.MsgCommunityPoolSpend.encode(B).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", I).then((t) => e.MsgCommunityPoolSpendResponse.decode(new f.Reader(t)));
    }
  }
  e.MsgClientImpl = g;
})(ea);
Object.defineProperty(Et, "__esModule", { value: !0 });
Et.isMsgWithdrawDelegatorRewardEncodeObject = Et.distributionTypes = void 0;
const hr = ea;
Et.distributionTypes = [
  ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", hr.MsgFundCommunityPool],
  ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", hr.MsgSetWithdrawAddress],
  ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", hr.MsgWithdrawDelegatorReward],
  ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", hr.MsgWithdrawValidatorCommission]
];
function jp(e) {
  return e.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}
Et.isMsgWithdrawDelegatorRewardEncodeObject = jp;
var ni = {}, mu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(l, C, v, k) {
    k === void 0 && (k = v);
    var U = Object.getOwnPropertyDescriptor(C, v);
    (!U || ("get" in U ? !C.__esModule : U.writable || U.configurable)) && (U = { enumerable: !0, get: function() {
      return C[v];
    } }), Object.defineProperty(l, k, U);
  } : function(l, C, v, k) {
    k === void 0 && (k = v), l[k] = C[v];
  }), c = G && G.__setModuleDefault || (Object.create ? function(l, C) {
    Object.defineProperty(l, "default", { enumerable: !0, value: C });
  } : function(l, C) {
    l.default = C;
  }), i = G && G.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var C = {};
    if (l != null)
      for (var v in l)
        v !== "default" && Object.prototype.hasOwnProperty.call(l, v) && n(C, l, v);
    return c(C, l), C;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryCommunityPoolResponse = e.QueryCommunityPoolRequest = e.QueryDelegatorWithdrawAddressResponse = e.QueryDelegatorWithdrawAddressRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryDelegationTotalRewardsResponse = e.QueryDelegationTotalRewardsRequest = e.QueryDelegationRewardsResponse = e.QueryDelegationRewardsRequest = e.QueryValidatorSlashesResponse = e.QueryValidatorSlashesRequest = e.QueryValidatorCommissionResponse = e.QueryValidatorCommissionRequest = e.QueryValidatorOutstandingRewardsResponse = e.QueryValidatorOutstandingRewardsRequest = e.QueryValidatorDistributionInfoResponse = e.QueryValidatorDistributionInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const r = Re, u = na, f = Me, O = oe, A = i(ie);
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function T() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(l, C = A.Writer.create()) {
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = T();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return T();
    }
  };
  function L() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(l, C = A.Writer.create()) {
      return l.params !== void 0 && u.Params.encode(l.params, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = L();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.params = u.Params.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        params: (0, O.isSet)(l.params) ? u.Params.fromJSON(l.params) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.params !== void 0 && (C.params = l.params ? u.Params.toJSON(l.params) : void 0), C;
    },
    fromPartial(l) {
      const C = L();
      return C.params = l.params !== void 0 && l.params !== null ? u.Params.fromPartial(l.params) : void 0, C;
    }
  };
  function M() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorDistributionInfoRequest = {
    encode(l, C = A.Writer.create()) {
      return l.validatorAddress !== "" && C.uint32(10).string(l.validatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = M();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.validatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        validatorAddress: (0, O.isSet)(l.validatorAddress) ? String(l.validatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.validatorAddress !== void 0 && (C.validatorAddress = l.validatorAddress), C;
    },
    fromPartial(l) {
      const C = M();
      return C.validatorAddress = l.validatorAddress ?? "", C;
    }
  };
  function V() {
    return {
      operatorAddress: "",
      selfBondRewards: [],
      commission: []
    };
  }
  e.QueryValidatorDistributionInfoResponse = {
    encode(l, C = A.Writer.create()) {
      l.operatorAddress !== "" && C.uint32(10).string(l.operatorAddress);
      for (const v of l.selfBondRewards)
        f.DecCoin.encode(v, C.uint32(18).fork()).ldelim();
      for (const v of l.commission)
        f.DecCoin.encode(v, C.uint32(26).fork()).ldelim();
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = V();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.operatorAddress = v.string();
            break;
          case 2:
            U.selfBondRewards.push(f.DecCoin.decode(v, v.uint32()));
            break;
          case 3:
            U.commission.push(f.DecCoin.decode(v, v.uint32()));
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        operatorAddress: (0, O.isSet)(l.operatorAddress) ? String(l.operatorAddress) : "",
        selfBondRewards: Array.isArray(l == null ? void 0 : l.selfBondRewards) ? l.selfBondRewards.map((C) => f.DecCoin.fromJSON(C)) : [],
        commission: Array.isArray(l == null ? void 0 : l.commission) ? l.commission.map((C) => f.DecCoin.fromJSON(C)) : []
      };
    },
    toJSON(l) {
      const C = {};
      return l.operatorAddress !== void 0 && (C.operatorAddress = l.operatorAddress), l.selfBondRewards ? C.selfBondRewards = l.selfBondRewards.map((v) => v ? f.DecCoin.toJSON(v) : void 0) : C.selfBondRewards = [], l.commission ? C.commission = l.commission.map((v) => v ? f.DecCoin.toJSON(v) : void 0) : C.commission = [], C;
    },
    fromPartial(l) {
      var v, k;
      const C = V();
      return C.operatorAddress = l.operatorAddress ?? "", C.selfBondRewards = ((v = l.selfBondRewards) == null ? void 0 : v.map((U) => f.DecCoin.fromPartial(U))) || [], C.commission = ((k = l.commission) == null ? void 0 : k.map((U) => f.DecCoin.fromPartial(U))) || [], C;
    }
  };
  function D() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorOutstandingRewardsRequest = {
    encode(l, C = A.Writer.create()) {
      return l.validatorAddress !== "" && C.uint32(10).string(l.validatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = D();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.validatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        validatorAddress: (0, O.isSet)(l.validatorAddress) ? String(l.validatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.validatorAddress !== void 0 && (C.validatorAddress = l.validatorAddress), C;
    },
    fromPartial(l) {
      const C = D();
      return C.validatorAddress = l.validatorAddress ?? "", C;
    }
  };
  function b() {
    return {
      rewards: void 0
    };
  }
  e.QueryValidatorOutstandingRewardsResponse = {
    encode(l, C = A.Writer.create()) {
      return l.rewards !== void 0 && u.ValidatorOutstandingRewards.encode(l.rewards, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = b();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.rewards = u.ValidatorOutstandingRewards.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        rewards: (0, O.isSet)(l.rewards) ? u.ValidatorOutstandingRewards.fromJSON(l.rewards) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.rewards !== void 0 && (C.rewards = l.rewards ? u.ValidatorOutstandingRewards.toJSON(l.rewards) : void 0), C;
    },
    fromPartial(l) {
      const C = b();
      return C.rewards = l.rewards !== void 0 && l.rewards !== null ? u.ValidatorOutstandingRewards.fromPartial(l.rewards) : void 0, C;
    }
  };
  function h() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorCommissionRequest = {
    encode(l, C = A.Writer.create()) {
      return l.validatorAddress !== "" && C.uint32(10).string(l.validatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = h();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.validatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        validatorAddress: (0, O.isSet)(l.validatorAddress) ? String(l.validatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.validatorAddress !== void 0 && (C.validatorAddress = l.validatorAddress), C;
    },
    fromPartial(l) {
      const C = h();
      return C.validatorAddress = l.validatorAddress ?? "", C;
    }
  };
  function S() {
    return {
      commission: void 0
    };
  }
  e.QueryValidatorCommissionResponse = {
    encode(l, C = A.Writer.create()) {
      return l.commission !== void 0 && u.ValidatorAccumulatedCommission.encode(l.commission, C.uint32(10).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = S();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.commission = u.ValidatorAccumulatedCommission.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        commission: (0, O.isSet)(l.commission) ? u.ValidatorAccumulatedCommission.fromJSON(l.commission) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.commission !== void 0 && (C.commission = l.commission ? u.ValidatorAccumulatedCommission.toJSON(l.commission) : void 0), C;
    },
    fromPartial(l) {
      const C = S();
      return C.commission = l.commission !== void 0 && l.commission !== null ? u.ValidatorAccumulatedCommission.fromPartial(l.commission) : void 0, C;
    }
  };
  function _() {
    return {
      validatorAddress: "",
      startingHeight: O.Long.UZERO,
      endingHeight: O.Long.UZERO,
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesRequest = {
    encode(l, C = A.Writer.create()) {
      return l.validatorAddress !== "" && C.uint32(10).string(l.validatorAddress), l.startingHeight.isZero() || C.uint32(16).uint64(l.startingHeight), l.endingHeight.isZero() || C.uint32(24).uint64(l.endingHeight), l.pagination !== void 0 && r.PageRequest.encode(l.pagination, C.uint32(34).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = _();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.validatorAddress = v.string();
            break;
          case 2:
            U.startingHeight = v.uint64();
            break;
          case 3:
            U.endingHeight = v.uint64();
            break;
          case 4:
            U.pagination = r.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        validatorAddress: (0, O.isSet)(l.validatorAddress) ? String(l.validatorAddress) : "",
        startingHeight: (0, O.isSet)(l.startingHeight) ? O.Long.fromValue(l.startingHeight) : O.Long.UZERO,
        endingHeight: (0, O.isSet)(l.endingHeight) ? O.Long.fromValue(l.endingHeight) : O.Long.UZERO,
        pagination: (0, O.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.validatorAddress !== void 0 && (C.validatorAddress = l.validatorAddress), l.startingHeight !== void 0 && (C.startingHeight = (l.startingHeight || O.Long.UZERO).toString()), l.endingHeight !== void 0 && (C.endingHeight = (l.endingHeight || O.Long.UZERO).toString()), l.pagination !== void 0 && (C.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), C;
    },
    fromPartial(l) {
      const C = _();
      return C.validatorAddress = l.validatorAddress ?? "", C.startingHeight = l.startingHeight !== void 0 && l.startingHeight !== null ? O.Long.fromValue(l.startingHeight) : O.Long.UZERO, C.endingHeight = l.endingHeight !== void 0 && l.endingHeight !== null ? O.Long.fromValue(l.endingHeight) : O.Long.UZERO, C.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, C;
    }
  };
  function d() {
    return {
      slashes: [],
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.slashes)
        u.ValidatorSlashEvent.encode(v, C.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, C.uint32(18).fork()).ldelim(), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = d();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.slashes.push(u.ValidatorSlashEvent.decode(v, v.uint32()));
            break;
          case 2:
            U.pagination = r.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        slashes: Array.isArray(l == null ? void 0 : l.slashes) ? l.slashes.map((C) => u.ValidatorSlashEvent.fromJSON(C)) : [],
        pagination: (0, O.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const C = {};
      return l.slashes ? C.slashes = l.slashes.map((v) => v ? u.ValidatorSlashEvent.toJSON(v) : void 0) : C.slashes = [], l.pagination !== void 0 && (C.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), C;
    },
    fromPartial(l) {
      var v;
      const C = d();
      return C.slashes = ((v = l.slashes) == null ? void 0 : v.map((k) => u.ValidatorSlashEvent.fromPartial(k))) || [], C.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, C;
    }
  };
  function p() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.QueryDelegationRewardsRequest = {
    encode(l, C = A.Writer.create()) {
      return l.delegatorAddress !== "" && C.uint32(10).string(l.delegatorAddress), l.validatorAddress !== "" && C.uint32(18).string(l.validatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = p();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.delegatorAddress = v.string();
            break;
          case 2:
            U.validatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        delegatorAddress: (0, O.isSet)(l.delegatorAddress) ? String(l.delegatorAddress) : "",
        validatorAddress: (0, O.isSet)(l.validatorAddress) ? String(l.validatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.delegatorAddress !== void 0 && (C.delegatorAddress = l.delegatorAddress), l.validatorAddress !== void 0 && (C.validatorAddress = l.validatorAddress), C;
    },
    fromPartial(l) {
      const C = p();
      return C.delegatorAddress = l.delegatorAddress ?? "", C.validatorAddress = l.validatorAddress ?? "", C;
    }
  };
  function g() {
    return {
      rewards: []
    };
  }
  e.QueryDelegationRewardsResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.rewards)
        f.DecCoin.encode(v, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = g();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.rewards.push(f.DecCoin.decode(v, v.uint32()));
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        rewards: Array.isArray(l == null ? void 0 : l.rewards) ? l.rewards.map((C) => f.DecCoin.fromJSON(C)) : []
      };
    },
    toJSON(l) {
      const C = {};
      return l.rewards ? C.rewards = l.rewards.map((v) => v ? f.DecCoin.toJSON(v) : void 0) : C.rewards = [], C;
    },
    fromPartial(l) {
      var v;
      const C = g();
      return C.rewards = ((v = l.rewards) == null ? void 0 : v.map((k) => f.DecCoin.fromPartial(k))) || [], C;
    }
  };
  function J() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegationTotalRewardsRequest = {
    encode(l, C = A.Writer.create()) {
      return l.delegatorAddress !== "" && C.uint32(10).string(l.delegatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = J();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.delegatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        delegatorAddress: (0, O.isSet)(l.delegatorAddress) ? String(l.delegatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.delegatorAddress !== void 0 && (C.delegatorAddress = l.delegatorAddress), C;
    },
    fromPartial(l) {
      const C = J();
      return C.delegatorAddress = l.delegatorAddress ?? "", C;
    }
  };
  function B() {
    return {
      rewards: [],
      total: []
    };
  }
  e.QueryDelegationTotalRewardsResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.rewards)
        u.DelegationDelegatorReward.encode(v, C.uint32(10).fork()).ldelim();
      for (const v of l.total)
        f.DecCoin.encode(v, C.uint32(18).fork()).ldelim();
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = B();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.rewards.push(u.DelegationDelegatorReward.decode(v, v.uint32()));
            break;
          case 2:
            U.total.push(f.DecCoin.decode(v, v.uint32()));
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        rewards: Array.isArray(l == null ? void 0 : l.rewards) ? l.rewards.map((C) => u.DelegationDelegatorReward.fromJSON(C)) : [],
        total: Array.isArray(l == null ? void 0 : l.total) ? l.total.map((C) => f.DecCoin.fromJSON(C)) : []
      };
    },
    toJSON(l) {
      const C = {};
      return l.rewards ? C.rewards = l.rewards.map((v) => v ? u.DelegationDelegatorReward.toJSON(v) : void 0) : C.rewards = [], l.total ? C.total = l.total.map((v) => v ? f.DecCoin.toJSON(v) : void 0) : C.total = [], C;
    },
    fromPartial(l) {
      var v, k;
      const C = B();
      return C.rewards = ((v = l.rewards) == null ? void 0 : v.map((U) => u.DelegationDelegatorReward.fromPartial(U))) || [], C.total = ((k = l.total) == null ? void 0 : k.map((U) => f.DecCoin.fromPartial(U))) || [], C;
    }
  };
  function I() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    encode(l, C = A.Writer.create()) {
      return l.delegatorAddress !== "" && C.uint32(10).string(l.delegatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = I();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.delegatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        delegatorAddress: (0, O.isSet)(l.delegatorAddress) ? String(l.delegatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.delegatorAddress !== void 0 && (C.delegatorAddress = l.delegatorAddress), C;
    },
    fromPartial(l) {
      const C = I();
      return C.delegatorAddress = l.delegatorAddress ?? "", C;
    }
  };
  function Z() {
    return {
      validators: []
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.validators)
        C.uint32(10).string(v);
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = Z();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.validators.push(v.string());
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        validators: Array.isArray(l == null ? void 0 : l.validators) ? l.validators.map((C) => String(C)) : []
      };
    },
    toJSON(l) {
      const C = {};
      return l.validators ? C.validators = l.validators.map((v) => v) : C.validators = [], C;
    },
    fromPartial(l) {
      var v;
      const C = Z();
      return C.validators = ((v = l.validators) == null ? void 0 : v.map((k) => k)) || [], C;
    }
  };
  function t() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressRequest = {
    encode(l, C = A.Writer.create()) {
      return l.delegatorAddress !== "" && C.uint32(10).string(l.delegatorAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = t();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.delegatorAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        delegatorAddress: (0, O.isSet)(l.delegatorAddress) ? String(l.delegatorAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.delegatorAddress !== void 0 && (C.delegatorAddress = l.delegatorAddress), C;
    },
    fromPartial(l) {
      const C = t();
      return C.delegatorAddress = l.delegatorAddress ?? "", C;
    }
  };
  function y() {
    return {
      withdrawAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressResponse = {
    encode(l, C = A.Writer.create()) {
      return l.withdrawAddress !== "" && C.uint32(10).string(l.withdrawAddress), C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = y();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.withdrawAddress = v.string();
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        withdrawAddress: (0, O.isSet)(l.withdrawAddress) ? String(l.withdrawAddress) : ""
      };
    },
    toJSON(l) {
      const C = {};
      return l.withdrawAddress !== void 0 && (C.withdrawAddress = l.withdrawAddress), C;
    },
    fromPartial(l) {
      const C = y();
      return C.withdrawAddress = l.withdrawAddress ?? "", C;
    }
  };
  function E() {
    return {};
  }
  e.QueryCommunityPoolRequest = {
    encode(l, C = A.Writer.create()) {
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = E();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return E();
    }
  };
  function H() {
    return {
      pool: []
    };
  }
  e.QueryCommunityPoolResponse = {
    encode(l, C = A.Writer.create()) {
      for (const v of l.pool)
        f.DecCoin.encode(v, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(l, C) {
      const v = l instanceof A.Reader ? l : new A.Reader(l);
      let k = C === void 0 ? v.len : v.pos + C;
      const U = H();
      for (; v.pos < k; ) {
        const F = v.uint32();
        switch (F >>> 3) {
          case 1:
            U.pool.push(f.DecCoin.decode(v, v.uint32()));
            break;
          default:
            v.skipType(F & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(l) {
      return {
        pool: Array.isArray(l == null ? void 0 : l.pool) ? l.pool.map((C) => f.DecCoin.fromJSON(C)) : []
      };
    },
    toJSON(l) {
      const C = {};
      return l.pool ? C.pool = l.pool.map((v) => v ? f.DecCoin.toJSON(v) : void 0) : C.pool = [], C;
    },
    fromPartial(l) {
      var v;
      const C = H();
      return C.pool = ((v = l.pool) == null ? void 0 : v.map((k) => f.DecCoin.fromPartial(k))) || [], C;
    }
  };
  class a {
    constructor(C) {
      this.rpc = C, this.Params = this.Params.bind(this), this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this), this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this), this.ValidatorCommission = this.ValidatorCommission.bind(this), this.ValidatorSlashes = this.ValidatorSlashes.bind(this), this.DelegationRewards = this.DelegationRewards.bind(this), this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this), this.CommunityPool = this.CommunityPool.bind(this);
    }
    Params(C = {}) {
      const v = e.QueryParamsRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", v).then((U) => e.QueryParamsResponse.decode(new A.Reader(U)));
    }
    ValidatorDistributionInfo(C) {
      const v = e.QueryValidatorDistributionInfoRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", v).then((U) => e.QueryValidatorDistributionInfoResponse.decode(new A.Reader(U)));
    }
    ValidatorOutstandingRewards(C) {
      const v = e.QueryValidatorOutstandingRewardsRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", v).then((U) => e.QueryValidatorOutstandingRewardsResponse.decode(new A.Reader(U)));
    }
    ValidatorCommission(C) {
      const v = e.QueryValidatorCommissionRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", v).then((U) => e.QueryValidatorCommissionResponse.decode(new A.Reader(U)));
    }
    ValidatorSlashes(C) {
      const v = e.QueryValidatorSlashesRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", v).then((U) => e.QueryValidatorSlashesResponse.decode(new A.Reader(U)));
    }
    DelegationRewards(C) {
      const v = e.QueryDelegationRewardsRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", v).then((U) => e.QueryDelegationRewardsResponse.decode(new A.Reader(U)));
    }
    DelegationTotalRewards(C) {
      const v = e.QueryDelegationTotalRewardsRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", v).then((U) => e.QueryDelegationTotalRewardsResponse.decode(new A.Reader(U)));
    }
    DelegatorValidators(C) {
      const v = e.QueryDelegatorValidatorsRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", v).then((U) => e.QueryDelegatorValidatorsResponse.decode(new A.Reader(U)));
    }
    DelegatorWithdrawAddress(C) {
      const v = e.QueryDelegatorWithdrawAddressRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", v).then((U) => e.QueryDelegatorWithdrawAddressResponse.decode(new A.Reader(U)));
    }
    CommunityPool(C = {}) {
      const v = e.QueryCommunityPoolRequest.encode(C).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", v).then((U) => e.QueryCommunityPoolResponse.decode(new A.Reader(U)));
    }
  }
  e.QueryClientImpl = a;
})(mu);
var eh = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.setupDistributionExtension = void 0;
const nh = mu, Es = eh(An), Cs = Le;
function th(e) {
  const n = (0, Cs.createProtobufRpcClient)(e), c = new nh.QueryClientImpl(n);
  return {
    distribution: {
      communityPool: async () => await c.CommunityPool({}),
      delegationRewards: async (i, r) => await c.DelegationRewards({
        delegatorAddress: i,
        validatorAddress: r
      }),
      delegationTotalRewards: async (i) => await c.DelegationTotalRewards({
        delegatorAddress: i
      }),
      delegatorValidators: async (i) => await c.DelegatorValidators({
        delegatorAddress: i
      }),
      delegatorWithdrawAddress: async (i) => await c.DelegatorWithdrawAddress({
        delegatorAddress: i
      }),
      params: async () => await c.Params({}),
      validatorCommission: async (i) => await c.ValidatorCommission({
        validatorAddress: i
      }),
      validatorOutstandingRewards: async (i) => await c.ValidatorOutstandingRewards({
        validatorAddress: i
      }),
      validatorSlashes: async (i, r, u, f) => await c.ValidatorSlashes({
        validatorAddress: i,
        startingHeight: Es.default.fromNumber(r, !0),
        endingHeight: Es.default.fromNumber(u, !0),
        pagination: (0, Cs.createPagination)(f)
      })
    }
  };
}
ni.setupDistributionExtension = th;
var Ct = {};
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.createEvidenceAminoConverters = Ct.isAminoMsgSubmitEvidence = void 0;
function rh(e) {
  return e.type === "cosmos-sdk/MsgSubmitEvidence";
}
Ct.isAminoMsgSubmitEvidence = rh;
function ih() {
  throw new Error("Not implemented");
}
Ct.createEvidenceAminoConverters = ih;
var ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.createFeegrantAminoConverters = void 0;
function oh() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
    // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
  };
}
ti.createFeegrantAminoConverters = oh;
var ri = {}, gu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(V, D, b, h) {
    h === void 0 && (h = b);
    var S = Object.getOwnPropertyDescriptor(D, b);
    (!S || ("get" in S ? !D.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return D[b];
    } }), Object.defineProperty(V, h, S);
  } : function(V, D, b, h) {
    h === void 0 && (h = b), V[h] = D[b];
  }), c = G && G.__setModuleDefault || (Object.create ? function(V, D) {
    Object.defineProperty(V, "default", { enumerable: !0, value: D });
  } : function(V, D) {
    V.default = D;
  }), i = G && G.__importStar || function(V) {
    if (V && V.__esModule)
      return V;
    var D = {};
    if (V != null)
      for (var b in V)
        b !== "default" && Object.prototype.hasOwnProperty.call(V, b) && n(D, V, b);
    return c(D, V), D;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeAllowanceResponse = e.MsgRevokeAllowance = e.MsgGrantAllowanceResponse = e.MsgGrantAllowance = e.protobufPackage = void 0;
  const r = Se, u = i(ie), f = oe;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function O() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.MsgGrantAllowance = {
    encode(V, D = u.Writer.create()) {
      return V.granter !== "" && D.uint32(10).string(V.granter), V.grantee !== "" && D.uint32(18).string(V.grantee), V.allowance !== void 0 && r.Any.encode(V.allowance, D.uint32(26).fork()).ldelim(), D;
    },
    decode(V, D) {
      const b = V instanceof u.Reader ? V : new u.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = O();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          case 1:
            S.granter = b.string();
            break;
          case 2:
            S.grantee = b.string();
            break;
          case 3:
            S.allowance = r.Any.decode(b, b.uint32());
            break;
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {
        granter: (0, f.isSet)(V.granter) ? String(V.granter) : "",
        grantee: (0, f.isSet)(V.grantee) ? String(V.grantee) : "",
        allowance: (0, f.isSet)(V.allowance) ? r.Any.fromJSON(V.allowance) : void 0
      };
    },
    toJSON(V) {
      const D = {};
      return V.granter !== void 0 && (D.granter = V.granter), V.grantee !== void 0 && (D.grantee = V.grantee), V.allowance !== void 0 && (D.allowance = V.allowance ? r.Any.toJSON(V.allowance) : void 0), D;
    },
    fromPartial(V) {
      const D = O();
      return D.granter = V.granter ?? "", D.grantee = V.grantee ?? "", D.allowance = V.allowance !== void 0 && V.allowance !== null ? r.Any.fromPartial(V.allowance) : void 0, D;
    }
  };
  function A() {
    return {};
  }
  e.MsgGrantAllowanceResponse = {
    encode(V, D = u.Writer.create()) {
      return D;
    },
    decode(V, D) {
      const b = V instanceof u.Reader ? V : new u.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = A();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {};
    },
    toJSON(V) {
      return {};
    },
    fromPartial(V) {
      return A();
    }
  };
  function T() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.MsgRevokeAllowance = {
    encode(V, D = u.Writer.create()) {
      return V.granter !== "" && D.uint32(10).string(V.granter), V.grantee !== "" && D.uint32(18).string(V.grantee), D;
    },
    decode(V, D) {
      const b = V instanceof u.Reader ? V : new u.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = T();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          case 1:
            S.granter = b.string();
            break;
          case 2:
            S.grantee = b.string();
            break;
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {
        granter: (0, f.isSet)(V.granter) ? String(V.granter) : "",
        grantee: (0, f.isSet)(V.grantee) ? String(V.grantee) : ""
      };
    },
    toJSON(V) {
      const D = {};
      return V.granter !== void 0 && (D.granter = V.granter), V.grantee !== void 0 && (D.grantee = V.grantee), D;
    },
    fromPartial(V) {
      const D = T();
      return D.granter = V.granter ?? "", D.grantee = V.grantee ?? "", D;
    }
  };
  function L() {
    return {};
  }
  e.MsgRevokeAllowanceResponse = {
    encode(V, D = u.Writer.create()) {
      return D;
    },
    decode(V, D) {
      const b = V instanceof u.Reader ? V : new u.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = L();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {};
    },
    toJSON(V) {
      return {};
    },
    fromPartial(V) {
      return L();
    }
  };
  class M {
    constructor(D) {
      this.rpc = D, this.GrantAllowance = this.GrantAllowance.bind(this), this.RevokeAllowance = this.RevokeAllowance.bind(this);
    }
    GrantAllowance(D) {
      const b = e.MsgGrantAllowance.encode(D).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", b).then((S) => e.MsgGrantAllowanceResponse.decode(new u.Reader(S)));
    }
    RevokeAllowance(D) {
      const b = e.MsgRevokeAllowance.encode(D).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", b).then((S) => e.MsgRevokeAllowanceResponse.decode(new u.Reader(S)));
    }
  }
  e.MsgClientImpl = M;
})(gu);
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.feegrantTypes = void 0;
const Is = gu;
ri.feegrantTypes = [
  ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", Is.MsgGrantAllowance],
  ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", Is.MsgRevokeAllowance]
];
var ii = {}, yu = {}, Su = {}, en = {}, ah = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), sh = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), dh = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && ah(n, e, c);
  return sh(n, e), n;
};
Object.defineProperty(en, "__esModule", { value: !0 });
en.Duration = en.protobufPackage = void 0;
const Dn = oe, xi = dh(ie);
en.protobufPackage = "google.protobuf";
function ws() {
  return {
    seconds: Dn.Long.ZERO,
    nanos: 0
  };
}
en.Duration = {
  encode(e, n = xi.Writer.create()) {
    return e.seconds.isZero() || n.uint32(8).int64(e.seconds), e.nanos !== 0 && n.uint32(16).int32(e.nanos), n;
  },
  decode(e, n) {
    const c = e instanceof xi.Reader ? e : new xi.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = ws();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.seconds = c.int64();
          break;
        case 2:
          r.nanos = c.int32();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      seconds: (0, Dn.isSet)(e.seconds) ? Dn.Long.fromValue(e.seconds) : Dn.Long.ZERO,
      nanos: (0, Dn.isSet)(e.nanos) ? Number(e.nanos) : 0
    };
  },
  toJSON(e) {
    const n = {};
    return e.seconds !== void 0 && (n.seconds = (e.seconds || Dn.Long.ZERO).toString()), e.nanos !== void 0 && (n.nanos = Math.round(e.nanos)), n;
  },
  fromPartial(e) {
    const n = ws();
    return n.seconds = e.seconds !== void 0 && e.seconds !== null ? Dn.Long.fromValue(e.seconds) : Dn.Long.ZERO, n.nanos = e.nanos ?? 0, n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(b, h, S, _) {
    _ === void 0 && (_ = S);
    var d = Object.getOwnPropertyDescriptor(h, S);
    (!d || ("get" in d ? !h.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return h[S];
    } }), Object.defineProperty(b, _, d);
  } : function(b, h, S, _) {
    _ === void 0 && (_ = S), b[_] = h[S];
  }), c = G && G.__setModuleDefault || (Object.create ? function(b, h) {
    Object.defineProperty(b, "default", { enumerable: !0, value: h });
  } : function(b, h) {
    b.default = h;
  }), i = G && G.__importStar || function(b) {
    if (b && b.__esModule)
      return b;
    var h = {};
    if (b != null)
      for (var S in b)
        S !== "default" && Object.prototype.hasOwnProperty.call(b, S) && n(h, b, S);
    return c(h, b), h;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Grant = e.AllowedMsgAllowance = e.PeriodicAllowance = e.BasicAllowance = e.protobufPackage = void 0;
  const r = Me, u = _e, f = en, O = Se, A = i(ie), T = oe;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function L() {
    return {
      spendLimit: [],
      expiration: void 0
    };
  }
  e.BasicAllowance = {
    encode(b, h = A.Writer.create()) {
      for (const S of b.spendLimit)
        r.Coin.encode(S, h.uint32(10).fork()).ldelim();
      return b.expiration !== void 0 && u.Timestamp.encode(b.expiration, h.uint32(18).fork()).ldelim(), h;
    },
    decode(b, h) {
      const S = b instanceof A.Reader ? b : new A.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = L();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.spendLimit.push(r.Coin.decode(S, S.uint32()));
            break;
          case 2:
            d.expiration = u.Timestamp.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        spendLimit: Array.isArray(b == null ? void 0 : b.spendLimit) ? b.spendLimit.map((h) => r.Coin.fromJSON(h)) : [],
        expiration: (0, T.isSet)(b.expiration) ? (0, T.fromJsonTimestamp)(b.expiration) : void 0
      };
    },
    toJSON(b) {
      const h = {};
      return b.spendLimit ? h.spendLimit = b.spendLimit.map((S) => S ? r.Coin.toJSON(S) : void 0) : h.spendLimit = [], b.expiration !== void 0 && (h.expiration = (0, T.fromTimestamp)(b.expiration).toISOString()), h;
    },
    fromPartial(b) {
      var S;
      const h = L();
      return h.spendLimit = ((S = b.spendLimit) == null ? void 0 : S.map((_) => r.Coin.fromPartial(_))) || [], h.expiration = b.expiration !== void 0 && b.expiration !== null ? u.Timestamp.fromPartial(b.expiration) : void 0, h;
    }
  };
  function M() {
    return {
      basic: void 0,
      period: void 0,
      periodSpendLimit: [],
      periodCanSpend: [],
      periodReset: void 0
    };
  }
  e.PeriodicAllowance = {
    encode(b, h = A.Writer.create()) {
      b.basic !== void 0 && e.BasicAllowance.encode(b.basic, h.uint32(10).fork()).ldelim(), b.period !== void 0 && f.Duration.encode(b.period, h.uint32(18).fork()).ldelim();
      for (const S of b.periodSpendLimit)
        r.Coin.encode(S, h.uint32(26).fork()).ldelim();
      for (const S of b.periodCanSpend)
        r.Coin.encode(S, h.uint32(34).fork()).ldelim();
      return b.periodReset !== void 0 && u.Timestamp.encode(b.periodReset, h.uint32(42).fork()).ldelim(), h;
    },
    decode(b, h) {
      const S = b instanceof A.Reader ? b : new A.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = M();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.basic = e.BasicAllowance.decode(S, S.uint32());
            break;
          case 2:
            d.period = f.Duration.decode(S, S.uint32());
            break;
          case 3:
            d.periodSpendLimit.push(r.Coin.decode(S, S.uint32()));
            break;
          case 4:
            d.periodCanSpend.push(r.Coin.decode(S, S.uint32()));
            break;
          case 5:
            d.periodReset = u.Timestamp.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        basic: (0, T.isSet)(b.basic) ? e.BasicAllowance.fromJSON(b.basic) : void 0,
        period: (0, T.isSet)(b.period) ? f.Duration.fromJSON(b.period) : void 0,
        periodSpendLimit: Array.isArray(b == null ? void 0 : b.periodSpendLimit) ? b.periodSpendLimit.map((h) => r.Coin.fromJSON(h)) : [],
        periodCanSpend: Array.isArray(b == null ? void 0 : b.periodCanSpend) ? b.periodCanSpend.map((h) => r.Coin.fromJSON(h)) : [],
        periodReset: (0, T.isSet)(b.periodReset) ? (0, T.fromJsonTimestamp)(b.periodReset) : void 0
      };
    },
    toJSON(b) {
      const h = {};
      return b.basic !== void 0 && (h.basic = b.basic ? e.BasicAllowance.toJSON(b.basic) : void 0), b.period !== void 0 && (h.period = b.period ? f.Duration.toJSON(b.period) : void 0), b.periodSpendLimit ? h.periodSpendLimit = b.periodSpendLimit.map((S) => S ? r.Coin.toJSON(S) : void 0) : h.periodSpendLimit = [], b.periodCanSpend ? h.periodCanSpend = b.periodCanSpend.map((S) => S ? r.Coin.toJSON(S) : void 0) : h.periodCanSpend = [], b.periodReset !== void 0 && (h.periodReset = (0, T.fromTimestamp)(b.periodReset).toISOString()), h;
    },
    fromPartial(b) {
      var S, _;
      const h = M();
      return h.basic = b.basic !== void 0 && b.basic !== null ? e.BasicAllowance.fromPartial(b.basic) : void 0, h.period = b.period !== void 0 && b.period !== null ? f.Duration.fromPartial(b.period) : void 0, h.periodSpendLimit = ((S = b.periodSpendLimit) == null ? void 0 : S.map((d) => r.Coin.fromPartial(d))) || [], h.periodCanSpend = ((_ = b.periodCanSpend) == null ? void 0 : _.map((d) => r.Coin.fromPartial(d))) || [], h.periodReset = b.periodReset !== void 0 && b.periodReset !== null ? u.Timestamp.fromPartial(b.periodReset) : void 0, h;
    }
  };
  function V() {
    return {
      allowance: void 0,
      allowedMessages: []
    };
  }
  e.AllowedMsgAllowance = {
    encode(b, h = A.Writer.create()) {
      b.allowance !== void 0 && O.Any.encode(b.allowance, h.uint32(10).fork()).ldelim();
      for (const S of b.allowedMessages)
        h.uint32(18).string(S);
      return h;
    },
    decode(b, h) {
      const S = b instanceof A.Reader ? b : new A.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = V();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.allowance = O.Any.decode(S, S.uint32());
            break;
          case 2:
            d.allowedMessages.push(S.string());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        allowance: (0, T.isSet)(b.allowance) ? O.Any.fromJSON(b.allowance) : void 0,
        allowedMessages: Array.isArray(b == null ? void 0 : b.allowedMessages) ? b.allowedMessages.map((h) => String(h)) : []
      };
    },
    toJSON(b) {
      const h = {};
      return b.allowance !== void 0 && (h.allowance = b.allowance ? O.Any.toJSON(b.allowance) : void 0), b.allowedMessages ? h.allowedMessages = b.allowedMessages.map((S) => S) : h.allowedMessages = [], h;
    },
    fromPartial(b) {
      var S;
      const h = V();
      return h.allowance = b.allowance !== void 0 && b.allowance !== null ? O.Any.fromPartial(b.allowance) : void 0, h.allowedMessages = ((S = b.allowedMessages) == null ? void 0 : S.map((_) => _)) || [], h;
    }
  };
  function D() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.Grant = {
    encode(b, h = A.Writer.create()) {
      return b.granter !== "" && h.uint32(10).string(b.granter), b.grantee !== "" && h.uint32(18).string(b.grantee), b.allowance !== void 0 && O.Any.encode(b.allowance, h.uint32(26).fork()).ldelim(), h;
    },
    decode(b, h) {
      const S = b instanceof A.Reader ? b : new A.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = D();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.granter = S.string();
            break;
          case 2:
            d.grantee = S.string();
            break;
          case 3:
            d.allowance = O.Any.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        granter: (0, T.isSet)(b.granter) ? String(b.granter) : "",
        grantee: (0, T.isSet)(b.grantee) ? String(b.grantee) : "",
        allowance: (0, T.isSet)(b.allowance) ? O.Any.fromJSON(b.allowance) : void 0
      };
    },
    toJSON(b) {
      const h = {};
      return b.granter !== void 0 && (h.granter = b.granter), b.grantee !== void 0 && (h.grantee = b.grantee), b.allowance !== void 0 && (h.allowance = b.allowance ? O.Any.toJSON(b.allowance) : void 0), h;
    },
    fromPartial(b) {
      const h = D();
      return h.granter = b.granter ?? "", h.grantee = b.grantee ?? "", h.allowance = b.allowance !== void 0 && b.allowance !== null ? O.Any.fromPartial(b.allowance) : void 0, h;
    }
  };
})(Su);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(h, S, _, d) {
    d === void 0 && (d = _);
    var p = Object.getOwnPropertyDescriptor(S, _);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[_];
    } }), Object.defineProperty(h, d, p);
  } : function(h, S, _, d) {
    d === void 0 && (d = _), h[d] = S[_];
  }), c = G && G.__setModuleDefault || (Object.create ? function(h, S) {
    Object.defineProperty(h, "default", { enumerable: !0, value: S });
  } : function(h, S) {
    h.default = S;
  }), i = G && G.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var S = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && n(S, h, _);
    return c(S, h), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAllowancesByGranterResponse = e.QueryAllowancesByGranterRequest = e.QueryAllowancesResponse = e.QueryAllowancesRequest = e.QueryAllowanceResponse = e.QueryAllowanceRequest = e.protobufPackage = void 0;
  const r = Re, u = Su, f = i(ie), O = oe;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function A() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.QueryAllowanceRequest = {
    encode(h, S = f.Writer.create()) {
      return h.granter !== "" && S.uint32(10).string(h.granter), h.grantee !== "" && S.uint32(18).string(h.grantee), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = A();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.granter = _.string();
            break;
          case 2:
            p.grantee = _.string();
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        granter: (0, O.isSet)(h.granter) ? String(h.granter) : "",
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : ""
      };
    },
    toJSON(h) {
      const S = {};
      return h.granter !== void 0 && (S.granter = h.granter), h.grantee !== void 0 && (S.grantee = h.grantee), S;
    },
    fromPartial(h) {
      const S = A();
      return S.granter = h.granter ?? "", S.grantee = h.grantee ?? "", S;
    }
  };
  function T() {
    return {
      allowance: void 0
    };
  }
  e.QueryAllowanceResponse = {
    encode(h, S = f.Writer.create()) {
      return h.allowance !== void 0 && u.Grant.encode(h.allowance, S.uint32(10).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = T();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.allowance = u.Grant.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        allowance: (0, O.isSet)(h.allowance) ? u.Grant.fromJSON(h.allowance) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.allowance !== void 0 && (S.allowance = h.allowance ? u.Grant.toJSON(h.allowance) : void 0), S;
    },
    fromPartial(h) {
      const S = T();
      return S.allowance = h.allowance !== void 0 && h.allowance !== null ? u.Grant.fromPartial(h.allowance) : void 0, S;
    }
  };
  function L() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesRequest = {
    encode(h, S = f.Writer.create()) {
      return h.grantee !== "" && S.uint32(10).string(h.grantee), h.pagination !== void 0 && r.PageRequest.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = L();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.grantee = _.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        grantee: (0, O.isSet)(h.grantee) ? String(h.grantee) : "",
        pagination: (0, O.isSet)(h.pagination) ? r.PageRequest.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.grantee !== void 0 && (S.grantee = h.grantee), h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageRequest.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      const S = L();
      return S.grantee = h.grantee ?? "", S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageRequest.fromPartial(h.pagination) : void 0, S;
    }
  };
  function M() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.allowances)
        u.Grant.encode(_, S.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && r.PageResponse.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = M();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.allowances.push(u.Grant.decode(_, _.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        allowances: Array.isArray(h == null ? void 0 : h.allowances) ? h.allowances.map((S) => u.Grant.fromJSON(S)) : [],
        pagination: (0, O.isSet)(h.pagination) ? r.PageResponse.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.allowances ? S.allowances = h.allowances.map((_) => _ ? u.Grant.toJSON(_) : void 0) : S.allowances = [], h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageResponse.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      var _;
      const S = M();
      return S.allowances = ((_ = h.allowances) == null ? void 0 : _.map((d) => u.Grant.fromPartial(d))) || [], S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageResponse.fromPartial(h.pagination) : void 0, S;
    }
  };
  function V() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterRequest = {
    encode(h, S = f.Writer.create()) {
      return h.granter !== "" && S.uint32(10).string(h.granter), h.pagination !== void 0 && r.PageRequest.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = V();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.granter = _.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        granter: (0, O.isSet)(h.granter) ? String(h.granter) : "",
        pagination: (0, O.isSet)(h.pagination) ? r.PageRequest.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.granter !== void 0 && (S.granter = h.granter), h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageRequest.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      const S = V();
      return S.granter = h.granter ?? "", S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageRequest.fromPartial(h.pagination) : void 0, S;
    }
  };
  function D() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.allowances)
        u.Grant.encode(_, S.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && r.PageResponse.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = D();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.allowances.push(u.Grant.decode(_, _.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        allowances: Array.isArray(h == null ? void 0 : h.allowances) ? h.allowances.map((S) => u.Grant.fromJSON(S)) : [],
        pagination: (0, O.isSet)(h.pagination) ? r.PageResponse.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.allowances ? S.allowances = h.allowances.map((_) => _ ? u.Grant.toJSON(_) : void 0) : S.allowances = [], h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageResponse.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      var _;
      const S = D();
      return S.allowances = ((_ = h.allowances) == null ? void 0 : _.map((d) => u.Grant.fromPartial(d))) || [], S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageResponse.fromPartial(h.pagination) : void 0, S;
    }
  };
  class b {
    constructor(S) {
      this.rpc = S, this.Allowance = this.Allowance.bind(this), this.Allowances = this.Allowances.bind(this), this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
    }
    Allowance(S) {
      const _ = e.QueryAllowanceRequest.encode(S).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", _).then((p) => e.QueryAllowanceResponse.decode(new f.Reader(p)));
    }
    Allowances(S) {
      const _ = e.QueryAllowancesRequest.encode(S).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", _).then((p) => e.QueryAllowancesResponse.decode(new f.Reader(p)));
    }
    AllowancesByGranter(S) {
      const _ = e.QueryAllowancesByGranterRequest.encode(S).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", _).then((p) => e.QueryAllowancesByGranterResponse.decode(new f.Reader(p)));
    }
  }
  e.QueryClientImpl = b;
})(yu);
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.setupFeegrantExtension = void 0;
const uh = yu, bs = Le;
function ch(e) {
  const n = (0, bs.createProtobufRpcClient)(e), c = new uh.QueryClientImpl(n);
  return {
    feegrant: {
      allowance: async (i, r) => await c.Allowance({
        granter: i,
        grantee: r
      }),
      allowances: async (i, r) => await c.Allowances({
        grantee: i,
        pagination: (0, bs.createPagination)(r)
      })
    }
  };
}
ii.setupFeegrantExtension = ch;
var on = {}, oi = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(t, y, E, H) {
    H === void 0 && (H = E);
    var a = Object.getOwnPropertyDescriptor(y, E);
    (!a || ("get" in a ? !y.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return y[E];
    } }), Object.defineProperty(t, H, a);
  } : function(t, y, E, H) {
    H === void 0 && (H = E), t[H] = y[E];
  }), c = G && G.__setModuleDefault || (Object.create ? function(t, y) {
    Object.defineProperty(t, "default", { enumerable: !0, value: y });
  } : function(t, y) {
    t.default = y;
  }), i = G && G.__importStar || function(t) {
    if (t && t.__esModule)
      return t;
    var y = {};
    if (t != null)
      for (var E in t)
        E !== "default" && Object.prototype.hasOwnProperty.call(t, E) && n(y, t, E);
    return c(y, t), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.TextProposal = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const r = Me, u = Se, f = _e, O = en, A = oe, T = i(ie);
  e.protobufPackage = "cosmos.gov.v1beta1";
  var L;
  (function(t) {
    t[t.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", t[t.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", t[t.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", t[t.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", t[t.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(L = e.VoteOption || (e.VoteOption = {}));
  function M(t) {
    switch (t) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return L.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return L.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return L.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return L.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return L.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return L.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = M;
  function V(t) {
    switch (t) {
      case L.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case L.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case L.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case L.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case L.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case L.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = V;
  var D;
  (function(t) {
    t[t.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", t[t.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", t[t.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", t[t.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", t[t.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", t[t.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(D = e.ProposalStatus || (e.ProposalStatus = {}));
  function b(t) {
    switch (t) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return D.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return D.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return D.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return D.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return D.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return D.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return D.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = b;
  function h(t) {
    switch (t) {
      case D.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case D.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case D.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case D.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case D.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case D.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case D.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = h;
  function S() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    encode(t, y = T.Writer.create()) {
      return t.option !== 0 && y.uint32(8).int32(t.option), t.weight !== "" && y.uint32(18).string(t.weight), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = S();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.option = E.int32();
            break;
          case 2:
            a.weight = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        option: (0, A.isSet)(t.option) ? M(t.option) : 0,
        weight: (0, A.isSet)(t.weight) ? String(t.weight) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.option !== void 0 && (y.option = V(t.option)), t.weight !== void 0 && (y.weight = t.weight), y;
    },
    fromPartial(t) {
      const y = S();
      return y.option = t.option ?? 0, y.weight = t.weight ?? "", y;
    }
  };
  function _() {
    return {
      title: "",
      description: ""
    };
  }
  e.TextProposal = {
    encode(t, y = T.Writer.create()) {
      return t.title !== "" && y.uint32(10).string(t.title), t.description !== "" && y.uint32(18).string(t.description), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = _();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.title = E.string();
            break;
          case 2:
            a.description = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        title: (0, A.isSet)(t.title) ? String(t.title) : "",
        description: (0, A.isSet)(t.description) ? String(t.description) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.title !== void 0 && (y.title = t.title), t.description !== void 0 && (y.description = t.description), y;
    },
    fromPartial(t) {
      const y = _();
      return y.title = t.title ?? "", y.description = t.description ?? "", y;
    }
  };
  function d() {
    return {
      proposalId: A.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    encode(t, y = T.Writer.create()) {
      t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.depositor !== "" && y.uint32(18).string(t.depositor);
      for (const E of t.amount)
        r.Coin.encode(E, y.uint32(26).fork()).ldelim();
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = d();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.depositor = E.string();
            break;
          case 3:
            a.amount.push(r.Coin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, A.isSet)(t.proposalId) ? A.Long.fromValue(t.proposalId) : A.Long.UZERO,
        depositor: (0, A.isSet)(t.depositor) ? String(t.depositor) : "",
        amount: Array.isArray(t == null ? void 0 : t.amount) ? t.amount.map((y) => r.Coin.fromJSON(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || A.Long.UZERO).toString()), t.depositor !== void 0 && (y.depositor = t.depositor), t.amount ? y.amount = t.amount.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.amount = [], y;
    },
    fromPartial(t) {
      var E;
      const y = d();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? A.Long.fromValue(t.proposalId) : A.Long.UZERO, y.depositor = t.depositor ?? "", y.amount = ((E = t.amount) == null ? void 0 : E.map((H) => r.Coin.fromPartial(H))) || [], y;
    }
  };
  function p() {
    return {
      proposalId: A.Long.UZERO,
      content: void 0,
      status: 0,
      finalTallyResult: void 0,
      submitTime: void 0,
      depositEndTime: void 0,
      totalDeposit: [],
      votingStartTime: void 0,
      votingEndTime: void 0
    };
  }
  e.Proposal = {
    encode(t, y = T.Writer.create()) {
      t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.content !== void 0 && u.Any.encode(t.content, y.uint32(18).fork()).ldelim(), t.status !== 0 && y.uint32(24).int32(t.status), t.finalTallyResult !== void 0 && e.TallyResult.encode(t.finalTallyResult, y.uint32(34).fork()).ldelim(), t.submitTime !== void 0 && f.Timestamp.encode(t.submitTime, y.uint32(42).fork()).ldelim(), t.depositEndTime !== void 0 && f.Timestamp.encode(t.depositEndTime, y.uint32(50).fork()).ldelim();
      for (const E of t.totalDeposit)
        r.Coin.encode(E, y.uint32(58).fork()).ldelim();
      return t.votingStartTime !== void 0 && f.Timestamp.encode(t.votingStartTime, y.uint32(66).fork()).ldelim(), t.votingEndTime !== void 0 && f.Timestamp.encode(t.votingEndTime, y.uint32(74).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = p();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.content = u.Any.decode(E, E.uint32());
            break;
          case 3:
            a.status = E.int32();
            break;
          case 4:
            a.finalTallyResult = e.TallyResult.decode(E, E.uint32());
            break;
          case 5:
            a.submitTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 6:
            a.depositEndTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 7:
            a.totalDeposit.push(r.Coin.decode(E, E.uint32()));
            break;
          case 8:
            a.votingStartTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 9:
            a.votingEndTime = f.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, A.isSet)(t.proposalId) ? A.Long.fromValue(t.proposalId) : A.Long.UZERO,
        content: (0, A.isSet)(t.content) ? u.Any.fromJSON(t.content) : void 0,
        status: (0, A.isSet)(t.status) ? b(t.status) : 0,
        finalTallyResult: (0, A.isSet)(t.finalTallyResult) ? e.TallyResult.fromJSON(t.finalTallyResult) : void 0,
        submitTime: (0, A.isSet)(t.submitTime) ? (0, A.fromJsonTimestamp)(t.submitTime) : void 0,
        depositEndTime: (0, A.isSet)(t.depositEndTime) ? (0, A.fromJsonTimestamp)(t.depositEndTime) : void 0,
        totalDeposit: Array.isArray(t == null ? void 0 : t.totalDeposit) ? t.totalDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        votingStartTime: (0, A.isSet)(t.votingStartTime) ? (0, A.fromJsonTimestamp)(t.votingStartTime) : void 0,
        votingEndTime: (0, A.isSet)(t.votingEndTime) ? (0, A.fromJsonTimestamp)(t.votingEndTime) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || A.Long.UZERO).toString()), t.content !== void 0 && (y.content = t.content ? u.Any.toJSON(t.content) : void 0), t.status !== void 0 && (y.status = h(t.status)), t.finalTallyResult !== void 0 && (y.finalTallyResult = t.finalTallyResult ? e.TallyResult.toJSON(t.finalTallyResult) : void 0), t.submitTime !== void 0 && (y.submitTime = (0, A.fromTimestamp)(t.submitTime).toISOString()), t.depositEndTime !== void 0 && (y.depositEndTime = (0, A.fromTimestamp)(t.depositEndTime).toISOString()), t.totalDeposit ? y.totalDeposit = t.totalDeposit.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.totalDeposit = [], t.votingStartTime !== void 0 && (y.votingStartTime = (0, A.fromTimestamp)(t.votingStartTime).toISOString()), t.votingEndTime !== void 0 && (y.votingEndTime = (0, A.fromTimestamp)(t.votingEndTime).toISOString()), y;
    },
    fromPartial(t) {
      var E;
      const y = p();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? A.Long.fromValue(t.proposalId) : A.Long.UZERO, y.content = t.content !== void 0 && t.content !== null ? u.Any.fromPartial(t.content) : void 0, y.status = t.status ?? 0, y.finalTallyResult = t.finalTallyResult !== void 0 && t.finalTallyResult !== null ? e.TallyResult.fromPartial(t.finalTallyResult) : void 0, y.submitTime = t.submitTime !== void 0 && t.submitTime !== null ? f.Timestamp.fromPartial(t.submitTime) : void 0, y.depositEndTime = t.depositEndTime !== void 0 && t.depositEndTime !== null ? f.Timestamp.fromPartial(t.depositEndTime) : void 0, y.totalDeposit = ((E = t.totalDeposit) == null ? void 0 : E.map((H) => r.Coin.fromPartial(H))) || [], y.votingStartTime = t.votingStartTime !== void 0 && t.votingStartTime !== null ? f.Timestamp.fromPartial(t.votingStartTime) : void 0, y.votingEndTime = t.votingEndTime !== void 0 && t.votingEndTime !== null ? f.Timestamp.fromPartial(t.votingEndTime) : void 0, y;
    }
  };
  function g() {
    return {
      yes: "",
      abstain: "",
      no: "",
      noWithVeto: ""
    };
  }
  e.TallyResult = {
    encode(t, y = T.Writer.create()) {
      return t.yes !== "" && y.uint32(10).string(t.yes), t.abstain !== "" && y.uint32(18).string(t.abstain), t.no !== "" && y.uint32(26).string(t.no), t.noWithVeto !== "" && y.uint32(34).string(t.noWithVeto), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = g();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.yes = E.string();
            break;
          case 2:
            a.abstain = E.string();
            break;
          case 3:
            a.no = E.string();
            break;
          case 4:
            a.noWithVeto = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        yes: (0, A.isSet)(t.yes) ? String(t.yes) : "",
        abstain: (0, A.isSet)(t.abstain) ? String(t.abstain) : "",
        no: (0, A.isSet)(t.no) ? String(t.no) : "",
        noWithVeto: (0, A.isSet)(t.noWithVeto) ? String(t.noWithVeto) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.yes !== void 0 && (y.yes = t.yes), t.abstain !== void 0 && (y.abstain = t.abstain), t.no !== void 0 && (y.no = t.no), t.noWithVeto !== void 0 && (y.noWithVeto = t.noWithVeto), y;
    },
    fromPartial(t) {
      const y = g();
      return y.yes = t.yes ?? "", y.abstain = t.abstain ?? "", y.no = t.no ?? "", y.noWithVeto = t.noWithVeto ?? "", y;
    }
  };
  function J() {
    return {
      proposalId: A.Long.UZERO,
      voter: "",
      option: 0,
      options: []
    };
  }
  e.Vote = {
    encode(t, y = T.Writer.create()) {
      t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.voter !== "" && y.uint32(18).string(t.voter), t.option !== 0 && y.uint32(24).int32(t.option);
      for (const E of t.options)
        e.WeightedVoteOption.encode(E, y.uint32(34).fork()).ldelim();
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = J();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.voter = E.string();
            break;
          case 3:
            a.option = E.int32();
            break;
          case 4:
            a.options.push(e.WeightedVoteOption.decode(E, E.uint32()));
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, A.isSet)(t.proposalId) ? A.Long.fromValue(t.proposalId) : A.Long.UZERO,
        voter: (0, A.isSet)(t.voter) ? String(t.voter) : "",
        option: (0, A.isSet)(t.option) ? M(t.option) : 0,
        options: Array.isArray(t == null ? void 0 : t.options) ? t.options.map((y) => e.WeightedVoteOption.fromJSON(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || A.Long.UZERO).toString()), t.voter !== void 0 && (y.voter = t.voter), t.option !== void 0 && (y.option = V(t.option)), t.options ? y.options = t.options.map((E) => E ? e.WeightedVoteOption.toJSON(E) : void 0) : y.options = [], y;
    },
    fromPartial(t) {
      var E;
      const y = J();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? A.Long.fromValue(t.proposalId) : A.Long.UZERO, y.voter = t.voter ?? "", y.option = t.option ?? 0, y.options = ((E = t.options) == null ? void 0 : E.map((H) => e.WeightedVoteOption.fromPartial(H))) || [], y;
    }
  };
  function B() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0
    };
  }
  e.DepositParams = {
    encode(t, y = T.Writer.create()) {
      for (const E of t.minDeposit)
        r.Coin.encode(E, y.uint32(10).fork()).ldelim();
      return t.maxDepositPeriod !== void 0 && O.Duration.encode(t.maxDepositPeriod, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = B();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.minDeposit.push(r.Coin.decode(E, E.uint32()));
            break;
          case 2:
            a.maxDepositPeriod = O.Duration.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        minDeposit: Array.isArray(t == null ? void 0 : t.minDeposit) ? t.minDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        maxDepositPeriod: (0, A.isSet)(t.maxDepositPeriod) ? O.Duration.fromJSON(t.maxDepositPeriod) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.minDeposit ? y.minDeposit = t.minDeposit.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.minDeposit = [], t.maxDepositPeriod !== void 0 && (y.maxDepositPeriod = t.maxDepositPeriod ? O.Duration.toJSON(t.maxDepositPeriod) : void 0), y;
    },
    fromPartial(t) {
      var E;
      const y = B();
      return y.minDeposit = ((E = t.minDeposit) == null ? void 0 : E.map((H) => r.Coin.fromPartial(H))) || [], y.maxDepositPeriod = t.maxDepositPeriod !== void 0 && t.maxDepositPeriod !== null ? O.Duration.fromPartial(t.maxDepositPeriod) : void 0, y;
    }
  };
  function I() {
    return {
      votingPeriod: void 0
    };
  }
  e.VotingParams = {
    encode(t, y = T.Writer.create()) {
      return t.votingPeriod !== void 0 && O.Duration.encode(t.votingPeriod, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = I();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.votingPeriod = O.Duration.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        votingPeriod: (0, A.isSet)(t.votingPeriod) ? O.Duration.fromJSON(t.votingPeriod) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.votingPeriod !== void 0 && (y.votingPeriod = t.votingPeriod ? O.Duration.toJSON(t.votingPeriod) : void 0), y;
    },
    fromPartial(t) {
      const y = I();
      return y.votingPeriod = t.votingPeriod !== void 0 && t.votingPeriod !== null ? O.Duration.fromPartial(t.votingPeriod) : void 0, y;
    }
  };
  function Z() {
    return {
      quorum: new Uint8Array(),
      threshold: new Uint8Array(),
      vetoThreshold: new Uint8Array()
    };
  }
  e.TallyParams = {
    encode(t, y = T.Writer.create()) {
      return t.quorum.length !== 0 && y.uint32(10).bytes(t.quorum), t.threshold.length !== 0 && y.uint32(18).bytes(t.threshold), t.vetoThreshold.length !== 0 && y.uint32(26).bytes(t.vetoThreshold), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = Z();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.quorum = E.bytes();
            break;
          case 2:
            a.threshold = E.bytes();
            break;
          case 3:
            a.vetoThreshold = E.bytes();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        quorum: (0, A.isSet)(t.quorum) ? (0, A.bytesFromBase64)(t.quorum) : new Uint8Array(),
        threshold: (0, A.isSet)(t.threshold) ? (0, A.bytesFromBase64)(t.threshold) : new Uint8Array(),
        vetoThreshold: (0, A.isSet)(t.vetoThreshold) ? (0, A.bytesFromBase64)(t.vetoThreshold) : new Uint8Array()
      };
    },
    toJSON(t) {
      const y = {};
      return t.quorum !== void 0 && (y.quorum = (0, A.base64FromBytes)(t.quorum !== void 0 ? t.quorum : new Uint8Array())), t.threshold !== void 0 && (y.threshold = (0, A.base64FromBytes)(t.threshold !== void 0 ? t.threshold : new Uint8Array())), t.vetoThreshold !== void 0 && (y.vetoThreshold = (0, A.base64FromBytes)(t.vetoThreshold !== void 0 ? t.vetoThreshold : new Uint8Array())), y;
    },
    fromPartial(t) {
      const y = Z();
      return y.quorum = t.quorum ?? new Uint8Array(), y.threshold = t.threshold ?? new Uint8Array(), y.vetoThreshold = t.vetoThreshold ?? new Uint8Array(), y;
    }
  };
})(oi);
var lh = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(on, "__esModule", { value: !0 });
on.createGovAminoConverters = on.isAminoMsgDeposit = on.isAminoMsgVoteWeighted = on.isAminoMsgVote = on.isAminoMsgSubmitProposal = void 0;
const fh = _n, qt = yn, Wt = oi, ph = Se, ji = lh(An), hh = Le;
function mh(e) {
  return e.type === "cosmos-sdk/MsgSubmitProposal";
}
on.isAminoMsgSubmitProposal = mh;
function gh(e) {
  return e.type === "cosmos-sdk/MsgVote";
}
on.isAminoMsgVote = gh;
function yh(e) {
  return e.type === "cosmos-sdk/MsgVoteWeighted";
}
on.isAminoMsgVoteWeighted = yh;
function Sh(e) {
  return e.type === "cosmos-sdk/MsgDeposit";
}
on.isAminoMsgDeposit = Sh;
function Oh() {
  return {
    "/cosmos.gov.v1beta1.MsgDeposit": {
      aminoType: "cosmos-sdk/MsgDeposit",
      toAmino: ({ amount: e, depositor: n, proposalId: c }) => ({
        amount: e,
        depositor: n,
        proposal_id: c.toString()
      }),
      fromAmino: ({ amount: e, depositor: n, proposal_id: c }) => ({
        amount: Array.from(e),
        depositor: n,
        proposalId: ji.default.fromString(c)
      })
    },
    "/cosmos.gov.v1beta1.MsgVote": {
      aminoType: "cosmos-sdk/MsgVote",
      toAmino: ({ option: e, proposalId: n, voter: c }) => ({
        option: e,
        proposal_id: n.toString(),
        voter: c
      }),
      fromAmino: ({ option: e, proposal_id: n, voter: c }) => ({
        option: (0, Wt.voteOptionFromJSON)(e),
        proposalId: ji.default.fromString(n),
        voter: c
      })
    },
    "/cosmos.gov.v1beta1.MsgVoteWeighted": {
      aminoType: "cosmos-sdk/MsgVoteWeighted",
      toAmino: ({ options: e, proposalId: n, voter: c }) => ({
        options: e.map((i) => ({
          option: i.option,
          // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
          // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
          weight: (0, hh.decodeCosmosSdkDecFromProto)(i.weight).toString().padEnd(20, "0")
        })),
        proposal_id: n.toString(),
        voter: c
      }),
      fromAmino: ({ options: e, proposal_id: n, voter: c }) => ({
        proposalId: ji.default.fromString(n),
        voter: c,
        options: e.map((i) => ({
          option: (0, Wt.voteOptionFromJSON)(i.option),
          weight: fh.Decimal.fromUserInput(i.weight, 18).atomics
        }))
      })
    },
    "/cosmos.gov.v1beta1.MsgSubmitProposal": {
      aminoType: "cosmos-sdk/MsgSubmitProposal",
      toAmino: ({ initialDeposit: e, proposer: n, content: c }) => {
        (0, qt.assertDefinedAndNotNull)(c);
        let i;
        switch (c.typeUrl) {
          case "/cosmos.gov.v1beta1.TextProposal": {
            const r = Wt.TextProposal.decode(c.value);
            i = {
              type: "cosmos-sdk/TextProposal",
              value: {
                description: r.description,
                title: r.title
              }
            };
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${c.typeUrl}'`);
        }
        return {
          initial_deposit: e,
          proposer: n,
          content: i
        };
      },
      fromAmino: ({ initial_deposit: e, proposer: n, content: c }) => {
        let i;
        switch (c.type) {
          case "cosmos-sdk/TextProposal": {
            const { value: r } = c;
            (0, qt.assert)((0, qt.isNonNullObject)(r));
            const { title: u, description: f } = r;
            (0, qt.assert)(typeof u == "string"), (0, qt.assert)(typeof f == "string"), i = ph.Any.fromPartial({
              typeUrl: "/cosmos.gov.v1beta1.TextProposal",
              value: Wt.TextProposal.encode(Wt.TextProposal.fromPartial({
                title: u,
                description: f
              })).finish()
            });
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${c.type}'`);
        }
        return {
          initialDeposit: Array.from(e),
          proposer: n,
          content: i
        };
      }
    }
  };
}
on.createGovAminoConverters = Oh;
var an = {}, Ou = {}, Ru = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(t, y, E, H) {
    H === void 0 && (H = E);
    var a = Object.getOwnPropertyDescriptor(y, E);
    (!a || ("get" in a ? !y.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return y[E];
    } }), Object.defineProperty(t, H, a);
  } : function(t, y, E, H) {
    H === void 0 && (H = E), t[H] = y[E];
  }), c = G && G.__setModuleDefault || (Object.create ? function(t, y) {
    Object.defineProperty(t, "default", { enumerable: !0, value: y });
  } : function(t, y) {
    t.default = y;
  }), i = G && G.__importStar || function(t) {
    if (t && t.__esModule)
      return t;
    var y = {};
    if (t != null)
      for (var E in t)
        E !== "default" && Object.prototype.hasOwnProperty.call(t, E) && n(y, t, E);
    return c(y, t), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const r = Me, u = Se, f = _e, O = en, A = oe, T = i(ie);
  e.protobufPackage = "cosmos.gov.v1";
  var L;
  (function(t) {
    t[t.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", t[t.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", t[t.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", t[t.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", t[t.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(L = e.VoteOption || (e.VoteOption = {}));
  function M(t) {
    switch (t) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return L.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return L.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return L.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return L.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return L.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return L.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = M;
  function V(t) {
    switch (t) {
      case L.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case L.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case L.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case L.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case L.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case L.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = V;
  var D;
  (function(t) {
    t[t.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", t[t.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", t[t.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", t[t.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", t[t.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", t[t.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(D = e.ProposalStatus || (e.ProposalStatus = {}));
  function b(t) {
    switch (t) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return D.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return D.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return D.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return D.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return D.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return D.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return D.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = b;
  function h(t) {
    switch (t) {
      case D.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case D.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case D.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case D.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case D.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case D.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case D.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = h;
  function S() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    encode(t, y = T.Writer.create()) {
      return t.option !== 0 && y.uint32(8).int32(t.option), t.weight !== "" && y.uint32(18).string(t.weight), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = S();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.option = E.int32();
            break;
          case 2:
            a.weight = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        option: (0, A.isSet)(t.option) ? M(t.option) : 0,
        weight: (0, A.isSet)(t.weight) ? String(t.weight) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.option !== void 0 && (y.option = V(t.option)), t.weight !== void 0 && (y.weight = t.weight), y;
    },
    fromPartial(t) {
      const y = S();
      return y.option = t.option ?? 0, y.weight = t.weight ?? "", y;
    }
  };
  function _() {
    return {
      proposalId: A.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    encode(t, y = T.Writer.create()) {
      t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.depositor !== "" && y.uint32(18).string(t.depositor);
      for (const E of t.amount)
        r.Coin.encode(E, y.uint32(26).fork()).ldelim();
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = _();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.depositor = E.string();
            break;
          case 3:
            a.amount.push(r.Coin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, A.isSet)(t.proposalId) ? A.Long.fromValue(t.proposalId) : A.Long.UZERO,
        depositor: (0, A.isSet)(t.depositor) ? String(t.depositor) : "",
        amount: Array.isArray(t == null ? void 0 : t.amount) ? t.amount.map((y) => r.Coin.fromJSON(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || A.Long.UZERO).toString()), t.depositor !== void 0 && (y.depositor = t.depositor), t.amount ? y.amount = t.amount.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.amount = [], y;
    },
    fromPartial(t) {
      var E;
      const y = _();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? A.Long.fromValue(t.proposalId) : A.Long.UZERO, y.depositor = t.depositor ?? "", y.amount = ((E = t.amount) == null ? void 0 : E.map((H) => r.Coin.fromPartial(H))) || [], y;
    }
  };
  function d() {
    return {
      id: A.Long.UZERO,
      messages: [],
      status: 0,
      finalTallyResult: void 0,
      submitTime: void 0,
      depositEndTime: void 0,
      totalDeposit: [],
      votingStartTime: void 0,
      votingEndTime: void 0,
      metadata: "",
      title: "",
      summary: "",
      proposer: ""
    };
  }
  e.Proposal = {
    encode(t, y = T.Writer.create()) {
      t.id.isZero() || y.uint32(8).uint64(t.id);
      for (const E of t.messages)
        u.Any.encode(E, y.uint32(18).fork()).ldelim();
      t.status !== 0 && y.uint32(24).int32(t.status), t.finalTallyResult !== void 0 && e.TallyResult.encode(t.finalTallyResult, y.uint32(34).fork()).ldelim(), t.submitTime !== void 0 && f.Timestamp.encode(t.submitTime, y.uint32(42).fork()).ldelim(), t.depositEndTime !== void 0 && f.Timestamp.encode(t.depositEndTime, y.uint32(50).fork()).ldelim();
      for (const E of t.totalDeposit)
        r.Coin.encode(E, y.uint32(58).fork()).ldelim();
      return t.votingStartTime !== void 0 && f.Timestamp.encode(t.votingStartTime, y.uint32(66).fork()).ldelim(), t.votingEndTime !== void 0 && f.Timestamp.encode(t.votingEndTime, y.uint32(74).fork()).ldelim(), t.metadata !== "" && y.uint32(82).string(t.metadata), t.title !== "" && y.uint32(90).string(t.title), t.summary !== "" && y.uint32(98).string(t.summary), t.proposer !== "" && y.uint32(106).string(t.proposer), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = d();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.id = E.uint64();
            break;
          case 2:
            a.messages.push(u.Any.decode(E, E.uint32()));
            break;
          case 3:
            a.status = E.int32();
            break;
          case 4:
            a.finalTallyResult = e.TallyResult.decode(E, E.uint32());
            break;
          case 5:
            a.submitTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 6:
            a.depositEndTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 7:
            a.totalDeposit.push(r.Coin.decode(E, E.uint32()));
            break;
          case 8:
            a.votingStartTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 9:
            a.votingEndTime = f.Timestamp.decode(E, E.uint32());
            break;
          case 10:
            a.metadata = E.string();
            break;
          case 11:
            a.title = E.string();
            break;
          case 12:
            a.summary = E.string();
            break;
          case 13:
            a.proposer = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        id: (0, A.isSet)(t.id) ? A.Long.fromValue(t.id) : A.Long.UZERO,
        messages: Array.isArray(t == null ? void 0 : t.messages) ? t.messages.map((y) => u.Any.fromJSON(y)) : [],
        status: (0, A.isSet)(t.status) ? b(t.status) : 0,
        finalTallyResult: (0, A.isSet)(t.finalTallyResult) ? e.TallyResult.fromJSON(t.finalTallyResult) : void 0,
        submitTime: (0, A.isSet)(t.submitTime) ? (0, A.fromJsonTimestamp)(t.submitTime) : void 0,
        depositEndTime: (0, A.isSet)(t.depositEndTime) ? (0, A.fromJsonTimestamp)(t.depositEndTime) : void 0,
        totalDeposit: Array.isArray(t == null ? void 0 : t.totalDeposit) ? t.totalDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        votingStartTime: (0, A.isSet)(t.votingStartTime) ? (0, A.fromJsonTimestamp)(t.votingStartTime) : void 0,
        votingEndTime: (0, A.isSet)(t.votingEndTime) ? (0, A.fromJsonTimestamp)(t.votingEndTime) : void 0,
        metadata: (0, A.isSet)(t.metadata) ? String(t.metadata) : "",
        title: (0, A.isSet)(t.title) ? String(t.title) : "",
        summary: (0, A.isSet)(t.summary) ? String(t.summary) : "",
        proposer: (0, A.isSet)(t.proposer) ? String(t.proposer) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.id !== void 0 && (y.id = (t.id || A.Long.UZERO).toString()), t.messages ? y.messages = t.messages.map((E) => E ? u.Any.toJSON(E) : void 0) : y.messages = [], t.status !== void 0 && (y.status = h(t.status)), t.finalTallyResult !== void 0 && (y.finalTallyResult = t.finalTallyResult ? e.TallyResult.toJSON(t.finalTallyResult) : void 0), t.submitTime !== void 0 && (y.submitTime = (0, A.fromTimestamp)(t.submitTime).toISOString()), t.depositEndTime !== void 0 && (y.depositEndTime = (0, A.fromTimestamp)(t.depositEndTime).toISOString()), t.totalDeposit ? y.totalDeposit = t.totalDeposit.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.totalDeposit = [], t.votingStartTime !== void 0 && (y.votingStartTime = (0, A.fromTimestamp)(t.votingStartTime).toISOString()), t.votingEndTime !== void 0 && (y.votingEndTime = (0, A.fromTimestamp)(t.votingEndTime).toISOString()), t.metadata !== void 0 && (y.metadata = t.metadata), t.title !== void 0 && (y.title = t.title), t.summary !== void 0 && (y.summary = t.summary), t.proposer !== void 0 && (y.proposer = t.proposer), y;
    },
    fromPartial(t) {
      var E, H;
      const y = d();
      return y.id = t.id !== void 0 && t.id !== null ? A.Long.fromValue(t.id) : A.Long.UZERO, y.messages = ((E = t.messages) == null ? void 0 : E.map((a) => u.Any.fromPartial(a))) || [], y.status = t.status ?? 0, y.finalTallyResult = t.finalTallyResult !== void 0 && t.finalTallyResult !== null ? e.TallyResult.fromPartial(t.finalTallyResult) : void 0, y.submitTime = t.submitTime !== void 0 && t.submitTime !== null ? f.Timestamp.fromPartial(t.submitTime) : void 0, y.depositEndTime = t.depositEndTime !== void 0 && t.depositEndTime !== null ? f.Timestamp.fromPartial(t.depositEndTime) : void 0, y.totalDeposit = ((H = t.totalDeposit) == null ? void 0 : H.map((a) => r.Coin.fromPartial(a))) || [], y.votingStartTime = t.votingStartTime !== void 0 && t.votingStartTime !== null ? f.Timestamp.fromPartial(t.votingStartTime) : void 0, y.votingEndTime = t.votingEndTime !== void 0 && t.votingEndTime !== null ? f.Timestamp.fromPartial(t.votingEndTime) : void 0, y.metadata = t.metadata ?? "", y.title = t.title ?? "", y.summary = t.summary ?? "", y.proposer = t.proposer ?? "", y;
    }
  };
  function p() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    encode(t, y = T.Writer.create()) {
      return t.yesCount !== "" && y.uint32(10).string(t.yesCount), t.abstainCount !== "" && y.uint32(18).string(t.abstainCount), t.noCount !== "" && y.uint32(26).string(t.noCount), t.noWithVetoCount !== "" && y.uint32(34).string(t.noWithVetoCount), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = p();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.yesCount = E.string();
            break;
          case 2:
            a.abstainCount = E.string();
            break;
          case 3:
            a.noCount = E.string();
            break;
          case 4:
            a.noWithVetoCount = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        yesCount: (0, A.isSet)(t.yesCount) ? String(t.yesCount) : "",
        abstainCount: (0, A.isSet)(t.abstainCount) ? String(t.abstainCount) : "",
        noCount: (0, A.isSet)(t.noCount) ? String(t.noCount) : "",
        noWithVetoCount: (0, A.isSet)(t.noWithVetoCount) ? String(t.noWithVetoCount) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.yesCount !== void 0 && (y.yesCount = t.yesCount), t.abstainCount !== void 0 && (y.abstainCount = t.abstainCount), t.noCount !== void 0 && (y.noCount = t.noCount), t.noWithVetoCount !== void 0 && (y.noWithVetoCount = t.noWithVetoCount), y;
    },
    fromPartial(t) {
      const y = p();
      return y.yesCount = t.yesCount ?? "", y.abstainCount = t.abstainCount ?? "", y.noCount = t.noCount ?? "", y.noWithVetoCount = t.noWithVetoCount ?? "", y;
    }
  };
  function g() {
    return {
      proposalId: A.Long.UZERO,
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.Vote = {
    encode(t, y = T.Writer.create()) {
      t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.voter !== "" && y.uint32(18).string(t.voter);
      for (const E of t.options)
        e.WeightedVoteOption.encode(E, y.uint32(34).fork()).ldelim();
      return t.metadata !== "" && y.uint32(42).string(t.metadata), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = g();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.voter = E.string();
            break;
          case 4:
            a.options.push(e.WeightedVoteOption.decode(E, E.uint32()));
            break;
          case 5:
            a.metadata = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, A.isSet)(t.proposalId) ? A.Long.fromValue(t.proposalId) : A.Long.UZERO,
        voter: (0, A.isSet)(t.voter) ? String(t.voter) : "",
        options: Array.isArray(t == null ? void 0 : t.options) ? t.options.map((y) => e.WeightedVoteOption.fromJSON(y)) : [],
        metadata: (0, A.isSet)(t.metadata) ? String(t.metadata) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || A.Long.UZERO).toString()), t.voter !== void 0 && (y.voter = t.voter), t.options ? y.options = t.options.map((E) => E ? e.WeightedVoteOption.toJSON(E) : void 0) : y.options = [], t.metadata !== void 0 && (y.metadata = t.metadata), y;
    },
    fromPartial(t) {
      var E;
      const y = g();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? A.Long.fromValue(t.proposalId) : A.Long.UZERO, y.voter = t.voter ?? "", y.options = ((E = t.options) == null ? void 0 : E.map((H) => e.WeightedVoteOption.fromPartial(H))) || [], y.metadata = t.metadata ?? "", y;
    }
  };
  function J() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0
    };
  }
  e.DepositParams = {
    encode(t, y = T.Writer.create()) {
      for (const E of t.minDeposit)
        r.Coin.encode(E, y.uint32(10).fork()).ldelim();
      return t.maxDepositPeriod !== void 0 && O.Duration.encode(t.maxDepositPeriod, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = J();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.minDeposit.push(r.Coin.decode(E, E.uint32()));
            break;
          case 2:
            a.maxDepositPeriod = O.Duration.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        minDeposit: Array.isArray(t == null ? void 0 : t.minDeposit) ? t.minDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        maxDepositPeriod: (0, A.isSet)(t.maxDepositPeriod) ? O.Duration.fromJSON(t.maxDepositPeriod) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.minDeposit ? y.minDeposit = t.minDeposit.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.minDeposit = [], t.maxDepositPeriod !== void 0 && (y.maxDepositPeriod = t.maxDepositPeriod ? O.Duration.toJSON(t.maxDepositPeriod) : void 0), y;
    },
    fromPartial(t) {
      var E;
      const y = J();
      return y.minDeposit = ((E = t.minDeposit) == null ? void 0 : E.map((H) => r.Coin.fromPartial(H))) || [], y.maxDepositPeriod = t.maxDepositPeriod !== void 0 && t.maxDepositPeriod !== null ? O.Duration.fromPartial(t.maxDepositPeriod) : void 0, y;
    }
  };
  function B() {
    return {
      votingPeriod: void 0
    };
  }
  e.VotingParams = {
    encode(t, y = T.Writer.create()) {
      return t.votingPeriod !== void 0 && O.Duration.encode(t.votingPeriod, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = B();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.votingPeriod = O.Duration.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        votingPeriod: (0, A.isSet)(t.votingPeriod) ? O.Duration.fromJSON(t.votingPeriod) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.votingPeriod !== void 0 && (y.votingPeriod = t.votingPeriod ? O.Duration.toJSON(t.votingPeriod) : void 0), y;
    },
    fromPartial(t) {
      const y = B();
      return y.votingPeriod = t.votingPeriod !== void 0 && t.votingPeriod !== null ? O.Duration.fromPartial(t.votingPeriod) : void 0, y;
    }
  };
  function I() {
    return {
      quorum: "",
      threshold: "",
      vetoThreshold: ""
    };
  }
  e.TallyParams = {
    encode(t, y = T.Writer.create()) {
      return t.quorum !== "" && y.uint32(10).string(t.quorum), t.threshold !== "" && y.uint32(18).string(t.threshold), t.vetoThreshold !== "" && y.uint32(26).string(t.vetoThreshold), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = I();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.quorum = E.string();
            break;
          case 2:
            a.threshold = E.string();
            break;
          case 3:
            a.vetoThreshold = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        quorum: (0, A.isSet)(t.quorum) ? String(t.quorum) : "",
        threshold: (0, A.isSet)(t.threshold) ? String(t.threshold) : "",
        vetoThreshold: (0, A.isSet)(t.vetoThreshold) ? String(t.vetoThreshold) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.quorum !== void 0 && (y.quorum = t.quorum), t.threshold !== void 0 && (y.threshold = t.threshold), t.vetoThreshold !== void 0 && (y.vetoThreshold = t.vetoThreshold), y;
    },
    fromPartial(t) {
      const y = I();
      return y.quorum = t.quorum ?? "", y.threshold = t.threshold ?? "", y.vetoThreshold = t.vetoThreshold ?? "", y;
    }
  };
  function Z() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0,
      votingPeriod: void 0,
      quorum: "",
      threshold: "",
      vetoThreshold: "",
      minInitialDepositRatio: "",
      burnVoteQuorum: !1,
      burnProposalDepositPrevote: !1,
      burnVoteVeto: !1
    };
  }
  e.Params = {
    encode(t, y = T.Writer.create()) {
      for (const E of t.minDeposit)
        r.Coin.encode(E, y.uint32(10).fork()).ldelim();
      return t.maxDepositPeriod !== void 0 && O.Duration.encode(t.maxDepositPeriod, y.uint32(18).fork()).ldelim(), t.votingPeriod !== void 0 && O.Duration.encode(t.votingPeriod, y.uint32(26).fork()).ldelim(), t.quorum !== "" && y.uint32(34).string(t.quorum), t.threshold !== "" && y.uint32(42).string(t.threshold), t.vetoThreshold !== "" && y.uint32(50).string(t.vetoThreshold), t.minInitialDepositRatio !== "" && y.uint32(58).string(t.minInitialDepositRatio), t.burnVoteQuorum === !0 && y.uint32(104).bool(t.burnVoteQuorum), t.burnProposalDepositPrevote === !0 && y.uint32(112).bool(t.burnProposalDepositPrevote), t.burnVoteVeto === !0 && y.uint32(120).bool(t.burnVoteVeto), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = Z();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.minDeposit.push(r.Coin.decode(E, E.uint32()));
            break;
          case 2:
            a.maxDepositPeriod = O.Duration.decode(E, E.uint32());
            break;
          case 3:
            a.votingPeriod = O.Duration.decode(E, E.uint32());
            break;
          case 4:
            a.quorum = E.string();
            break;
          case 5:
            a.threshold = E.string();
            break;
          case 6:
            a.vetoThreshold = E.string();
            break;
          case 7:
            a.minInitialDepositRatio = E.string();
            break;
          case 13:
            a.burnVoteQuorum = E.bool();
            break;
          case 14:
            a.burnProposalDepositPrevote = E.bool();
            break;
          case 15:
            a.burnVoteVeto = E.bool();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        minDeposit: Array.isArray(t == null ? void 0 : t.minDeposit) ? t.minDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        maxDepositPeriod: (0, A.isSet)(t.maxDepositPeriod) ? O.Duration.fromJSON(t.maxDepositPeriod) : void 0,
        votingPeriod: (0, A.isSet)(t.votingPeriod) ? O.Duration.fromJSON(t.votingPeriod) : void 0,
        quorum: (0, A.isSet)(t.quorum) ? String(t.quorum) : "",
        threshold: (0, A.isSet)(t.threshold) ? String(t.threshold) : "",
        vetoThreshold: (0, A.isSet)(t.vetoThreshold) ? String(t.vetoThreshold) : "",
        minInitialDepositRatio: (0, A.isSet)(t.minInitialDepositRatio) ? String(t.minInitialDepositRatio) : "",
        burnVoteQuorum: (0, A.isSet)(t.burnVoteQuorum) ? !!t.burnVoteQuorum : !1,
        burnProposalDepositPrevote: (0, A.isSet)(t.burnProposalDepositPrevote) ? !!t.burnProposalDepositPrevote : !1,
        burnVoteVeto: (0, A.isSet)(t.burnVoteVeto) ? !!t.burnVoteVeto : !1
      };
    },
    toJSON(t) {
      const y = {};
      return t.minDeposit ? y.minDeposit = t.minDeposit.map((E) => E ? r.Coin.toJSON(E) : void 0) : y.minDeposit = [], t.maxDepositPeriod !== void 0 && (y.maxDepositPeriod = t.maxDepositPeriod ? O.Duration.toJSON(t.maxDepositPeriod) : void 0), t.votingPeriod !== void 0 && (y.votingPeriod = t.votingPeriod ? O.Duration.toJSON(t.votingPeriod) : void 0), t.quorum !== void 0 && (y.quorum = t.quorum), t.threshold !== void 0 && (y.threshold = t.threshold), t.vetoThreshold !== void 0 && (y.vetoThreshold = t.vetoThreshold), t.minInitialDepositRatio !== void 0 && (y.minInitialDepositRatio = t.minInitialDepositRatio), t.burnVoteQuorum !== void 0 && (y.burnVoteQuorum = t.burnVoteQuorum), t.burnProposalDepositPrevote !== void 0 && (y.burnProposalDepositPrevote = t.burnProposalDepositPrevote), t.burnVoteVeto !== void 0 && (y.burnVoteVeto = t.burnVoteVeto), y;
    },
    fromPartial(t) {
      var E;
      const y = Z();
      return y.minDeposit = ((E = t.minDeposit) == null ? void 0 : E.map((H) => r.Coin.fromPartial(H))) || [], y.maxDepositPeriod = t.maxDepositPeriod !== void 0 && t.maxDepositPeriod !== null ? O.Duration.fromPartial(t.maxDepositPeriod) : void 0, y.votingPeriod = t.votingPeriod !== void 0 && t.votingPeriod !== null ? O.Duration.fromPartial(t.votingPeriod) : void 0, y.quorum = t.quorum ?? "", y.threshold = t.threshold ?? "", y.vetoThreshold = t.vetoThreshold ?? "", y.minInitialDepositRatio = t.minInitialDepositRatio ?? "", y.burnVoteQuorum = t.burnVoteQuorum ?? !1, y.burnProposalDepositPrevote = t.burnProposalDepositPrevote ?? !1, y.burnVoteVeto = t.burnVoteVeto ?? !1, y;
    }
  };
})(Ru);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(B, I, Z, t) {
    t === void 0 && (t = Z);
    var y = Object.getOwnPropertyDescriptor(I, Z);
    (!y || ("get" in y ? !I.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return I[Z];
    } }), Object.defineProperty(B, t, y);
  } : function(B, I, Z, t) {
    t === void 0 && (t = Z), B[t] = I[Z];
  }), c = G && G.__setModuleDefault || (Object.create ? function(B, I) {
    Object.defineProperty(B, "default", { enumerable: !0, value: I });
  } : function(B, I) {
    B.default = I;
  }), i = G && G.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var I = {};
    if (B != null)
      for (var Z in B)
        Z !== "default" && Object.prototype.hasOwnProperty.call(B, Z) && n(I, B, Z);
    return c(I, B), I;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgExecLegacyContentResponse = e.MsgExecLegacyContent = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const r = Se, u = Me, f = Ru, O = oe, A = i(ie);
  e.protobufPackage = "cosmos.gov.v1";
  function T() {
    return {
      messages: [],
      initialDeposit: [],
      proposer: "",
      metadata: "",
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    encode(B, I = A.Writer.create()) {
      for (const Z of B.messages)
        r.Any.encode(Z, I.uint32(10).fork()).ldelim();
      for (const Z of B.initialDeposit)
        u.Coin.encode(Z, I.uint32(18).fork()).ldelim();
      return B.proposer !== "" && I.uint32(26).string(B.proposer), B.metadata !== "" && I.uint32(34).string(B.metadata), B.title !== "" && I.uint32(42).string(B.title), B.summary !== "" && I.uint32(50).string(B.summary), I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = T();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.messages.push(r.Any.decode(Z, Z.uint32()));
            break;
          case 2:
            y.initialDeposit.push(u.Coin.decode(Z, Z.uint32()));
            break;
          case 3:
            y.proposer = Z.string();
            break;
          case 4:
            y.metadata = Z.string();
            break;
          case 5:
            y.title = Z.string();
            break;
          case 6:
            y.summary = Z.string();
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        messages: Array.isArray(B == null ? void 0 : B.messages) ? B.messages.map((I) => r.Any.fromJSON(I)) : [],
        initialDeposit: Array.isArray(B == null ? void 0 : B.initialDeposit) ? B.initialDeposit.map((I) => u.Coin.fromJSON(I)) : [],
        proposer: (0, O.isSet)(B.proposer) ? String(B.proposer) : "",
        metadata: (0, O.isSet)(B.metadata) ? String(B.metadata) : "",
        title: (0, O.isSet)(B.title) ? String(B.title) : "",
        summary: (0, O.isSet)(B.summary) ? String(B.summary) : ""
      };
    },
    toJSON(B) {
      const I = {};
      return B.messages ? I.messages = B.messages.map((Z) => Z ? r.Any.toJSON(Z) : void 0) : I.messages = [], B.initialDeposit ? I.initialDeposit = B.initialDeposit.map((Z) => Z ? u.Coin.toJSON(Z) : void 0) : I.initialDeposit = [], B.proposer !== void 0 && (I.proposer = B.proposer), B.metadata !== void 0 && (I.metadata = B.metadata), B.title !== void 0 && (I.title = B.title), B.summary !== void 0 && (I.summary = B.summary), I;
    },
    fromPartial(B) {
      var Z, t;
      const I = T();
      return I.messages = ((Z = B.messages) == null ? void 0 : Z.map((y) => r.Any.fromPartial(y))) || [], I.initialDeposit = ((t = B.initialDeposit) == null ? void 0 : t.map((y) => u.Coin.fromPartial(y))) || [], I.proposer = B.proposer ?? "", I.metadata = B.metadata ?? "", I.title = B.title ?? "", I.summary = B.summary ?? "", I;
    }
  };
  function L() {
    return {
      proposalId: O.Long.UZERO
    };
  }
  e.MsgSubmitProposalResponse = {
    encode(B, I = A.Writer.create()) {
      return B.proposalId.isZero() || I.uint32(8).uint64(B.proposalId), I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = L();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.proposalId = Z.uint64();
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        proposalId: (0, O.isSet)(B.proposalId) ? O.Long.fromValue(B.proposalId) : O.Long.UZERO
      };
    },
    toJSON(B) {
      const I = {};
      return B.proposalId !== void 0 && (I.proposalId = (B.proposalId || O.Long.UZERO).toString()), I;
    },
    fromPartial(B) {
      const I = L();
      return I.proposalId = B.proposalId !== void 0 && B.proposalId !== null ? O.Long.fromValue(B.proposalId) : O.Long.UZERO, I;
    }
  };
  function M() {
    return {
      content: void 0,
      authority: ""
    };
  }
  e.MsgExecLegacyContent = {
    encode(B, I = A.Writer.create()) {
      return B.content !== void 0 && r.Any.encode(B.content, I.uint32(10).fork()).ldelim(), B.authority !== "" && I.uint32(18).string(B.authority), I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = M();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.content = r.Any.decode(Z, Z.uint32());
            break;
          case 2:
            y.authority = Z.string();
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        content: (0, O.isSet)(B.content) ? r.Any.fromJSON(B.content) : void 0,
        authority: (0, O.isSet)(B.authority) ? String(B.authority) : ""
      };
    },
    toJSON(B) {
      const I = {};
      return B.content !== void 0 && (I.content = B.content ? r.Any.toJSON(B.content) : void 0), B.authority !== void 0 && (I.authority = B.authority), I;
    },
    fromPartial(B) {
      const I = M();
      return I.content = B.content !== void 0 && B.content !== null ? r.Any.fromPartial(B.content) : void 0, I.authority = B.authority ?? "", I;
    }
  };
  function V() {
    return {};
  }
  e.MsgExecLegacyContentResponse = {
    encode(B, I = A.Writer.create()) {
      return I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = V();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return V();
    }
  };
  function D() {
    return {
      proposalId: O.Long.UZERO,
      voter: "",
      option: 0,
      metadata: ""
    };
  }
  e.MsgVote = {
    encode(B, I = A.Writer.create()) {
      return B.proposalId.isZero() || I.uint32(8).uint64(B.proposalId), B.voter !== "" && I.uint32(18).string(B.voter), B.option !== 0 && I.uint32(24).int32(B.option), B.metadata !== "" && I.uint32(34).string(B.metadata), I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = D();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.proposalId = Z.uint64();
            break;
          case 2:
            y.voter = Z.string();
            break;
          case 3:
            y.option = Z.int32();
            break;
          case 4:
            y.metadata = Z.string();
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        proposalId: (0, O.isSet)(B.proposalId) ? O.Long.fromValue(B.proposalId) : O.Long.UZERO,
        voter: (0, O.isSet)(B.voter) ? String(B.voter) : "",
        option: (0, O.isSet)(B.option) ? (0, f.voteOptionFromJSON)(B.option) : 0,
        metadata: (0, O.isSet)(B.metadata) ? String(B.metadata) : ""
      };
    },
    toJSON(B) {
      const I = {};
      return B.proposalId !== void 0 && (I.proposalId = (B.proposalId || O.Long.UZERO).toString()), B.voter !== void 0 && (I.voter = B.voter), B.option !== void 0 && (I.option = (0, f.voteOptionToJSON)(B.option)), B.metadata !== void 0 && (I.metadata = B.metadata), I;
    },
    fromPartial(B) {
      const I = D();
      return I.proposalId = B.proposalId !== void 0 && B.proposalId !== null ? O.Long.fromValue(B.proposalId) : O.Long.UZERO, I.voter = B.voter ?? "", I.option = B.option ?? 0, I.metadata = B.metadata ?? "", I;
    }
  };
  function b() {
    return {};
  }
  e.MsgVoteResponse = {
    encode(B, I = A.Writer.create()) {
      return I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = b();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return b();
    }
  };
  function h() {
    return {
      proposalId: O.Long.UZERO,
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.MsgVoteWeighted = {
    encode(B, I = A.Writer.create()) {
      B.proposalId.isZero() || I.uint32(8).uint64(B.proposalId), B.voter !== "" && I.uint32(18).string(B.voter);
      for (const Z of B.options)
        f.WeightedVoteOption.encode(Z, I.uint32(26).fork()).ldelim();
      return B.metadata !== "" && I.uint32(34).string(B.metadata), I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = h();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.proposalId = Z.uint64();
            break;
          case 2:
            y.voter = Z.string();
            break;
          case 3:
            y.options.push(f.WeightedVoteOption.decode(Z, Z.uint32()));
            break;
          case 4:
            y.metadata = Z.string();
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        proposalId: (0, O.isSet)(B.proposalId) ? O.Long.fromValue(B.proposalId) : O.Long.UZERO,
        voter: (0, O.isSet)(B.voter) ? String(B.voter) : "",
        options: Array.isArray(B == null ? void 0 : B.options) ? B.options.map((I) => f.WeightedVoteOption.fromJSON(I)) : [],
        metadata: (0, O.isSet)(B.metadata) ? String(B.metadata) : ""
      };
    },
    toJSON(B) {
      const I = {};
      return B.proposalId !== void 0 && (I.proposalId = (B.proposalId || O.Long.UZERO).toString()), B.voter !== void 0 && (I.voter = B.voter), B.options ? I.options = B.options.map((Z) => Z ? f.WeightedVoteOption.toJSON(Z) : void 0) : I.options = [], B.metadata !== void 0 && (I.metadata = B.metadata), I;
    },
    fromPartial(B) {
      var Z;
      const I = h();
      return I.proposalId = B.proposalId !== void 0 && B.proposalId !== null ? O.Long.fromValue(B.proposalId) : O.Long.UZERO, I.voter = B.voter ?? "", I.options = ((Z = B.options) == null ? void 0 : Z.map((t) => f.WeightedVoteOption.fromPartial(t))) || [], I.metadata = B.metadata ?? "", I;
    }
  };
  function S() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    encode(B, I = A.Writer.create()) {
      return I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = S();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return S();
    }
  };
  function _() {
    return {
      proposalId: O.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    encode(B, I = A.Writer.create()) {
      B.proposalId.isZero() || I.uint32(8).uint64(B.proposalId), B.depositor !== "" && I.uint32(18).string(B.depositor);
      for (const Z of B.amount)
        u.Coin.encode(Z, I.uint32(26).fork()).ldelim();
      return I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = _();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.proposalId = Z.uint64();
            break;
          case 2:
            y.depositor = Z.string();
            break;
          case 3:
            y.amount.push(u.Coin.decode(Z, Z.uint32()));
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        proposalId: (0, O.isSet)(B.proposalId) ? O.Long.fromValue(B.proposalId) : O.Long.UZERO,
        depositor: (0, O.isSet)(B.depositor) ? String(B.depositor) : "",
        amount: Array.isArray(B == null ? void 0 : B.amount) ? B.amount.map((I) => u.Coin.fromJSON(I)) : []
      };
    },
    toJSON(B) {
      const I = {};
      return B.proposalId !== void 0 && (I.proposalId = (B.proposalId || O.Long.UZERO).toString()), B.depositor !== void 0 && (I.depositor = B.depositor), B.amount ? I.amount = B.amount.map((Z) => Z ? u.Coin.toJSON(Z) : void 0) : I.amount = [], I;
    },
    fromPartial(B) {
      var Z;
      const I = _();
      return I.proposalId = B.proposalId !== void 0 && B.proposalId !== null ? O.Long.fromValue(B.proposalId) : O.Long.UZERO, I.depositor = B.depositor ?? "", I.amount = ((Z = B.amount) == null ? void 0 : Z.map((t) => u.Coin.fromPartial(t))) || [], I;
    }
  };
  function d() {
    return {};
  }
  e.MsgDepositResponse = {
    encode(B, I = A.Writer.create()) {
      return I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = d();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return d();
    }
  };
  function p() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(B, I = A.Writer.create()) {
      return B.authority !== "" && I.uint32(10).string(B.authority), B.params !== void 0 && f.Params.encode(B.params, I.uint32(18).fork()).ldelim(), I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = p();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          case 1:
            y.authority = Z.string();
            break;
          case 2:
            y.params = f.Params.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {
        authority: (0, O.isSet)(B.authority) ? String(B.authority) : "",
        params: (0, O.isSet)(B.params) ? f.Params.fromJSON(B.params) : void 0
      };
    },
    toJSON(B) {
      const I = {};
      return B.authority !== void 0 && (I.authority = B.authority), B.params !== void 0 && (I.params = B.params ? f.Params.toJSON(B.params) : void 0), I;
    },
    fromPartial(B) {
      const I = p();
      return I.authority = B.authority ?? "", I.params = B.params !== void 0 && B.params !== null ? f.Params.fromPartial(B.params) : void 0, I;
    }
  };
  function g() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(B, I = A.Writer.create()) {
      return I;
    },
    decode(B, I) {
      const Z = B instanceof A.Reader ? B : new A.Reader(B);
      let t = I === void 0 ? Z.len : Z.pos + I;
      const y = g();
      for (; Z.pos < t; ) {
        const E = Z.uint32();
        switch (E >>> 3) {
          default:
            Z.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return g();
    }
  };
  class J {
    constructor(I) {
      this.rpc = I, this.SubmitProposal = this.SubmitProposal.bind(this), this.ExecLegacyContent = this.ExecLegacyContent.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    SubmitProposal(I) {
      const Z = e.MsgSubmitProposal.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", Z).then((y) => e.MsgSubmitProposalResponse.decode(new A.Reader(y)));
    }
    ExecLegacyContent(I) {
      const Z = e.MsgExecLegacyContent.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", Z).then((y) => e.MsgExecLegacyContentResponse.decode(new A.Reader(y)));
    }
    Vote(I) {
      const Z = e.MsgVote.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Vote", Z).then((y) => e.MsgVoteResponse.decode(new A.Reader(y)));
    }
    VoteWeighted(I) {
      const Z = e.MsgVoteWeighted.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", Z).then((y) => e.MsgVoteWeightedResponse.decode(new A.Reader(y)));
    }
    Deposit(I) {
      const Z = e.MsgDeposit.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Deposit", Z).then((y) => e.MsgDepositResponse.decode(new A.Reader(y)));
    }
    UpdateParams(I) {
      const Z = e.MsgUpdateParams.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", Z).then((y) => e.MsgUpdateParamsResponse.decode(new A.Reader(y)));
    }
  }
  e.MsgClientImpl = J;
})(Ou);
var Pu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(d, p, g, J) {
    J === void 0 && (J = g);
    var B = Object.getOwnPropertyDescriptor(p, g);
    (!B || ("get" in B ? !p.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return p[g];
    } }), Object.defineProperty(d, J, B);
  } : function(d, p, g, J) {
    J === void 0 && (J = g), d[J] = p[g];
  }), c = G && G.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), i = G && G.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var g in d)
        g !== "default" && Object.prototype.hasOwnProperty.call(d, g) && n(p, d, g);
    return c(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const r = Se, u = Me, f = oi, O = oe, A = i(ie);
  e.protobufPackage = "cosmos.gov.v1beta1";
  function T() {
    return {
      content: void 0,
      initialDeposit: [],
      proposer: ""
    };
  }
  e.MsgSubmitProposal = {
    encode(d, p = A.Writer.create()) {
      d.content !== void 0 && r.Any.encode(d.content, p.uint32(10).fork()).ldelim();
      for (const g of d.initialDeposit)
        u.Coin.encode(g, p.uint32(18).fork()).ldelim();
      return d.proposer !== "" && p.uint32(26).string(d.proposer), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = T();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.content = r.Any.decode(g, g.uint32());
            break;
          case 2:
            B.initialDeposit.push(u.Coin.decode(g, g.uint32()));
            break;
          case 3:
            B.proposer = g.string();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        content: (0, O.isSet)(d.content) ? r.Any.fromJSON(d.content) : void 0,
        initialDeposit: Array.isArray(d == null ? void 0 : d.initialDeposit) ? d.initialDeposit.map((p) => u.Coin.fromJSON(p)) : [],
        proposer: (0, O.isSet)(d.proposer) ? String(d.proposer) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.content !== void 0 && (p.content = d.content ? r.Any.toJSON(d.content) : void 0), d.initialDeposit ? p.initialDeposit = d.initialDeposit.map((g) => g ? u.Coin.toJSON(g) : void 0) : p.initialDeposit = [], d.proposer !== void 0 && (p.proposer = d.proposer), p;
    },
    fromPartial(d) {
      var g;
      const p = T();
      return p.content = d.content !== void 0 && d.content !== null ? r.Any.fromPartial(d.content) : void 0, p.initialDeposit = ((g = d.initialDeposit) == null ? void 0 : g.map((J) => u.Coin.fromPartial(J))) || [], p.proposer = d.proposer ?? "", p;
    }
  };
  function L() {
    return {
      proposalId: O.Long.UZERO
    };
  }
  e.MsgSubmitProposalResponse = {
    encode(d, p = A.Writer.create()) {
      return d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = L();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.proposalId = g.uint64();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        proposalId: (0, O.isSet)(d.proposalId) ? O.Long.fromValue(d.proposalId) : O.Long.UZERO
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || O.Long.UZERO).toString()), p;
    },
    fromPartial(d) {
      const p = L();
      return p.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? O.Long.fromValue(d.proposalId) : O.Long.UZERO, p;
    }
  };
  function M() {
    return {
      proposalId: O.Long.UZERO,
      voter: "",
      option: 0
    };
  }
  e.MsgVote = {
    encode(d, p = A.Writer.create()) {
      return d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), d.voter !== "" && p.uint32(18).string(d.voter), d.option !== 0 && p.uint32(24).int32(d.option), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = M();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.proposalId = g.uint64();
            break;
          case 2:
            B.voter = g.string();
            break;
          case 3:
            B.option = g.int32();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        proposalId: (0, O.isSet)(d.proposalId) ? O.Long.fromValue(d.proposalId) : O.Long.UZERO,
        voter: (0, O.isSet)(d.voter) ? String(d.voter) : "",
        option: (0, O.isSet)(d.option) ? (0, f.voteOptionFromJSON)(d.option) : 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || O.Long.UZERO).toString()), d.voter !== void 0 && (p.voter = d.voter), d.option !== void 0 && (p.option = (0, f.voteOptionToJSON)(d.option)), p;
    },
    fromPartial(d) {
      const p = M();
      return p.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? O.Long.fromValue(d.proposalId) : O.Long.UZERO, p.voter = d.voter ?? "", p.option = d.option ?? 0, p;
    }
  };
  function V() {
    return {};
  }
  e.MsgVoteResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = V();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return V();
    }
  };
  function D() {
    return {
      proposalId: O.Long.UZERO,
      voter: "",
      options: []
    };
  }
  e.MsgVoteWeighted = {
    encode(d, p = A.Writer.create()) {
      d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), d.voter !== "" && p.uint32(18).string(d.voter);
      for (const g of d.options)
        f.WeightedVoteOption.encode(g, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = D();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.proposalId = g.uint64();
            break;
          case 2:
            B.voter = g.string();
            break;
          case 3:
            B.options.push(f.WeightedVoteOption.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        proposalId: (0, O.isSet)(d.proposalId) ? O.Long.fromValue(d.proposalId) : O.Long.UZERO,
        voter: (0, O.isSet)(d.voter) ? String(d.voter) : "",
        options: Array.isArray(d == null ? void 0 : d.options) ? d.options.map((p) => f.WeightedVoteOption.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || O.Long.UZERO).toString()), d.voter !== void 0 && (p.voter = d.voter), d.options ? p.options = d.options.map((g) => g ? f.WeightedVoteOption.toJSON(g) : void 0) : p.options = [], p;
    },
    fromPartial(d) {
      var g;
      const p = D();
      return p.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? O.Long.fromValue(d.proposalId) : O.Long.UZERO, p.voter = d.voter ?? "", p.options = ((g = d.options) == null ? void 0 : g.map((J) => f.WeightedVoteOption.fromPartial(J))) || [], p;
    }
  };
  function b() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = b();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return b();
    }
  };
  function h() {
    return {
      proposalId: O.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    encode(d, p = A.Writer.create()) {
      d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), d.depositor !== "" && p.uint32(18).string(d.depositor);
      for (const g of d.amount)
        u.Coin.encode(g, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = h();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.proposalId = g.uint64();
            break;
          case 2:
            B.depositor = g.string();
            break;
          case 3:
            B.amount.push(u.Coin.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        proposalId: (0, O.isSet)(d.proposalId) ? O.Long.fromValue(d.proposalId) : O.Long.UZERO,
        depositor: (0, O.isSet)(d.depositor) ? String(d.depositor) : "",
        amount: Array.isArray(d == null ? void 0 : d.amount) ? d.amount.map((p) => u.Coin.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || O.Long.UZERO).toString()), d.depositor !== void 0 && (p.depositor = d.depositor), d.amount ? p.amount = d.amount.map((g) => g ? u.Coin.toJSON(g) : void 0) : p.amount = [], p;
    },
    fromPartial(d) {
      var g;
      const p = h();
      return p.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? O.Long.fromValue(d.proposalId) : O.Long.UZERO, p.depositor = d.depositor ?? "", p.amount = ((g = d.amount) == null ? void 0 : g.map((J) => u.Coin.fromPartial(J))) || [], p;
    }
  };
  function S() {
    return {};
  }
  e.MsgDepositResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = S();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return S();
    }
  };
  class _ {
    constructor(p) {
      this.rpc = p, this.SubmitProposal = this.SubmitProposal.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this);
    }
    SubmitProposal(p) {
      const g = e.MsgSubmitProposal.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", g).then((B) => e.MsgSubmitProposalResponse.decode(new A.Reader(B)));
    }
    Vote(p) {
      const g = e.MsgVote.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", g).then((B) => e.MsgVoteResponse.decode(new A.Reader(B)));
    }
    VoteWeighted(p) {
      const g = e.MsgVoteWeighted.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", g).then((B) => e.MsgVoteWeightedResponse.decode(new A.Reader(B)));
    }
    Deposit(p) {
      const g = e.MsgDeposit.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", g).then((B) => e.MsgDepositResponse.decode(new A.Reader(B)));
    }
  }
  e.MsgClientImpl = _;
})(Pu);
Object.defineProperty(an, "__esModule", { value: !0 });
an.isMsgVoteWeightedEncodeObject = an.isMsgVoteEncodeObject = an.isMsgSubmitProposalEncodeObject = an.isMsgDepositEncodeObject = an.govTypes = void 0;
const Zt = Ou, mr = Pu;
an.govTypes = [
  ["/cosmos.gov.v1.MsgDeposit", Zt.MsgDeposit],
  ["/cosmos.gov.v1.MsgSubmitProposal", Zt.MsgSubmitProposal],
  ["/cosmos.gov.v1.MsgUpdateParams", Zt.MsgUpdateParams],
  ["/cosmos.gov.v1.MsgVote", Zt.MsgVote],
  ["/cosmos.gov.v1.MsgVoteWeighted", Zt.MsgVoteWeighted],
  ["/cosmos.gov.v1beta1.MsgDeposit", mr.MsgDeposit],
  ["/cosmos.gov.v1beta1.MsgSubmitProposal", mr.MsgSubmitProposal],
  ["/cosmos.gov.v1beta1.MsgVote", mr.MsgVote],
  ["/cosmos.gov.v1beta1.MsgVoteWeighted", mr.MsgVoteWeighted]
];
function Rh(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
}
an.isMsgDepositEncodeObject = Rh;
function Ph(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
}
an.isMsgSubmitProposalEncodeObject = Ph;
function vh(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
}
an.isMsgVoteEncodeObject = vh;
function kh(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
}
an.isMsgVoteWeightedEncodeObject = kh;
var ai = {}, vu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(t, y, E, H) {
    H === void 0 && (H = E);
    var a = Object.getOwnPropertyDescriptor(y, E);
    (!a || ("get" in a ? !y.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return y[E];
    } }), Object.defineProperty(t, H, a);
  } : function(t, y, E, H) {
    H === void 0 && (H = E), t[H] = y[E];
  }), c = G && G.__setModuleDefault || (Object.create ? function(t, y) {
    Object.defineProperty(t, "default", { enumerable: !0, value: y });
  } : function(t, y) {
    t.default = y;
  }), i = G && G.__importStar || function(t) {
    if (t && t.__esModule)
      return t;
    var y = {};
    if (t != null)
      for (var E in t)
        E !== "default" && Object.prototype.hasOwnProperty.call(t, E) && n(y, t, E);
    return c(y, t), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryTallyResultResponse = e.QueryTallyResultRequest = e.QueryDepositsResponse = e.QueryDepositsRequest = e.QueryDepositResponse = e.QueryDepositRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryVotesResponse = e.QueryVotesRequest = e.QueryVoteResponse = e.QueryVoteRequest = e.QueryProposalsResponse = e.QueryProposalsRequest = e.QueryProposalResponse = e.QueryProposalRequest = e.protobufPackage = void 0;
  const r = oi, u = Re, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.gov.v1beta1";
  function A() {
    return {
      proposalId: f.Long.UZERO
    };
  }
  e.QueryProposalRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = A();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, f.isSet)(t.proposalId) ? f.Long.fromValue(t.proposalId) : f.Long.UZERO
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || f.Long.UZERO).toString()), y;
    },
    fromPartial(t) {
      const y = A();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? f.Long.fromValue(t.proposalId) : f.Long.UZERO, y;
    }
  };
  function T() {
    return {
      proposal: void 0
    };
  }
  e.QueryProposalResponse = {
    encode(t, y = O.Writer.create()) {
      return t.proposal !== void 0 && r.Proposal.encode(t.proposal, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = T();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposal = r.Proposal.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposal: (0, f.isSet)(t.proposal) ? r.Proposal.fromJSON(t.proposal) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposal !== void 0 && (y.proposal = t.proposal ? r.Proposal.toJSON(t.proposal) : void 0), y;
    },
    fromPartial(t) {
      const y = T();
      return y.proposal = t.proposal !== void 0 && t.proposal !== null ? r.Proposal.fromPartial(t.proposal) : void 0, y;
    }
  };
  function L() {
    return {
      proposalStatus: 0,
      voter: "",
      depositor: "",
      pagination: void 0
    };
  }
  e.QueryProposalsRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalStatus !== 0 && y.uint32(8).int32(t.proposalStatus), t.voter !== "" && y.uint32(18).string(t.voter), t.depositor !== "" && y.uint32(26).string(t.depositor), t.pagination !== void 0 && u.PageRequest.encode(t.pagination, y.uint32(34).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = L();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalStatus = E.int32();
            break;
          case 2:
            a.voter = E.string();
            break;
          case 3:
            a.depositor = E.string();
            break;
          case 4:
            a.pagination = u.PageRequest.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalStatus: (0, f.isSet)(t.proposalStatus) ? (0, r.proposalStatusFromJSON)(t.proposalStatus) : 0,
        voter: (0, f.isSet)(t.voter) ? String(t.voter) : "",
        depositor: (0, f.isSet)(t.depositor) ? String(t.depositor) : "",
        pagination: (0, f.isSet)(t.pagination) ? u.PageRequest.fromJSON(t.pagination) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalStatus !== void 0 && (y.proposalStatus = (0, r.proposalStatusToJSON)(t.proposalStatus)), t.voter !== void 0 && (y.voter = t.voter), t.depositor !== void 0 && (y.depositor = t.depositor), t.pagination !== void 0 && (y.pagination = t.pagination ? u.PageRequest.toJSON(t.pagination) : void 0), y;
    },
    fromPartial(t) {
      const y = L();
      return y.proposalStatus = t.proposalStatus ?? 0, y.voter = t.voter ?? "", y.depositor = t.depositor ?? "", y.pagination = t.pagination !== void 0 && t.pagination !== null ? u.PageRequest.fromPartial(t.pagination) : void 0, y;
    }
  };
  function M() {
    return {
      proposals: [],
      pagination: void 0
    };
  }
  e.QueryProposalsResponse = {
    encode(t, y = O.Writer.create()) {
      for (const E of t.proposals)
        r.Proposal.encode(E, y.uint32(10).fork()).ldelim();
      return t.pagination !== void 0 && u.PageResponse.encode(t.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = M();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposals.push(r.Proposal.decode(E, E.uint32()));
            break;
          case 2:
            a.pagination = u.PageResponse.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposals: Array.isArray(t == null ? void 0 : t.proposals) ? t.proposals.map((y) => r.Proposal.fromJSON(y)) : [],
        pagination: (0, f.isSet)(t.pagination) ? u.PageResponse.fromJSON(t.pagination) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposals ? y.proposals = t.proposals.map((E) => E ? r.Proposal.toJSON(E) : void 0) : y.proposals = [], t.pagination !== void 0 && (y.pagination = t.pagination ? u.PageResponse.toJSON(t.pagination) : void 0), y;
    },
    fromPartial(t) {
      var E;
      const y = M();
      return y.proposals = ((E = t.proposals) == null ? void 0 : E.map((H) => r.Proposal.fromPartial(H))) || [], y.pagination = t.pagination !== void 0 && t.pagination !== null ? u.PageResponse.fromPartial(t.pagination) : void 0, y;
    }
  };
  function V() {
    return {
      proposalId: f.Long.UZERO,
      voter: ""
    };
  }
  e.QueryVoteRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.voter !== "" && y.uint32(18).string(t.voter), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = V();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.voter = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, f.isSet)(t.proposalId) ? f.Long.fromValue(t.proposalId) : f.Long.UZERO,
        voter: (0, f.isSet)(t.voter) ? String(t.voter) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || f.Long.UZERO).toString()), t.voter !== void 0 && (y.voter = t.voter), y;
    },
    fromPartial(t) {
      const y = V();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? f.Long.fromValue(t.proposalId) : f.Long.UZERO, y.voter = t.voter ?? "", y;
    }
  };
  function D() {
    return {
      vote: void 0
    };
  }
  e.QueryVoteResponse = {
    encode(t, y = O.Writer.create()) {
      return t.vote !== void 0 && r.Vote.encode(t.vote, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = D();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.vote = r.Vote.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        vote: (0, f.isSet)(t.vote) ? r.Vote.fromJSON(t.vote) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.vote !== void 0 && (y.vote = t.vote ? r.Vote.toJSON(t.vote) : void 0), y;
    },
    fromPartial(t) {
      const y = D();
      return y.vote = t.vote !== void 0 && t.vote !== null ? r.Vote.fromPartial(t.vote) : void 0, y;
    }
  };
  function b() {
    return {
      proposalId: f.Long.UZERO,
      pagination: void 0
    };
  }
  e.QueryVotesRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.pagination !== void 0 && u.PageRequest.encode(t.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = b();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.pagination = u.PageRequest.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, f.isSet)(t.proposalId) ? f.Long.fromValue(t.proposalId) : f.Long.UZERO,
        pagination: (0, f.isSet)(t.pagination) ? u.PageRequest.fromJSON(t.pagination) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || f.Long.UZERO).toString()), t.pagination !== void 0 && (y.pagination = t.pagination ? u.PageRequest.toJSON(t.pagination) : void 0), y;
    },
    fromPartial(t) {
      const y = b();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? f.Long.fromValue(t.proposalId) : f.Long.UZERO, y.pagination = t.pagination !== void 0 && t.pagination !== null ? u.PageRequest.fromPartial(t.pagination) : void 0, y;
    }
  };
  function h() {
    return {
      votes: [],
      pagination: void 0
    };
  }
  e.QueryVotesResponse = {
    encode(t, y = O.Writer.create()) {
      for (const E of t.votes)
        r.Vote.encode(E, y.uint32(10).fork()).ldelim();
      return t.pagination !== void 0 && u.PageResponse.encode(t.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = h();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.votes.push(r.Vote.decode(E, E.uint32()));
            break;
          case 2:
            a.pagination = u.PageResponse.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        votes: Array.isArray(t == null ? void 0 : t.votes) ? t.votes.map((y) => r.Vote.fromJSON(y)) : [],
        pagination: (0, f.isSet)(t.pagination) ? u.PageResponse.fromJSON(t.pagination) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.votes ? y.votes = t.votes.map((E) => E ? r.Vote.toJSON(E) : void 0) : y.votes = [], t.pagination !== void 0 && (y.pagination = t.pagination ? u.PageResponse.toJSON(t.pagination) : void 0), y;
    },
    fromPartial(t) {
      var E;
      const y = h();
      return y.votes = ((E = t.votes) == null ? void 0 : E.map((H) => r.Vote.fromPartial(H))) || [], y.pagination = t.pagination !== void 0 && t.pagination !== null ? u.PageResponse.fromPartial(t.pagination) : void 0, y;
    }
  };
  function S() {
    return {
      paramsType: ""
    };
  }
  e.QueryParamsRequest = {
    encode(t, y = O.Writer.create()) {
      return t.paramsType !== "" && y.uint32(10).string(t.paramsType), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = S();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.paramsType = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        paramsType: (0, f.isSet)(t.paramsType) ? String(t.paramsType) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.paramsType !== void 0 && (y.paramsType = t.paramsType), y;
    },
    fromPartial(t) {
      const y = S();
      return y.paramsType = t.paramsType ?? "", y;
    }
  };
  function _() {
    return {
      votingParams: void 0,
      depositParams: void 0,
      tallyParams: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(t, y = O.Writer.create()) {
      return t.votingParams !== void 0 && r.VotingParams.encode(t.votingParams, y.uint32(10).fork()).ldelim(), t.depositParams !== void 0 && r.DepositParams.encode(t.depositParams, y.uint32(18).fork()).ldelim(), t.tallyParams !== void 0 && r.TallyParams.encode(t.tallyParams, y.uint32(26).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = _();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.votingParams = r.VotingParams.decode(E, E.uint32());
            break;
          case 2:
            a.depositParams = r.DepositParams.decode(E, E.uint32());
            break;
          case 3:
            a.tallyParams = r.TallyParams.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        votingParams: (0, f.isSet)(t.votingParams) ? r.VotingParams.fromJSON(t.votingParams) : void 0,
        depositParams: (0, f.isSet)(t.depositParams) ? r.DepositParams.fromJSON(t.depositParams) : void 0,
        tallyParams: (0, f.isSet)(t.tallyParams) ? r.TallyParams.fromJSON(t.tallyParams) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.votingParams !== void 0 && (y.votingParams = t.votingParams ? r.VotingParams.toJSON(t.votingParams) : void 0), t.depositParams !== void 0 && (y.depositParams = t.depositParams ? r.DepositParams.toJSON(t.depositParams) : void 0), t.tallyParams !== void 0 && (y.tallyParams = t.tallyParams ? r.TallyParams.toJSON(t.tallyParams) : void 0), y;
    },
    fromPartial(t) {
      const y = _();
      return y.votingParams = t.votingParams !== void 0 && t.votingParams !== null ? r.VotingParams.fromPartial(t.votingParams) : void 0, y.depositParams = t.depositParams !== void 0 && t.depositParams !== null ? r.DepositParams.fromPartial(t.depositParams) : void 0, y.tallyParams = t.tallyParams !== void 0 && t.tallyParams !== null ? r.TallyParams.fromPartial(t.tallyParams) : void 0, y;
    }
  };
  function d() {
    return {
      proposalId: f.Long.UZERO,
      depositor: ""
    };
  }
  e.QueryDepositRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.depositor !== "" && y.uint32(18).string(t.depositor), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = d();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.depositor = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, f.isSet)(t.proposalId) ? f.Long.fromValue(t.proposalId) : f.Long.UZERO,
        depositor: (0, f.isSet)(t.depositor) ? String(t.depositor) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || f.Long.UZERO).toString()), t.depositor !== void 0 && (y.depositor = t.depositor), y;
    },
    fromPartial(t) {
      const y = d();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? f.Long.fromValue(t.proposalId) : f.Long.UZERO, y.depositor = t.depositor ?? "", y;
    }
  };
  function p() {
    return {
      deposit: void 0
    };
  }
  e.QueryDepositResponse = {
    encode(t, y = O.Writer.create()) {
      return t.deposit !== void 0 && r.Deposit.encode(t.deposit, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = p();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.deposit = r.Deposit.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        deposit: (0, f.isSet)(t.deposit) ? r.Deposit.fromJSON(t.deposit) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.deposit !== void 0 && (y.deposit = t.deposit ? r.Deposit.toJSON(t.deposit) : void 0), y;
    },
    fromPartial(t) {
      const y = p();
      return y.deposit = t.deposit !== void 0 && t.deposit !== null ? r.Deposit.fromPartial(t.deposit) : void 0, y;
    }
  };
  function g() {
    return {
      proposalId: f.Long.UZERO,
      pagination: void 0
    };
  }
  e.QueryDepositsRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), t.pagination !== void 0 && u.PageRequest.encode(t.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = g();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          case 2:
            a.pagination = u.PageRequest.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, f.isSet)(t.proposalId) ? f.Long.fromValue(t.proposalId) : f.Long.UZERO,
        pagination: (0, f.isSet)(t.pagination) ? u.PageRequest.fromJSON(t.pagination) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || f.Long.UZERO).toString()), t.pagination !== void 0 && (y.pagination = t.pagination ? u.PageRequest.toJSON(t.pagination) : void 0), y;
    },
    fromPartial(t) {
      const y = g();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? f.Long.fromValue(t.proposalId) : f.Long.UZERO, y.pagination = t.pagination !== void 0 && t.pagination !== null ? u.PageRequest.fromPartial(t.pagination) : void 0, y;
    }
  };
  function J() {
    return {
      deposits: [],
      pagination: void 0
    };
  }
  e.QueryDepositsResponse = {
    encode(t, y = O.Writer.create()) {
      for (const E of t.deposits)
        r.Deposit.encode(E, y.uint32(10).fork()).ldelim();
      return t.pagination !== void 0 && u.PageResponse.encode(t.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = J();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.deposits.push(r.Deposit.decode(E, E.uint32()));
            break;
          case 2:
            a.pagination = u.PageResponse.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        deposits: Array.isArray(t == null ? void 0 : t.deposits) ? t.deposits.map((y) => r.Deposit.fromJSON(y)) : [],
        pagination: (0, f.isSet)(t.pagination) ? u.PageResponse.fromJSON(t.pagination) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.deposits ? y.deposits = t.deposits.map((E) => E ? r.Deposit.toJSON(E) : void 0) : y.deposits = [], t.pagination !== void 0 && (y.pagination = t.pagination ? u.PageResponse.toJSON(t.pagination) : void 0), y;
    },
    fromPartial(t) {
      var E;
      const y = J();
      return y.deposits = ((E = t.deposits) == null ? void 0 : E.map((H) => r.Deposit.fromPartial(H))) || [], y.pagination = t.pagination !== void 0 && t.pagination !== null ? u.PageResponse.fromPartial(t.pagination) : void 0, y;
    }
  };
  function B() {
    return {
      proposalId: f.Long.UZERO
    };
  }
  e.QueryTallyResultRequest = {
    encode(t, y = O.Writer.create()) {
      return t.proposalId.isZero() || y.uint32(8).uint64(t.proposalId), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = B();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.proposalId = E.uint64();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        proposalId: (0, f.isSet)(t.proposalId) ? f.Long.fromValue(t.proposalId) : f.Long.UZERO
      };
    },
    toJSON(t) {
      const y = {};
      return t.proposalId !== void 0 && (y.proposalId = (t.proposalId || f.Long.UZERO).toString()), y;
    },
    fromPartial(t) {
      const y = B();
      return y.proposalId = t.proposalId !== void 0 && t.proposalId !== null ? f.Long.fromValue(t.proposalId) : f.Long.UZERO, y;
    }
  };
  function I() {
    return {
      tally: void 0
    };
  }
  e.QueryTallyResultResponse = {
    encode(t, y = O.Writer.create()) {
      return t.tally !== void 0 && r.TallyResult.encode(t.tally, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof O.Reader ? t : new O.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = I();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.tally = r.TallyResult.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        tally: (0, f.isSet)(t.tally) ? r.TallyResult.fromJSON(t.tally) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.tally !== void 0 && (y.tally = t.tally ? r.TallyResult.toJSON(t.tally) : void 0), y;
    },
    fromPartial(t) {
      const y = I();
      return y.tally = t.tally !== void 0 && t.tally !== null ? r.TallyResult.fromPartial(t.tally) : void 0, y;
    }
  };
  class Z {
    constructor(y) {
      this.rpc = y, this.Proposal = this.Proposal.bind(this), this.Proposals = this.Proposals.bind(this), this.Vote = this.Vote.bind(this), this.Votes = this.Votes.bind(this), this.Params = this.Params.bind(this), this.Deposit = this.Deposit.bind(this), this.Deposits = this.Deposits.bind(this), this.TallyResult = this.TallyResult.bind(this);
    }
    Proposal(y) {
      const E = e.QueryProposalRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", E).then((a) => e.QueryProposalResponse.decode(new O.Reader(a)));
    }
    Proposals(y) {
      const E = e.QueryProposalsRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", E).then((a) => e.QueryProposalsResponse.decode(new O.Reader(a)));
    }
    Vote(y) {
      const E = e.QueryVoteRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", E).then((a) => e.QueryVoteResponse.decode(new O.Reader(a)));
    }
    Votes(y) {
      const E = e.QueryVotesRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", E).then((a) => e.QueryVotesResponse.decode(new O.Reader(a)));
    }
    Params(y) {
      const E = e.QueryParamsRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Params", E).then((a) => e.QueryParamsResponse.decode(new O.Reader(a)));
    }
    Deposit(y) {
      const E = e.QueryDepositRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", E).then((a) => e.QueryDepositResponse.decode(new O.Reader(a)));
    }
    Deposits(y) {
      const E = e.QueryDepositsRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", E).then((a) => e.QueryDepositsResponse.decode(new O.Reader(a)));
    }
    TallyResult(y) {
      const E = e.QueryTallyResultRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", E).then((a) => e.QueryTallyResultResponse.decode(new O.Reader(a)));
    }
  }
  e.QueryClientImpl = Z;
})(vu);
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.setupGovExtension = void 0;
const Ah = vu, Sn = Le;
function _h(e) {
  const n = (0, Sn.createProtobufRpcClient)(e), c = new Ah.QueryClientImpl(n);
  return {
    gov: {
      params: async (i) => await c.Params({ paramsType: i }),
      proposals: async (i, r, u, f) => await c.Proposals({
        proposalStatus: i,
        depositor: r,
        voter: u,
        pagination: (0, Sn.createPagination)(f)
      }),
      proposal: async (i) => await c.Proposal({ proposalId: (0, Sn.longify)(i) }),
      deposits: async (i, r) => await c.Deposits({
        proposalId: (0, Sn.longify)(i),
        pagination: (0, Sn.createPagination)(r)
      }),
      deposit: async (i, r) => await c.Deposit({
        proposalId: (0, Sn.longify)(i),
        depositor: r
      }),
      tally: async (i) => await c.TallyResult({
        proposalId: (0, Sn.longify)(i)
      }),
      votes: async (i, r) => await c.Votes({
        proposalId: (0, Sn.longify)(i),
        pagination: (0, Sn.createPagination)(r)
      }),
      vote: async (i, r) => await c.Vote({
        proposalId: (0, Sn.longify)(i),
        voter: r
      })
    }
  };
}
ai.setupGovExtension = _h;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.createGroupAminoConverters = void 0;
function Nh() {
  return {};
}
si.createGroupAminoConverters = Nh;
var di = {}, ku = {}, Au = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(a, l, C, v) {
    v === void 0 && (v = C);
    var k = Object.getOwnPropertyDescriptor(l, C);
    (!k || ("get" in k ? !l.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return l[C];
    } }), Object.defineProperty(a, v, k);
  } : function(a, l, C, v) {
    v === void 0 && (v = C), a[v] = l[C];
  }), c = G && G.__setModuleDefault || (Object.create ? function(a, l) {
    Object.defineProperty(a, "default", { enumerable: !0, value: l });
  } : function(a, l) {
    a.default = l;
  }), i = G && G.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var l = {};
    if (a != null)
      for (var C in a)
        C !== "default" && Object.prototype.hasOwnProperty.call(a, C) && n(l, a, C);
    return c(l, a), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Vote = e.TallyResult = e.Proposal = e.GroupPolicyInfo = e.GroupMember = e.GroupInfo = e.DecisionPolicyWindows = e.PercentageDecisionPolicy = e.ThresholdDecisionPolicy = e.MemberRequest = e.Member = e.proposalExecutorResultToJSON = e.proposalExecutorResultFromJSON = e.ProposalExecutorResult = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const r = _e, u = en, f = Se, O = oe, A = i(ie);
  e.protobufPackage = "cosmos.group.v1";
  var T;
  (function(a) {
    a[a.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", a[a.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", a[a.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", a[a.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", a[a.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T = e.VoteOption || (e.VoteOption = {}));
  function L(a) {
    switch (a) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return T.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return T.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return T.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return T.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return T.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = L;
  function M(a) {
    switch (a) {
      case T.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case T.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case T.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case T.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case T.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = M;
  var V;
  (function(a) {
    a[a.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", a[a.PROPOSAL_STATUS_SUBMITTED = 1] = "PROPOSAL_STATUS_SUBMITTED", a[a.PROPOSAL_STATUS_ACCEPTED = 2] = "PROPOSAL_STATUS_ACCEPTED", a[a.PROPOSAL_STATUS_REJECTED = 3] = "PROPOSAL_STATUS_REJECTED", a[a.PROPOSAL_STATUS_ABORTED = 4] = "PROPOSAL_STATUS_ABORTED", a[a.PROPOSAL_STATUS_WITHDRAWN = 5] = "PROPOSAL_STATUS_WITHDRAWN", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = e.ProposalStatus || (e.ProposalStatus = {}));
  function D(a) {
    switch (a) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return V.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_SUBMITTED":
        return V.PROPOSAL_STATUS_SUBMITTED;
      case 2:
      case "PROPOSAL_STATUS_ACCEPTED":
        return V.PROPOSAL_STATUS_ACCEPTED;
      case 3:
      case "PROPOSAL_STATUS_REJECTED":
        return V.PROPOSAL_STATUS_REJECTED;
      case 4:
      case "PROPOSAL_STATUS_ABORTED":
        return V.PROPOSAL_STATUS_ABORTED;
      case 5:
      case "PROPOSAL_STATUS_WITHDRAWN":
        return V.PROPOSAL_STATUS_WITHDRAWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = D;
  function b(a) {
    switch (a) {
      case V.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case V.PROPOSAL_STATUS_SUBMITTED:
        return "PROPOSAL_STATUS_SUBMITTED";
      case V.PROPOSAL_STATUS_ACCEPTED:
        return "PROPOSAL_STATUS_ACCEPTED";
      case V.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case V.PROPOSAL_STATUS_ABORTED:
        return "PROPOSAL_STATUS_ABORTED";
      case V.PROPOSAL_STATUS_WITHDRAWN:
        return "PROPOSAL_STATUS_WITHDRAWN";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = b;
  var h;
  (function(a) {
    a[a.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED", a[a.PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN", a[a.PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS", a[a.PROPOSAL_EXECUTOR_RESULT_FAILURE = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(h = e.ProposalExecutorResult || (e.ProposalExecutorResult = {}));
  function S(a) {
    switch (a) {
      case 0:
      case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
        return h.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
      case 1:
      case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
        return h.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
      case 2:
      case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
        return h.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
      case 3:
      case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
        return h.PROPOSAL_EXECUTOR_RESULT_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return h.UNRECOGNIZED;
    }
  }
  e.proposalExecutorResultFromJSON = S;
  function _(a) {
    switch (a) {
      case h.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
        return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      case h.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
        return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      case h.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
        return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      case h.PROPOSAL_EXECUTOR_RESULT_FAILURE:
        return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      case h.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalExecutorResultToJSON = _;
  function d() {
    return {
      address: "",
      weight: "",
      metadata: "",
      addedAt: void 0
    };
  }
  e.Member = {
    encode(a, l = A.Writer.create()) {
      return a.address !== "" && l.uint32(10).string(a.address), a.weight !== "" && l.uint32(18).string(a.weight), a.metadata !== "" && l.uint32(26).string(a.metadata), a.addedAt !== void 0 && r.Timestamp.encode(a.addedAt, l.uint32(34).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = d();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.address = C.string();
            break;
          case 2:
            k.weight = C.string();
            break;
          case 3:
            k.metadata = C.string();
            break;
          case 4:
            k.addedAt = r.Timestamp.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        address: (0, O.isSet)(a.address) ? String(a.address) : "",
        weight: (0, O.isSet)(a.weight) ? String(a.weight) : "",
        metadata: (0, O.isSet)(a.metadata) ? String(a.metadata) : "",
        addedAt: (0, O.isSet)(a.addedAt) ? (0, O.fromJsonTimestamp)(a.addedAt) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.address !== void 0 && (l.address = a.address), a.weight !== void 0 && (l.weight = a.weight), a.metadata !== void 0 && (l.metadata = a.metadata), a.addedAt !== void 0 && (l.addedAt = (0, O.fromTimestamp)(a.addedAt).toISOString()), l;
    },
    fromPartial(a) {
      const l = d();
      return l.address = a.address ?? "", l.weight = a.weight ?? "", l.metadata = a.metadata ?? "", l.addedAt = a.addedAt !== void 0 && a.addedAt !== null ? r.Timestamp.fromPartial(a.addedAt) : void 0, l;
    }
  };
  function p() {
    return {
      address: "",
      weight: "",
      metadata: ""
    };
  }
  e.MemberRequest = {
    encode(a, l = A.Writer.create()) {
      return a.address !== "" && l.uint32(10).string(a.address), a.weight !== "" && l.uint32(18).string(a.weight), a.metadata !== "" && l.uint32(26).string(a.metadata), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = p();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.address = C.string();
            break;
          case 2:
            k.weight = C.string();
            break;
          case 3:
            k.metadata = C.string();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        address: (0, O.isSet)(a.address) ? String(a.address) : "",
        weight: (0, O.isSet)(a.weight) ? String(a.weight) : "",
        metadata: (0, O.isSet)(a.metadata) ? String(a.metadata) : ""
      };
    },
    toJSON(a) {
      const l = {};
      return a.address !== void 0 && (l.address = a.address), a.weight !== void 0 && (l.weight = a.weight), a.metadata !== void 0 && (l.metadata = a.metadata), l;
    },
    fromPartial(a) {
      const l = p();
      return l.address = a.address ?? "", l.weight = a.weight ?? "", l.metadata = a.metadata ?? "", l;
    }
  };
  function g() {
    return {
      threshold: "",
      windows: void 0
    };
  }
  e.ThresholdDecisionPolicy = {
    encode(a, l = A.Writer.create()) {
      return a.threshold !== "" && l.uint32(10).string(a.threshold), a.windows !== void 0 && e.DecisionPolicyWindows.encode(a.windows, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = g();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.threshold = C.string();
            break;
          case 2:
            k.windows = e.DecisionPolicyWindows.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        threshold: (0, O.isSet)(a.threshold) ? String(a.threshold) : "",
        windows: (0, O.isSet)(a.windows) ? e.DecisionPolicyWindows.fromJSON(a.windows) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.threshold !== void 0 && (l.threshold = a.threshold), a.windows !== void 0 && (l.windows = a.windows ? e.DecisionPolicyWindows.toJSON(a.windows) : void 0), l;
    },
    fromPartial(a) {
      const l = g();
      return l.threshold = a.threshold ?? "", l.windows = a.windows !== void 0 && a.windows !== null ? e.DecisionPolicyWindows.fromPartial(a.windows) : void 0, l;
    }
  };
  function J() {
    return {
      percentage: "",
      windows: void 0
    };
  }
  e.PercentageDecisionPolicy = {
    encode(a, l = A.Writer.create()) {
      return a.percentage !== "" && l.uint32(10).string(a.percentage), a.windows !== void 0 && e.DecisionPolicyWindows.encode(a.windows, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = J();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.percentage = C.string();
            break;
          case 2:
            k.windows = e.DecisionPolicyWindows.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        percentage: (0, O.isSet)(a.percentage) ? String(a.percentage) : "",
        windows: (0, O.isSet)(a.windows) ? e.DecisionPolicyWindows.fromJSON(a.windows) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.percentage !== void 0 && (l.percentage = a.percentage), a.windows !== void 0 && (l.windows = a.windows ? e.DecisionPolicyWindows.toJSON(a.windows) : void 0), l;
    },
    fromPartial(a) {
      const l = J();
      return l.percentage = a.percentage ?? "", l.windows = a.windows !== void 0 && a.windows !== null ? e.DecisionPolicyWindows.fromPartial(a.windows) : void 0, l;
    }
  };
  function B() {
    return {
      votingPeriod: void 0,
      minExecutionPeriod: void 0
    };
  }
  e.DecisionPolicyWindows = {
    encode(a, l = A.Writer.create()) {
      return a.votingPeriod !== void 0 && u.Duration.encode(a.votingPeriod, l.uint32(10).fork()).ldelim(), a.minExecutionPeriod !== void 0 && u.Duration.encode(a.minExecutionPeriod, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = B();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.votingPeriod = u.Duration.decode(C, C.uint32());
            break;
          case 2:
            k.minExecutionPeriod = u.Duration.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        votingPeriod: (0, O.isSet)(a.votingPeriod) ? u.Duration.fromJSON(a.votingPeriod) : void 0,
        minExecutionPeriod: (0, O.isSet)(a.minExecutionPeriod) ? u.Duration.fromJSON(a.minExecutionPeriod) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.votingPeriod !== void 0 && (l.votingPeriod = a.votingPeriod ? u.Duration.toJSON(a.votingPeriod) : void 0), a.minExecutionPeriod !== void 0 && (l.minExecutionPeriod = a.minExecutionPeriod ? u.Duration.toJSON(a.minExecutionPeriod) : void 0), l;
    },
    fromPartial(a) {
      const l = B();
      return l.votingPeriod = a.votingPeriod !== void 0 && a.votingPeriod !== null ? u.Duration.fromPartial(a.votingPeriod) : void 0, l.minExecutionPeriod = a.minExecutionPeriod !== void 0 && a.minExecutionPeriod !== null ? u.Duration.fromPartial(a.minExecutionPeriod) : void 0, l;
    }
  };
  function I() {
    return {
      id: O.Long.UZERO,
      admin: "",
      metadata: "",
      version: O.Long.UZERO,
      totalWeight: "",
      createdAt: void 0
    };
  }
  e.GroupInfo = {
    encode(a, l = A.Writer.create()) {
      return a.id.isZero() || l.uint32(8).uint64(a.id), a.admin !== "" && l.uint32(18).string(a.admin), a.metadata !== "" && l.uint32(26).string(a.metadata), a.version.isZero() || l.uint32(32).uint64(a.version), a.totalWeight !== "" && l.uint32(42).string(a.totalWeight), a.createdAt !== void 0 && r.Timestamp.encode(a.createdAt, l.uint32(50).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = I();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.id = C.uint64();
            break;
          case 2:
            k.admin = C.string();
            break;
          case 3:
            k.metadata = C.string();
            break;
          case 4:
            k.version = C.uint64();
            break;
          case 5:
            k.totalWeight = C.string();
            break;
          case 6:
            k.createdAt = r.Timestamp.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        id: (0, O.isSet)(a.id) ? O.Long.fromValue(a.id) : O.Long.UZERO,
        admin: (0, O.isSet)(a.admin) ? String(a.admin) : "",
        metadata: (0, O.isSet)(a.metadata) ? String(a.metadata) : "",
        version: (0, O.isSet)(a.version) ? O.Long.fromValue(a.version) : O.Long.UZERO,
        totalWeight: (0, O.isSet)(a.totalWeight) ? String(a.totalWeight) : "",
        createdAt: (0, O.isSet)(a.createdAt) ? (0, O.fromJsonTimestamp)(a.createdAt) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.id !== void 0 && (l.id = (a.id || O.Long.UZERO).toString()), a.admin !== void 0 && (l.admin = a.admin), a.metadata !== void 0 && (l.metadata = a.metadata), a.version !== void 0 && (l.version = (a.version || O.Long.UZERO).toString()), a.totalWeight !== void 0 && (l.totalWeight = a.totalWeight), a.createdAt !== void 0 && (l.createdAt = (0, O.fromTimestamp)(a.createdAt).toISOString()), l;
    },
    fromPartial(a) {
      const l = I();
      return l.id = a.id !== void 0 && a.id !== null ? O.Long.fromValue(a.id) : O.Long.UZERO, l.admin = a.admin ?? "", l.metadata = a.metadata ?? "", l.version = a.version !== void 0 && a.version !== null ? O.Long.fromValue(a.version) : O.Long.UZERO, l.totalWeight = a.totalWeight ?? "", l.createdAt = a.createdAt !== void 0 && a.createdAt !== null ? r.Timestamp.fromPartial(a.createdAt) : void 0, l;
    }
  };
  function Z() {
    return {
      groupId: O.Long.UZERO,
      member: void 0
    };
  }
  e.GroupMember = {
    encode(a, l = A.Writer.create()) {
      return a.groupId.isZero() || l.uint32(8).uint64(a.groupId), a.member !== void 0 && e.Member.encode(a.member, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = Z();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.groupId = C.uint64();
            break;
          case 2:
            k.member = e.Member.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        groupId: (0, O.isSet)(a.groupId) ? O.Long.fromValue(a.groupId) : O.Long.UZERO,
        member: (0, O.isSet)(a.member) ? e.Member.fromJSON(a.member) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.groupId !== void 0 && (l.groupId = (a.groupId || O.Long.UZERO).toString()), a.member !== void 0 && (l.member = a.member ? e.Member.toJSON(a.member) : void 0), l;
    },
    fromPartial(a) {
      const l = Z();
      return l.groupId = a.groupId !== void 0 && a.groupId !== null ? O.Long.fromValue(a.groupId) : O.Long.UZERO, l.member = a.member !== void 0 && a.member !== null ? e.Member.fromPartial(a.member) : void 0, l;
    }
  };
  function t() {
    return {
      address: "",
      groupId: O.Long.UZERO,
      admin: "",
      metadata: "",
      version: O.Long.UZERO,
      decisionPolicy: void 0,
      createdAt: void 0
    };
  }
  e.GroupPolicyInfo = {
    encode(a, l = A.Writer.create()) {
      return a.address !== "" && l.uint32(10).string(a.address), a.groupId.isZero() || l.uint32(16).uint64(a.groupId), a.admin !== "" && l.uint32(26).string(a.admin), a.metadata !== "" && l.uint32(34).string(a.metadata), a.version.isZero() || l.uint32(40).uint64(a.version), a.decisionPolicy !== void 0 && f.Any.encode(a.decisionPolicy, l.uint32(50).fork()).ldelim(), a.createdAt !== void 0 && r.Timestamp.encode(a.createdAt, l.uint32(58).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = t();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.address = C.string();
            break;
          case 2:
            k.groupId = C.uint64();
            break;
          case 3:
            k.admin = C.string();
            break;
          case 4:
            k.metadata = C.string();
            break;
          case 5:
            k.version = C.uint64();
            break;
          case 6:
            k.decisionPolicy = f.Any.decode(C, C.uint32());
            break;
          case 7:
            k.createdAt = r.Timestamp.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        address: (0, O.isSet)(a.address) ? String(a.address) : "",
        groupId: (0, O.isSet)(a.groupId) ? O.Long.fromValue(a.groupId) : O.Long.UZERO,
        admin: (0, O.isSet)(a.admin) ? String(a.admin) : "",
        metadata: (0, O.isSet)(a.metadata) ? String(a.metadata) : "",
        version: (0, O.isSet)(a.version) ? O.Long.fromValue(a.version) : O.Long.UZERO,
        decisionPolicy: (0, O.isSet)(a.decisionPolicy) ? f.Any.fromJSON(a.decisionPolicy) : void 0,
        createdAt: (0, O.isSet)(a.createdAt) ? (0, O.fromJsonTimestamp)(a.createdAt) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.address !== void 0 && (l.address = a.address), a.groupId !== void 0 && (l.groupId = (a.groupId || O.Long.UZERO).toString()), a.admin !== void 0 && (l.admin = a.admin), a.metadata !== void 0 && (l.metadata = a.metadata), a.version !== void 0 && (l.version = (a.version || O.Long.UZERO).toString()), a.decisionPolicy !== void 0 && (l.decisionPolicy = a.decisionPolicy ? f.Any.toJSON(a.decisionPolicy) : void 0), a.createdAt !== void 0 && (l.createdAt = (0, O.fromTimestamp)(a.createdAt).toISOString()), l;
    },
    fromPartial(a) {
      const l = t();
      return l.address = a.address ?? "", l.groupId = a.groupId !== void 0 && a.groupId !== null ? O.Long.fromValue(a.groupId) : O.Long.UZERO, l.admin = a.admin ?? "", l.metadata = a.metadata ?? "", l.version = a.version !== void 0 && a.version !== null ? O.Long.fromValue(a.version) : O.Long.UZERO, l.decisionPolicy = a.decisionPolicy !== void 0 && a.decisionPolicy !== null ? f.Any.fromPartial(a.decisionPolicy) : void 0, l.createdAt = a.createdAt !== void 0 && a.createdAt !== null ? r.Timestamp.fromPartial(a.createdAt) : void 0, l;
    }
  };
  function y() {
    return {
      id: O.Long.UZERO,
      groupPolicyAddress: "",
      metadata: "",
      proposers: [],
      submitTime: void 0,
      groupVersion: O.Long.UZERO,
      groupPolicyVersion: O.Long.UZERO,
      status: 0,
      finalTallyResult: void 0,
      votingPeriodEnd: void 0,
      executorResult: 0,
      messages: [],
      title: "",
      summary: ""
    };
  }
  e.Proposal = {
    encode(a, l = A.Writer.create()) {
      a.id.isZero() || l.uint32(8).uint64(a.id), a.groupPolicyAddress !== "" && l.uint32(18).string(a.groupPolicyAddress), a.metadata !== "" && l.uint32(26).string(a.metadata);
      for (const C of a.proposers)
        l.uint32(34).string(C);
      a.submitTime !== void 0 && r.Timestamp.encode(a.submitTime, l.uint32(42).fork()).ldelim(), a.groupVersion.isZero() || l.uint32(48).uint64(a.groupVersion), a.groupPolicyVersion.isZero() || l.uint32(56).uint64(a.groupPolicyVersion), a.status !== 0 && l.uint32(64).int32(a.status), a.finalTallyResult !== void 0 && e.TallyResult.encode(a.finalTallyResult, l.uint32(74).fork()).ldelim(), a.votingPeriodEnd !== void 0 && r.Timestamp.encode(a.votingPeriodEnd, l.uint32(82).fork()).ldelim(), a.executorResult !== 0 && l.uint32(88).int32(a.executorResult);
      for (const C of a.messages)
        f.Any.encode(C, l.uint32(98).fork()).ldelim();
      return a.title !== "" && l.uint32(106).string(a.title), a.summary !== "" && l.uint32(114).string(a.summary), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = y();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.id = C.uint64();
            break;
          case 2:
            k.groupPolicyAddress = C.string();
            break;
          case 3:
            k.metadata = C.string();
            break;
          case 4:
            k.proposers.push(C.string());
            break;
          case 5:
            k.submitTime = r.Timestamp.decode(C, C.uint32());
            break;
          case 6:
            k.groupVersion = C.uint64();
            break;
          case 7:
            k.groupPolicyVersion = C.uint64();
            break;
          case 8:
            k.status = C.int32();
            break;
          case 9:
            k.finalTallyResult = e.TallyResult.decode(C, C.uint32());
            break;
          case 10:
            k.votingPeriodEnd = r.Timestamp.decode(C, C.uint32());
            break;
          case 11:
            k.executorResult = C.int32();
            break;
          case 12:
            k.messages.push(f.Any.decode(C, C.uint32()));
            break;
          case 13:
            k.title = C.string();
            break;
          case 14:
            k.summary = C.string();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        id: (0, O.isSet)(a.id) ? O.Long.fromValue(a.id) : O.Long.UZERO,
        groupPolicyAddress: (0, O.isSet)(a.groupPolicyAddress) ? String(a.groupPolicyAddress) : "",
        metadata: (0, O.isSet)(a.metadata) ? String(a.metadata) : "",
        proposers: Array.isArray(a == null ? void 0 : a.proposers) ? a.proposers.map((l) => String(l)) : [],
        submitTime: (0, O.isSet)(a.submitTime) ? (0, O.fromJsonTimestamp)(a.submitTime) : void 0,
        groupVersion: (0, O.isSet)(a.groupVersion) ? O.Long.fromValue(a.groupVersion) : O.Long.UZERO,
        groupPolicyVersion: (0, O.isSet)(a.groupPolicyVersion) ? O.Long.fromValue(a.groupPolicyVersion) : O.Long.UZERO,
        status: (0, O.isSet)(a.status) ? D(a.status) : 0,
        finalTallyResult: (0, O.isSet)(a.finalTallyResult) ? e.TallyResult.fromJSON(a.finalTallyResult) : void 0,
        votingPeriodEnd: (0, O.isSet)(a.votingPeriodEnd) ? (0, O.fromJsonTimestamp)(a.votingPeriodEnd) : void 0,
        executorResult: (0, O.isSet)(a.executorResult) ? S(a.executorResult) : 0,
        messages: Array.isArray(a == null ? void 0 : a.messages) ? a.messages.map((l) => f.Any.fromJSON(l)) : [],
        title: (0, O.isSet)(a.title) ? String(a.title) : "",
        summary: (0, O.isSet)(a.summary) ? String(a.summary) : ""
      };
    },
    toJSON(a) {
      const l = {};
      return a.id !== void 0 && (l.id = (a.id || O.Long.UZERO).toString()), a.groupPolicyAddress !== void 0 && (l.groupPolicyAddress = a.groupPolicyAddress), a.metadata !== void 0 && (l.metadata = a.metadata), a.proposers ? l.proposers = a.proposers.map((C) => C) : l.proposers = [], a.submitTime !== void 0 && (l.submitTime = (0, O.fromTimestamp)(a.submitTime).toISOString()), a.groupVersion !== void 0 && (l.groupVersion = (a.groupVersion || O.Long.UZERO).toString()), a.groupPolicyVersion !== void 0 && (l.groupPolicyVersion = (a.groupPolicyVersion || O.Long.UZERO).toString()), a.status !== void 0 && (l.status = b(a.status)), a.finalTallyResult !== void 0 && (l.finalTallyResult = a.finalTallyResult ? e.TallyResult.toJSON(a.finalTallyResult) : void 0), a.votingPeriodEnd !== void 0 && (l.votingPeriodEnd = (0, O.fromTimestamp)(a.votingPeriodEnd).toISOString()), a.executorResult !== void 0 && (l.executorResult = _(a.executorResult)), a.messages ? l.messages = a.messages.map((C) => C ? f.Any.toJSON(C) : void 0) : l.messages = [], a.title !== void 0 && (l.title = a.title), a.summary !== void 0 && (l.summary = a.summary), l;
    },
    fromPartial(a) {
      var C, v;
      const l = y();
      return l.id = a.id !== void 0 && a.id !== null ? O.Long.fromValue(a.id) : O.Long.UZERO, l.groupPolicyAddress = a.groupPolicyAddress ?? "", l.metadata = a.metadata ?? "", l.proposers = ((C = a.proposers) == null ? void 0 : C.map((k) => k)) || [], l.submitTime = a.submitTime !== void 0 && a.submitTime !== null ? r.Timestamp.fromPartial(a.submitTime) : void 0, l.groupVersion = a.groupVersion !== void 0 && a.groupVersion !== null ? O.Long.fromValue(a.groupVersion) : O.Long.UZERO, l.groupPolicyVersion = a.groupPolicyVersion !== void 0 && a.groupPolicyVersion !== null ? O.Long.fromValue(a.groupPolicyVersion) : O.Long.UZERO, l.status = a.status ?? 0, l.finalTallyResult = a.finalTallyResult !== void 0 && a.finalTallyResult !== null ? e.TallyResult.fromPartial(a.finalTallyResult) : void 0, l.votingPeriodEnd = a.votingPeriodEnd !== void 0 && a.votingPeriodEnd !== null ? r.Timestamp.fromPartial(a.votingPeriodEnd) : void 0, l.executorResult = a.executorResult ?? 0, l.messages = ((v = a.messages) == null ? void 0 : v.map((k) => f.Any.fromPartial(k))) || [], l.title = a.title ?? "", l.summary = a.summary ?? "", l;
    }
  };
  function E() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    encode(a, l = A.Writer.create()) {
      return a.yesCount !== "" && l.uint32(10).string(a.yesCount), a.abstainCount !== "" && l.uint32(18).string(a.abstainCount), a.noCount !== "" && l.uint32(26).string(a.noCount), a.noWithVetoCount !== "" && l.uint32(34).string(a.noWithVetoCount), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = E();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.yesCount = C.string();
            break;
          case 2:
            k.abstainCount = C.string();
            break;
          case 3:
            k.noCount = C.string();
            break;
          case 4:
            k.noWithVetoCount = C.string();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        yesCount: (0, O.isSet)(a.yesCount) ? String(a.yesCount) : "",
        abstainCount: (0, O.isSet)(a.abstainCount) ? String(a.abstainCount) : "",
        noCount: (0, O.isSet)(a.noCount) ? String(a.noCount) : "",
        noWithVetoCount: (0, O.isSet)(a.noWithVetoCount) ? String(a.noWithVetoCount) : ""
      };
    },
    toJSON(a) {
      const l = {};
      return a.yesCount !== void 0 && (l.yesCount = a.yesCount), a.abstainCount !== void 0 && (l.abstainCount = a.abstainCount), a.noCount !== void 0 && (l.noCount = a.noCount), a.noWithVetoCount !== void 0 && (l.noWithVetoCount = a.noWithVetoCount), l;
    },
    fromPartial(a) {
      const l = E();
      return l.yesCount = a.yesCount ?? "", l.abstainCount = a.abstainCount ?? "", l.noCount = a.noCount ?? "", l.noWithVetoCount = a.noWithVetoCount ?? "", l;
    }
  };
  function H() {
    return {
      proposalId: O.Long.UZERO,
      voter: "",
      option: 0,
      metadata: "",
      submitTime: void 0
    };
  }
  e.Vote = {
    encode(a, l = A.Writer.create()) {
      return a.proposalId.isZero() || l.uint32(8).uint64(a.proposalId), a.voter !== "" && l.uint32(18).string(a.voter), a.option !== 0 && l.uint32(24).int32(a.option), a.metadata !== "" && l.uint32(34).string(a.metadata), a.submitTime !== void 0 && r.Timestamp.encode(a.submitTime, l.uint32(42).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof A.Reader ? a : new A.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = H();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.proposalId = C.uint64();
            break;
          case 2:
            k.voter = C.string();
            break;
          case 3:
            k.option = C.int32();
            break;
          case 4:
            k.metadata = C.string();
            break;
          case 5:
            k.submitTime = r.Timestamp.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        proposalId: (0, O.isSet)(a.proposalId) ? O.Long.fromValue(a.proposalId) : O.Long.UZERO,
        voter: (0, O.isSet)(a.voter) ? String(a.voter) : "",
        option: (0, O.isSet)(a.option) ? L(a.option) : 0,
        metadata: (0, O.isSet)(a.metadata) ? String(a.metadata) : "",
        submitTime: (0, O.isSet)(a.submitTime) ? (0, O.fromJsonTimestamp)(a.submitTime) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.proposalId !== void 0 && (l.proposalId = (a.proposalId || O.Long.UZERO).toString()), a.voter !== void 0 && (l.voter = a.voter), a.option !== void 0 && (l.option = M(a.option)), a.metadata !== void 0 && (l.metadata = a.metadata), a.submitTime !== void 0 && (l.submitTime = (0, O.fromTimestamp)(a.submitTime).toISOString()), l;
    },
    fromPartial(a) {
      const l = H();
      return l.proposalId = a.proposalId !== void 0 && a.proposalId !== null ? O.Long.fromValue(a.proposalId) : O.Long.UZERO, l.voter = a.voter ?? "", l.option = a.option ?? 0, l.metadata = a.metadata ?? "", l.submitTime = a.submitTime !== void 0 && a.submitTime !== null ? r.Timestamp.fromPartial(a.submitTime) : void 0, l;
    }
  };
})(Au);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(R, N, Q, K) {
    K === void 0 && (K = Q);
    var z = Object.getOwnPropertyDescriptor(N, Q);
    (!z || ("get" in z ? !N.__esModule : z.writable || z.configurable)) && (z = { enumerable: !0, get: function() {
      return N[Q];
    } }), Object.defineProperty(R, K, z);
  } : function(R, N, Q, K) {
    K === void 0 && (K = Q), R[K] = N[Q];
  }), c = G && G.__setModuleDefault || (Object.create ? function(R, N) {
    Object.defineProperty(R, "default", { enumerable: !0, value: N });
  } : function(R, N) {
    R.default = N;
  }), i = G && G.__importStar || function(R) {
    if (R && R.__esModule)
      return R;
    var N = {};
    if (R != null)
      for (var Q in R)
        Q !== "default" && Object.prototype.hasOwnProperty.call(R, Q) && n(N, R, Q);
    return c(N, R), N;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgLeaveGroupResponse = e.MsgLeaveGroup = e.MsgExecResponse = e.MsgExec = e.MsgVoteResponse = e.MsgVote = e.MsgWithdrawProposalResponse = e.MsgWithdrawProposal = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.MsgUpdateGroupPolicyMetadataResponse = e.MsgUpdateGroupPolicyMetadata = e.MsgUpdateGroupPolicyDecisionPolicyResponse = e.MsgUpdateGroupPolicyDecisionPolicy = e.MsgCreateGroupWithPolicyResponse = e.MsgCreateGroupWithPolicy = e.MsgUpdateGroupPolicyAdminResponse = e.MsgUpdateGroupPolicyAdmin = e.MsgCreateGroupPolicyResponse = e.MsgCreateGroupPolicy = e.MsgUpdateGroupMetadataResponse = e.MsgUpdateGroupMetadata = e.MsgUpdateGroupAdminResponse = e.MsgUpdateGroupAdmin = e.MsgUpdateGroupMembersResponse = e.MsgUpdateGroupMembers = e.MsgCreateGroupResponse = e.MsgCreateGroup = e.execToJSON = e.execFromJSON = e.Exec = e.protobufPackage = void 0;
  const r = Au, u = Se, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.group.v1";
  var A;
  (function(R) {
    R[R.EXEC_UNSPECIFIED = 0] = "EXEC_UNSPECIFIED", R[R.EXEC_TRY = 1] = "EXEC_TRY", R[R.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(A = e.Exec || (e.Exec = {}));
  function T(R) {
    switch (R) {
      case 0:
      case "EXEC_UNSPECIFIED":
        return A.EXEC_UNSPECIFIED;
      case 1:
      case "EXEC_TRY":
        return A.EXEC_TRY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return A.UNRECOGNIZED;
    }
  }
  e.execFromJSON = T;
  function L(R) {
    switch (R) {
      case A.EXEC_UNSPECIFIED:
        return "EXEC_UNSPECIFIED";
      case A.EXEC_TRY:
        return "EXEC_TRY";
      case A.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.execToJSON = L;
  function M() {
    return {
      admin: "",
      members: [],
      metadata: ""
    };
  }
  e.MsgCreateGroup = {
    encode(R, N = O.Writer.create()) {
      R.admin !== "" && N.uint32(10).string(R.admin);
      for (const Q of R.members)
        r.MemberRequest.encode(Q, N.uint32(18).fork()).ldelim();
      return R.metadata !== "" && N.uint32(26).string(R.metadata), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = M();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.members.push(r.MemberRequest.decode(Q, Q.uint32()));
            break;
          case 3:
            z.metadata = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        members: Array.isArray(R == null ? void 0 : R.members) ? R.members.map((N) => r.MemberRequest.fromJSON(N)) : [],
        metadata: (0, f.isSet)(R.metadata) ? String(R.metadata) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.members ? N.members = R.members.map((Q) => Q ? r.MemberRequest.toJSON(Q) : void 0) : N.members = [], R.metadata !== void 0 && (N.metadata = R.metadata), N;
    },
    fromPartial(R) {
      var Q;
      const N = M();
      return N.admin = R.admin ?? "", N.members = ((Q = R.members) == null ? void 0 : Q.map((K) => r.MemberRequest.fromPartial(K))) || [], N.metadata = R.metadata ?? "", N;
    }
  };
  function V() {
    return {
      groupId: f.Long.UZERO
    };
  }
  e.MsgCreateGroupResponse = {
    encode(R, N = O.Writer.create()) {
      return R.groupId.isZero() || N.uint32(8).uint64(R.groupId), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = V();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.groupId = Q.uint64();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO
      };
    },
    toJSON(R) {
      const N = {};
      return R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), N;
    },
    fromPartial(R) {
      const N = V();
      return N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N;
    }
  };
  function D() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      memberUpdates: []
    };
  }
  e.MsgUpdateGroupMembers = {
    encode(R, N = O.Writer.create()) {
      R.admin !== "" && N.uint32(10).string(R.admin), R.groupId.isZero() || N.uint32(16).uint64(R.groupId);
      for (const Q of R.memberUpdates)
        r.MemberRequest.encode(Q, N.uint32(26).fork()).ldelim();
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = D();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupId = Q.uint64();
            break;
          case 3:
            z.memberUpdates.push(r.MemberRequest.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO,
        memberUpdates: Array.isArray(R == null ? void 0 : R.memberUpdates) ? R.memberUpdates.map((N) => r.MemberRequest.fromJSON(N)) : []
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), R.memberUpdates ? N.memberUpdates = R.memberUpdates.map((Q) => Q ? r.MemberRequest.toJSON(Q) : void 0) : N.memberUpdates = [], N;
    },
    fromPartial(R) {
      var Q;
      const N = D();
      return N.admin = R.admin ?? "", N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N.memberUpdates = ((Q = R.memberUpdates) == null ? void 0 : Q.map((K) => r.MemberRequest.fromPartial(K))) || [], N;
    }
  };
  function b() {
    return {};
  }
  e.MsgUpdateGroupMembersResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = b();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return b();
    }
  };
  function h() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupAdmin = {
    encode(R, N = O.Writer.create()) {
      return R.admin !== "" && N.uint32(10).string(R.admin), R.groupId.isZero() || N.uint32(16).uint64(R.groupId), R.newAdmin !== "" && N.uint32(26).string(R.newAdmin), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = h();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupId = Q.uint64();
            break;
          case 3:
            z.newAdmin = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO,
        newAdmin: (0, f.isSet)(R.newAdmin) ? String(R.newAdmin) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), R.newAdmin !== void 0 && (N.newAdmin = R.newAdmin), N;
    },
    fromPartial(R) {
      const N = h();
      return N.admin = R.admin ?? "", N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N.newAdmin = R.newAdmin ?? "", N;
    }
  };
  function S() {
    return {};
  }
  e.MsgUpdateGroupAdminResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = S();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return S();
    }
  };
  function _() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      metadata: ""
    };
  }
  e.MsgUpdateGroupMetadata = {
    encode(R, N = O.Writer.create()) {
      return R.admin !== "" && N.uint32(10).string(R.admin), R.groupId.isZero() || N.uint32(16).uint64(R.groupId), R.metadata !== "" && N.uint32(26).string(R.metadata), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = _();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupId = Q.uint64();
            break;
          case 3:
            z.metadata = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO,
        metadata: (0, f.isSet)(R.metadata) ? String(R.metadata) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), R.metadata !== void 0 && (N.metadata = R.metadata), N;
    },
    fromPartial(R) {
      const N = _();
      return N.admin = R.admin ?? "", N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N.metadata = R.metadata ?? "", N;
    }
  };
  function d() {
    return {};
  }
  e.MsgUpdateGroupMetadataResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = d();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return d();
    }
  };
  function p() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      metadata: "",
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupPolicy = {
    encode(R, N = O.Writer.create()) {
      return R.admin !== "" && N.uint32(10).string(R.admin), R.groupId.isZero() || N.uint32(16).uint64(R.groupId), R.metadata !== "" && N.uint32(26).string(R.metadata), R.decisionPolicy !== void 0 && u.Any.encode(R.decisionPolicy, N.uint32(34).fork()).ldelim(), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = p();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupId = Q.uint64();
            break;
          case 3:
            z.metadata = Q.string();
            break;
          case 4:
            z.decisionPolicy = u.Any.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO,
        metadata: (0, f.isSet)(R.metadata) ? String(R.metadata) : "",
        decisionPolicy: (0, f.isSet)(R.decisionPolicy) ? u.Any.fromJSON(R.decisionPolicy) : void 0
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), R.metadata !== void 0 && (N.metadata = R.metadata), R.decisionPolicy !== void 0 && (N.decisionPolicy = R.decisionPolicy ? u.Any.toJSON(R.decisionPolicy) : void 0), N;
    },
    fromPartial(R) {
      const N = p();
      return N.admin = R.admin ?? "", N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N.metadata = R.metadata ?? "", N.decisionPolicy = R.decisionPolicy !== void 0 && R.decisionPolicy !== null ? u.Any.fromPartial(R.decisionPolicy) : void 0, N;
    }
  };
  function g() {
    return {
      address: ""
    };
  }
  e.MsgCreateGroupPolicyResponse = {
    encode(R, N = O.Writer.create()) {
      return R.address !== "" && N.uint32(10).string(R.address), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = g();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.address = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        address: (0, f.isSet)(R.address) ? String(R.address) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.address !== void 0 && (N.address = R.address), N;
    },
    fromPartial(R) {
      const N = g();
      return N.address = R.address ?? "", N;
    }
  };
  function J() {
    return {
      admin: "",
      groupPolicyAddress: "",
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupPolicyAdmin = {
    encode(R, N = O.Writer.create()) {
      return R.admin !== "" && N.uint32(10).string(R.admin), R.groupPolicyAddress !== "" && N.uint32(18).string(R.groupPolicyAddress), R.newAdmin !== "" && N.uint32(26).string(R.newAdmin), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = J();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupPolicyAddress = Q.string();
            break;
          case 3:
            z.newAdmin = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupPolicyAddress: (0, f.isSet)(R.groupPolicyAddress) ? String(R.groupPolicyAddress) : "",
        newAdmin: (0, f.isSet)(R.newAdmin) ? String(R.newAdmin) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = R.groupPolicyAddress), R.newAdmin !== void 0 && (N.newAdmin = R.newAdmin), N;
    },
    fromPartial(R) {
      const N = J();
      return N.admin = R.admin ?? "", N.groupPolicyAddress = R.groupPolicyAddress ?? "", N.newAdmin = R.newAdmin ?? "", N;
    }
  };
  function B() {
    return {};
  }
  e.MsgUpdateGroupPolicyAdminResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = B();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return B();
    }
  };
  function I() {
    return {
      admin: "",
      members: [],
      groupMetadata: "",
      groupPolicyMetadata: "",
      groupPolicyAsAdmin: !1,
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupWithPolicy = {
    encode(R, N = O.Writer.create()) {
      R.admin !== "" && N.uint32(10).string(R.admin);
      for (const Q of R.members)
        r.MemberRequest.encode(Q, N.uint32(18).fork()).ldelim();
      return R.groupMetadata !== "" && N.uint32(26).string(R.groupMetadata), R.groupPolicyMetadata !== "" && N.uint32(34).string(R.groupPolicyMetadata), R.groupPolicyAsAdmin === !0 && N.uint32(40).bool(R.groupPolicyAsAdmin), R.decisionPolicy !== void 0 && u.Any.encode(R.decisionPolicy, N.uint32(50).fork()).ldelim(), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = I();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.members.push(r.MemberRequest.decode(Q, Q.uint32()));
            break;
          case 3:
            z.groupMetadata = Q.string();
            break;
          case 4:
            z.groupPolicyMetadata = Q.string();
            break;
          case 5:
            z.groupPolicyAsAdmin = Q.bool();
            break;
          case 6:
            z.decisionPolicy = u.Any.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        members: Array.isArray(R == null ? void 0 : R.members) ? R.members.map((N) => r.MemberRequest.fromJSON(N)) : [],
        groupMetadata: (0, f.isSet)(R.groupMetadata) ? String(R.groupMetadata) : "",
        groupPolicyMetadata: (0, f.isSet)(R.groupPolicyMetadata) ? String(R.groupPolicyMetadata) : "",
        groupPolicyAsAdmin: (0, f.isSet)(R.groupPolicyAsAdmin) ? !!R.groupPolicyAsAdmin : !1,
        decisionPolicy: (0, f.isSet)(R.decisionPolicy) ? u.Any.fromJSON(R.decisionPolicy) : void 0
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.members ? N.members = R.members.map((Q) => Q ? r.MemberRequest.toJSON(Q) : void 0) : N.members = [], R.groupMetadata !== void 0 && (N.groupMetadata = R.groupMetadata), R.groupPolicyMetadata !== void 0 && (N.groupPolicyMetadata = R.groupPolicyMetadata), R.groupPolicyAsAdmin !== void 0 && (N.groupPolicyAsAdmin = R.groupPolicyAsAdmin), R.decisionPolicy !== void 0 && (N.decisionPolicy = R.decisionPolicy ? u.Any.toJSON(R.decisionPolicy) : void 0), N;
    },
    fromPartial(R) {
      var Q;
      const N = I();
      return N.admin = R.admin ?? "", N.members = ((Q = R.members) == null ? void 0 : Q.map((K) => r.MemberRequest.fromPartial(K))) || [], N.groupMetadata = R.groupMetadata ?? "", N.groupPolicyMetadata = R.groupPolicyMetadata ?? "", N.groupPolicyAsAdmin = R.groupPolicyAsAdmin ?? !1, N.decisionPolicy = R.decisionPolicy !== void 0 && R.decisionPolicy !== null ? u.Any.fromPartial(R.decisionPolicy) : void 0, N;
    }
  };
  function Z() {
    return {
      groupId: f.Long.UZERO,
      groupPolicyAddress: ""
    };
  }
  e.MsgCreateGroupWithPolicyResponse = {
    encode(R, N = O.Writer.create()) {
      return R.groupId.isZero() || N.uint32(8).uint64(R.groupId), R.groupPolicyAddress !== "" && N.uint32(18).string(R.groupPolicyAddress), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = Z();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.groupId = Q.uint64();
            break;
          case 2:
            z.groupPolicyAddress = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO,
        groupPolicyAddress: (0, f.isSet)(R.groupPolicyAddress) ? String(R.groupPolicyAddress) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), R.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = R.groupPolicyAddress), N;
    },
    fromPartial(R) {
      const N = Z();
      return N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N.groupPolicyAddress = R.groupPolicyAddress ?? "", N;
    }
  };
  function t() {
    return {
      admin: "",
      groupPolicyAddress: "",
      decisionPolicy: void 0
    };
  }
  e.MsgUpdateGroupPolicyDecisionPolicy = {
    encode(R, N = O.Writer.create()) {
      return R.admin !== "" && N.uint32(10).string(R.admin), R.groupPolicyAddress !== "" && N.uint32(18).string(R.groupPolicyAddress), R.decisionPolicy !== void 0 && u.Any.encode(R.decisionPolicy, N.uint32(26).fork()).ldelim(), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = t();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupPolicyAddress = Q.string();
            break;
          case 3:
            z.decisionPolicy = u.Any.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupPolicyAddress: (0, f.isSet)(R.groupPolicyAddress) ? String(R.groupPolicyAddress) : "",
        decisionPolicy: (0, f.isSet)(R.decisionPolicy) ? u.Any.fromJSON(R.decisionPolicy) : void 0
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = R.groupPolicyAddress), R.decisionPolicy !== void 0 && (N.decisionPolicy = R.decisionPolicy ? u.Any.toJSON(R.decisionPolicy) : void 0), N;
    },
    fromPartial(R) {
      const N = t();
      return N.admin = R.admin ?? "", N.groupPolicyAddress = R.groupPolicyAddress ?? "", N.decisionPolicy = R.decisionPolicy !== void 0 && R.decisionPolicy !== null ? u.Any.fromPartial(R.decisionPolicy) : void 0, N;
    }
  };
  function y() {
    return {};
  }
  e.MsgUpdateGroupPolicyDecisionPolicyResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = y();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return y();
    }
  };
  function E() {
    return {
      admin: "",
      groupPolicyAddress: "",
      metadata: ""
    };
  }
  e.MsgUpdateGroupPolicyMetadata = {
    encode(R, N = O.Writer.create()) {
      return R.admin !== "" && N.uint32(10).string(R.admin), R.groupPolicyAddress !== "" && N.uint32(18).string(R.groupPolicyAddress), R.metadata !== "" && N.uint32(26).string(R.metadata), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = E();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.admin = Q.string();
            break;
          case 2:
            z.groupPolicyAddress = Q.string();
            break;
          case 3:
            z.metadata = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        admin: (0, f.isSet)(R.admin) ? String(R.admin) : "",
        groupPolicyAddress: (0, f.isSet)(R.groupPolicyAddress) ? String(R.groupPolicyAddress) : "",
        metadata: (0, f.isSet)(R.metadata) ? String(R.metadata) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.admin !== void 0 && (N.admin = R.admin), R.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = R.groupPolicyAddress), R.metadata !== void 0 && (N.metadata = R.metadata), N;
    },
    fromPartial(R) {
      const N = E();
      return N.admin = R.admin ?? "", N.groupPolicyAddress = R.groupPolicyAddress ?? "", N.metadata = R.metadata ?? "", N;
    }
  };
  function H() {
    return {};
  }
  e.MsgUpdateGroupPolicyMetadataResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = H();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return H();
    }
  };
  function a() {
    return {
      groupPolicyAddress: "",
      proposers: [],
      metadata: "",
      messages: [],
      exec: 0,
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    encode(R, N = O.Writer.create()) {
      R.groupPolicyAddress !== "" && N.uint32(10).string(R.groupPolicyAddress);
      for (const Q of R.proposers)
        N.uint32(18).string(Q);
      R.metadata !== "" && N.uint32(26).string(R.metadata);
      for (const Q of R.messages)
        u.Any.encode(Q, N.uint32(34).fork()).ldelim();
      return R.exec !== 0 && N.uint32(40).int32(R.exec), R.title !== "" && N.uint32(50).string(R.title), R.summary !== "" && N.uint32(58).string(R.summary), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = a();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.groupPolicyAddress = Q.string();
            break;
          case 2:
            z.proposers.push(Q.string());
            break;
          case 3:
            z.metadata = Q.string();
            break;
          case 4:
            z.messages.push(u.Any.decode(Q, Q.uint32()));
            break;
          case 5:
            z.exec = Q.int32();
            break;
          case 6:
            z.title = Q.string();
            break;
          case 7:
            z.summary = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        groupPolicyAddress: (0, f.isSet)(R.groupPolicyAddress) ? String(R.groupPolicyAddress) : "",
        proposers: Array.isArray(R == null ? void 0 : R.proposers) ? R.proposers.map((N) => String(N)) : [],
        metadata: (0, f.isSet)(R.metadata) ? String(R.metadata) : "",
        messages: Array.isArray(R == null ? void 0 : R.messages) ? R.messages.map((N) => u.Any.fromJSON(N)) : [],
        exec: (0, f.isSet)(R.exec) ? T(R.exec) : 0,
        title: (0, f.isSet)(R.title) ? String(R.title) : "",
        summary: (0, f.isSet)(R.summary) ? String(R.summary) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = R.groupPolicyAddress), R.proposers ? N.proposers = R.proposers.map((Q) => Q) : N.proposers = [], R.metadata !== void 0 && (N.metadata = R.metadata), R.messages ? N.messages = R.messages.map((Q) => Q ? u.Any.toJSON(Q) : void 0) : N.messages = [], R.exec !== void 0 && (N.exec = L(R.exec)), R.title !== void 0 && (N.title = R.title), R.summary !== void 0 && (N.summary = R.summary), N;
    },
    fromPartial(R) {
      var Q, K;
      const N = a();
      return N.groupPolicyAddress = R.groupPolicyAddress ?? "", N.proposers = ((Q = R.proposers) == null ? void 0 : Q.map((z) => z)) || [], N.metadata = R.metadata ?? "", N.messages = ((K = R.messages) == null ? void 0 : K.map((z) => u.Any.fromPartial(z))) || [], N.exec = R.exec ?? 0, N.title = R.title ?? "", N.summary = R.summary ?? "", N;
    }
  };
  function l() {
    return {
      proposalId: f.Long.UZERO
    };
  }
  e.MsgSubmitProposalResponse = {
    encode(R, N = O.Writer.create()) {
      return R.proposalId.isZero() || N.uint32(8).uint64(R.proposalId), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = l();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.proposalId = Q.uint64();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        proposalId: (0, f.isSet)(R.proposalId) ? f.Long.fromValue(R.proposalId) : f.Long.UZERO
      };
    },
    toJSON(R) {
      const N = {};
      return R.proposalId !== void 0 && (N.proposalId = (R.proposalId || f.Long.UZERO).toString()), N;
    },
    fromPartial(R) {
      const N = l();
      return N.proposalId = R.proposalId !== void 0 && R.proposalId !== null ? f.Long.fromValue(R.proposalId) : f.Long.UZERO, N;
    }
  };
  function C() {
    return {
      proposalId: f.Long.UZERO,
      address: ""
    };
  }
  e.MsgWithdrawProposal = {
    encode(R, N = O.Writer.create()) {
      return R.proposalId.isZero() || N.uint32(8).uint64(R.proposalId), R.address !== "" && N.uint32(18).string(R.address), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = C();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.proposalId = Q.uint64();
            break;
          case 2:
            z.address = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        proposalId: (0, f.isSet)(R.proposalId) ? f.Long.fromValue(R.proposalId) : f.Long.UZERO,
        address: (0, f.isSet)(R.address) ? String(R.address) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.proposalId !== void 0 && (N.proposalId = (R.proposalId || f.Long.UZERO).toString()), R.address !== void 0 && (N.address = R.address), N;
    },
    fromPartial(R) {
      const N = C();
      return N.proposalId = R.proposalId !== void 0 && R.proposalId !== null ? f.Long.fromValue(R.proposalId) : f.Long.UZERO, N.address = R.address ?? "", N;
    }
  };
  function v() {
    return {};
  }
  e.MsgWithdrawProposalResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = v();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return v();
    }
  };
  function k() {
    return {
      proposalId: f.Long.UZERO,
      voter: "",
      option: 0,
      metadata: "",
      exec: 0
    };
  }
  e.MsgVote = {
    encode(R, N = O.Writer.create()) {
      return R.proposalId.isZero() || N.uint32(8).uint64(R.proposalId), R.voter !== "" && N.uint32(18).string(R.voter), R.option !== 0 && N.uint32(24).int32(R.option), R.metadata !== "" && N.uint32(34).string(R.metadata), R.exec !== 0 && N.uint32(40).int32(R.exec), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = k();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.proposalId = Q.uint64();
            break;
          case 2:
            z.voter = Q.string();
            break;
          case 3:
            z.option = Q.int32();
            break;
          case 4:
            z.metadata = Q.string();
            break;
          case 5:
            z.exec = Q.int32();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        proposalId: (0, f.isSet)(R.proposalId) ? f.Long.fromValue(R.proposalId) : f.Long.UZERO,
        voter: (0, f.isSet)(R.voter) ? String(R.voter) : "",
        option: (0, f.isSet)(R.option) ? (0, r.voteOptionFromJSON)(R.option) : 0,
        metadata: (0, f.isSet)(R.metadata) ? String(R.metadata) : "",
        exec: (0, f.isSet)(R.exec) ? T(R.exec) : 0
      };
    },
    toJSON(R) {
      const N = {};
      return R.proposalId !== void 0 && (N.proposalId = (R.proposalId || f.Long.UZERO).toString()), R.voter !== void 0 && (N.voter = R.voter), R.option !== void 0 && (N.option = (0, r.voteOptionToJSON)(R.option)), R.metadata !== void 0 && (N.metadata = R.metadata), R.exec !== void 0 && (N.exec = L(R.exec)), N;
    },
    fromPartial(R) {
      const N = k();
      return N.proposalId = R.proposalId !== void 0 && R.proposalId !== null ? f.Long.fromValue(R.proposalId) : f.Long.UZERO, N.voter = R.voter ?? "", N.option = R.option ?? 0, N.metadata = R.metadata ?? "", N.exec = R.exec ?? 0, N;
    }
  };
  function U() {
    return {};
  }
  e.MsgVoteResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = U();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return U();
    }
  };
  function F() {
    return {
      proposalId: f.Long.UZERO,
      executor: ""
    };
  }
  e.MsgExec = {
    encode(R, N = O.Writer.create()) {
      return R.proposalId.isZero() || N.uint32(8).uint64(R.proposalId), R.executor !== "" && N.uint32(18).string(R.executor), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = F();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.proposalId = Q.uint64();
            break;
          case 2:
            z.executor = Q.string();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        proposalId: (0, f.isSet)(R.proposalId) ? f.Long.fromValue(R.proposalId) : f.Long.UZERO,
        executor: (0, f.isSet)(R.executor) ? String(R.executor) : ""
      };
    },
    toJSON(R) {
      const N = {};
      return R.proposalId !== void 0 && (N.proposalId = (R.proposalId || f.Long.UZERO).toString()), R.executor !== void 0 && (N.executor = R.executor), N;
    },
    fromPartial(R) {
      const N = F();
      return N.proposalId = R.proposalId !== void 0 && R.proposalId !== null ? f.Long.fromValue(R.proposalId) : f.Long.UZERO, N.executor = R.executor ?? "", N;
    }
  };
  function q() {
    return {
      result: 0
    };
  }
  e.MsgExecResponse = {
    encode(R, N = O.Writer.create()) {
      return R.result !== 0 && N.uint32(16).int32(R.result), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = q();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 2:
            z.result = Q.int32();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        result: (0, f.isSet)(R.result) ? (0, r.proposalExecutorResultFromJSON)(R.result) : 0
      };
    },
    toJSON(R) {
      const N = {};
      return R.result !== void 0 && (N.result = (0, r.proposalExecutorResultToJSON)(R.result)), N;
    },
    fromPartial(R) {
      const N = q();
      return N.result = R.result ?? 0, N;
    }
  };
  function o() {
    return {
      address: "",
      groupId: f.Long.UZERO
    };
  }
  e.MsgLeaveGroup = {
    encode(R, N = O.Writer.create()) {
      return R.address !== "" && N.uint32(10).string(R.address), R.groupId.isZero() || N.uint32(16).uint64(R.groupId), N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = o();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          case 1:
            z.address = Q.string();
            break;
          case 2:
            z.groupId = Q.uint64();
            break;
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {
        address: (0, f.isSet)(R.address) ? String(R.address) : "",
        groupId: (0, f.isSet)(R.groupId) ? f.Long.fromValue(R.groupId) : f.Long.UZERO
      };
    },
    toJSON(R) {
      const N = {};
      return R.address !== void 0 && (N.address = R.address), R.groupId !== void 0 && (N.groupId = (R.groupId || f.Long.UZERO).toString()), N;
    },
    fromPartial(R) {
      const N = o();
      return N.address = R.address ?? "", N.groupId = R.groupId !== void 0 && R.groupId !== null ? f.Long.fromValue(R.groupId) : f.Long.UZERO, N;
    }
  };
  function P() {
    return {};
  }
  e.MsgLeaveGroupResponse = {
    encode(R, N = O.Writer.create()) {
      return N;
    },
    decode(R, N) {
      const Q = R instanceof O.Reader ? R : new O.Reader(R);
      let K = N === void 0 ? Q.len : Q.pos + N;
      const z = P();
      for (; Q.pos < K; ) {
        const re = Q.uint32();
        switch (re >>> 3) {
          default:
            Q.skipType(re & 7);
            break;
        }
      }
      return z;
    },
    fromJSON(R) {
      return {};
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return P();
    }
  };
  class m {
    constructor(N) {
      this.rpc = N, this.CreateGroup = this.CreateGroup.bind(this), this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this), this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this), this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this), this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this), this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this), this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this), this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this), this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this), this.SubmitProposal = this.SubmitProposal.bind(this), this.WithdrawProposal = this.WithdrawProposal.bind(this), this.Vote = this.Vote.bind(this), this.Exec = this.Exec.bind(this), this.LeaveGroup = this.LeaveGroup.bind(this);
    }
    CreateGroup(N) {
      const Q = e.MsgCreateGroup.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", Q).then((z) => e.MsgCreateGroupResponse.decode(new O.Reader(z)));
    }
    UpdateGroupMembers(N) {
      const Q = e.MsgUpdateGroupMembers.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", Q).then((z) => e.MsgUpdateGroupMembersResponse.decode(new O.Reader(z)));
    }
    UpdateGroupAdmin(N) {
      const Q = e.MsgUpdateGroupAdmin.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", Q).then((z) => e.MsgUpdateGroupAdminResponse.decode(new O.Reader(z)));
    }
    UpdateGroupMetadata(N) {
      const Q = e.MsgUpdateGroupMetadata.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", Q).then((z) => e.MsgUpdateGroupMetadataResponse.decode(new O.Reader(z)));
    }
    CreateGroupPolicy(N) {
      const Q = e.MsgCreateGroupPolicy.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", Q).then((z) => e.MsgCreateGroupPolicyResponse.decode(new O.Reader(z)));
    }
    CreateGroupWithPolicy(N) {
      const Q = e.MsgCreateGroupWithPolicy.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", Q).then((z) => e.MsgCreateGroupWithPolicyResponse.decode(new O.Reader(z)));
    }
    UpdateGroupPolicyAdmin(N) {
      const Q = e.MsgUpdateGroupPolicyAdmin.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", Q).then((z) => e.MsgUpdateGroupPolicyAdminResponse.decode(new O.Reader(z)));
    }
    UpdateGroupPolicyDecisionPolicy(N) {
      const Q = e.MsgUpdateGroupPolicyDecisionPolicy.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", Q).then((z) => e.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new O.Reader(z)));
    }
    UpdateGroupPolicyMetadata(N) {
      const Q = e.MsgUpdateGroupPolicyMetadata.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", Q).then((z) => e.MsgUpdateGroupPolicyMetadataResponse.decode(new O.Reader(z)));
    }
    SubmitProposal(N) {
      const Q = e.MsgSubmitProposal.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", Q).then((z) => e.MsgSubmitProposalResponse.decode(new O.Reader(z)));
    }
    WithdrawProposal(N) {
      const Q = e.MsgWithdrawProposal.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", Q).then((z) => e.MsgWithdrawProposalResponse.decode(new O.Reader(z)));
    }
    Vote(N) {
      const Q = e.MsgVote.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Vote", Q).then((z) => e.MsgVoteResponse.decode(new O.Reader(z)));
    }
    Exec(N) {
      const Q = e.MsgExec.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Exec", Q).then((z) => e.MsgExecResponse.decode(new O.Reader(z)));
    }
    LeaveGroup(N) {
      const Q = e.MsgLeaveGroup.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", Q).then((z) => e.MsgLeaveGroupResponse.decode(new O.Reader(z)));
    }
  }
  e.MsgClientImpl = m;
})(ku);
Object.defineProperty(di, "__esModule", { value: !0 });
di.groupTypes = void 0;
const He = ku;
di.groupTypes = [
  ["/cosmos.group.v1.MsgCreateGroup", He.MsgCreateGroup],
  ["/cosmos.group.v1.MsgCreateGroupPolicy", He.MsgCreateGroupPolicy],
  ["/cosmos.group.v1.MsgCreateGroupWithPolicy", He.MsgCreateGroupWithPolicy],
  ["/cosmos.group.v1.MsgExec", He.MsgExec],
  ["/cosmos.group.v1.MsgLeaveGroup", He.MsgLeaveGroup],
  ["/cosmos.group.v1.MsgSubmitProposal", He.MsgSubmitProposal],
  ["/cosmos.group.v1.MsgUpdateGroupAdmin", He.MsgUpdateGroupAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupMembers", He.MsgUpdateGroupMembers],
  ["/cosmos.group.v1.MsgUpdateGroupMetadata", He.MsgUpdateGroupMetadata],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", He.MsgUpdateGroupPolicyAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", He.MsgUpdateGroupPolicyDecisionPolicy],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", He.MsgUpdateGroupPolicyMetadata],
  ["/cosmos.group.v1.MsgVote", He.MsgVote],
  ["/cosmos.group.v1.MsgWithdrawProposal", He.MsgWithdrawProposal]
];
var It = {}, ui = {}, In = {}, _u = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(V, D, b, h) {
    h === void 0 && (h = b);
    var S = Object.getOwnPropertyDescriptor(D, b);
    (!S || ("get" in S ? !D.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return D[b];
    } }), Object.defineProperty(V, h, S);
  } : function(V, D, b, h) {
    h === void 0 && (h = b), V[h] = D[b];
  }), c = G && G.__setModuleDefault || (Object.create ? function(V, D) {
    Object.defineProperty(V, "default", { enumerable: !0, value: D });
  } : function(V, D) {
    V.default = D;
  }), i = G && G.__importStar || function(V) {
    if (V && V.__esModule)
      return V;
    var D = {};
    if (V != null)
      for (var b in V)
        b !== "default" && Object.prototype.hasOwnProperty.call(V, b) && n(D, V, b);
    return c(D, V), D;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ModuleVersion = e.CancelSoftwareUpgradeProposal = e.SoftwareUpgradeProposal = e.Plan = e.protobufPackage = void 0;
  const r = _e, u = Se, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.upgrade.v1beta1";
  function A() {
    return {
      name: "",
      time: void 0,
      height: f.Long.ZERO,
      info: "",
      upgradedClientState: void 0
    };
  }
  e.Plan = {
    encode(V, D = O.Writer.create()) {
      return V.name !== "" && D.uint32(10).string(V.name), V.time !== void 0 && r.Timestamp.encode(V.time, D.uint32(18).fork()).ldelim(), V.height.isZero() || D.uint32(24).int64(V.height), V.info !== "" && D.uint32(34).string(V.info), V.upgradedClientState !== void 0 && u.Any.encode(V.upgradedClientState, D.uint32(42).fork()).ldelim(), D;
    },
    decode(V, D) {
      const b = V instanceof O.Reader ? V : new O.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = A();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          case 1:
            S.name = b.string();
            break;
          case 2:
            S.time = r.Timestamp.decode(b, b.uint32());
            break;
          case 3:
            S.height = b.int64();
            break;
          case 4:
            S.info = b.string();
            break;
          case 5:
            S.upgradedClientState = u.Any.decode(b, b.uint32());
            break;
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {
        name: (0, f.isSet)(V.name) ? String(V.name) : "",
        time: (0, f.isSet)(V.time) ? (0, f.fromJsonTimestamp)(V.time) : void 0,
        height: (0, f.isSet)(V.height) ? f.Long.fromValue(V.height) : f.Long.ZERO,
        info: (0, f.isSet)(V.info) ? String(V.info) : "",
        upgradedClientState: (0, f.isSet)(V.upgradedClientState) ? u.Any.fromJSON(V.upgradedClientState) : void 0
      };
    },
    toJSON(V) {
      const D = {};
      return V.name !== void 0 && (D.name = V.name), V.time !== void 0 && (D.time = (0, f.fromTimestamp)(V.time).toISOString()), V.height !== void 0 && (D.height = (V.height || f.Long.ZERO).toString()), V.info !== void 0 && (D.info = V.info), V.upgradedClientState !== void 0 && (D.upgradedClientState = V.upgradedClientState ? u.Any.toJSON(V.upgradedClientState) : void 0), D;
    },
    fromPartial(V) {
      const D = A();
      return D.name = V.name ?? "", D.time = V.time !== void 0 && V.time !== null ? r.Timestamp.fromPartial(V.time) : void 0, D.height = V.height !== void 0 && V.height !== null ? f.Long.fromValue(V.height) : f.Long.ZERO, D.info = V.info ?? "", D.upgradedClientState = V.upgradedClientState !== void 0 && V.upgradedClientState !== null ? u.Any.fromPartial(V.upgradedClientState) : void 0, D;
    }
  };
  function T() {
    return {
      title: "",
      description: "",
      plan: void 0
    };
  }
  e.SoftwareUpgradeProposal = {
    encode(V, D = O.Writer.create()) {
      return V.title !== "" && D.uint32(10).string(V.title), V.description !== "" && D.uint32(18).string(V.description), V.plan !== void 0 && e.Plan.encode(V.plan, D.uint32(26).fork()).ldelim(), D;
    },
    decode(V, D) {
      const b = V instanceof O.Reader ? V : new O.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = T();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          case 1:
            S.title = b.string();
            break;
          case 2:
            S.description = b.string();
            break;
          case 3:
            S.plan = e.Plan.decode(b, b.uint32());
            break;
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {
        title: (0, f.isSet)(V.title) ? String(V.title) : "",
        description: (0, f.isSet)(V.description) ? String(V.description) : "",
        plan: (0, f.isSet)(V.plan) ? e.Plan.fromJSON(V.plan) : void 0
      };
    },
    toJSON(V) {
      const D = {};
      return V.title !== void 0 && (D.title = V.title), V.description !== void 0 && (D.description = V.description), V.plan !== void 0 && (D.plan = V.plan ? e.Plan.toJSON(V.plan) : void 0), D;
    },
    fromPartial(V) {
      const D = T();
      return D.title = V.title ?? "", D.description = V.description ?? "", D.plan = V.plan !== void 0 && V.plan !== null ? e.Plan.fromPartial(V.plan) : void 0, D;
    }
  };
  function L() {
    return {
      title: "",
      description: ""
    };
  }
  e.CancelSoftwareUpgradeProposal = {
    encode(V, D = O.Writer.create()) {
      return V.title !== "" && D.uint32(10).string(V.title), V.description !== "" && D.uint32(18).string(V.description), D;
    },
    decode(V, D) {
      const b = V instanceof O.Reader ? V : new O.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = L();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          case 1:
            S.title = b.string();
            break;
          case 2:
            S.description = b.string();
            break;
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {
        title: (0, f.isSet)(V.title) ? String(V.title) : "",
        description: (0, f.isSet)(V.description) ? String(V.description) : ""
      };
    },
    toJSON(V) {
      const D = {};
      return V.title !== void 0 && (D.title = V.title), V.description !== void 0 && (D.description = V.description), D;
    },
    fromPartial(V) {
      const D = L();
      return D.title = V.title ?? "", D.description = V.description ?? "", D;
    }
  };
  function M() {
    return {
      name: "",
      version: f.Long.UZERO
    };
  }
  e.ModuleVersion = {
    encode(V, D = O.Writer.create()) {
      return V.name !== "" && D.uint32(10).string(V.name), V.version.isZero() || D.uint32(16).uint64(V.version), D;
    },
    decode(V, D) {
      const b = V instanceof O.Reader ? V : new O.Reader(V);
      let h = D === void 0 ? b.len : b.pos + D;
      const S = M();
      for (; b.pos < h; ) {
        const _ = b.uint32();
        switch (_ >>> 3) {
          case 1:
            S.name = b.string();
            break;
          case 2:
            S.version = b.uint64();
            break;
          default:
            b.skipType(_ & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(V) {
      return {
        name: (0, f.isSet)(V.name) ? String(V.name) : "",
        version: (0, f.isSet)(V.version) ? f.Long.fromValue(V.version) : f.Long.UZERO
      };
    },
    toJSON(V) {
      const D = {};
      return V.name !== void 0 && (D.name = V.name), V.version !== void 0 && (D.version = (V.version || f.Long.UZERO).toString()), D;
    },
    fromPartial(V) {
      const D = M();
      return D.name = V.name ?? "", D.version = V.version !== void 0 && V.version !== null ? f.Long.fromValue(V.version) : f.Long.UZERO, D;
    }
  };
})(_u);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(h, S, _, d) {
    d === void 0 && (d = _);
    var p = Object.getOwnPropertyDescriptor(S, _);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[_];
    } }), Object.defineProperty(h, d, p);
  } : function(h, S, _, d) {
    d === void 0 && (d = _), h[d] = S[_];
  }), c = G && G.__setModuleDefault || (Object.create ? function(h, S) {
    Object.defineProperty(h, "default", { enumerable: !0, value: S });
  } : function(h, S) {
    h.default = S;
  }), i = G && G.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var S = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && n(S, h, _);
    return c(S, h), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Height = e.UpgradeProposal = e.ClientUpdateProposal = e.ClientConsensusStates = e.ConsensusStateWithHeight = e.IdentifiedClientState = e.protobufPackage = void 0;
  const r = Se, u = _u, f = oe, O = i(ie);
  e.protobufPackage = "ibc.core.client.v1";
  function A() {
    return {
      clientId: "",
      clientState: void 0
    };
  }
  e.IdentifiedClientState = {
    encode(h, S = O.Writer.create()) {
      return h.clientId !== "" && S.uint32(10).string(h.clientId), h.clientState !== void 0 && r.Any.encode(h.clientState, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = A();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.clientId = _.string();
            break;
          case 2:
            p.clientState = r.Any.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        clientId: (0, f.isSet)(h.clientId) ? String(h.clientId) : "",
        clientState: (0, f.isSet)(h.clientState) ? r.Any.fromJSON(h.clientState) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.clientId !== void 0 && (S.clientId = h.clientId), h.clientState !== void 0 && (S.clientState = h.clientState ? r.Any.toJSON(h.clientState) : void 0), S;
    },
    fromPartial(h) {
      const S = A();
      return S.clientId = h.clientId ?? "", S.clientState = h.clientState !== void 0 && h.clientState !== null ? r.Any.fromPartial(h.clientState) : void 0, S;
    }
  };
  function T() {
    return {
      height: void 0,
      consensusState: void 0
    };
  }
  e.ConsensusStateWithHeight = {
    encode(h, S = O.Writer.create()) {
      return h.height !== void 0 && e.Height.encode(h.height, S.uint32(10).fork()).ldelim(), h.consensusState !== void 0 && r.Any.encode(h.consensusState, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = T();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.height = e.Height.decode(_, _.uint32());
            break;
          case 2:
            p.consensusState = r.Any.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        height: (0, f.isSet)(h.height) ? e.Height.fromJSON(h.height) : void 0,
        consensusState: (0, f.isSet)(h.consensusState) ? r.Any.fromJSON(h.consensusState) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.height !== void 0 && (S.height = h.height ? e.Height.toJSON(h.height) : void 0), h.consensusState !== void 0 && (S.consensusState = h.consensusState ? r.Any.toJSON(h.consensusState) : void 0), S;
    },
    fromPartial(h) {
      const S = T();
      return S.height = h.height !== void 0 && h.height !== null ? e.Height.fromPartial(h.height) : void 0, S.consensusState = h.consensusState !== void 0 && h.consensusState !== null ? r.Any.fromPartial(h.consensusState) : void 0, S;
    }
  };
  function L() {
    return {
      clientId: "",
      consensusStates: []
    };
  }
  e.ClientConsensusStates = {
    encode(h, S = O.Writer.create()) {
      h.clientId !== "" && S.uint32(10).string(h.clientId);
      for (const _ of h.consensusStates)
        e.ConsensusStateWithHeight.encode(_, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = L();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.clientId = _.string();
            break;
          case 2:
            p.consensusStates.push(e.ConsensusStateWithHeight.decode(_, _.uint32()));
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        clientId: (0, f.isSet)(h.clientId) ? String(h.clientId) : "",
        consensusStates: Array.isArray(h == null ? void 0 : h.consensusStates) ? h.consensusStates.map((S) => e.ConsensusStateWithHeight.fromJSON(S)) : []
      };
    },
    toJSON(h) {
      const S = {};
      return h.clientId !== void 0 && (S.clientId = h.clientId), h.consensusStates ? S.consensusStates = h.consensusStates.map((_) => _ ? e.ConsensusStateWithHeight.toJSON(_) : void 0) : S.consensusStates = [], S;
    },
    fromPartial(h) {
      var _;
      const S = L();
      return S.clientId = h.clientId ?? "", S.consensusStates = ((_ = h.consensusStates) == null ? void 0 : _.map((d) => e.ConsensusStateWithHeight.fromPartial(d))) || [], S;
    }
  };
  function M() {
    return {
      title: "",
      description: "",
      subjectClientId: "",
      substituteClientId: ""
    };
  }
  e.ClientUpdateProposal = {
    encode(h, S = O.Writer.create()) {
      return h.title !== "" && S.uint32(10).string(h.title), h.description !== "" && S.uint32(18).string(h.description), h.subjectClientId !== "" && S.uint32(26).string(h.subjectClientId), h.substituteClientId !== "" && S.uint32(34).string(h.substituteClientId), S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = M();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.title = _.string();
            break;
          case 2:
            p.description = _.string();
            break;
          case 3:
            p.subjectClientId = _.string();
            break;
          case 4:
            p.substituteClientId = _.string();
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        title: (0, f.isSet)(h.title) ? String(h.title) : "",
        description: (0, f.isSet)(h.description) ? String(h.description) : "",
        subjectClientId: (0, f.isSet)(h.subjectClientId) ? String(h.subjectClientId) : "",
        substituteClientId: (0, f.isSet)(h.substituteClientId) ? String(h.substituteClientId) : ""
      };
    },
    toJSON(h) {
      const S = {};
      return h.title !== void 0 && (S.title = h.title), h.description !== void 0 && (S.description = h.description), h.subjectClientId !== void 0 && (S.subjectClientId = h.subjectClientId), h.substituteClientId !== void 0 && (S.substituteClientId = h.substituteClientId), S;
    },
    fromPartial(h) {
      const S = M();
      return S.title = h.title ?? "", S.description = h.description ?? "", S.subjectClientId = h.subjectClientId ?? "", S.substituteClientId = h.substituteClientId ?? "", S;
    }
  };
  function V() {
    return {
      title: "",
      description: "",
      plan: void 0,
      upgradedClientState: void 0
    };
  }
  e.UpgradeProposal = {
    encode(h, S = O.Writer.create()) {
      return h.title !== "" && S.uint32(10).string(h.title), h.description !== "" && S.uint32(18).string(h.description), h.plan !== void 0 && u.Plan.encode(h.plan, S.uint32(26).fork()).ldelim(), h.upgradedClientState !== void 0 && r.Any.encode(h.upgradedClientState, S.uint32(34).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = V();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.title = _.string();
            break;
          case 2:
            p.description = _.string();
            break;
          case 3:
            p.plan = u.Plan.decode(_, _.uint32());
            break;
          case 4:
            p.upgradedClientState = r.Any.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        title: (0, f.isSet)(h.title) ? String(h.title) : "",
        description: (0, f.isSet)(h.description) ? String(h.description) : "",
        plan: (0, f.isSet)(h.plan) ? u.Plan.fromJSON(h.plan) : void 0,
        upgradedClientState: (0, f.isSet)(h.upgradedClientState) ? r.Any.fromJSON(h.upgradedClientState) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.title !== void 0 && (S.title = h.title), h.description !== void 0 && (S.description = h.description), h.plan !== void 0 && (S.plan = h.plan ? u.Plan.toJSON(h.plan) : void 0), h.upgradedClientState !== void 0 && (S.upgradedClientState = h.upgradedClientState ? r.Any.toJSON(h.upgradedClientState) : void 0), S;
    },
    fromPartial(h) {
      const S = V();
      return S.title = h.title ?? "", S.description = h.description ?? "", S.plan = h.plan !== void 0 && h.plan !== null ? u.Plan.fromPartial(h.plan) : void 0, S.upgradedClientState = h.upgradedClientState !== void 0 && h.upgradedClientState !== null ? r.Any.fromPartial(h.upgradedClientState) : void 0, S;
    }
  };
  function D() {
    return {
      revisionNumber: f.Long.UZERO,
      revisionHeight: f.Long.UZERO
    };
  }
  e.Height = {
    encode(h, S = O.Writer.create()) {
      return h.revisionNumber.isZero() || S.uint32(8).uint64(h.revisionNumber), h.revisionHeight.isZero() || S.uint32(16).uint64(h.revisionHeight), S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = D();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.revisionNumber = _.uint64();
            break;
          case 2:
            p.revisionHeight = _.uint64();
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        revisionNumber: (0, f.isSet)(h.revisionNumber) ? f.Long.fromValue(h.revisionNumber) : f.Long.UZERO,
        revisionHeight: (0, f.isSet)(h.revisionHeight) ? f.Long.fromValue(h.revisionHeight) : f.Long.UZERO
      };
    },
    toJSON(h) {
      const S = {};
      return h.revisionNumber !== void 0 && (S.revisionNumber = (h.revisionNumber || f.Long.UZERO).toString()), h.revisionHeight !== void 0 && (S.revisionHeight = (h.revisionHeight || f.Long.UZERO).toString()), S;
    },
    fromPartial(h) {
      const S = D();
      return S.revisionNumber = h.revisionNumber !== void 0 && h.revisionNumber !== null ? f.Long.fromValue(h.revisionNumber) : f.Long.UZERO, S.revisionHeight = h.revisionHeight !== void 0 && h.revisionHeight !== null ? f.Long.fromValue(h.revisionHeight) : f.Long.UZERO, S;
    }
  };
  function b() {
    return {
      allowedClients: []
    };
  }
  e.Params = {
    encode(h, S = O.Writer.create()) {
      for (const _ of h.allowedClients)
        S.uint32(10).string(_);
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = b();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.allowedClients.push(_.string());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        allowedClients: Array.isArray(h == null ? void 0 : h.allowedClients) ? h.allowedClients.map((S) => String(S)) : []
      };
    },
    toJSON(h) {
      const S = {};
      return h.allowedClients ? S.allowedClients = h.allowedClients.map((_) => _) : S.allowedClients = [], S;
    },
    fromPartial(h) {
      var _;
      const S = b();
      return S.allowedClients = ((_ = h.allowedClients) == null ? void 0 : _.map((d) => d)) || [], S;
    }
  };
})(In);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(M, V, D, b) {
    b === void 0 && (b = D);
    var h = Object.getOwnPropertyDescriptor(V, D);
    (!h || ("get" in h ? !V.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return V[D];
    } }), Object.defineProperty(M, b, h);
  } : function(M, V, D, b) {
    b === void 0 && (b = D), M[b] = V[D];
  }), c = G && G.__setModuleDefault || (Object.create ? function(M, V) {
    Object.defineProperty(M, "default", { enumerable: !0, value: V });
  } : function(M, V) {
    M.default = V;
  }), i = G && G.__importStar || function(M) {
    if (M && M.__esModule)
      return M;
    var V = {};
    if (M != null)
      for (var D in M)
        D !== "default" && Object.prototype.hasOwnProperty.call(M, D) && n(V, M, D);
    return c(V, M), V;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgTransferResponse = e.MsgTransfer = e.protobufPackage = void 0;
  const r = Me, u = In, f = oe, O = i(ie);
  e.protobufPackage = "ibc.applications.transfer.v1";
  function A() {
    return {
      sourcePort: "",
      sourceChannel: "",
      token: void 0,
      sender: "",
      receiver: "",
      timeoutHeight: void 0,
      timeoutTimestamp: f.Long.UZERO,
      memo: ""
    };
  }
  e.MsgTransfer = {
    encode(M, V = O.Writer.create()) {
      return M.sourcePort !== "" && V.uint32(10).string(M.sourcePort), M.sourceChannel !== "" && V.uint32(18).string(M.sourceChannel), M.token !== void 0 && r.Coin.encode(M.token, V.uint32(26).fork()).ldelim(), M.sender !== "" && V.uint32(34).string(M.sender), M.receiver !== "" && V.uint32(42).string(M.receiver), M.timeoutHeight !== void 0 && u.Height.encode(M.timeoutHeight, V.uint32(50).fork()).ldelim(), M.timeoutTimestamp.isZero() || V.uint32(56).uint64(M.timeoutTimestamp), M.memo !== "" && V.uint32(66).string(M.memo), V;
    },
    decode(M, V) {
      const D = M instanceof O.Reader ? M : new O.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = A();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.sourcePort = D.string();
            break;
          case 2:
            h.sourceChannel = D.string();
            break;
          case 3:
            h.token = r.Coin.decode(D, D.uint32());
            break;
          case 4:
            h.sender = D.string();
            break;
          case 5:
            h.receiver = D.string();
            break;
          case 6:
            h.timeoutHeight = u.Height.decode(D, D.uint32());
            break;
          case 7:
            h.timeoutTimestamp = D.uint64();
            break;
          case 8:
            h.memo = D.string();
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        sourcePort: (0, f.isSet)(M.sourcePort) ? String(M.sourcePort) : "",
        sourceChannel: (0, f.isSet)(M.sourceChannel) ? String(M.sourceChannel) : "",
        token: (0, f.isSet)(M.token) ? r.Coin.fromJSON(M.token) : void 0,
        sender: (0, f.isSet)(M.sender) ? String(M.sender) : "",
        receiver: (0, f.isSet)(M.receiver) ? String(M.receiver) : "",
        timeoutHeight: (0, f.isSet)(M.timeoutHeight) ? u.Height.fromJSON(M.timeoutHeight) : void 0,
        timeoutTimestamp: (0, f.isSet)(M.timeoutTimestamp) ? f.Long.fromValue(M.timeoutTimestamp) : f.Long.UZERO,
        memo: (0, f.isSet)(M.memo) ? String(M.memo) : ""
      };
    },
    toJSON(M) {
      const V = {};
      return M.sourcePort !== void 0 && (V.sourcePort = M.sourcePort), M.sourceChannel !== void 0 && (V.sourceChannel = M.sourceChannel), M.token !== void 0 && (V.token = M.token ? r.Coin.toJSON(M.token) : void 0), M.sender !== void 0 && (V.sender = M.sender), M.receiver !== void 0 && (V.receiver = M.receiver), M.timeoutHeight !== void 0 && (V.timeoutHeight = M.timeoutHeight ? u.Height.toJSON(M.timeoutHeight) : void 0), M.timeoutTimestamp !== void 0 && (V.timeoutTimestamp = (M.timeoutTimestamp || f.Long.UZERO).toString()), M.memo !== void 0 && (V.memo = M.memo), V;
    },
    fromPartial(M) {
      const V = A();
      return V.sourcePort = M.sourcePort ?? "", V.sourceChannel = M.sourceChannel ?? "", V.token = M.token !== void 0 && M.token !== null ? r.Coin.fromPartial(M.token) : void 0, V.sender = M.sender ?? "", V.receiver = M.receiver ?? "", V.timeoutHeight = M.timeoutHeight !== void 0 && M.timeoutHeight !== null ? u.Height.fromPartial(M.timeoutHeight) : void 0, V.timeoutTimestamp = M.timeoutTimestamp !== void 0 && M.timeoutTimestamp !== null ? f.Long.fromValue(M.timeoutTimestamp) : f.Long.UZERO, V.memo = M.memo ?? "", V;
    }
  };
  function T() {
    return {
      sequence: f.Long.UZERO
    };
  }
  e.MsgTransferResponse = {
    encode(M, V = O.Writer.create()) {
      return M.sequence.isZero() || V.uint32(8).uint64(M.sequence), V;
    },
    decode(M, V) {
      const D = M instanceof O.Reader ? M : new O.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = T();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.sequence = D.uint64();
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        sequence: (0, f.isSet)(M.sequence) ? f.Long.fromValue(M.sequence) : f.Long.UZERO
      };
    },
    toJSON(M) {
      const V = {};
      return M.sequence !== void 0 && (V.sequence = (M.sequence || f.Long.UZERO).toString()), V;
    },
    fromPartial(M) {
      const V = T();
      return V.sequence = M.sequence !== void 0 && M.sequence !== null ? f.Long.fromValue(M.sequence) : f.Long.UZERO, V;
    }
  };
  class L {
    constructor(V) {
      this.rpc = V, this.Transfer = this.Transfer.bind(this);
    }
    Transfer(V) {
      const D = e.MsgTransfer.encode(V).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", D).then((h) => e.MsgTransferResponse.decode(new O.Reader(h)));
    }
  }
  e.MsgClientImpl = L;
})(ui);
var Th = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(It, "__esModule", { value: !0 });
It.createIbcAminoConverters = It.isAminoMsgTransfer = void 0;
const Eh = ui, Er = Th(An);
function Ch(e) {
  return e.type === "cosmos-sdk/MsgTransfer";
}
It.isAminoMsgTransfer = Ch;
function eo(e) {
  if (typeof e == "string")
    return e === "" ? void 0 : e;
  if (typeof e == "number")
    return e === 0 ? void 0 : e;
  if (Er.default.isLong(e))
    return e.isZero() ? void 0 : e;
  throw new Error(`Got unsupported type '${typeof e}'`);
}
function Ih() {
  return {
    "/ibc.applications.transfer.v1.MsgTransfer": {
      aminoType: "cosmos-sdk/MsgTransfer",
      toAmino: ({ sourcePort: e, sourceChannel: n, token: c, sender: i, receiver: r, timeoutHeight: u, timeoutTimestamp: f }) => {
        var O, A, T;
        return {
          source_port: e,
          source_channel: n,
          token: c,
          sender: i,
          receiver: r,
          timeout_height: u ? {
            revision_height: (O = eo(u.revisionHeight)) == null ? void 0 : O.toString(),
            revision_number: (A = eo(u.revisionNumber)) == null ? void 0 : A.toString()
          } : {},
          timeout_timestamp: (T = eo(f)) == null ? void 0 : T.toString()
        };
      },
      fromAmino: ({ source_port: e, source_channel: n, token: c, sender: i, receiver: r, timeout_height: u, timeout_timestamp: f }) => Eh.MsgTransfer.fromPartial({
        sourcePort: e,
        sourceChannel: n,
        token: c,
        sender: i,
        receiver: r,
        timeoutHeight: u ? {
          revisionHeight: Er.default.fromString(u.revision_height || "0", !0),
          revisionNumber: Er.default.fromString(u.revision_number || "0", !0)
        } : void 0,
        timeoutTimestamp: Er.default.fromString(f || "0", !0)
      })
    }
  };
}
It.createIbcAminoConverters = Ih;
var wt = {}, Nu = {}, ci = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(g, J, B, I) {
    I === void 0 && (I = B);
    var Z = Object.getOwnPropertyDescriptor(J, B);
    (!Z || ("get" in Z ? !J.__esModule : Z.writable || Z.configurable)) && (Z = { enumerable: !0, get: function() {
      return J[B];
    } }), Object.defineProperty(g, I, Z);
  } : function(g, J, B, I) {
    I === void 0 && (I = B), g[I] = J[B];
  }), c = G && G.__setModuleDefault || (Object.create ? function(g, J) {
    Object.defineProperty(g, "default", { enumerable: !0, value: J });
  } : function(g, J) {
    g.default = J;
  }), i = G && G.__importStar || function(g) {
    if (g && g.__esModule)
      return g;
    var J = {};
    if (g != null)
      for (var B in g)
        B !== "default" && Object.prototype.hasOwnProperty.call(g, B) && n(J, g, B);
    return c(J, g), J;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Acknowledgement = e.PacketId = e.PacketState = e.Packet = e.Counterparty = e.IdentifiedChannel = e.Channel = e.orderToJSON = e.orderFromJSON = e.Order = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const r = In, u = oe, f = i(ie);
  e.protobufPackage = "ibc.core.channel.v1";
  var O;
  (function(g) {
    g[g.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", g[g.STATE_INIT = 1] = "STATE_INIT", g[g.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", g[g.STATE_OPEN = 3] = "STATE_OPEN", g[g.STATE_CLOSED = 4] = "STATE_CLOSED", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = e.State || (e.State = {}));
  function A(g) {
    switch (g) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return O.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return O.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return O.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return O.STATE_OPEN;
      case 4:
      case "STATE_CLOSED":
        return O.STATE_CLOSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = A;
  function T(g) {
    switch (g) {
      case O.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case O.STATE_INIT:
        return "STATE_INIT";
      case O.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case O.STATE_OPEN:
        return "STATE_OPEN";
      case O.STATE_CLOSED:
        return "STATE_CLOSED";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = T;
  var L;
  (function(g) {
    g[g.ORDER_NONE_UNSPECIFIED = 0] = "ORDER_NONE_UNSPECIFIED", g[g.ORDER_UNORDERED = 1] = "ORDER_UNORDERED", g[g.ORDER_ORDERED = 2] = "ORDER_ORDERED", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(L = e.Order || (e.Order = {}));
  function M(g) {
    switch (g) {
      case 0:
      case "ORDER_NONE_UNSPECIFIED":
        return L.ORDER_NONE_UNSPECIFIED;
      case 1:
      case "ORDER_UNORDERED":
        return L.ORDER_UNORDERED;
      case 2:
      case "ORDER_ORDERED":
        return L.ORDER_ORDERED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return L.UNRECOGNIZED;
    }
  }
  e.orderFromJSON = M;
  function V(g) {
    switch (g) {
      case L.ORDER_NONE_UNSPECIFIED:
        return "ORDER_NONE_UNSPECIFIED";
      case L.ORDER_UNORDERED:
        return "ORDER_UNORDERED";
      case L.ORDER_ORDERED:
        return "ORDER_ORDERED";
      case L.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderToJSON = V;
  function D() {
    return {
      state: 0,
      ordering: 0,
      counterparty: void 0,
      connectionHops: [],
      version: ""
    };
  }
  e.Channel = {
    encode(g, J = f.Writer.create()) {
      g.state !== 0 && J.uint32(8).int32(g.state), g.ordering !== 0 && J.uint32(16).int32(g.ordering), g.counterparty !== void 0 && e.Counterparty.encode(g.counterparty, J.uint32(26).fork()).ldelim();
      for (const B of g.connectionHops)
        J.uint32(34).string(B);
      return g.version !== "" && J.uint32(42).string(g.version), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = D();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 1:
            Z.state = B.int32();
            break;
          case 2:
            Z.ordering = B.int32();
            break;
          case 3:
            Z.counterparty = e.Counterparty.decode(B, B.uint32());
            break;
          case 4:
            Z.connectionHops.push(B.string());
            break;
          case 5:
            Z.version = B.string();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        state: (0, u.isSet)(g.state) ? A(g.state) : 0,
        ordering: (0, u.isSet)(g.ordering) ? M(g.ordering) : 0,
        counterparty: (0, u.isSet)(g.counterparty) ? e.Counterparty.fromJSON(g.counterparty) : void 0,
        connectionHops: Array.isArray(g == null ? void 0 : g.connectionHops) ? g.connectionHops.map((J) => String(J)) : [],
        version: (0, u.isSet)(g.version) ? String(g.version) : ""
      };
    },
    toJSON(g) {
      const J = {};
      return g.state !== void 0 && (J.state = T(g.state)), g.ordering !== void 0 && (J.ordering = V(g.ordering)), g.counterparty !== void 0 && (J.counterparty = g.counterparty ? e.Counterparty.toJSON(g.counterparty) : void 0), g.connectionHops ? J.connectionHops = g.connectionHops.map((B) => B) : J.connectionHops = [], g.version !== void 0 && (J.version = g.version), J;
    },
    fromPartial(g) {
      var B;
      const J = D();
      return J.state = g.state ?? 0, J.ordering = g.ordering ?? 0, J.counterparty = g.counterparty !== void 0 && g.counterparty !== null ? e.Counterparty.fromPartial(g.counterparty) : void 0, J.connectionHops = ((B = g.connectionHops) == null ? void 0 : B.map((I) => I)) || [], J.version = g.version ?? "", J;
    }
  };
  function b() {
    return {
      state: 0,
      ordering: 0,
      counterparty: void 0,
      connectionHops: [],
      version: "",
      portId: "",
      channelId: ""
    };
  }
  e.IdentifiedChannel = {
    encode(g, J = f.Writer.create()) {
      g.state !== 0 && J.uint32(8).int32(g.state), g.ordering !== 0 && J.uint32(16).int32(g.ordering), g.counterparty !== void 0 && e.Counterparty.encode(g.counterparty, J.uint32(26).fork()).ldelim();
      for (const B of g.connectionHops)
        J.uint32(34).string(B);
      return g.version !== "" && J.uint32(42).string(g.version), g.portId !== "" && J.uint32(50).string(g.portId), g.channelId !== "" && J.uint32(58).string(g.channelId), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = b();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 1:
            Z.state = B.int32();
            break;
          case 2:
            Z.ordering = B.int32();
            break;
          case 3:
            Z.counterparty = e.Counterparty.decode(B, B.uint32());
            break;
          case 4:
            Z.connectionHops.push(B.string());
            break;
          case 5:
            Z.version = B.string();
            break;
          case 6:
            Z.portId = B.string();
            break;
          case 7:
            Z.channelId = B.string();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        state: (0, u.isSet)(g.state) ? A(g.state) : 0,
        ordering: (0, u.isSet)(g.ordering) ? M(g.ordering) : 0,
        counterparty: (0, u.isSet)(g.counterparty) ? e.Counterparty.fromJSON(g.counterparty) : void 0,
        connectionHops: Array.isArray(g == null ? void 0 : g.connectionHops) ? g.connectionHops.map((J) => String(J)) : [],
        version: (0, u.isSet)(g.version) ? String(g.version) : "",
        portId: (0, u.isSet)(g.portId) ? String(g.portId) : "",
        channelId: (0, u.isSet)(g.channelId) ? String(g.channelId) : ""
      };
    },
    toJSON(g) {
      const J = {};
      return g.state !== void 0 && (J.state = T(g.state)), g.ordering !== void 0 && (J.ordering = V(g.ordering)), g.counterparty !== void 0 && (J.counterparty = g.counterparty ? e.Counterparty.toJSON(g.counterparty) : void 0), g.connectionHops ? J.connectionHops = g.connectionHops.map((B) => B) : J.connectionHops = [], g.version !== void 0 && (J.version = g.version), g.portId !== void 0 && (J.portId = g.portId), g.channelId !== void 0 && (J.channelId = g.channelId), J;
    },
    fromPartial(g) {
      var B;
      const J = b();
      return J.state = g.state ?? 0, J.ordering = g.ordering ?? 0, J.counterparty = g.counterparty !== void 0 && g.counterparty !== null ? e.Counterparty.fromPartial(g.counterparty) : void 0, J.connectionHops = ((B = g.connectionHops) == null ? void 0 : B.map((I) => I)) || [], J.version = g.version ?? "", J.portId = g.portId ?? "", J.channelId = g.channelId ?? "", J;
    }
  };
  function h() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.Counterparty = {
    encode(g, J = f.Writer.create()) {
      return g.portId !== "" && J.uint32(10).string(g.portId), g.channelId !== "" && J.uint32(18).string(g.channelId), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = h();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 1:
            Z.portId = B.string();
            break;
          case 2:
            Z.channelId = B.string();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        portId: (0, u.isSet)(g.portId) ? String(g.portId) : "",
        channelId: (0, u.isSet)(g.channelId) ? String(g.channelId) : ""
      };
    },
    toJSON(g) {
      const J = {};
      return g.portId !== void 0 && (J.portId = g.portId), g.channelId !== void 0 && (J.channelId = g.channelId), J;
    },
    fromPartial(g) {
      const J = h();
      return J.portId = g.portId ?? "", J.channelId = g.channelId ?? "", J;
    }
  };
  function S() {
    return {
      sequence: u.Long.UZERO,
      sourcePort: "",
      sourceChannel: "",
      destinationPort: "",
      destinationChannel: "",
      data: new Uint8Array(),
      timeoutHeight: void 0,
      timeoutTimestamp: u.Long.UZERO
    };
  }
  e.Packet = {
    encode(g, J = f.Writer.create()) {
      return g.sequence.isZero() || J.uint32(8).uint64(g.sequence), g.sourcePort !== "" && J.uint32(18).string(g.sourcePort), g.sourceChannel !== "" && J.uint32(26).string(g.sourceChannel), g.destinationPort !== "" && J.uint32(34).string(g.destinationPort), g.destinationChannel !== "" && J.uint32(42).string(g.destinationChannel), g.data.length !== 0 && J.uint32(50).bytes(g.data), g.timeoutHeight !== void 0 && r.Height.encode(g.timeoutHeight, J.uint32(58).fork()).ldelim(), g.timeoutTimestamp.isZero() || J.uint32(64).uint64(g.timeoutTimestamp), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = S();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 1:
            Z.sequence = B.uint64();
            break;
          case 2:
            Z.sourcePort = B.string();
            break;
          case 3:
            Z.sourceChannel = B.string();
            break;
          case 4:
            Z.destinationPort = B.string();
            break;
          case 5:
            Z.destinationChannel = B.string();
            break;
          case 6:
            Z.data = B.bytes();
            break;
          case 7:
            Z.timeoutHeight = r.Height.decode(B, B.uint32());
            break;
          case 8:
            Z.timeoutTimestamp = B.uint64();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        sequence: (0, u.isSet)(g.sequence) ? u.Long.fromValue(g.sequence) : u.Long.UZERO,
        sourcePort: (0, u.isSet)(g.sourcePort) ? String(g.sourcePort) : "",
        sourceChannel: (0, u.isSet)(g.sourceChannel) ? String(g.sourceChannel) : "",
        destinationPort: (0, u.isSet)(g.destinationPort) ? String(g.destinationPort) : "",
        destinationChannel: (0, u.isSet)(g.destinationChannel) ? String(g.destinationChannel) : "",
        data: (0, u.isSet)(g.data) ? (0, u.bytesFromBase64)(g.data) : new Uint8Array(),
        timeoutHeight: (0, u.isSet)(g.timeoutHeight) ? r.Height.fromJSON(g.timeoutHeight) : void 0,
        timeoutTimestamp: (0, u.isSet)(g.timeoutTimestamp) ? u.Long.fromValue(g.timeoutTimestamp) : u.Long.UZERO
      };
    },
    toJSON(g) {
      const J = {};
      return g.sequence !== void 0 && (J.sequence = (g.sequence || u.Long.UZERO).toString()), g.sourcePort !== void 0 && (J.sourcePort = g.sourcePort), g.sourceChannel !== void 0 && (J.sourceChannel = g.sourceChannel), g.destinationPort !== void 0 && (J.destinationPort = g.destinationPort), g.destinationChannel !== void 0 && (J.destinationChannel = g.destinationChannel), g.data !== void 0 && (J.data = (0, u.base64FromBytes)(g.data !== void 0 ? g.data : new Uint8Array())), g.timeoutHeight !== void 0 && (J.timeoutHeight = g.timeoutHeight ? r.Height.toJSON(g.timeoutHeight) : void 0), g.timeoutTimestamp !== void 0 && (J.timeoutTimestamp = (g.timeoutTimestamp || u.Long.UZERO).toString()), J;
    },
    fromPartial(g) {
      const J = S();
      return J.sequence = g.sequence !== void 0 && g.sequence !== null ? u.Long.fromValue(g.sequence) : u.Long.UZERO, J.sourcePort = g.sourcePort ?? "", J.sourceChannel = g.sourceChannel ?? "", J.destinationPort = g.destinationPort ?? "", J.destinationChannel = g.destinationChannel ?? "", J.data = g.data ?? new Uint8Array(), J.timeoutHeight = g.timeoutHeight !== void 0 && g.timeoutHeight !== null ? r.Height.fromPartial(g.timeoutHeight) : void 0, J.timeoutTimestamp = g.timeoutTimestamp !== void 0 && g.timeoutTimestamp !== null ? u.Long.fromValue(g.timeoutTimestamp) : u.Long.UZERO, J;
    }
  };
  function _() {
    return {
      portId: "",
      channelId: "",
      sequence: u.Long.UZERO,
      data: new Uint8Array()
    };
  }
  e.PacketState = {
    encode(g, J = f.Writer.create()) {
      return g.portId !== "" && J.uint32(10).string(g.portId), g.channelId !== "" && J.uint32(18).string(g.channelId), g.sequence.isZero() || J.uint32(24).uint64(g.sequence), g.data.length !== 0 && J.uint32(34).bytes(g.data), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = _();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 1:
            Z.portId = B.string();
            break;
          case 2:
            Z.channelId = B.string();
            break;
          case 3:
            Z.sequence = B.uint64();
            break;
          case 4:
            Z.data = B.bytes();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        portId: (0, u.isSet)(g.portId) ? String(g.portId) : "",
        channelId: (0, u.isSet)(g.channelId) ? String(g.channelId) : "",
        sequence: (0, u.isSet)(g.sequence) ? u.Long.fromValue(g.sequence) : u.Long.UZERO,
        data: (0, u.isSet)(g.data) ? (0, u.bytesFromBase64)(g.data) : new Uint8Array()
      };
    },
    toJSON(g) {
      const J = {};
      return g.portId !== void 0 && (J.portId = g.portId), g.channelId !== void 0 && (J.channelId = g.channelId), g.sequence !== void 0 && (J.sequence = (g.sequence || u.Long.UZERO).toString()), g.data !== void 0 && (J.data = (0, u.base64FromBytes)(g.data !== void 0 ? g.data : new Uint8Array())), J;
    },
    fromPartial(g) {
      const J = _();
      return J.portId = g.portId ?? "", J.channelId = g.channelId ?? "", J.sequence = g.sequence !== void 0 && g.sequence !== null ? u.Long.fromValue(g.sequence) : u.Long.UZERO, J.data = g.data ?? new Uint8Array(), J;
    }
  };
  function d() {
    return {
      portId: "",
      channelId: "",
      sequence: u.Long.UZERO
    };
  }
  e.PacketId = {
    encode(g, J = f.Writer.create()) {
      return g.portId !== "" && J.uint32(10).string(g.portId), g.channelId !== "" && J.uint32(18).string(g.channelId), g.sequence.isZero() || J.uint32(24).uint64(g.sequence), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = d();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 1:
            Z.portId = B.string();
            break;
          case 2:
            Z.channelId = B.string();
            break;
          case 3:
            Z.sequence = B.uint64();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        portId: (0, u.isSet)(g.portId) ? String(g.portId) : "",
        channelId: (0, u.isSet)(g.channelId) ? String(g.channelId) : "",
        sequence: (0, u.isSet)(g.sequence) ? u.Long.fromValue(g.sequence) : u.Long.UZERO
      };
    },
    toJSON(g) {
      const J = {};
      return g.portId !== void 0 && (J.portId = g.portId), g.channelId !== void 0 && (J.channelId = g.channelId), g.sequence !== void 0 && (J.sequence = (g.sequence || u.Long.UZERO).toString()), J;
    },
    fromPartial(g) {
      const J = d();
      return J.portId = g.portId ?? "", J.channelId = g.channelId ?? "", J.sequence = g.sequence !== void 0 && g.sequence !== null ? u.Long.fromValue(g.sequence) : u.Long.UZERO, J;
    }
  };
  function p() {
    return {
      result: void 0,
      error: void 0
    };
  }
  e.Acknowledgement = {
    encode(g, J = f.Writer.create()) {
      return g.result !== void 0 && J.uint32(170).bytes(g.result), g.error !== void 0 && J.uint32(178).string(g.error), J;
    },
    decode(g, J) {
      const B = g instanceof f.Reader ? g : new f.Reader(g);
      let I = J === void 0 ? B.len : B.pos + J;
      const Z = p();
      for (; B.pos < I; ) {
        const t = B.uint32();
        switch (t >>> 3) {
          case 21:
            Z.result = B.bytes();
            break;
          case 22:
            Z.error = B.string();
            break;
          default:
            B.skipType(t & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(g) {
      return {
        result: (0, u.isSet)(g.result) ? (0, u.bytesFromBase64)(g.result) : void 0,
        error: (0, u.isSet)(g.error) ? String(g.error) : void 0
      };
    },
    toJSON(g) {
      const J = {};
      return g.result !== void 0 && (J.result = g.result !== void 0 ? (0, u.base64FromBytes)(g.result) : void 0), g.error !== void 0 && (J.error = g.error), J;
    },
    fromPartial(g) {
      const J = p();
      return J.result = g.result ?? void 0, J.error = g.error ?? void 0, J;
    }
  };
})(ci);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(v, k, U, F) {
    F === void 0 && (F = U);
    var q = Object.getOwnPropertyDescriptor(k, U);
    (!q || ("get" in q ? !k.__esModule : q.writable || q.configurable)) && (q = { enumerable: !0, get: function() {
      return k[U];
    } }), Object.defineProperty(v, F, q);
  } : function(v, k, U, F) {
    F === void 0 && (F = U), v[F] = k[U];
  }), c = G && G.__setModuleDefault || (Object.create ? function(v, k) {
    Object.defineProperty(v, "default", { enumerable: !0, value: k });
  } : function(v, k) {
    v.default = k;
  }), i = G && G.__importStar || function(v) {
    if (v && v.__esModule)
      return v;
    var k = {};
    if (v != null)
      for (var U in v)
        U !== "default" && Object.prototype.hasOwnProperty.call(v, U) && n(k, v, U);
    return c(k, v), k;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgAcknowledgementResponse = e.MsgAcknowledgement = e.MsgTimeoutOnCloseResponse = e.MsgTimeoutOnClose = e.MsgTimeoutResponse = e.MsgTimeout = e.MsgRecvPacketResponse = e.MsgRecvPacket = e.MsgChannelCloseConfirmResponse = e.MsgChannelCloseConfirm = e.MsgChannelCloseInitResponse = e.MsgChannelCloseInit = e.MsgChannelOpenConfirmResponse = e.MsgChannelOpenConfirm = e.MsgChannelOpenAckResponse = e.MsgChannelOpenAck = e.MsgChannelOpenTryResponse = e.MsgChannelOpenTry = e.MsgChannelOpenInitResponse = e.MsgChannelOpenInit = e.responseResultTypeToJSON = e.responseResultTypeFromJSON = e.ResponseResultType = e.protobufPackage = void 0;
  const r = ci, u = In, f = oe, O = i(ie);
  e.protobufPackage = "ibc.core.channel.v1";
  var A;
  (function(v) {
    v[v.RESPONSE_RESULT_TYPE_UNSPECIFIED = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED", v[v.RESPONSE_RESULT_TYPE_NOOP = 1] = "RESPONSE_RESULT_TYPE_NOOP", v[v.RESPONSE_RESULT_TYPE_SUCCESS = 2] = "RESPONSE_RESULT_TYPE_SUCCESS", v[v.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(A = e.ResponseResultType || (e.ResponseResultType = {}));
  function T(v) {
    switch (v) {
      case 0:
      case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
        return A.RESPONSE_RESULT_TYPE_UNSPECIFIED;
      case 1:
      case "RESPONSE_RESULT_TYPE_NOOP":
        return A.RESPONSE_RESULT_TYPE_NOOP;
      case 2:
      case "RESPONSE_RESULT_TYPE_SUCCESS":
        return A.RESPONSE_RESULT_TYPE_SUCCESS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return A.UNRECOGNIZED;
    }
  }
  e.responseResultTypeFromJSON = T;
  function L(v) {
    switch (v) {
      case A.RESPONSE_RESULT_TYPE_UNSPECIFIED:
        return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      case A.RESPONSE_RESULT_TYPE_NOOP:
        return "RESPONSE_RESULT_TYPE_NOOP";
      case A.RESPONSE_RESULT_TYPE_SUCCESS:
        return "RESPONSE_RESULT_TYPE_SUCCESS";
      case A.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseResultTypeToJSON = L;
  function M() {
    return {
      portId: "",
      channel: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenInit = {
    encode(v, k = O.Writer.create()) {
      return v.portId !== "" && k.uint32(10).string(v.portId), v.channel !== void 0 && r.Channel.encode(v.channel, k.uint32(18).fork()).ldelim(), v.signer !== "" && k.uint32(26).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = M();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.portId = U.string();
            break;
          case 2:
            q.channel = r.Channel.decode(U, U.uint32());
            break;
          case 3:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        portId: (0, f.isSet)(v.portId) ? String(v.portId) : "",
        channel: (0, f.isSet)(v.channel) ? r.Channel.fromJSON(v.channel) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.portId !== void 0 && (k.portId = v.portId), v.channel !== void 0 && (k.channel = v.channel ? r.Channel.toJSON(v.channel) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = M();
      return k.portId = v.portId ?? "", k.channel = v.channel !== void 0 && v.channel !== null ? r.Channel.fromPartial(v.channel) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function V() {
    return {
      channelId: "",
      version: ""
    };
  }
  e.MsgChannelOpenInitResponse = {
    encode(v, k = O.Writer.create()) {
      return v.channelId !== "" && k.uint32(10).string(v.channelId), v.version !== "" && k.uint32(18).string(v.version), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = V();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.channelId = U.string();
            break;
          case 2:
            q.version = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        channelId: (0, f.isSet)(v.channelId) ? String(v.channelId) : "",
        version: (0, f.isSet)(v.version) ? String(v.version) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.channelId !== void 0 && (k.channelId = v.channelId), v.version !== void 0 && (k.version = v.version), k;
    },
    fromPartial(v) {
      const k = V();
      return k.channelId = v.channelId ?? "", k.version = v.version ?? "", k;
    }
  };
  function D() {
    return {
      portId: "",
      previousChannelId: "",
      channel: void 0,
      counterpartyVersion: "",
      proofInit: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenTry = {
    encode(v, k = O.Writer.create()) {
      return v.portId !== "" && k.uint32(10).string(v.portId), v.previousChannelId !== "" && k.uint32(18).string(v.previousChannelId), v.channel !== void 0 && r.Channel.encode(v.channel, k.uint32(26).fork()).ldelim(), v.counterpartyVersion !== "" && k.uint32(34).string(v.counterpartyVersion), v.proofInit.length !== 0 && k.uint32(42).bytes(v.proofInit), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(50).fork()).ldelim(), v.signer !== "" && k.uint32(58).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = D();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.portId = U.string();
            break;
          case 2:
            q.previousChannelId = U.string();
            break;
          case 3:
            q.channel = r.Channel.decode(U, U.uint32());
            break;
          case 4:
            q.counterpartyVersion = U.string();
            break;
          case 5:
            q.proofInit = U.bytes();
            break;
          case 6:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 7:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        portId: (0, f.isSet)(v.portId) ? String(v.portId) : "",
        previousChannelId: (0, f.isSet)(v.previousChannelId) ? String(v.previousChannelId) : "",
        channel: (0, f.isSet)(v.channel) ? r.Channel.fromJSON(v.channel) : void 0,
        counterpartyVersion: (0, f.isSet)(v.counterpartyVersion) ? String(v.counterpartyVersion) : "",
        proofInit: (0, f.isSet)(v.proofInit) ? (0, f.bytesFromBase64)(v.proofInit) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.portId !== void 0 && (k.portId = v.portId), v.previousChannelId !== void 0 && (k.previousChannelId = v.previousChannelId), v.channel !== void 0 && (k.channel = v.channel ? r.Channel.toJSON(v.channel) : void 0), v.counterpartyVersion !== void 0 && (k.counterpartyVersion = v.counterpartyVersion), v.proofInit !== void 0 && (k.proofInit = (0, f.base64FromBytes)(v.proofInit !== void 0 ? v.proofInit : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = D();
      return k.portId = v.portId ?? "", k.previousChannelId = v.previousChannelId ?? "", k.channel = v.channel !== void 0 && v.channel !== null ? r.Channel.fromPartial(v.channel) : void 0, k.counterpartyVersion = v.counterpartyVersion ?? "", k.proofInit = v.proofInit ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function b() {
    return {
      version: ""
    };
  }
  e.MsgChannelOpenTryResponse = {
    encode(v, k = O.Writer.create()) {
      return v.version !== "" && k.uint32(10).string(v.version), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = b();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.version = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        version: (0, f.isSet)(v.version) ? String(v.version) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.version !== void 0 && (k.version = v.version), k;
    },
    fromPartial(v) {
      const k = b();
      return k.version = v.version ?? "", k;
    }
  };
  function h() {
    return {
      portId: "",
      channelId: "",
      counterpartyChannelId: "",
      counterpartyVersion: "",
      proofTry: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenAck = {
    encode(v, k = O.Writer.create()) {
      return v.portId !== "" && k.uint32(10).string(v.portId), v.channelId !== "" && k.uint32(18).string(v.channelId), v.counterpartyChannelId !== "" && k.uint32(26).string(v.counterpartyChannelId), v.counterpartyVersion !== "" && k.uint32(34).string(v.counterpartyVersion), v.proofTry.length !== 0 && k.uint32(42).bytes(v.proofTry), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(50).fork()).ldelim(), v.signer !== "" && k.uint32(58).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = h();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.portId = U.string();
            break;
          case 2:
            q.channelId = U.string();
            break;
          case 3:
            q.counterpartyChannelId = U.string();
            break;
          case 4:
            q.counterpartyVersion = U.string();
            break;
          case 5:
            q.proofTry = U.bytes();
            break;
          case 6:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 7:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        portId: (0, f.isSet)(v.portId) ? String(v.portId) : "",
        channelId: (0, f.isSet)(v.channelId) ? String(v.channelId) : "",
        counterpartyChannelId: (0, f.isSet)(v.counterpartyChannelId) ? String(v.counterpartyChannelId) : "",
        counterpartyVersion: (0, f.isSet)(v.counterpartyVersion) ? String(v.counterpartyVersion) : "",
        proofTry: (0, f.isSet)(v.proofTry) ? (0, f.bytesFromBase64)(v.proofTry) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.portId !== void 0 && (k.portId = v.portId), v.channelId !== void 0 && (k.channelId = v.channelId), v.counterpartyChannelId !== void 0 && (k.counterpartyChannelId = v.counterpartyChannelId), v.counterpartyVersion !== void 0 && (k.counterpartyVersion = v.counterpartyVersion), v.proofTry !== void 0 && (k.proofTry = (0, f.base64FromBytes)(v.proofTry !== void 0 ? v.proofTry : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = h();
      return k.portId = v.portId ?? "", k.channelId = v.channelId ?? "", k.counterpartyChannelId = v.counterpartyChannelId ?? "", k.counterpartyVersion = v.counterpartyVersion ?? "", k.proofTry = v.proofTry ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function S() {
    return {};
  }
  e.MsgChannelOpenAckResponse = {
    encode(v, k = O.Writer.create()) {
      return k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = S();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return S();
    }
  };
  function _() {
    return {
      portId: "",
      channelId: "",
      proofAck: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenConfirm = {
    encode(v, k = O.Writer.create()) {
      return v.portId !== "" && k.uint32(10).string(v.portId), v.channelId !== "" && k.uint32(18).string(v.channelId), v.proofAck.length !== 0 && k.uint32(26).bytes(v.proofAck), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(34).fork()).ldelim(), v.signer !== "" && k.uint32(42).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = _();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.portId = U.string();
            break;
          case 2:
            q.channelId = U.string();
            break;
          case 3:
            q.proofAck = U.bytes();
            break;
          case 4:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 5:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        portId: (0, f.isSet)(v.portId) ? String(v.portId) : "",
        channelId: (0, f.isSet)(v.channelId) ? String(v.channelId) : "",
        proofAck: (0, f.isSet)(v.proofAck) ? (0, f.bytesFromBase64)(v.proofAck) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.portId !== void 0 && (k.portId = v.portId), v.channelId !== void 0 && (k.channelId = v.channelId), v.proofAck !== void 0 && (k.proofAck = (0, f.base64FromBytes)(v.proofAck !== void 0 ? v.proofAck : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = _();
      return k.portId = v.portId ?? "", k.channelId = v.channelId ?? "", k.proofAck = v.proofAck ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function d() {
    return {};
  }
  e.MsgChannelOpenConfirmResponse = {
    encode(v, k = O.Writer.create()) {
      return k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = d();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return d();
    }
  };
  function p() {
    return {
      portId: "",
      channelId: "",
      signer: ""
    };
  }
  e.MsgChannelCloseInit = {
    encode(v, k = O.Writer.create()) {
      return v.portId !== "" && k.uint32(10).string(v.portId), v.channelId !== "" && k.uint32(18).string(v.channelId), v.signer !== "" && k.uint32(26).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = p();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.portId = U.string();
            break;
          case 2:
            q.channelId = U.string();
            break;
          case 3:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        portId: (0, f.isSet)(v.portId) ? String(v.portId) : "",
        channelId: (0, f.isSet)(v.channelId) ? String(v.channelId) : "",
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.portId !== void 0 && (k.portId = v.portId), v.channelId !== void 0 && (k.channelId = v.channelId), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = p();
      return k.portId = v.portId ?? "", k.channelId = v.channelId ?? "", k.signer = v.signer ?? "", k;
    }
  };
  function g() {
    return {};
  }
  e.MsgChannelCloseInitResponse = {
    encode(v, k = O.Writer.create()) {
      return k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = g();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return g();
    }
  };
  function J() {
    return {
      portId: "",
      channelId: "",
      proofInit: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelCloseConfirm = {
    encode(v, k = O.Writer.create()) {
      return v.portId !== "" && k.uint32(10).string(v.portId), v.channelId !== "" && k.uint32(18).string(v.channelId), v.proofInit.length !== 0 && k.uint32(26).bytes(v.proofInit), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(34).fork()).ldelim(), v.signer !== "" && k.uint32(42).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = J();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.portId = U.string();
            break;
          case 2:
            q.channelId = U.string();
            break;
          case 3:
            q.proofInit = U.bytes();
            break;
          case 4:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 5:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        portId: (0, f.isSet)(v.portId) ? String(v.portId) : "",
        channelId: (0, f.isSet)(v.channelId) ? String(v.channelId) : "",
        proofInit: (0, f.isSet)(v.proofInit) ? (0, f.bytesFromBase64)(v.proofInit) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.portId !== void 0 && (k.portId = v.portId), v.channelId !== void 0 && (k.channelId = v.channelId), v.proofInit !== void 0 && (k.proofInit = (0, f.base64FromBytes)(v.proofInit !== void 0 ? v.proofInit : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = J();
      return k.portId = v.portId ?? "", k.channelId = v.channelId ?? "", k.proofInit = v.proofInit ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function B() {
    return {};
  }
  e.MsgChannelCloseConfirmResponse = {
    encode(v, k = O.Writer.create()) {
      return k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = B();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return B();
    }
  };
  function I() {
    return {
      packet: void 0,
      proofCommitment: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgRecvPacket = {
    encode(v, k = O.Writer.create()) {
      return v.packet !== void 0 && r.Packet.encode(v.packet, k.uint32(10).fork()).ldelim(), v.proofCommitment.length !== 0 && k.uint32(18).bytes(v.proofCommitment), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(26).fork()).ldelim(), v.signer !== "" && k.uint32(34).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = I();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.packet = r.Packet.decode(U, U.uint32());
            break;
          case 2:
            q.proofCommitment = U.bytes();
            break;
          case 3:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 4:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        packet: (0, f.isSet)(v.packet) ? r.Packet.fromJSON(v.packet) : void 0,
        proofCommitment: (0, f.isSet)(v.proofCommitment) ? (0, f.bytesFromBase64)(v.proofCommitment) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.packet !== void 0 && (k.packet = v.packet ? r.Packet.toJSON(v.packet) : void 0), v.proofCommitment !== void 0 && (k.proofCommitment = (0, f.base64FromBytes)(v.proofCommitment !== void 0 ? v.proofCommitment : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = I();
      return k.packet = v.packet !== void 0 && v.packet !== null ? r.Packet.fromPartial(v.packet) : void 0, k.proofCommitment = v.proofCommitment ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function Z() {
    return {
      result: 0
    };
  }
  e.MsgRecvPacketResponse = {
    encode(v, k = O.Writer.create()) {
      return v.result !== 0 && k.uint32(8).int32(v.result), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = Z();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.result = U.int32();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        result: (0, f.isSet)(v.result) ? T(v.result) : 0
      };
    },
    toJSON(v) {
      const k = {};
      return v.result !== void 0 && (k.result = L(v.result)), k;
    },
    fromPartial(v) {
      const k = Z();
      return k.result = v.result ?? 0, k;
    }
  };
  function t() {
    return {
      packet: void 0,
      proofUnreceived: new Uint8Array(),
      proofHeight: void 0,
      nextSequenceRecv: f.Long.UZERO,
      signer: ""
    };
  }
  e.MsgTimeout = {
    encode(v, k = O.Writer.create()) {
      return v.packet !== void 0 && r.Packet.encode(v.packet, k.uint32(10).fork()).ldelim(), v.proofUnreceived.length !== 0 && k.uint32(18).bytes(v.proofUnreceived), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(26).fork()).ldelim(), v.nextSequenceRecv.isZero() || k.uint32(32).uint64(v.nextSequenceRecv), v.signer !== "" && k.uint32(42).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = t();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.packet = r.Packet.decode(U, U.uint32());
            break;
          case 2:
            q.proofUnreceived = U.bytes();
            break;
          case 3:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 4:
            q.nextSequenceRecv = U.uint64();
            break;
          case 5:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        packet: (0, f.isSet)(v.packet) ? r.Packet.fromJSON(v.packet) : void 0,
        proofUnreceived: (0, f.isSet)(v.proofUnreceived) ? (0, f.bytesFromBase64)(v.proofUnreceived) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        nextSequenceRecv: (0, f.isSet)(v.nextSequenceRecv) ? f.Long.fromValue(v.nextSequenceRecv) : f.Long.UZERO,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.packet !== void 0 && (k.packet = v.packet ? r.Packet.toJSON(v.packet) : void 0), v.proofUnreceived !== void 0 && (k.proofUnreceived = (0, f.base64FromBytes)(v.proofUnreceived !== void 0 ? v.proofUnreceived : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.nextSequenceRecv !== void 0 && (k.nextSequenceRecv = (v.nextSequenceRecv || f.Long.UZERO).toString()), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = t();
      return k.packet = v.packet !== void 0 && v.packet !== null ? r.Packet.fromPartial(v.packet) : void 0, k.proofUnreceived = v.proofUnreceived ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.nextSequenceRecv = v.nextSequenceRecv !== void 0 && v.nextSequenceRecv !== null ? f.Long.fromValue(v.nextSequenceRecv) : f.Long.UZERO, k.signer = v.signer ?? "", k;
    }
  };
  function y() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutResponse = {
    encode(v, k = O.Writer.create()) {
      return v.result !== 0 && k.uint32(8).int32(v.result), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = y();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.result = U.int32();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        result: (0, f.isSet)(v.result) ? T(v.result) : 0
      };
    },
    toJSON(v) {
      const k = {};
      return v.result !== void 0 && (k.result = L(v.result)), k;
    },
    fromPartial(v) {
      const k = y();
      return k.result = v.result ?? 0, k;
    }
  };
  function E() {
    return {
      packet: void 0,
      proofUnreceived: new Uint8Array(),
      proofClose: new Uint8Array(),
      proofHeight: void 0,
      nextSequenceRecv: f.Long.UZERO,
      signer: ""
    };
  }
  e.MsgTimeoutOnClose = {
    encode(v, k = O.Writer.create()) {
      return v.packet !== void 0 && r.Packet.encode(v.packet, k.uint32(10).fork()).ldelim(), v.proofUnreceived.length !== 0 && k.uint32(18).bytes(v.proofUnreceived), v.proofClose.length !== 0 && k.uint32(26).bytes(v.proofClose), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(34).fork()).ldelim(), v.nextSequenceRecv.isZero() || k.uint32(40).uint64(v.nextSequenceRecv), v.signer !== "" && k.uint32(50).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = E();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.packet = r.Packet.decode(U, U.uint32());
            break;
          case 2:
            q.proofUnreceived = U.bytes();
            break;
          case 3:
            q.proofClose = U.bytes();
            break;
          case 4:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 5:
            q.nextSequenceRecv = U.uint64();
            break;
          case 6:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        packet: (0, f.isSet)(v.packet) ? r.Packet.fromJSON(v.packet) : void 0,
        proofUnreceived: (0, f.isSet)(v.proofUnreceived) ? (0, f.bytesFromBase64)(v.proofUnreceived) : new Uint8Array(),
        proofClose: (0, f.isSet)(v.proofClose) ? (0, f.bytesFromBase64)(v.proofClose) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        nextSequenceRecv: (0, f.isSet)(v.nextSequenceRecv) ? f.Long.fromValue(v.nextSequenceRecv) : f.Long.UZERO,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.packet !== void 0 && (k.packet = v.packet ? r.Packet.toJSON(v.packet) : void 0), v.proofUnreceived !== void 0 && (k.proofUnreceived = (0, f.base64FromBytes)(v.proofUnreceived !== void 0 ? v.proofUnreceived : new Uint8Array())), v.proofClose !== void 0 && (k.proofClose = (0, f.base64FromBytes)(v.proofClose !== void 0 ? v.proofClose : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.nextSequenceRecv !== void 0 && (k.nextSequenceRecv = (v.nextSequenceRecv || f.Long.UZERO).toString()), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = E();
      return k.packet = v.packet !== void 0 && v.packet !== null ? r.Packet.fromPartial(v.packet) : void 0, k.proofUnreceived = v.proofUnreceived ?? new Uint8Array(), k.proofClose = v.proofClose ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.nextSequenceRecv = v.nextSequenceRecv !== void 0 && v.nextSequenceRecv !== null ? f.Long.fromValue(v.nextSequenceRecv) : f.Long.UZERO, k.signer = v.signer ?? "", k;
    }
  };
  function H() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutOnCloseResponse = {
    encode(v, k = O.Writer.create()) {
      return v.result !== 0 && k.uint32(8).int32(v.result), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = H();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.result = U.int32();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        result: (0, f.isSet)(v.result) ? T(v.result) : 0
      };
    },
    toJSON(v) {
      const k = {};
      return v.result !== void 0 && (k.result = L(v.result)), k;
    },
    fromPartial(v) {
      const k = H();
      return k.result = v.result ?? 0, k;
    }
  };
  function a() {
    return {
      packet: void 0,
      acknowledgement: new Uint8Array(),
      proofAcked: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgAcknowledgement = {
    encode(v, k = O.Writer.create()) {
      return v.packet !== void 0 && r.Packet.encode(v.packet, k.uint32(10).fork()).ldelim(), v.acknowledgement.length !== 0 && k.uint32(18).bytes(v.acknowledgement), v.proofAcked.length !== 0 && k.uint32(26).bytes(v.proofAcked), v.proofHeight !== void 0 && u.Height.encode(v.proofHeight, k.uint32(34).fork()).ldelim(), v.signer !== "" && k.uint32(42).string(v.signer), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = a();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.packet = r.Packet.decode(U, U.uint32());
            break;
          case 2:
            q.acknowledgement = U.bytes();
            break;
          case 3:
            q.proofAcked = U.bytes();
            break;
          case 4:
            q.proofHeight = u.Height.decode(U, U.uint32());
            break;
          case 5:
            q.signer = U.string();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        packet: (0, f.isSet)(v.packet) ? r.Packet.fromJSON(v.packet) : void 0,
        acknowledgement: (0, f.isSet)(v.acknowledgement) ? (0, f.bytesFromBase64)(v.acknowledgement) : new Uint8Array(),
        proofAcked: (0, f.isSet)(v.proofAcked) ? (0, f.bytesFromBase64)(v.proofAcked) : new Uint8Array(),
        proofHeight: (0, f.isSet)(v.proofHeight) ? u.Height.fromJSON(v.proofHeight) : void 0,
        signer: (0, f.isSet)(v.signer) ? String(v.signer) : ""
      };
    },
    toJSON(v) {
      const k = {};
      return v.packet !== void 0 && (k.packet = v.packet ? r.Packet.toJSON(v.packet) : void 0), v.acknowledgement !== void 0 && (k.acknowledgement = (0, f.base64FromBytes)(v.acknowledgement !== void 0 ? v.acknowledgement : new Uint8Array())), v.proofAcked !== void 0 && (k.proofAcked = (0, f.base64FromBytes)(v.proofAcked !== void 0 ? v.proofAcked : new Uint8Array())), v.proofHeight !== void 0 && (k.proofHeight = v.proofHeight ? u.Height.toJSON(v.proofHeight) : void 0), v.signer !== void 0 && (k.signer = v.signer), k;
    },
    fromPartial(v) {
      const k = a();
      return k.packet = v.packet !== void 0 && v.packet !== null ? r.Packet.fromPartial(v.packet) : void 0, k.acknowledgement = v.acknowledgement ?? new Uint8Array(), k.proofAcked = v.proofAcked ?? new Uint8Array(), k.proofHeight = v.proofHeight !== void 0 && v.proofHeight !== null ? u.Height.fromPartial(v.proofHeight) : void 0, k.signer = v.signer ?? "", k;
    }
  };
  function l() {
    return {
      result: 0
    };
  }
  e.MsgAcknowledgementResponse = {
    encode(v, k = O.Writer.create()) {
      return v.result !== 0 && k.uint32(8).int32(v.result), k;
    },
    decode(v, k) {
      const U = v instanceof O.Reader ? v : new O.Reader(v);
      let F = k === void 0 ? U.len : U.pos + k;
      const q = l();
      for (; U.pos < F; ) {
        const o = U.uint32();
        switch (o >>> 3) {
          case 1:
            q.result = U.int32();
            break;
          default:
            U.skipType(o & 7);
            break;
        }
      }
      return q;
    },
    fromJSON(v) {
      return {
        result: (0, f.isSet)(v.result) ? T(v.result) : 0
      };
    },
    toJSON(v) {
      const k = {};
      return v.result !== void 0 && (k.result = L(v.result)), k;
    },
    fromPartial(v) {
      const k = l();
      return k.result = v.result ?? 0, k;
    }
  };
  class C {
    constructor(k) {
      this.rpc = k, this.ChannelOpenInit = this.ChannelOpenInit.bind(this), this.ChannelOpenTry = this.ChannelOpenTry.bind(this), this.ChannelOpenAck = this.ChannelOpenAck.bind(this), this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this), this.ChannelCloseInit = this.ChannelCloseInit.bind(this), this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this), this.RecvPacket = this.RecvPacket.bind(this), this.Timeout = this.Timeout.bind(this), this.TimeoutOnClose = this.TimeoutOnClose.bind(this), this.Acknowledgement = this.Acknowledgement.bind(this);
    }
    ChannelOpenInit(k) {
      const U = e.MsgChannelOpenInit.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", U).then((q) => e.MsgChannelOpenInitResponse.decode(new O.Reader(q)));
    }
    ChannelOpenTry(k) {
      const U = e.MsgChannelOpenTry.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", U).then((q) => e.MsgChannelOpenTryResponse.decode(new O.Reader(q)));
    }
    ChannelOpenAck(k) {
      const U = e.MsgChannelOpenAck.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", U).then((q) => e.MsgChannelOpenAckResponse.decode(new O.Reader(q)));
    }
    ChannelOpenConfirm(k) {
      const U = e.MsgChannelOpenConfirm.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", U).then((q) => e.MsgChannelOpenConfirmResponse.decode(new O.Reader(q)));
    }
    ChannelCloseInit(k) {
      const U = e.MsgChannelCloseInit.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", U).then((q) => e.MsgChannelCloseInitResponse.decode(new O.Reader(q)));
    }
    ChannelCloseConfirm(k) {
      const U = e.MsgChannelCloseConfirm.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", U).then((q) => e.MsgChannelCloseConfirmResponse.decode(new O.Reader(q)));
    }
    RecvPacket(k) {
      const U = e.MsgRecvPacket.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", U).then((q) => e.MsgRecvPacketResponse.decode(new O.Reader(q)));
    }
    Timeout(k) {
      const U = e.MsgTimeout.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", U).then((q) => e.MsgTimeoutResponse.decode(new O.Reader(q)));
    }
    TimeoutOnClose(k) {
      const U = e.MsgTimeoutOnClose.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", U).then((q) => e.MsgTimeoutOnCloseResponse.decode(new O.Reader(q)));
    }
    Acknowledgement(k) {
      const U = e.MsgAcknowledgement.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", U).then((q) => e.MsgAcknowledgementResponse.decode(new O.Reader(q)));
    }
  }
  e.MsgClientImpl = C;
})(Nu);
var Tu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(S, _, d, p) {
    p === void 0 && (p = d);
    var g = Object.getOwnPropertyDescriptor(_, d);
    (!g || ("get" in g ? !_.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
      return _[d];
    } }), Object.defineProperty(S, p, g);
  } : function(S, _, d, p) {
    p === void 0 && (p = d), S[p] = _[d];
  }), c = G && G.__setModuleDefault || (Object.create ? function(S, _) {
    Object.defineProperty(S, "default", { enumerable: !0, value: _ });
  } : function(S, _) {
    S.default = _;
  }), i = G && G.__importStar || function(S) {
    if (S && S.__esModule)
      return S;
    var _ = {};
    if (S != null)
      for (var d in S)
        d !== "default" && Object.prototype.hasOwnProperty.call(S, d) && n(_, S, d);
    return c(_, S), _;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSubmitMisbehaviourResponse = e.MsgSubmitMisbehaviour = e.MsgUpgradeClientResponse = e.MsgUpgradeClient = e.MsgUpdateClientResponse = e.MsgUpdateClient = e.MsgCreateClientResponse = e.MsgCreateClient = e.protobufPackage = void 0;
  const r = Se, u = i(ie), f = oe;
  e.protobufPackage = "ibc.core.client.v1";
  function O() {
    return {
      clientState: void 0,
      consensusState: void 0,
      signer: ""
    };
  }
  e.MsgCreateClient = {
    encode(S, _ = u.Writer.create()) {
      return S.clientState !== void 0 && r.Any.encode(S.clientState, _.uint32(10).fork()).ldelim(), S.consensusState !== void 0 && r.Any.encode(S.consensusState, _.uint32(18).fork()).ldelim(), S.signer !== "" && _.uint32(26).string(S.signer), _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = O();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          case 1:
            g.clientState = r.Any.decode(d, d.uint32());
            break;
          case 2:
            g.consensusState = r.Any.decode(d, d.uint32());
            break;
          case 3:
            g.signer = d.string();
            break;
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {
        clientState: (0, f.isSet)(S.clientState) ? r.Any.fromJSON(S.clientState) : void 0,
        consensusState: (0, f.isSet)(S.consensusState) ? r.Any.fromJSON(S.consensusState) : void 0,
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const _ = {};
      return S.clientState !== void 0 && (_.clientState = S.clientState ? r.Any.toJSON(S.clientState) : void 0), S.consensusState !== void 0 && (_.consensusState = S.consensusState ? r.Any.toJSON(S.consensusState) : void 0), S.signer !== void 0 && (_.signer = S.signer), _;
    },
    fromPartial(S) {
      const _ = O();
      return _.clientState = S.clientState !== void 0 && S.clientState !== null ? r.Any.fromPartial(S.clientState) : void 0, _.consensusState = S.consensusState !== void 0 && S.consensusState !== null ? r.Any.fromPartial(S.consensusState) : void 0, _.signer = S.signer ?? "", _;
    }
  };
  function A() {
    return {};
  }
  e.MsgCreateClientResponse = {
    encode(S, _ = u.Writer.create()) {
      return _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = A();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return A();
    }
  };
  function T() {
    return {
      clientId: "",
      clientMessage: void 0,
      signer: ""
    };
  }
  e.MsgUpdateClient = {
    encode(S, _ = u.Writer.create()) {
      return S.clientId !== "" && _.uint32(10).string(S.clientId), S.clientMessage !== void 0 && r.Any.encode(S.clientMessage, _.uint32(18).fork()).ldelim(), S.signer !== "" && _.uint32(26).string(S.signer), _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = T();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          case 1:
            g.clientId = d.string();
            break;
          case 2:
            g.clientMessage = r.Any.decode(d, d.uint32());
            break;
          case 3:
            g.signer = d.string();
            break;
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {
        clientId: (0, f.isSet)(S.clientId) ? String(S.clientId) : "",
        clientMessage: (0, f.isSet)(S.clientMessage) ? r.Any.fromJSON(S.clientMessage) : void 0,
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const _ = {};
      return S.clientId !== void 0 && (_.clientId = S.clientId), S.clientMessage !== void 0 && (_.clientMessage = S.clientMessage ? r.Any.toJSON(S.clientMessage) : void 0), S.signer !== void 0 && (_.signer = S.signer), _;
    },
    fromPartial(S) {
      const _ = T();
      return _.clientId = S.clientId ?? "", _.clientMessage = S.clientMessage !== void 0 && S.clientMessage !== null ? r.Any.fromPartial(S.clientMessage) : void 0, _.signer = S.signer ?? "", _;
    }
  };
  function L() {
    return {};
  }
  e.MsgUpdateClientResponse = {
    encode(S, _ = u.Writer.create()) {
      return _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = L();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return L();
    }
  };
  function M() {
    return {
      clientId: "",
      clientState: void 0,
      consensusState: void 0,
      proofUpgradeClient: new Uint8Array(),
      proofUpgradeConsensusState: new Uint8Array(),
      signer: ""
    };
  }
  e.MsgUpgradeClient = {
    encode(S, _ = u.Writer.create()) {
      return S.clientId !== "" && _.uint32(10).string(S.clientId), S.clientState !== void 0 && r.Any.encode(S.clientState, _.uint32(18).fork()).ldelim(), S.consensusState !== void 0 && r.Any.encode(S.consensusState, _.uint32(26).fork()).ldelim(), S.proofUpgradeClient.length !== 0 && _.uint32(34).bytes(S.proofUpgradeClient), S.proofUpgradeConsensusState.length !== 0 && _.uint32(42).bytes(S.proofUpgradeConsensusState), S.signer !== "" && _.uint32(50).string(S.signer), _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = M();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          case 1:
            g.clientId = d.string();
            break;
          case 2:
            g.clientState = r.Any.decode(d, d.uint32());
            break;
          case 3:
            g.consensusState = r.Any.decode(d, d.uint32());
            break;
          case 4:
            g.proofUpgradeClient = d.bytes();
            break;
          case 5:
            g.proofUpgradeConsensusState = d.bytes();
            break;
          case 6:
            g.signer = d.string();
            break;
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {
        clientId: (0, f.isSet)(S.clientId) ? String(S.clientId) : "",
        clientState: (0, f.isSet)(S.clientState) ? r.Any.fromJSON(S.clientState) : void 0,
        consensusState: (0, f.isSet)(S.consensusState) ? r.Any.fromJSON(S.consensusState) : void 0,
        proofUpgradeClient: (0, f.isSet)(S.proofUpgradeClient) ? (0, f.bytesFromBase64)(S.proofUpgradeClient) : new Uint8Array(),
        proofUpgradeConsensusState: (0, f.isSet)(S.proofUpgradeConsensusState) ? (0, f.bytesFromBase64)(S.proofUpgradeConsensusState) : new Uint8Array(),
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const _ = {};
      return S.clientId !== void 0 && (_.clientId = S.clientId), S.clientState !== void 0 && (_.clientState = S.clientState ? r.Any.toJSON(S.clientState) : void 0), S.consensusState !== void 0 && (_.consensusState = S.consensusState ? r.Any.toJSON(S.consensusState) : void 0), S.proofUpgradeClient !== void 0 && (_.proofUpgradeClient = (0, f.base64FromBytes)(S.proofUpgradeClient !== void 0 ? S.proofUpgradeClient : new Uint8Array())), S.proofUpgradeConsensusState !== void 0 && (_.proofUpgradeConsensusState = (0, f.base64FromBytes)(S.proofUpgradeConsensusState !== void 0 ? S.proofUpgradeConsensusState : new Uint8Array())), S.signer !== void 0 && (_.signer = S.signer), _;
    },
    fromPartial(S) {
      const _ = M();
      return _.clientId = S.clientId ?? "", _.clientState = S.clientState !== void 0 && S.clientState !== null ? r.Any.fromPartial(S.clientState) : void 0, _.consensusState = S.consensusState !== void 0 && S.consensusState !== null ? r.Any.fromPartial(S.consensusState) : void 0, _.proofUpgradeClient = S.proofUpgradeClient ?? new Uint8Array(), _.proofUpgradeConsensusState = S.proofUpgradeConsensusState ?? new Uint8Array(), _.signer = S.signer ?? "", _;
    }
  };
  function V() {
    return {};
  }
  e.MsgUpgradeClientResponse = {
    encode(S, _ = u.Writer.create()) {
      return _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = V();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return V();
    }
  };
  function D() {
    return {
      clientId: "",
      misbehaviour: void 0,
      signer: ""
    };
  }
  e.MsgSubmitMisbehaviour = {
    encode(S, _ = u.Writer.create()) {
      return S.clientId !== "" && _.uint32(10).string(S.clientId), S.misbehaviour !== void 0 && r.Any.encode(S.misbehaviour, _.uint32(18).fork()).ldelim(), S.signer !== "" && _.uint32(26).string(S.signer), _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = D();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          case 1:
            g.clientId = d.string();
            break;
          case 2:
            g.misbehaviour = r.Any.decode(d, d.uint32());
            break;
          case 3:
            g.signer = d.string();
            break;
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {
        clientId: (0, f.isSet)(S.clientId) ? String(S.clientId) : "",
        misbehaviour: (0, f.isSet)(S.misbehaviour) ? r.Any.fromJSON(S.misbehaviour) : void 0,
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const _ = {};
      return S.clientId !== void 0 && (_.clientId = S.clientId), S.misbehaviour !== void 0 && (_.misbehaviour = S.misbehaviour ? r.Any.toJSON(S.misbehaviour) : void 0), S.signer !== void 0 && (_.signer = S.signer), _;
    },
    fromPartial(S) {
      const _ = D();
      return _.clientId = S.clientId ?? "", _.misbehaviour = S.misbehaviour !== void 0 && S.misbehaviour !== null ? r.Any.fromPartial(S.misbehaviour) : void 0, _.signer = S.signer ?? "", _;
    }
  };
  function b() {
    return {};
  }
  e.MsgSubmitMisbehaviourResponse = {
    encode(S, _ = u.Writer.create()) {
      return _;
    },
    decode(S, _) {
      const d = S instanceof u.Reader ? S : new u.Reader(S);
      let p = _ === void 0 ? d.len : d.pos + _;
      const g = b();
      for (; d.pos < p; ) {
        const J = d.uint32();
        switch (J >>> 3) {
          default:
            d.skipType(J & 7);
            break;
        }
      }
      return g;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return b();
    }
  };
  class h {
    constructor(_) {
      this.rpc = _, this.CreateClient = this.CreateClient.bind(this), this.UpdateClient = this.UpdateClient.bind(this), this.UpgradeClient = this.UpgradeClient.bind(this), this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
    }
    CreateClient(_) {
      const d = e.MsgCreateClient.encode(_).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", d).then((g) => e.MsgCreateClientResponse.decode(new u.Reader(g)));
    }
    UpdateClient(_) {
      const d = e.MsgUpdateClient.encode(_).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", d).then((g) => e.MsgUpdateClientResponse.decode(new u.Reader(g)));
    }
    UpgradeClient(_) {
      const d = e.MsgUpgradeClient.encode(_).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", d).then((g) => e.MsgUpgradeClientResponse.decode(new u.Reader(g)));
    }
    SubmitMisbehaviour(_) {
      const d = e.MsgSubmitMisbehaviour.encode(_).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", d).then((g) => e.MsgSubmitMisbehaviourResponse.decode(new u.Reader(g)));
    }
  }
  e.MsgClientImpl = h;
})(Tu);
var Eu = {}, ta = {}, je = {}, ra = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(t, y, E, H) {
    H === void 0 && (H = E);
    var a = Object.getOwnPropertyDescriptor(y, E);
    (!a || ("get" in a ? !y.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return y[E];
    } }), Object.defineProperty(t, H, a);
  } : function(t, y, E, H) {
    H === void 0 && (H = E), t[H] = y[E];
  }), c = G && G.__setModuleDefault || (Object.create ? function(t, y) {
    Object.defineProperty(t, "default", { enumerable: !0, value: y });
  } : function(t, y) {
    t.default = y;
  }), i = G && G.__importStar || function(t) {
    if (t && t.__esModule)
      return t;
    var y = {};
    if (t != null)
      for (var E in t)
        E !== "default" && Object.prototype.hasOwnProperty.call(t, E) && n(y, t, E);
    return c(y, t), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CompressedNonExistenceProof = e.CompressedExistenceProof = e.CompressedBatchEntry = e.CompressedBatchProof = e.BatchEntry = e.BatchProof = e.InnerSpec = e.ProofSpec = e.InnerOp = e.LeafOp = e.CommitmentProof = e.NonExistenceProof = e.ExistenceProof = e.lengthOpToJSON = e.lengthOpFromJSON = e.LengthOp = e.hashOpToJSON = e.hashOpFromJSON = e.HashOp = e.protobufPackage = void 0;
  const r = i(ie), u = oe;
  e.protobufPackage = "cosmos.ics23.v1";
  var f;
  (function(t) {
    t[t.NO_HASH = 0] = "NO_HASH", t[t.SHA256 = 1] = "SHA256", t[t.SHA512 = 2] = "SHA512", t[t.KECCAK = 3] = "KECCAK", t[t.RIPEMD160 = 4] = "RIPEMD160", t[t.BITCOIN = 5] = "BITCOIN", t[t.SHA512_256 = 6] = "SHA512_256", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f = e.HashOp || (e.HashOp = {}));
  function O(t) {
    switch (t) {
      case 0:
      case "NO_HASH":
        return f.NO_HASH;
      case 1:
      case "SHA256":
        return f.SHA256;
      case 2:
      case "SHA512":
        return f.SHA512;
      case 3:
      case "KECCAK":
        return f.KECCAK;
      case 4:
      case "RIPEMD160":
        return f.RIPEMD160;
      case 5:
      case "BITCOIN":
        return f.BITCOIN;
      case 6:
      case "SHA512_256":
        return f.SHA512_256;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.hashOpFromJSON = O;
  function A(t) {
    switch (t) {
      case f.NO_HASH:
        return "NO_HASH";
      case f.SHA256:
        return "SHA256";
      case f.SHA512:
        return "SHA512";
      case f.KECCAK:
        return "KECCAK";
      case f.RIPEMD160:
        return "RIPEMD160";
      case f.BITCOIN:
        return "BITCOIN";
      case f.SHA512_256:
        return "SHA512_256";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.hashOpToJSON = A;
  var T;
  (function(t) {
    t[t.NO_PREFIX = 0] = "NO_PREFIX", t[t.VAR_PROTO = 1] = "VAR_PROTO", t[t.VAR_RLP = 2] = "VAR_RLP", t[t.FIXED32_BIG = 3] = "FIXED32_BIG", t[t.FIXED32_LITTLE = 4] = "FIXED32_LITTLE", t[t.FIXED64_BIG = 5] = "FIXED64_BIG", t[t.FIXED64_LITTLE = 6] = "FIXED64_LITTLE", t[t.REQUIRE_32_BYTES = 7] = "REQUIRE_32_BYTES", t[t.REQUIRE_64_BYTES = 8] = "REQUIRE_64_BYTES", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T = e.LengthOp || (e.LengthOp = {}));
  function L(t) {
    switch (t) {
      case 0:
      case "NO_PREFIX":
        return T.NO_PREFIX;
      case 1:
      case "VAR_PROTO":
        return T.VAR_PROTO;
      case 2:
      case "VAR_RLP":
        return T.VAR_RLP;
      case 3:
      case "FIXED32_BIG":
        return T.FIXED32_BIG;
      case 4:
      case "FIXED32_LITTLE":
        return T.FIXED32_LITTLE;
      case 5:
      case "FIXED64_BIG":
        return T.FIXED64_BIG;
      case 6:
      case "FIXED64_LITTLE":
        return T.FIXED64_LITTLE;
      case 7:
      case "REQUIRE_32_BYTES":
        return T.REQUIRE_32_BYTES;
      case 8:
      case "REQUIRE_64_BYTES":
        return T.REQUIRE_64_BYTES;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.lengthOpFromJSON = L;
  function M(t) {
    switch (t) {
      case T.NO_PREFIX:
        return "NO_PREFIX";
      case T.VAR_PROTO:
        return "VAR_PROTO";
      case T.VAR_RLP:
        return "VAR_RLP";
      case T.FIXED32_BIG:
        return "FIXED32_BIG";
      case T.FIXED32_LITTLE:
        return "FIXED32_LITTLE";
      case T.FIXED64_BIG:
        return "FIXED64_BIG";
      case T.FIXED64_LITTLE:
        return "FIXED64_LITTLE";
      case T.REQUIRE_32_BYTES:
        return "REQUIRE_32_BYTES";
      case T.REQUIRE_64_BYTES:
        return "REQUIRE_64_BYTES";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.lengthOpToJSON = M;
  function V() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.ExistenceProof = {
    encode(t, y = r.Writer.create()) {
      t.key.length !== 0 && y.uint32(10).bytes(t.key), t.value.length !== 0 && y.uint32(18).bytes(t.value), t.leaf !== void 0 && e.LeafOp.encode(t.leaf, y.uint32(26).fork()).ldelim();
      for (const E of t.path)
        e.InnerOp.encode(E, y.uint32(34).fork()).ldelim();
      return y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = V();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.key = E.bytes();
            break;
          case 2:
            a.value = E.bytes();
            break;
          case 3:
            a.leaf = e.LeafOp.decode(E, E.uint32());
            break;
          case 4:
            a.path.push(e.InnerOp.decode(E, E.uint32()));
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        key: (0, u.isSet)(t.key) ? (0, u.bytesFromBase64)(t.key) : new Uint8Array(),
        value: (0, u.isSet)(t.value) ? (0, u.bytesFromBase64)(t.value) : new Uint8Array(),
        leaf: (0, u.isSet)(t.leaf) ? e.LeafOp.fromJSON(t.leaf) : void 0,
        path: Array.isArray(t == null ? void 0 : t.path) ? t.path.map((y) => e.InnerOp.fromJSON(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.key !== void 0 && (y.key = (0, u.base64FromBytes)(t.key !== void 0 ? t.key : new Uint8Array())), t.value !== void 0 && (y.value = (0, u.base64FromBytes)(t.value !== void 0 ? t.value : new Uint8Array())), t.leaf !== void 0 && (y.leaf = t.leaf ? e.LeafOp.toJSON(t.leaf) : void 0), t.path ? y.path = t.path.map((E) => E ? e.InnerOp.toJSON(E) : void 0) : y.path = [], y;
    },
    fromPartial(t) {
      var E;
      const y = V();
      return y.key = t.key ?? new Uint8Array(), y.value = t.value ?? new Uint8Array(), y.leaf = t.leaf !== void 0 && t.leaf !== null ? e.LeafOp.fromPartial(t.leaf) : void 0, y.path = ((E = t.path) == null ? void 0 : E.map((H) => e.InnerOp.fromPartial(H))) || [], y;
    }
  };
  function D() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.NonExistenceProof = {
    encode(t, y = r.Writer.create()) {
      return t.key.length !== 0 && y.uint32(10).bytes(t.key), t.left !== void 0 && e.ExistenceProof.encode(t.left, y.uint32(18).fork()).ldelim(), t.right !== void 0 && e.ExistenceProof.encode(t.right, y.uint32(26).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = D();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.key = E.bytes();
            break;
          case 2:
            a.left = e.ExistenceProof.decode(E, E.uint32());
            break;
          case 3:
            a.right = e.ExistenceProof.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        key: (0, u.isSet)(t.key) ? (0, u.bytesFromBase64)(t.key) : new Uint8Array(),
        left: (0, u.isSet)(t.left) ? e.ExistenceProof.fromJSON(t.left) : void 0,
        right: (0, u.isSet)(t.right) ? e.ExistenceProof.fromJSON(t.right) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.key !== void 0 && (y.key = (0, u.base64FromBytes)(t.key !== void 0 ? t.key : new Uint8Array())), t.left !== void 0 && (y.left = t.left ? e.ExistenceProof.toJSON(t.left) : void 0), t.right !== void 0 && (y.right = t.right ? e.ExistenceProof.toJSON(t.right) : void 0), y;
    },
    fromPartial(t) {
      const y = D();
      return y.key = t.key ?? new Uint8Array(), y.left = t.left !== void 0 && t.left !== null ? e.ExistenceProof.fromPartial(t.left) : void 0, y.right = t.right !== void 0 && t.right !== null ? e.ExistenceProof.fromPartial(t.right) : void 0, y;
    }
  };
  function b() {
    return {
      exist: void 0,
      nonexist: void 0,
      batch: void 0,
      compressed: void 0
    };
  }
  e.CommitmentProof = {
    encode(t, y = r.Writer.create()) {
      return t.exist !== void 0 && e.ExistenceProof.encode(t.exist, y.uint32(10).fork()).ldelim(), t.nonexist !== void 0 && e.NonExistenceProof.encode(t.nonexist, y.uint32(18).fork()).ldelim(), t.batch !== void 0 && e.BatchProof.encode(t.batch, y.uint32(26).fork()).ldelim(), t.compressed !== void 0 && e.CompressedBatchProof.encode(t.compressed, y.uint32(34).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = b();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.exist = e.ExistenceProof.decode(E, E.uint32());
            break;
          case 2:
            a.nonexist = e.NonExistenceProof.decode(E, E.uint32());
            break;
          case 3:
            a.batch = e.BatchProof.decode(E, E.uint32());
            break;
          case 4:
            a.compressed = e.CompressedBatchProof.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        exist: (0, u.isSet)(t.exist) ? e.ExistenceProof.fromJSON(t.exist) : void 0,
        nonexist: (0, u.isSet)(t.nonexist) ? e.NonExistenceProof.fromJSON(t.nonexist) : void 0,
        batch: (0, u.isSet)(t.batch) ? e.BatchProof.fromJSON(t.batch) : void 0,
        compressed: (0, u.isSet)(t.compressed) ? e.CompressedBatchProof.fromJSON(t.compressed) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.exist !== void 0 && (y.exist = t.exist ? e.ExistenceProof.toJSON(t.exist) : void 0), t.nonexist !== void 0 && (y.nonexist = t.nonexist ? e.NonExistenceProof.toJSON(t.nonexist) : void 0), t.batch !== void 0 && (y.batch = t.batch ? e.BatchProof.toJSON(t.batch) : void 0), t.compressed !== void 0 && (y.compressed = t.compressed ? e.CompressedBatchProof.toJSON(t.compressed) : void 0), y;
    },
    fromPartial(t) {
      const y = b();
      return y.exist = t.exist !== void 0 && t.exist !== null ? e.ExistenceProof.fromPartial(t.exist) : void 0, y.nonexist = t.nonexist !== void 0 && t.nonexist !== null ? e.NonExistenceProof.fromPartial(t.nonexist) : void 0, y.batch = t.batch !== void 0 && t.batch !== null ? e.BatchProof.fromPartial(t.batch) : void 0, y.compressed = t.compressed !== void 0 && t.compressed !== null ? e.CompressedBatchProof.fromPartial(t.compressed) : void 0, y;
    }
  };
  function h() {
    return {
      hash: 0,
      prehashKey: 0,
      prehashValue: 0,
      length: 0,
      prefix: new Uint8Array()
    };
  }
  e.LeafOp = {
    encode(t, y = r.Writer.create()) {
      return t.hash !== 0 && y.uint32(8).int32(t.hash), t.prehashKey !== 0 && y.uint32(16).int32(t.prehashKey), t.prehashValue !== 0 && y.uint32(24).int32(t.prehashValue), t.length !== 0 && y.uint32(32).int32(t.length), t.prefix.length !== 0 && y.uint32(42).bytes(t.prefix), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = h();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.hash = E.int32();
            break;
          case 2:
            a.prehashKey = E.int32();
            break;
          case 3:
            a.prehashValue = E.int32();
            break;
          case 4:
            a.length = E.int32();
            break;
          case 5:
            a.prefix = E.bytes();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        hash: (0, u.isSet)(t.hash) ? O(t.hash) : 0,
        prehashKey: (0, u.isSet)(t.prehashKey) ? O(t.prehashKey) : 0,
        prehashValue: (0, u.isSet)(t.prehashValue) ? O(t.prehashValue) : 0,
        length: (0, u.isSet)(t.length) ? L(t.length) : 0,
        prefix: (0, u.isSet)(t.prefix) ? (0, u.bytesFromBase64)(t.prefix) : new Uint8Array()
      };
    },
    toJSON(t) {
      const y = {};
      return t.hash !== void 0 && (y.hash = A(t.hash)), t.prehashKey !== void 0 && (y.prehashKey = A(t.prehashKey)), t.prehashValue !== void 0 && (y.prehashValue = A(t.prehashValue)), t.length !== void 0 && (y.length = M(t.length)), t.prefix !== void 0 && (y.prefix = (0, u.base64FromBytes)(t.prefix !== void 0 ? t.prefix : new Uint8Array())), y;
    },
    fromPartial(t) {
      const y = h();
      return y.hash = t.hash ?? 0, y.prehashKey = t.prehashKey ?? 0, y.prehashValue = t.prehashValue ?? 0, y.length = t.length ?? 0, y.prefix = t.prefix ?? new Uint8Array(), y;
    }
  };
  function S() {
    return {
      hash: 0,
      prefix: new Uint8Array(),
      suffix: new Uint8Array()
    };
  }
  e.InnerOp = {
    encode(t, y = r.Writer.create()) {
      return t.hash !== 0 && y.uint32(8).int32(t.hash), t.prefix.length !== 0 && y.uint32(18).bytes(t.prefix), t.suffix.length !== 0 && y.uint32(26).bytes(t.suffix), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = S();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.hash = E.int32();
            break;
          case 2:
            a.prefix = E.bytes();
            break;
          case 3:
            a.suffix = E.bytes();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        hash: (0, u.isSet)(t.hash) ? O(t.hash) : 0,
        prefix: (0, u.isSet)(t.prefix) ? (0, u.bytesFromBase64)(t.prefix) : new Uint8Array(),
        suffix: (0, u.isSet)(t.suffix) ? (0, u.bytesFromBase64)(t.suffix) : new Uint8Array()
      };
    },
    toJSON(t) {
      const y = {};
      return t.hash !== void 0 && (y.hash = A(t.hash)), t.prefix !== void 0 && (y.prefix = (0, u.base64FromBytes)(t.prefix !== void 0 ? t.prefix : new Uint8Array())), t.suffix !== void 0 && (y.suffix = (0, u.base64FromBytes)(t.suffix !== void 0 ? t.suffix : new Uint8Array())), y;
    },
    fromPartial(t) {
      const y = S();
      return y.hash = t.hash ?? 0, y.prefix = t.prefix ?? new Uint8Array(), y.suffix = t.suffix ?? new Uint8Array(), y;
    }
  };
  function _() {
    return {
      leafSpec: void 0,
      innerSpec: void 0,
      maxDepth: 0,
      minDepth: 0
    };
  }
  e.ProofSpec = {
    encode(t, y = r.Writer.create()) {
      return t.leafSpec !== void 0 && e.LeafOp.encode(t.leafSpec, y.uint32(10).fork()).ldelim(), t.innerSpec !== void 0 && e.InnerSpec.encode(t.innerSpec, y.uint32(18).fork()).ldelim(), t.maxDepth !== 0 && y.uint32(24).int32(t.maxDepth), t.minDepth !== 0 && y.uint32(32).int32(t.minDepth), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = _();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.leafSpec = e.LeafOp.decode(E, E.uint32());
            break;
          case 2:
            a.innerSpec = e.InnerSpec.decode(E, E.uint32());
            break;
          case 3:
            a.maxDepth = E.int32();
            break;
          case 4:
            a.minDepth = E.int32();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        leafSpec: (0, u.isSet)(t.leafSpec) ? e.LeafOp.fromJSON(t.leafSpec) : void 0,
        innerSpec: (0, u.isSet)(t.innerSpec) ? e.InnerSpec.fromJSON(t.innerSpec) : void 0,
        maxDepth: (0, u.isSet)(t.maxDepth) ? Number(t.maxDepth) : 0,
        minDepth: (0, u.isSet)(t.minDepth) ? Number(t.minDepth) : 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.leafSpec !== void 0 && (y.leafSpec = t.leafSpec ? e.LeafOp.toJSON(t.leafSpec) : void 0), t.innerSpec !== void 0 && (y.innerSpec = t.innerSpec ? e.InnerSpec.toJSON(t.innerSpec) : void 0), t.maxDepth !== void 0 && (y.maxDepth = Math.round(t.maxDepth)), t.minDepth !== void 0 && (y.minDepth = Math.round(t.minDepth)), y;
    },
    fromPartial(t) {
      const y = _();
      return y.leafSpec = t.leafSpec !== void 0 && t.leafSpec !== null ? e.LeafOp.fromPartial(t.leafSpec) : void 0, y.innerSpec = t.innerSpec !== void 0 && t.innerSpec !== null ? e.InnerSpec.fromPartial(t.innerSpec) : void 0, y.maxDepth = t.maxDepth ?? 0, y.minDepth = t.minDepth ?? 0, y;
    }
  };
  function d() {
    return {
      childOrder: [],
      childSize: 0,
      minPrefixLength: 0,
      maxPrefixLength: 0,
      emptyChild: new Uint8Array(),
      hash: 0
    };
  }
  e.InnerSpec = {
    encode(t, y = r.Writer.create()) {
      y.uint32(10).fork();
      for (const E of t.childOrder)
        y.int32(E);
      return y.ldelim(), t.childSize !== 0 && y.uint32(16).int32(t.childSize), t.minPrefixLength !== 0 && y.uint32(24).int32(t.minPrefixLength), t.maxPrefixLength !== 0 && y.uint32(32).int32(t.maxPrefixLength), t.emptyChild.length !== 0 && y.uint32(42).bytes(t.emptyChild), t.hash !== 0 && y.uint32(48).int32(t.hash), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = d();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            if ((l & 7) === 2) {
              const C = E.uint32() + E.pos;
              for (; E.pos < C; )
                a.childOrder.push(E.int32());
            } else
              a.childOrder.push(E.int32());
            break;
          case 2:
            a.childSize = E.int32();
            break;
          case 3:
            a.minPrefixLength = E.int32();
            break;
          case 4:
            a.maxPrefixLength = E.int32();
            break;
          case 5:
            a.emptyChild = E.bytes();
            break;
          case 6:
            a.hash = E.int32();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        childOrder: Array.isArray(t == null ? void 0 : t.childOrder) ? t.childOrder.map((y) => Number(y)) : [],
        childSize: (0, u.isSet)(t.childSize) ? Number(t.childSize) : 0,
        minPrefixLength: (0, u.isSet)(t.minPrefixLength) ? Number(t.minPrefixLength) : 0,
        maxPrefixLength: (0, u.isSet)(t.maxPrefixLength) ? Number(t.maxPrefixLength) : 0,
        emptyChild: (0, u.isSet)(t.emptyChild) ? (0, u.bytesFromBase64)(t.emptyChild) : new Uint8Array(),
        hash: (0, u.isSet)(t.hash) ? O(t.hash) : 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.childOrder ? y.childOrder = t.childOrder.map((E) => Math.round(E)) : y.childOrder = [], t.childSize !== void 0 && (y.childSize = Math.round(t.childSize)), t.minPrefixLength !== void 0 && (y.minPrefixLength = Math.round(t.minPrefixLength)), t.maxPrefixLength !== void 0 && (y.maxPrefixLength = Math.round(t.maxPrefixLength)), t.emptyChild !== void 0 && (y.emptyChild = (0, u.base64FromBytes)(t.emptyChild !== void 0 ? t.emptyChild : new Uint8Array())), t.hash !== void 0 && (y.hash = A(t.hash)), y;
    },
    fromPartial(t) {
      var E;
      const y = d();
      return y.childOrder = ((E = t.childOrder) == null ? void 0 : E.map((H) => H)) || [], y.childSize = t.childSize ?? 0, y.minPrefixLength = t.minPrefixLength ?? 0, y.maxPrefixLength = t.maxPrefixLength ?? 0, y.emptyChild = t.emptyChild ?? new Uint8Array(), y.hash = t.hash ?? 0, y;
    }
  };
  function p() {
    return {
      entries: []
    };
  }
  e.BatchProof = {
    encode(t, y = r.Writer.create()) {
      for (const E of t.entries)
        e.BatchEntry.encode(E, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = p();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.entries.push(e.BatchEntry.decode(E, E.uint32()));
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        entries: Array.isArray(t == null ? void 0 : t.entries) ? t.entries.map((y) => e.BatchEntry.fromJSON(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.entries ? y.entries = t.entries.map((E) => E ? e.BatchEntry.toJSON(E) : void 0) : y.entries = [], y;
    },
    fromPartial(t) {
      var E;
      const y = p();
      return y.entries = ((E = t.entries) == null ? void 0 : E.map((H) => e.BatchEntry.fromPartial(H))) || [], y;
    }
  };
  function g() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.BatchEntry = {
    encode(t, y = r.Writer.create()) {
      return t.exist !== void 0 && e.ExistenceProof.encode(t.exist, y.uint32(10).fork()).ldelim(), t.nonexist !== void 0 && e.NonExistenceProof.encode(t.nonexist, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = g();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.exist = e.ExistenceProof.decode(E, E.uint32());
            break;
          case 2:
            a.nonexist = e.NonExistenceProof.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        exist: (0, u.isSet)(t.exist) ? e.ExistenceProof.fromJSON(t.exist) : void 0,
        nonexist: (0, u.isSet)(t.nonexist) ? e.NonExistenceProof.fromJSON(t.nonexist) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.exist !== void 0 && (y.exist = t.exist ? e.ExistenceProof.toJSON(t.exist) : void 0), t.nonexist !== void 0 && (y.nonexist = t.nonexist ? e.NonExistenceProof.toJSON(t.nonexist) : void 0), y;
    },
    fromPartial(t) {
      const y = g();
      return y.exist = t.exist !== void 0 && t.exist !== null ? e.ExistenceProof.fromPartial(t.exist) : void 0, y.nonexist = t.nonexist !== void 0 && t.nonexist !== null ? e.NonExistenceProof.fromPartial(t.nonexist) : void 0, y;
    }
  };
  function J() {
    return {
      entries: [],
      lookupInners: []
    };
  }
  e.CompressedBatchProof = {
    encode(t, y = r.Writer.create()) {
      for (const E of t.entries)
        e.CompressedBatchEntry.encode(E, y.uint32(10).fork()).ldelim();
      for (const E of t.lookupInners)
        e.InnerOp.encode(E, y.uint32(18).fork()).ldelim();
      return y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = J();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.entries.push(e.CompressedBatchEntry.decode(E, E.uint32()));
            break;
          case 2:
            a.lookupInners.push(e.InnerOp.decode(E, E.uint32()));
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        entries: Array.isArray(t == null ? void 0 : t.entries) ? t.entries.map((y) => e.CompressedBatchEntry.fromJSON(y)) : [],
        lookupInners: Array.isArray(t == null ? void 0 : t.lookupInners) ? t.lookupInners.map((y) => e.InnerOp.fromJSON(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.entries ? y.entries = t.entries.map((E) => E ? e.CompressedBatchEntry.toJSON(E) : void 0) : y.entries = [], t.lookupInners ? y.lookupInners = t.lookupInners.map((E) => E ? e.InnerOp.toJSON(E) : void 0) : y.lookupInners = [], y;
    },
    fromPartial(t) {
      var E, H;
      const y = J();
      return y.entries = ((E = t.entries) == null ? void 0 : E.map((a) => e.CompressedBatchEntry.fromPartial(a))) || [], y.lookupInners = ((H = t.lookupInners) == null ? void 0 : H.map((a) => e.InnerOp.fromPartial(a))) || [], y;
    }
  };
  function B() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.CompressedBatchEntry = {
    encode(t, y = r.Writer.create()) {
      return t.exist !== void 0 && e.CompressedExistenceProof.encode(t.exist, y.uint32(10).fork()).ldelim(), t.nonexist !== void 0 && e.CompressedNonExistenceProof.encode(t.nonexist, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = B();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.exist = e.CompressedExistenceProof.decode(E, E.uint32());
            break;
          case 2:
            a.nonexist = e.CompressedNonExistenceProof.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        exist: (0, u.isSet)(t.exist) ? e.CompressedExistenceProof.fromJSON(t.exist) : void 0,
        nonexist: (0, u.isSet)(t.nonexist) ? e.CompressedNonExistenceProof.fromJSON(t.nonexist) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.exist !== void 0 && (y.exist = t.exist ? e.CompressedExistenceProof.toJSON(t.exist) : void 0), t.nonexist !== void 0 && (y.nonexist = t.nonexist ? e.CompressedNonExistenceProof.toJSON(t.nonexist) : void 0), y;
    },
    fromPartial(t) {
      const y = B();
      return y.exist = t.exist !== void 0 && t.exist !== null ? e.CompressedExistenceProof.fromPartial(t.exist) : void 0, y.nonexist = t.nonexist !== void 0 && t.nonexist !== null ? e.CompressedNonExistenceProof.fromPartial(t.nonexist) : void 0, y;
    }
  };
  function I() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.CompressedExistenceProof = {
    encode(t, y = r.Writer.create()) {
      t.key.length !== 0 && y.uint32(10).bytes(t.key), t.value.length !== 0 && y.uint32(18).bytes(t.value), t.leaf !== void 0 && e.LeafOp.encode(t.leaf, y.uint32(26).fork()).ldelim(), y.uint32(34).fork();
      for (const E of t.path)
        y.int32(E);
      return y.ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = I();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.key = E.bytes();
            break;
          case 2:
            a.value = E.bytes();
            break;
          case 3:
            a.leaf = e.LeafOp.decode(E, E.uint32());
            break;
          case 4:
            if ((l & 7) === 2) {
              const C = E.uint32() + E.pos;
              for (; E.pos < C; )
                a.path.push(E.int32());
            } else
              a.path.push(E.int32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        key: (0, u.isSet)(t.key) ? (0, u.bytesFromBase64)(t.key) : new Uint8Array(),
        value: (0, u.isSet)(t.value) ? (0, u.bytesFromBase64)(t.value) : new Uint8Array(),
        leaf: (0, u.isSet)(t.leaf) ? e.LeafOp.fromJSON(t.leaf) : void 0,
        path: Array.isArray(t == null ? void 0 : t.path) ? t.path.map((y) => Number(y)) : []
      };
    },
    toJSON(t) {
      const y = {};
      return t.key !== void 0 && (y.key = (0, u.base64FromBytes)(t.key !== void 0 ? t.key : new Uint8Array())), t.value !== void 0 && (y.value = (0, u.base64FromBytes)(t.value !== void 0 ? t.value : new Uint8Array())), t.leaf !== void 0 && (y.leaf = t.leaf ? e.LeafOp.toJSON(t.leaf) : void 0), t.path ? y.path = t.path.map((E) => Math.round(E)) : y.path = [], y;
    },
    fromPartial(t) {
      var E;
      const y = I();
      return y.key = t.key ?? new Uint8Array(), y.value = t.value ?? new Uint8Array(), y.leaf = t.leaf !== void 0 && t.leaf !== null ? e.LeafOp.fromPartial(t.leaf) : void 0, y.path = ((E = t.path) == null ? void 0 : E.map((H) => H)) || [], y;
    }
  };
  function Z() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.CompressedNonExistenceProof = {
    encode(t, y = r.Writer.create()) {
      return t.key.length !== 0 && y.uint32(10).bytes(t.key), t.left !== void 0 && e.CompressedExistenceProof.encode(t.left, y.uint32(18).fork()).ldelim(), t.right !== void 0 && e.CompressedExistenceProof.encode(t.right, y.uint32(26).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof r.Reader ? t : new r.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = Z();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.key = E.bytes();
            break;
          case 2:
            a.left = e.CompressedExistenceProof.decode(E, E.uint32());
            break;
          case 3:
            a.right = e.CompressedExistenceProof.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        key: (0, u.isSet)(t.key) ? (0, u.bytesFromBase64)(t.key) : new Uint8Array(),
        left: (0, u.isSet)(t.left) ? e.CompressedExistenceProof.fromJSON(t.left) : void 0,
        right: (0, u.isSet)(t.right) ? e.CompressedExistenceProof.fromJSON(t.right) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.key !== void 0 && (y.key = (0, u.base64FromBytes)(t.key !== void 0 ? t.key : new Uint8Array())), t.left !== void 0 && (y.left = t.left ? e.CompressedExistenceProof.toJSON(t.left) : void 0), t.right !== void 0 && (y.right = t.right ? e.CompressedExistenceProof.toJSON(t.right) : void 0), y;
    },
    fromPartial(t) {
      const y = Z();
      return y.key = t.key ?? new Uint8Array(), y.left = t.left !== void 0 && t.left !== null ? e.CompressedExistenceProof.fromPartial(t.left) : void 0, y.right = t.right !== void 0 && t.right !== null ? e.CompressedExistenceProof.fromPartial(t.right) : void 0, y;
    }
  };
})(ra);
var wh = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), bh = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Bh = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && wh(n, e, c);
  return bh(n, e), n;
};
Object.defineProperty(je, "__esModule", { value: !0 });
je.MerkleProof = je.MerklePath = je.MerklePrefix = je.MerkleRoot = je.protobufPackage = void 0;
const Qt = ra, ln = Bh(ie), Ot = oe;
je.protobufPackage = "ibc.core.commitment.v1";
function Bs() {
  return {
    hash: new Uint8Array()
  };
}
je.MerkleRoot = {
  encode(e, n = ln.Writer.create()) {
    return e.hash.length !== 0 && n.uint32(10).bytes(e.hash), n;
  },
  decode(e, n) {
    const c = e instanceof ln.Reader ? e : new ln.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Bs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.hash = c.bytes();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      hash: (0, Ot.isSet)(e.hash) ? (0, Ot.bytesFromBase64)(e.hash) : new Uint8Array()
    };
  },
  toJSON(e) {
    const n = {};
    return e.hash !== void 0 && (n.hash = (0, Ot.base64FromBytes)(e.hash !== void 0 ? e.hash : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Bs();
    return n.hash = e.hash ?? new Uint8Array(), n;
  }
};
function Js() {
  return {
    keyPrefix: new Uint8Array()
  };
}
je.MerklePrefix = {
  encode(e, n = ln.Writer.create()) {
    return e.keyPrefix.length !== 0 && n.uint32(10).bytes(e.keyPrefix), n;
  },
  decode(e, n) {
    const c = e instanceof ln.Reader ? e : new ln.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Js();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.keyPrefix = c.bytes();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      keyPrefix: (0, Ot.isSet)(e.keyPrefix) ? (0, Ot.bytesFromBase64)(e.keyPrefix) : new Uint8Array()
    };
  },
  toJSON(e) {
    const n = {};
    return e.keyPrefix !== void 0 && (n.keyPrefix = (0, Ot.base64FromBytes)(e.keyPrefix !== void 0 ? e.keyPrefix : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Js();
    return n.keyPrefix = e.keyPrefix ?? new Uint8Array(), n;
  }
};
function Ds() {
  return {
    keyPath: []
  };
}
je.MerklePath = {
  encode(e, n = ln.Writer.create()) {
    for (const c of e.keyPath)
      n.uint32(10).string(c);
    return n;
  },
  decode(e, n) {
    const c = e instanceof ln.Reader ? e : new ln.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Ds();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.keyPath.push(c.string());
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      keyPath: Array.isArray(e == null ? void 0 : e.keyPath) ? e.keyPath.map((n) => String(n)) : []
    };
  },
  toJSON(e) {
    const n = {};
    return e.keyPath ? n.keyPath = e.keyPath.map((c) => c) : n.keyPath = [], n;
  },
  fromPartial(e) {
    var c;
    const n = Ds();
    return n.keyPath = ((c = e.keyPath) == null ? void 0 : c.map((i) => i)) || [], n;
  }
};
function Us() {
  return {
    proofs: []
  };
}
je.MerkleProof = {
  encode(e, n = ln.Writer.create()) {
    for (const c of e.proofs)
      Qt.CommitmentProof.encode(c, n.uint32(10).fork()).ldelim();
    return n;
  },
  decode(e, n) {
    const c = e instanceof ln.Reader ? e : new ln.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Us();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.proofs.push(Qt.CommitmentProof.decode(c, c.uint32()));
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      proofs: Array.isArray(e == null ? void 0 : e.proofs) ? e.proofs.map((n) => Qt.CommitmentProof.fromJSON(n)) : []
    };
  },
  toJSON(e) {
    const n = {};
    return e.proofs ? n.proofs = e.proofs.map((c) => c ? Qt.CommitmentProof.toJSON(c) : void 0) : n.proofs = [], n;
  },
  fromPartial(e) {
    var c;
    const n = Us();
    return n.proofs = ((c = e.proofs) == null ? void 0 : c.map((i) => Qt.CommitmentProof.fromPartial(i))) || [], n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(_, d, p, g) {
    g === void 0 && (g = p);
    var J = Object.getOwnPropertyDescriptor(d, p);
    (!J || ("get" in J ? !d.__esModule : J.writable || J.configurable)) && (J = { enumerable: !0, get: function() {
      return d[p];
    } }), Object.defineProperty(_, g, J);
  } : function(_, d, p, g) {
    g === void 0 && (g = p), _[g] = d[p];
  }), c = G && G.__setModuleDefault || (Object.create ? function(_, d) {
    Object.defineProperty(_, "default", { enumerable: !0, value: d });
  } : function(_, d) {
    _.default = d;
  }), i = G && G.__importStar || function(_) {
    if (_ && _.__esModule)
      return _;
    var d = {};
    if (_ != null)
      for (var p in _)
        p !== "default" && Object.prototype.hasOwnProperty.call(_, p) && n(d, _, p);
    return c(d, _), d;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Version = e.ConnectionPaths = e.ClientPaths = e.Counterparty = e.IdentifiedConnection = e.ConnectionEnd = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const r = je, u = oe, f = i(ie);
  e.protobufPackage = "ibc.core.connection.v1";
  var O;
  (function(_) {
    _[_.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", _[_.STATE_INIT = 1] = "STATE_INIT", _[_.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", _[_.STATE_OPEN = 3] = "STATE_OPEN", _[_.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(O = e.State || (e.State = {}));
  function A(_) {
    switch (_) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return O.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return O.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return O.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return O.STATE_OPEN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return O.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = A;
  function T(_) {
    switch (_) {
      case O.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case O.STATE_INIT:
        return "STATE_INIT";
      case O.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case O.STATE_OPEN:
        return "STATE_OPEN";
      case O.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = T;
  function L() {
    return {
      clientId: "",
      versions: [],
      state: 0,
      counterparty: void 0,
      delayPeriod: u.Long.UZERO
    };
  }
  e.ConnectionEnd = {
    encode(_, d = f.Writer.create()) {
      _.clientId !== "" && d.uint32(10).string(_.clientId);
      for (const p of _.versions)
        e.Version.encode(p, d.uint32(18).fork()).ldelim();
      return _.state !== 0 && d.uint32(24).int32(_.state), _.counterparty !== void 0 && e.Counterparty.encode(_.counterparty, d.uint32(34).fork()).ldelim(), _.delayPeriod.isZero() || d.uint32(40).uint64(_.delayPeriod), d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = L();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.clientId = p.string();
            break;
          case 2:
            J.versions.push(e.Version.decode(p, p.uint32()));
            break;
          case 3:
            J.state = p.int32();
            break;
          case 4:
            J.counterparty = e.Counterparty.decode(p, p.uint32());
            break;
          case 5:
            J.delayPeriod = p.uint64();
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        clientId: (0, u.isSet)(_.clientId) ? String(_.clientId) : "",
        versions: Array.isArray(_ == null ? void 0 : _.versions) ? _.versions.map((d) => e.Version.fromJSON(d)) : [],
        state: (0, u.isSet)(_.state) ? A(_.state) : 0,
        counterparty: (0, u.isSet)(_.counterparty) ? e.Counterparty.fromJSON(_.counterparty) : void 0,
        delayPeriod: (0, u.isSet)(_.delayPeriod) ? u.Long.fromValue(_.delayPeriod) : u.Long.UZERO
      };
    },
    toJSON(_) {
      const d = {};
      return _.clientId !== void 0 && (d.clientId = _.clientId), _.versions ? d.versions = _.versions.map((p) => p ? e.Version.toJSON(p) : void 0) : d.versions = [], _.state !== void 0 && (d.state = T(_.state)), _.counterparty !== void 0 && (d.counterparty = _.counterparty ? e.Counterparty.toJSON(_.counterparty) : void 0), _.delayPeriod !== void 0 && (d.delayPeriod = (_.delayPeriod || u.Long.UZERO).toString()), d;
    },
    fromPartial(_) {
      var p;
      const d = L();
      return d.clientId = _.clientId ?? "", d.versions = ((p = _.versions) == null ? void 0 : p.map((g) => e.Version.fromPartial(g))) || [], d.state = _.state ?? 0, d.counterparty = _.counterparty !== void 0 && _.counterparty !== null ? e.Counterparty.fromPartial(_.counterparty) : void 0, d.delayPeriod = _.delayPeriod !== void 0 && _.delayPeriod !== null ? u.Long.fromValue(_.delayPeriod) : u.Long.UZERO, d;
    }
  };
  function M() {
    return {
      id: "",
      clientId: "",
      versions: [],
      state: 0,
      counterparty: void 0,
      delayPeriod: u.Long.UZERO
    };
  }
  e.IdentifiedConnection = {
    encode(_, d = f.Writer.create()) {
      _.id !== "" && d.uint32(10).string(_.id), _.clientId !== "" && d.uint32(18).string(_.clientId);
      for (const p of _.versions)
        e.Version.encode(p, d.uint32(26).fork()).ldelim();
      return _.state !== 0 && d.uint32(32).int32(_.state), _.counterparty !== void 0 && e.Counterparty.encode(_.counterparty, d.uint32(42).fork()).ldelim(), _.delayPeriod.isZero() || d.uint32(48).uint64(_.delayPeriod), d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = M();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.id = p.string();
            break;
          case 2:
            J.clientId = p.string();
            break;
          case 3:
            J.versions.push(e.Version.decode(p, p.uint32()));
            break;
          case 4:
            J.state = p.int32();
            break;
          case 5:
            J.counterparty = e.Counterparty.decode(p, p.uint32());
            break;
          case 6:
            J.delayPeriod = p.uint64();
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        id: (0, u.isSet)(_.id) ? String(_.id) : "",
        clientId: (0, u.isSet)(_.clientId) ? String(_.clientId) : "",
        versions: Array.isArray(_ == null ? void 0 : _.versions) ? _.versions.map((d) => e.Version.fromJSON(d)) : [],
        state: (0, u.isSet)(_.state) ? A(_.state) : 0,
        counterparty: (0, u.isSet)(_.counterparty) ? e.Counterparty.fromJSON(_.counterparty) : void 0,
        delayPeriod: (0, u.isSet)(_.delayPeriod) ? u.Long.fromValue(_.delayPeriod) : u.Long.UZERO
      };
    },
    toJSON(_) {
      const d = {};
      return _.id !== void 0 && (d.id = _.id), _.clientId !== void 0 && (d.clientId = _.clientId), _.versions ? d.versions = _.versions.map((p) => p ? e.Version.toJSON(p) : void 0) : d.versions = [], _.state !== void 0 && (d.state = T(_.state)), _.counterparty !== void 0 && (d.counterparty = _.counterparty ? e.Counterparty.toJSON(_.counterparty) : void 0), _.delayPeriod !== void 0 && (d.delayPeriod = (_.delayPeriod || u.Long.UZERO).toString()), d;
    },
    fromPartial(_) {
      var p;
      const d = M();
      return d.id = _.id ?? "", d.clientId = _.clientId ?? "", d.versions = ((p = _.versions) == null ? void 0 : p.map((g) => e.Version.fromPartial(g))) || [], d.state = _.state ?? 0, d.counterparty = _.counterparty !== void 0 && _.counterparty !== null ? e.Counterparty.fromPartial(_.counterparty) : void 0, d.delayPeriod = _.delayPeriod !== void 0 && _.delayPeriod !== null ? u.Long.fromValue(_.delayPeriod) : u.Long.UZERO, d;
    }
  };
  function V() {
    return {
      clientId: "",
      connectionId: "",
      prefix: void 0
    };
  }
  e.Counterparty = {
    encode(_, d = f.Writer.create()) {
      return _.clientId !== "" && d.uint32(10).string(_.clientId), _.connectionId !== "" && d.uint32(18).string(_.connectionId), _.prefix !== void 0 && r.MerklePrefix.encode(_.prefix, d.uint32(26).fork()).ldelim(), d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = V();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.clientId = p.string();
            break;
          case 2:
            J.connectionId = p.string();
            break;
          case 3:
            J.prefix = r.MerklePrefix.decode(p, p.uint32());
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        clientId: (0, u.isSet)(_.clientId) ? String(_.clientId) : "",
        connectionId: (0, u.isSet)(_.connectionId) ? String(_.connectionId) : "",
        prefix: (0, u.isSet)(_.prefix) ? r.MerklePrefix.fromJSON(_.prefix) : void 0
      };
    },
    toJSON(_) {
      const d = {};
      return _.clientId !== void 0 && (d.clientId = _.clientId), _.connectionId !== void 0 && (d.connectionId = _.connectionId), _.prefix !== void 0 && (d.prefix = _.prefix ? r.MerklePrefix.toJSON(_.prefix) : void 0), d;
    },
    fromPartial(_) {
      const d = V();
      return d.clientId = _.clientId ?? "", d.connectionId = _.connectionId ?? "", d.prefix = _.prefix !== void 0 && _.prefix !== null ? r.MerklePrefix.fromPartial(_.prefix) : void 0, d;
    }
  };
  function D() {
    return {
      paths: []
    };
  }
  e.ClientPaths = {
    encode(_, d = f.Writer.create()) {
      for (const p of _.paths)
        d.uint32(10).string(p);
      return d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = D();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.paths.push(p.string());
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        paths: Array.isArray(_ == null ? void 0 : _.paths) ? _.paths.map((d) => String(d)) : []
      };
    },
    toJSON(_) {
      const d = {};
      return _.paths ? d.paths = _.paths.map((p) => p) : d.paths = [], d;
    },
    fromPartial(_) {
      var p;
      const d = D();
      return d.paths = ((p = _.paths) == null ? void 0 : p.map((g) => g)) || [], d;
    }
  };
  function b() {
    return {
      clientId: "",
      paths: []
    };
  }
  e.ConnectionPaths = {
    encode(_, d = f.Writer.create()) {
      _.clientId !== "" && d.uint32(10).string(_.clientId);
      for (const p of _.paths)
        d.uint32(18).string(p);
      return d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = b();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.clientId = p.string();
            break;
          case 2:
            J.paths.push(p.string());
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        clientId: (0, u.isSet)(_.clientId) ? String(_.clientId) : "",
        paths: Array.isArray(_ == null ? void 0 : _.paths) ? _.paths.map((d) => String(d)) : []
      };
    },
    toJSON(_) {
      const d = {};
      return _.clientId !== void 0 && (d.clientId = _.clientId), _.paths ? d.paths = _.paths.map((p) => p) : d.paths = [], d;
    },
    fromPartial(_) {
      var p;
      const d = b();
      return d.clientId = _.clientId ?? "", d.paths = ((p = _.paths) == null ? void 0 : p.map((g) => g)) || [], d;
    }
  };
  function h() {
    return {
      identifier: "",
      features: []
    };
  }
  e.Version = {
    encode(_, d = f.Writer.create()) {
      _.identifier !== "" && d.uint32(10).string(_.identifier);
      for (const p of _.features)
        d.uint32(18).string(p);
      return d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = h();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.identifier = p.string();
            break;
          case 2:
            J.features.push(p.string());
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        identifier: (0, u.isSet)(_.identifier) ? String(_.identifier) : "",
        features: Array.isArray(_ == null ? void 0 : _.features) ? _.features.map((d) => String(d)) : []
      };
    },
    toJSON(_) {
      const d = {};
      return _.identifier !== void 0 && (d.identifier = _.identifier), _.features ? d.features = _.features.map((p) => p) : d.features = [], d;
    },
    fromPartial(_) {
      var p;
      const d = h();
      return d.identifier = _.identifier ?? "", d.features = ((p = _.features) == null ? void 0 : p.map((g) => g)) || [], d;
    }
  };
  function S() {
    return {
      maxExpectedTimePerBlock: u.Long.UZERO
    };
  }
  e.Params = {
    encode(_, d = f.Writer.create()) {
      return _.maxExpectedTimePerBlock.isZero() || d.uint32(8).uint64(_.maxExpectedTimePerBlock), d;
    },
    decode(_, d) {
      const p = _ instanceof f.Reader ? _ : new f.Reader(_);
      let g = d === void 0 ? p.len : p.pos + d;
      const J = S();
      for (; p.pos < g; ) {
        const B = p.uint32();
        switch (B >>> 3) {
          case 1:
            J.maxExpectedTimePerBlock = p.uint64();
            break;
          default:
            p.skipType(B & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(_) {
      return {
        maxExpectedTimePerBlock: (0, u.isSet)(_.maxExpectedTimePerBlock) ? u.Long.fromValue(_.maxExpectedTimePerBlock) : u.Long.UZERO
      };
    },
    toJSON(_) {
      const d = {};
      return _.maxExpectedTimePerBlock !== void 0 && (d.maxExpectedTimePerBlock = (_.maxExpectedTimePerBlock || u.Long.UZERO).toString()), d;
    },
    fromPartial(_) {
      const d = S();
      return d.maxExpectedTimePerBlock = _.maxExpectedTimePerBlock !== void 0 && _.maxExpectedTimePerBlock !== null ? u.Long.fromValue(_.maxExpectedTimePerBlock) : u.Long.UZERO, d;
    }
  };
})(ta);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(d, p, g, J) {
    J === void 0 && (J = g);
    var B = Object.getOwnPropertyDescriptor(p, g);
    (!B || ("get" in B ? !p.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return p[g];
    } }), Object.defineProperty(d, J, B);
  } : function(d, p, g, J) {
    J === void 0 && (J = g), d[J] = p[g];
  }), c = G && G.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), i = G && G.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var g in d)
        g !== "default" && Object.prototype.hasOwnProperty.call(d, g) && n(p, d, g);
    return c(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgConnectionOpenConfirmResponse = e.MsgConnectionOpenConfirm = e.MsgConnectionOpenAckResponse = e.MsgConnectionOpenAck = e.MsgConnectionOpenTryResponse = e.MsgConnectionOpenTry = e.MsgConnectionOpenInitResponse = e.MsgConnectionOpenInit = e.protobufPackage = void 0;
  const r = ta, u = Se, f = In, O = oe, A = i(ie);
  e.protobufPackage = "ibc.core.connection.v1";
  function T() {
    return {
      clientId: "",
      counterparty: void 0,
      version: void 0,
      delayPeriod: O.Long.UZERO,
      signer: ""
    };
  }
  e.MsgConnectionOpenInit = {
    encode(d, p = A.Writer.create()) {
      return d.clientId !== "" && p.uint32(10).string(d.clientId), d.counterparty !== void 0 && r.Counterparty.encode(d.counterparty, p.uint32(18).fork()).ldelim(), d.version !== void 0 && r.Version.encode(d.version, p.uint32(26).fork()).ldelim(), d.delayPeriod.isZero() || p.uint32(32).uint64(d.delayPeriod), d.signer !== "" && p.uint32(42).string(d.signer), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = T();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.clientId = g.string();
            break;
          case 2:
            B.counterparty = r.Counterparty.decode(g, g.uint32());
            break;
          case 3:
            B.version = r.Version.decode(g, g.uint32());
            break;
          case 4:
            B.delayPeriod = g.uint64();
            break;
          case 5:
            B.signer = g.string();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        clientId: (0, O.isSet)(d.clientId) ? String(d.clientId) : "",
        counterparty: (0, O.isSet)(d.counterparty) ? r.Counterparty.fromJSON(d.counterparty) : void 0,
        version: (0, O.isSet)(d.version) ? r.Version.fromJSON(d.version) : void 0,
        delayPeriod: (0, O.isSet)(d.delayPeriod) ? O.Long.fromValue(d.delayPeriod) : O.Long.UZERO,
        signer: (0, O.isSet)(d.signer) ? String(d.signer) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.clientId !== void 0 && (p.clientId = d.clientId), d.counterparty !== void 0 && (p.counterparty = d.counterparty ? r.Counterparty.toJSON(d.counterparty) : void 0), d.version !== void 0 && (p.version = d.version ? r.Version.toJSON(d.version) : void 0), d.delayPeriod !== void 0 && (p.delayPeriod = (d.delayPeriod || O.Long.UZERO).toString()), d.signer !== void 0 && (p.signer = d.signer), p;
    },
    fromPartial(d) {
      const p = T();
      return p.clientId = d.clientId ?? "", p.counterparty = d.counterparty !== void 0 && d.counterparty !== null ? r.Counterparty.fromPartial(d.counterparty) : void 0, p.version = d.version !== void 0 && d.version !== null ? r.Version.fromPartial(d.version) : void 0, p.delayPeriod = d.delayPeriod !== void 0 && d.delayPeriod !== null ? O.Long.fromValue(d.delayPeriod) : O.Long.UZERO, p.signer = d.signer ?? "", p;
    }
  };
  function L() {
    return {};
  }
  e.MsgConnectionOpenInitResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = L();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return L();
    }
  };
  function M() {
    return {
      clientId: "",
      previousConnectionId: "",
      clientState: void 0,
      counterparty: void 0,
      delayPeriod: O.Long.UZERO,
      counterpartyVersions: [],
      proofHeight: void 0,
      proofInit: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: void 0,
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenTry = {
    encode(d, p = A.Writer.create()) {
      d.clientId !== "" && p.uint32(10).string(d.clientId), d.previousConnectionId !== "" && p.uint32(18).string(d.previousConnectionId), d.clientState !== void 0 && u.Any.encode(d.clientState, p.uint32(26).fork()).ldelim(), d.counterparty !== void 0 && r.Counterparty.encode(d.counterparty, p.uint32(34).fork()).ldelim(), d.delayPeriod.isZero() || p.uint32(40).uint64(d.delayPeriod);
      for (const g of d.counterpartyVersions)
        r.Version.encode(g, p.uint32(50).fork()).ldelim();
      return d.proofHeight !== void 0 && f.Height.encode(d.proofHeight, p.uint32(58).fork()).ldelim(), d.proofInit.length !== 0 && p.uint32(66).bytes(d.proofInit), d.proofClient.length !== 0 && p.uint32(74).bytes(d.proofClient), d.proofConsensus.length !== 0 && p.uint32(82).bytes(d.proofConsensus), d.consensusHeight !== void 0 && f.Height.encode(d.consensusHeight, p.uint32(90).fork()).ldelim(), d.signer !== "" && p.uint32(98).string(d.signer), d.hostConsensusStateProof.length !== 0 && p.uint32(106).bytes(d.hostConsensusStateProof), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = M();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.clientId = g.string();
            break;
          case 2:
            B.previousConnectionId = g.string();
            break;
          case 3:
            B.clientState = u.Any.decode(g, g.uint32());
            break;
          case 4:
            B.counterparty = r.Counterparty.decode(g, g.uint32());
            break;
          case 5:
            B.delayPeriod = g.uint64();
            break;
          case 6:
            B.counterpartyVersions.push(r.Version.decode(g, g.uint32()));
            break;
          case 7:
            B.proofHeight = f.Height.decode(g, g.uint32());
            break;
          case 8:
            B.proofInit = g.bytes();
            break;
          case 9:
            B.proofClient = g.bytes();
            break;
          case 10:
            B.proofConsensus = g.bytes();
            break;
          case 11:
            B.consensusHeight = f.Height.decode(g, g.uint32());
            break;
          case 12:
            B.signer = g.string();
            break;
          case 13:
            B.hostConsensusStateProof = g.bytes();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        clientId: (0, O.isSet)(d.clientId) ? String(d.clientId) : "",
        previousConnectionId: (0, O.isSet)(d.previousConnectionId) ? String(d.previousConnectionId) : "",
        clientState: (0, O.isSet)(d.clientState) ? u.Any.fromJSON(d.clientState) : void 0,
        counterparty: (0, O.isSet)(d.counterparty) ? r.Counterparty.fromJSON(d.counterparty) : void 0,
        delayPeriod: (0, O.isSet)(d.delayPeriod) ? O.Long.fromValue(d.delayPeriod) : O.Long.UZERO,
        counterpartyVersions: Array.isArray(d == null ? void 0 : d.counterpartyVersions) ? d.counterpartyVersions.map((p) => r.Version.fromJSON(p)) : [],
        proofHeight: (0, O.isSet)(d.proofHeight) ? f.Height.fromJSON(d.proofHeight) : void 0,
        proofInit: (0, O.isSet)(d.proofInit) ? (0, O.bytesFromBase64)(d.proofInit) : new Uint8Array(),
        proofClient: (0, O.isSet)(d.proofClient) ? (0, O.bytesFromBase64)(d.proofClient) : new Uint8Array(),
        proofConsensus: (0, O.isSet)(d.proofConsensus) ? (0, O.bytesFromBase64)(d.proofConsensus) : new Uint8Array(),
        consensusHeight: (0, O.isSet)(d.consensusHeight) ? f.Height.fromJSON(d.consensusHeight) : void 0,
        signer: (0, O.isSet)(d.signer) ? String(d.signer) : "",
        hostConsensusStateProof: (0, O.isSet)(d.hostConsensusStateProof) ? (0, O.bytesFromBase64)(d.hostConsensusStateProof) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.clientId !== void 0 && (p.clientId = d.clientId), d.previousConnectionId !== void 0 && (p.previousConnectionId = d.previousConnectionId), d.clientState !== void 0 && (p.clientState = d.clientState ? u.Any.toJSON(d.clientState) : void 0), d.counterparty !== void 0 && (p.counterparty = d.counterparty ? r.Counterparty.toJSON(d.counterparty) : void 0), d.delayPeriod !== void 0 && (p.delayPeriod = (d.delayPeriod || O.Long.UZERO).toString()), d.counterpartyVersions ? p.counterpartyVersions = d.counterpartyVersions.map((g) => g ? r.Version.toJSON(g) : void 0) : p.counterpartyVersions = [], d.proofHeight !== void 0 && (p.proofHeight = d.proofHeight ? f.Height.toJSON(d.proofHeight) : void 0), d.proofInit !== void 0 && (p.proofInit = (0, O.base64FromBytes)(d.proofInit !== void 0 ? d.proofInit : new Uint8Array())), d.proofClient !== void 0 && (p.proofClient = (0, O.base64FromBytes)(d.proofClient !== void 0 ? d.proofClient : new Uint8Array())), d.proofConsensus !== void 0 && (p.proofConsensus = (0, O.base64FromBytes)(d.proofConsensus !== void 0 ? d.proofConsensus : new Uint8Array())), d.consensusHeight !== void 0 && (p.consensusHeight = d.consensusHeight ? f.Height.toJSON(d.consensusHeight) : void 0), d.signer !== void 0 && (p.signer = d.signer), d.hostConsensusStateProof !== void 0 && (p.hostConsensusStateProof = (0, O.base64FromBytes)(d.hostConsensusStateProof !== void 0 ? d.hostConsensusStateProof : new Uint8Array())), p;
    },
    fromPartial(d) {
      var g;
      const p = M();
      return p.clientId = d.clientId ?? "", p.previousConnectionId = d.previousConnectionId ?? "", p.clientState = d.clientState !== void 0 && d.clientState !== null ? u.Any.fromPartial(d.clientState) : void 0, p.counterparty = d.counterparty !== void 0 && d.counterparty !== null ? r.Counterparty.fromPartial(d.counterparty) : void 0, p.delayPeriod = d.delayPeriod !== void 0 && d.delayPeriod !== null ? O.Long.fromValue(d.delayPeriod) : O.Long.UZERO, p.counterpartyVersions = ((g = d.counterpartyVersions) == null ? void 0 : g.map((J) => r.Version.fromPartial(J))) || [], p.proofHeight = d.proofHeight !== void 0 && d.proofHeight !== null ? f.Height.fromPartial(d.proofHeight) : void 0, p.proofInit = d.proofInit ?? new Uint8Array(), p.proofClient = d.proofClient ?? new Uint8Array(), p.proofConsensus = d.proofConsensus ?? new Uint8Array(), p.consensusHeight = d.consensusHeight !== void 0 && d.consensusHeight !== null ? f.Height.fromPartial(d.consensusHeight) : void 0, p.signer = d.signer ?? "", p.hostConsensusStateProof = d.hostConsensusStateProof ?? new Uint8Array(), p;
    }
  };
  function V() {
    return {};
  }
  e.MsgConnectionOpenTryResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = V();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return V();
    }
  };
  function D() {
    return {
      connectionId: "",
      counterpartyConnectionId: "",
      version: void 0,
      clientState: void 0,
      proofHeight: void 0,
      proofTry: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: void 0,
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenAck = {
    encode(d, p = A.Writer.create()) {
      return d.connectionId !== "" && p.uint32(10).string(d.connectionId), d.counterpartyConnectionId !== "" && p.uint32(18).string(d.counterpartyConnectionId), d.version !== void 0 && r.Version.encode(d.version, p.uint32(26).fork()).ldelim(), d.clientState !== void 0 && u.Any.encode(d.clientState, p.uint32(34).fork()).ldelim(), d.proofHeight !== void 0 && f.Height.encode(d.proofHeight, p.uint32(42).fork()).ldelim(), d.proofTry.length !== 0 && p.uint32(50).bytes(d.proofTry), d.proofClient.length !== 0 && p.uint32(58).bytes(d.proofClient), d.proofConsensus.length !== 0 && p.uint32(66).bytes(d.proofConsensus), d.consensusHeight !== void 0 && f.Height.encode(d.consensusHeight, p.uint32(74).fork()).ldelim(), d.signer !== "" && p.uint32(82).string(d.signer), d.hostConsensusStateProof.length !== 0 && p.uint32(90).bytes(d.hostConsensusStateProof), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = D();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.connectionId = g.string();
            break;
          case 2:
            B.counterpartyConnectionId = g.string();
            break;
          case 3:
            B.version = r.Version.decode(g, g.uint32());
            break;
          case 4:
            B.clientState = u.Any.decode(g, g.uint32());
            break;
          case 5:
            B.proofHeight = f.Height.decode(g, g.uint32());
            break;
          case 6:
            B.proofTry = g.bytes();
            break;
          case 7:
            B.proofClient = g.bytes();
            break;
          case 8:
            B.proofConsensus = g.bytes();
            break;
          case 9:
            B.consensusHeight = f.Height.decode(g, g.uint32());
            break;
          case 10:
            B.signer = g.string();
            break;
          case 11:
            B.hostConsensusStateProof = g.bytes();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        connectionId: (0, O.isSet)(d.connectionId) ? String(d.connectionId) : "",
        counterpartyConnectionId: (0, O.isSet)(d.counterpartyConnectionId) ? String(d.counterpartyConnectionId) : "",
        version: (0, O.isSet)(d.version) ? r.Version.fromJSON(d.version) : void 0,
        clientState: (0, O.isSet)(d.clientState) ? u.Any.fromJSON(d.clientState) : void 0,
        proofHeight: (0, O.isSet)(d.proofHeight) ? f.Height.fromJSON(d.proofHeight) : void 0,
        proofTry: (0, O.isSet)(d.proofTry) ? (0, O.bytesFromBase64)(d.proofTry) : new Uint8Array(),
        proofClient: (0, O.isSet)(d.proofClient) ? (0, O.bytesFromBase64)(d.proofClient) : new Uint8Array(),
        proofConsensus: (0, O.isSet)(d.proofConsensus) ? (0, O.bytesFromBase64)(d.proofConsensus) : new Uint8Array(),
        consensusHeight: (0, O.isSet)(d.consensusHeight) ? f.Height.fromJSON(d.consensusHeight) : void 0,
        signer: (0, O.isSet)(d.signer) ? String(d.signer) : "",
        hostConsensusStateProof: (0, O.isSet)(d.hostConsensusStateProof) ? (0, O.bytesFromBase64)(d.hostConsensusStateProof) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.connectionId !== void 0 && (p.connectionId = d.connectionId), d.counterpartyConnectionId !== void 0 && (p.counterpartyConnectionId = d.counterpartyConnectionId), d.version !== void 0 && (p.version = d.version ? r.Version.toJSON(d.version) : void 0), d.clientState !== void 0 && (p.clientState = d.clientState ? u.Any.toJSON(d.clientState) : void 0), d.proofHeight !== void 0 && (p.proofHeight = d.proofHeight ? f.Height.toJSON(d.proofHeight) : void 0), d.proofTry !== void 0 && (p.proofTry = (0, O.base64FromBytes)(d.proofTry !== void 0 ? d.proofTry : new Uint8Array())), d.proofClient !== void 0 && (p.proofClient = (0, O.base64FromBytes)(d.proofClient !== void 0 ? d.proofClient : new Uint8Array())), d.proofConsensus !== void 0 && (p.proofConsensus = (0, O.base64FromBytes)(d.proofConsensus !== void 0 ? d.proofConsensus : new Uint8Array())), d.consensusHeight !== void 0 && (p.consensusHeight = d.consensusHeight ? f.Height.toJSON(d.consensusHeight) : void 0), d.signer !== void 0 && (p.signer = d.signer), d.hostConsensusStateProof !== void 0 && (p.hostConsensusStateProof = (0, O.base64FromBytes)(d.hostConsensusStateProof !== void 0 ? d.hostConsensusStateProof : new Uint8Array())), p;
    },
    fromPartial(d) {
      const p = D();
      return p.connectionId = d.connectionId ?? "", p.counterpartyConnectionId = d.counterpartyConnectionId ?? "", p.version = d.version !== void 0 && d.version !== null ? r.Version.fromPartial(d.version) : void 0, p.clientState = d.clientState !== void 0 && d.clientState !== null ? u.Any.fromPartial(d.clientState) : void 0, p.proofHeight = d.proofHeight !== void 0 && d.proofHeight !== null ? f.Height.fromPartial(d.proofHeight) : void 0, p.proofTry = d.proofTry ?? new Uint8Array(), p.proofClient = d.proofClient ?? new Uint8Array(), p.proofConsensus = d.proofConsensus ?? new Uint8Array(), p.consensusHeight = d.consensusHeight !== void 0 && d.consensusHeight !== null ? f.Height.fromPartial(d.consensusHeight) : void 0, p.signer = d.signer ?? "", p.hostConsensusStateProof = d.hostConsensusStateProof ?? new Uint8Array(), p;
    }
  };
  function b() {
    return {};
  }
  e.MsgConnectionOpenAckResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = b();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return b();
    }
  };
  function h() {
    return {
      connectionId: "",
      proofAck: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgConnectionOpenConfirm = {
    encode(d, p = A.Writer.create()) {
      return d.connectionId !== "" && p.uint32(10).string(d.connectionId), d.proofAck.length !== 0 && p.uint32(18).bytes(d.proofAck), d.proofHeight !== void 0 && f.Height.encode(d.proofHeight, p.uint32(26).fork()).ldelim(), d.signer !== "" && p.uint32(34).string(d.signer), p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = h();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.connectionId = g.string();
            break;
          case 2:
            B.proofAck = g.bytes();
            break;
          case 3:
            B.proofHeight = f.Height.decode(g, g.uint32());
            break;
          case 4:
            B.signer = g.string();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        connectionId: (0, O.isSet)(d.connectionId) ? String(d.connectionId) : "",
        proofAck: (0, O.isSet)(d.proofAck) ? (0, O.bytesFromBase64)(d.proofAck) : new Uint8Array(),
        proofHeight: (0, O.isSet)(d.proofHeight) ? f.Height.fromJSON(d.proofHeight) : void 0,
        signer: (0, O.isSet)(d.signer) ? String(d.signer) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.connectionId !== void 0 && (p.connectionId = d.connectionId), d.proofAck !== void 0 && (p.proofAck = (0, O.base64FromBytes)(d.proofAck !== void 0 ? d.proofAck : new Uint8Array())), d.proofHeight !== void 0 && (p.proofHeight = d.proofHeight ? f.Height.toJSON(d.proofHeight) : void 0), d.signer !== void 0 && (p.signer = d.signer), p;
    },
    fromPartial(d) {
      const p = h();
      return p.connectionId = d.connectionId ?? "", p.proofAck = d.proofAck ?? new Uint8Array(), p.proofHeight = d.proofHeight !== void 0 && d.proofHeight !== null ? f.Height.fromPartial(d.proofHeight) : void 0, p.signer = d.signer ?? "", p;
    }
  };
  function S() {
    return {};
  }
  e.MsgConnectionOpenConfirmResponse = {
    encode(d, p = A.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const g = d instanceof A.Reader ? d : new A.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = S();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return S();
    }
  };
  class _ {
    constructor(p) {
      this.rpc = p, this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this), this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this), this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this), this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
    }
    ConnectionOpenInit(p) {
      const g = e.MsgConnectionOpenInit.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", g).then((B) => e.MsgConnectionOpenInitResponse.decode(new A.Reader(B)));
    }
    ConnectionOpenTry(p) {
      const g = e.MsgConnectionOpenTry.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", g).then((B) => e.MsgConnectionOpenTryResponse.decode(new A.Reader(B)));
    }
    ConnectionOpenAck(p) {
      const g = e.MsgConnectionOpenAck.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", g).then((B) => e.MsgConnectionOpenAckResponse.decode(new A.Reader(B)));
    }
    ConnectionOpenConfirm(p) {
      const g = e.MsgConnectionOpenConfirm.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", g).then((B) => e.MsgConnectionOpenConfirmResponse.decode(new A.Reader(B)));
    }
  }
  e.MsgClientImpl = _;
})(Eu);
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.isMsgTransferEncodeObject = wt.ibcTypes = void 0;
const Jh = ui, On = Nu, gr = Tu, yr = Eu;
wt.ibcTypes = [
  ["/ibc.applications.transfer.v1.MsgTransfer", Jh.MsgTransfer],
  ["/ibc.core.channel.v1.MsgAcknowledgement", On.MsgAcknowledgement],
  ["/ibc.core.channel.v1.MsgChannelCloseConfirm", On.MsgChannelCloseConfirm],
  ["/ibc.core.channel.v1.MsgChannelCloseInit", On.MsgChannelCloseInit],
  ["/ibc.core.channel.v1.MsgChannelOpenAck", On.MsgChannelOpenAck],
  ["/ibc.core.channel.v1.MsgChannelOpenConfirm", On.MsgChannelOpenConfirm],
  ["/ibc.core.channel.v1.MsgChannelOpenInit", On.MsgChannelOpenInit],
  ["/ibc.core.channel.v1.MsgChannelOpenTry", On.MsgChannelOpenTry],
  ["/ibc.core.channel.v1.MsgRecvPacket", On.MsgRecvPacket],
  ["/ibc.core.channel.v1.MsgTimeout", On.MsgTimeout],
  ["/ibc.core.channel.v1.MsgTimeoutOnClose", On.MsgTimeoutOnClose],
  ["/ibc.core.client.v1.MsgCreateClient", gr.MsgCreateClient],
  ["/ibc.core.client.v1.MsgSubmitMisbehaviour", gr.MsgSubmitMisbehaviour],
  ["/ibc.core.client.v1.MsgUpdateClient", gr.MsgUpdateClient],
  ["/ibc.core.client.v1.MsgUpgradeClient", gr.MsgUpgradeClient],
  ["/ibc.core.connection.v1.MsgConnectionOpenAck", yr.MsgConnectionOpenAck],
  ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", yr.MsgConnectionOpenConfirm],
  ["/ibc.core.connection.v1.MsgConnectionOpenInit", yr.MsgConnectionOpenInit],
  ["/ibc.core.connection.v1.MsgConnectionOpenTry", yr.MsgConnectionOpenTry]
];
function Dh(e) {
  return e.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
}
wt.isMsgTransferEncodeObject = Dh;
var li = {}, Cu = {}, Ln = {}, Uh = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), Mh = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Vh = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && Uh(n, e, c);
  return Mh(n, e), n;
};
Object.defineProperty(Ln, "__esModule", { value: !0 });
Ln.Params = Ln.DenomTrace = Ln.protobufPackage = void 0;
const Rt = Vh(ie), Br = oe;
Ln.protobufPackage = "ibc.applications.transfer.v1";
function Ms() {
  return {
    path: "",
    baseDenom: ""
  };
}
Ln.DenomTrace = {
  encode(e, n = Rt.Writer.create()) {
    return e.path !== "" && n.uint32(10).string(e.path), e.baseDenom !== "" && n.uint32(18).string(e.baseDenom), n;
  },
  decode(e, n) {
    const c = e instanceof Rt.Reader ? e : new Rt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Ms();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.path = c.string();
          break;
        case 2:
          r.baseDenom = c.string();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      path: (0, Br.isSet)(e.path) ? String(e.path) : "",
      baseDenom: (0, Br.isSet)(e.baseDenom) ? String(e.baseDenom) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.path !== void 0 && (n.path = e.path), e.baseDenom !== void 0 && (n.baseDenom = e.baseDenom), n;
  },
  fromPartial(e) {
    const n = Ms();
    return n.path = e.path ?? "", n.baseDenom = e.baseDenom ?? "", n;
  }
};
function Vs() {
  return {
    sendEnabled: !1,
    receiveEnabled: !1
  };
}
Ln.Params = {
  encode(e, n = Rt.Writer.create()) {
    return e.sendEnabled === !0 && n.uint32(8).bool(e.sendEnabled), e.receiveEnabled === !0 && n.uint32(16).bool(e.receiveEnabled), n;
  },
  decode(e, n) {
    const c = e instanceof Rt.Reader ? e : new Rt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Vs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.sendEnabled = c.bool();
          break;
        case 2:
          r.receiveEnabled = c.bool();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      sendEnabled: (0, Br.isSet)(e.sendEnabled) ? !!e.sendEnabled : !1,
      receiveEnabled: (0, Br.isSet)(e.receiveEnabled) ? !!e.receiveEnabled : !1
    };
  },
  toJSON(e) {
    const n = {};
    return e.sendEnabled !== void 0 && (n.sendEnabled = e.sendEnabled), e.receiveEnabled !== void 0 && (n.receiveEnabled = e.receiveEnabled), n;
  },
  fromPartial(e) {
    const n = Vs();
    return n.sendEnabled = e.sendEnabled ?? !1, n.receiveEnabled = e.receiveEnabled ?? !1, n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(p, g, J, B) {
    B === void 0 && (B = J);
    var I = Object.getOwnPropertyDescriptor(g, J);
    (!I || ("get" in I ? !g.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return g[J];
    } }), Object.defineProperty(p, B, I);
  } : function(p, g, J, B) {
    B === void 0 && (B = J), p[B] = g[J];
  }), c = G && G.__setModuleDefault || (Object.create ? function(p, g) {
    Object.defineProperty(p, "default", { enumerable: !0, value: g });
  } : function(p, g) {
    p.default = g;
  }), i = G && G.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var g = {};
    if (p != null)
      for (var J in p)
        J !== "default" && Object.prototype.hasOwnProperty.call(p, J) && n(g, p, J);
    return c(g, p), g;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryEscrowAddressResponse = e.QueryEscrowAddressRequest = e.QueryDenomHashResponse = e.QueryDenomHashRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryDenomTracesResponse = e.QueryDenomTracesRequest = e.QueryDenomTraceResponse = e.QueryDenomTraceRequest = e.protobufPackage = void 0;
  const r = Re, u = Ln, f = i(ie), O = oe;
  e.protobufPackage = "ibc.applications.transfer.v1";
  function A() {
    return {
      hash: ""
    };
  }
  e.QueryDenomTraceRequest = {
    encode(p, g = f.Writer.create()) {
      return p.hash !== "" && g.uint32(10).string(p.hash), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = A();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.hash = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        hash: (0, O.isSet)(p.hash) ? String(p.hash) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.hash !== void 0 && (g.hash = p.hash), g;
    },
    fromPartial(p) {
      const g = A();
      return g.hash = p.hash ?? "", g;
    }
  };
  function T() {
    return {
      denomTrace: void 0
    };
  }
  e.QueryDenomTraceResponse = {
    encode(p, g = f.Writer.create()) {
      return p.denomTrace !== void 0 && u.DenomTrace.encode(p.denomTrace, g.uint32(10).fork()).ldelim(), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = T();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.denomTrace = u.DenomTrace.decode(J, J.uint32());
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        denomTrace: (0, O.isSet)(p.denomTrace) ? u.DenomTrace.fromJSON(p.denomTrace) : void 0
      };
    },
    toJSON(p) {
      const g = {};
      return p.denomTrace !== void 0 && (g.denomTrace = p.denomTrace ? u.DenomTrace.toJSON(p.denomTrace) : void 0), g;
    },
    fromPartial(p) {
      const g = T();
      return g.denomTrace = p.denomTrace !== void 0 && p.denomTrace !== null ? u.DenomTrace.fromPartial(p.denomTrace) : void 0, g;
    }
  };
  function L() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomTracesRequest = {
    encode(p, g = f.Writer.create()) {
      return p.pagination !== void 0 && r.PageRequest.encode(p.pagination, g.uint32(10).fork()).ldelim(), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = L();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.pagination = r.PageRequest.decode(J, J.uint32());
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        pagination: (0, O.isSet)(p.pagination) ? r.PageRequest.fromJSON(p.pagination) : void 0
      };
    },
    toJSON(p) {
      const g = {};
      return p.pagination !== void 0 && (g.pagination = p.pagination ? r.PageRequest.toJSON(p.pagination) : void 0), g;
    },
    fromPartial(p) {
      const g = L();
      return g.pagination = p.pagination !== void 0 && p.pagination !== null ? r.PageRequest.fromPartial(p.pagination) : void 0, g;
    }
  };
  function M() {
    return {
      denomTraces: [],
      pagination: void 0
    };
  }
  e.QueryDenomTracesResponse = {
    encode(p, g = f.Writer.create()) {
      for (const J of p.denomTraces)
        u.DenomTrace.encode(J, g.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && r.PageResponse.encode(p.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = M();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.denomTraces.push(u.DenomTrace.decode(J, J.uint32()));
            break;
          case 2:
            I.pagination = r.PageResponse.decode(J, J.uint32());
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        denomTraces: Array.isArray(p == null ? void 0 : p.denomTraces) ? p.denomTraces.map((g) => u.DenomTrace.fromJSON(g)) : [],
        pagination: (0, O.isSet)(p.pagination) ? r.PageResponse.fromJSON(p.pagination) : void 0
      };
    },
    toJSON(p) {
      const g = {};
      return p.denomTraces ? g.denomTraces = p.denomTraces.map((J) => J ? u.DenomTrace.toJSON(J) : void 0) : g.denomTraces = [], p.pagination !== void 0 && (g.pagination = p.pagination ? r.PageResponse.toJSON(p.pagination) : void 0), g;
    },
    fromPartial(p) {
      var J;
      const g = M();
      return g.denomTraces = ((J = p.denomTraces) == null ? void 0 : J.map((B) => u.DenomTrace.fromPartial(B))) || [], g.pagination = p.pagination !== void 0 && p.pagination !== null ? r.PageResponse.fromPartial(p.pagination) : void 0, g;
    }
  };
  function V() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(p, g = f.Writer.create()) {
      return g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = V();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return V();
    }
  };
  function D() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(p, g = f.Writer.create()) {
      return p.params !== void 0 && u.Params.encode(p.params, g.uint32(10).fork()).ldelim(), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = D();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.params = u.Params.decode(J, J.uint32());
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        params: (0, O.isSet)(p.params) ? u.Params.fromJSON(p.params) : void 0
      };
    },
    toJSON(p) {
      const g = {};
      return p.params !== void 0 && (g.params = p.params ? u.Params.toJSON(p.params) : void 0), g;
    },
    fromPartial(p) {
      const g = D();
      return g.params = p.params !== void 0 && p.params !== null ? u.Params.fromPartial(p.params) : void 0, g;
    }
  };
  function b() {
    return {
      trace: ""
    };
  }
  e.QueryDenomHashRequest = {
    encode(p, g = f.Writer.create()) {
      return p.trace !== "" && g.uint32(10).string(p.trace), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = b();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.trace = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        trace: (0, O.isSet)(p.trace) ? String(p.trace) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.trace !== void 0 && (g.trace = p.trace), g;
    },
    fromPartial(p) {
      const g = b();
      return g.trace = p.trace ?? "", g;
    }
  };
  function h() {
    return {
      hash: ""
    };
  }
  e.QueryDenomHashResponse = {
    encode(p, g = f.Writer.create()) {
      return p.hash !== "" && g.uint32(10).string(p.hash), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = h();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.hash = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        hash: (0, O.isSet)(p.hash) ? String(p.hash) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.hash !== void 0 && (g.hash = p.hash), g;
    },
    fromPartial(p) {
      const g = h();
      return g.hash = p.hash ?? "", g;
    }
  };
  function S() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryEscrowAddressRequest = {
    encode(p, g = f.Writer.create()) {
      return p.portId !== "" && g.uint32(10).string(p.portId), p.channelId !== "" && g.uint32(18).string(p.channelId), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = S();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.portId = J.string();
            break;
          case 2:
            I.channelId = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        portId: (0, O.isSet)(p.portId) ? String(p.portId) : "",
        channelId: (0, O.isSet)(p.channelId) ? String(p.channelId) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.portId !== void 0 && (g.portId = p.portId), p.channelId !== void 0 && (g.channelId = p.channelId), g;
    },
    fromPartial(p) {
      const g = S();
      return g.portId = p.portId ?? "", g.channelId = p.channelId ?? "", g;
    }
  };
  function _() {
    return {
      escrowAddress: ""
    };
  }
  e.QueryEscrowAddressResponse = {
    encode(p, g = f.Writer.create()) {
      return p.escrowAddress !== "" && g.uint32(10).string(p.escrowAddress), g;
    },
    decode(p, g) {
      const J = p instanceof f.Reader ? p : new f.Reader(p);
      let B = g === void 0 ? J.len : J.pos + g;
      const I = _();
      for (; J.pos < B; ) {
        const Z = J.uint32();
        switch (Z >>> 3) {
          case 1:
            I.escrowAddress = J.string();
            break;
          default:
            J.skipType(Z & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        escrowAddress: (0, O.isSet)(p.escrowAddress) ? String(p.escrowAddress) : ""
      };
    },
    toJSON(p) {
      const g = {};
      return p.escrowAddress !== void 0 && (g.escrowAddress = p.escrowAddress), g;
    },
    fromPartial(p) {
      const g = _();
      return g.escrowAddress = p.escrowAddress ?? "", g;
    }
  };
  class d {
    constructor(g) {
      this.rpc = g, this.DenomTrace = this.DenomTrace.bind(this), this.DenomTraces = this.DenomTraces.bind(this), this.Params = this.Params.bind(this), this.DenomHash = this.DenomHash.bind(this), this.EscrowAddress = this.EscrowAddress.bind(this);
    }
    DenomTrace(g) {
      const J = e.QueryDenomTraceRequest.encode(g).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", J).then((I) => e.QueryDenomTraceResponse.decode(new f.Reader(I)));
    }
    DenomTraces(g = {
      pagination: void 0
    }) {
      const J = e.QueryDenomTracesRequest.encode(g).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", J).then((I) => e.QueryDenomTracesResponse.decode(new f.Reader(I)));
    }
    Params(g = {}) {
      const J = e.QueryParamsRequest.encode(g).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "Params", J).then((I) => e.QueryParamsResponse.decode(new f.Reader(I)));
    }
    DenomHash(g) {
      const J = e.QueryDenomHashRequest.encode(g).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", J).then((I) => e.QueryDenomHashResponse.decode(new f.Reader(I)));
    }
    EscrowAddress(g) {
      const J = e.QueryEscrowAddressRequest.encode(g).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", J).then((I) => e.QueryEscrowAddressResponse.decode(new f.Reader(I)));
    }
  }
  e.QueryClientImpl = d;
})(Cu);
var Iu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(o, P, m, R) {
    R === void 0 && (R = m);
    var N = Object.getOwnPropertyDescriptor(P, m);
    (!N || ("get" in N ? !P.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return P[m];
    } }), Object.defineProperty(o, R, N);
  } : function(o, P, m, R) {
    R === void 0 && (R = m), o[R] = P[m];
  }), c = G && G.__setModuleDefault || (Object.create ? function(o, P) {
    Object.defineProperty(o, "default", { enumerable: !0, value: P });
  } : function(o, P) {
    o.default = P;
  }), i = G && G.__importStar || function(o) {
    if (o && o.__esModule)
      return o;
    var P = {};
    if (o != null)
      for (var m in o)
        m !== "default" && Object.prototype.hasOwnProperty.call(o, m) && n(P, o, m);
    return c(P, o), P;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryNextSequenceReceiveResponse = e.QueryNextSequenceReceiveRequest = e.QueryUnreceivedAcksResponse = e.QueryUnreceivedAcksRequest = e.QueryUnreceivedPacketsResponse = e.QueryUnreceivedPacketsRequest = e.QueryPacketAcknowledgementsResponse = e.QueryPacketAcknowledgementsRequest = e.QueryPacketAcknowledgementResponse = e.QueryPacketAcknowledgementRequest = e.QueryPacketReceiptResponse = e.QueryPacketReceiptRequest = e.QueryPacketCommitmentsResponse = e.QueryPacketCommitmentsRequest = e.QueryPacketCommitmentResponse = e.QueryPacketCommitmentRequest = e.QueryChannelConsensusStateResponse = e.QueryChannelConsensusStateRequest = e.QueryChannelClientStateResponse = e.QueryChannelClientStateRequest = e.QueryConnectionChannelsResponse = e.QueryConnectionChannelsRequest = e.QueryChannelsResponse = e.QueryChannelsRequest = e.QueryChannelResponse = e.QueryChannelRequest = e.protobufPackage = void 0;
  const r = Re, u = ci, f = In, O = Se, A = oe, T = i(ie);
  e.protobufPackage = "ibc.core.channel.v1";
  function L() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = L();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), P;
    },
    fromPartial(o) {
      const P = L();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P;
    }
  };
  function M() {
    return {
      channel: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryChannelResponse = {
    encode(o, P = T.Writer.create()) {
      return o.channel !== void 0 && u.Channel.encode(o.channel, P.uint32(10).fork()).ldelim(), o.proof.length !== 0 && P.uint32(18).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = M();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.channel = u.Channel.decode(m, m.uint32());
            break;
          case 2:
            N.proof = m.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        channel: (0, A.isSet)(o.channel) ? u.Channel.fromJSON(o.channel) : void 0,
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.channel !== void 0 && (P.channel = o.channel ? u.Channel.toJSON(o.channel) : void 0), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = M();
      return P.channel = o.channel !== void 0 && o.channel !== null ? u.Channel.fromPartial(o.channel) : void 0, P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  function V() {
    return {
      pagination: void 0
    };
  }
  e.QueryChannelsRequest = {
    encode(o, P = T.Writer.create()) {
      return o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = V();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        pagination: (0, A.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = V();
      return P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function D() {
    return {
      channels: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryChannelsResponse = {
    encode(o, P = T.Writer.create()) {
      for (const m of o.channels)
        u.IdentifiedChannel.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), o.height !== void 0 && f.Height.encode(o.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = D();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.channels.push(u.IdentifiedChannel.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            N.height = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        channels: Array.isArray(o == null ? void 0 : o.channels) ? o.channels.map((P) => u.IdentifiedChannel.fromJSON(P)) : [],
        pagination: (0, A.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0,
        height: (0, A.isSet)(o.height) ? f.Height.fromJSON(o.height) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.channels ? P.channels = o.channels.map((m) => m ? u.IdentifiedChannel.toJSON(m) : void 0) : P.channels = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), o.height !== void 0 && (P.height = o.height ? f.Height.toJSON(o.height) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = D();
      return P.channels = ((m = o.channels) == null ? void 0 : m.map((R) => u.IdentifiedChannel.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P.height = o.height !== void 0 && o.height !== null ? f.Height.fromPartial(o.height) : void 0, P;
    }
  };
  function b() {
    return {
      connection: "",
      pagination: void 0
    };
  }
  e.QueryConnectionChannelsRequest = {
    encode(o, P = T.Writer.create()) {
      return o.connection !== "" && P.uint32(10).string(o.connection), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = b();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.connection = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        connection: (0, A.isSet)(o.connection) ? String(o.connection) : "",
        pagination: (0, A.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.connection !== void 0 && (P.connection = o.connection), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = b();
      return P.connection = o.connection ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function h() {
    return {
      channels: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryConnectionChannelsResponse = {
    encode(o, P = T.Writer.create()) {
      for (const m of o.channels)
        u.IdentifiedChannel.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), o.height !== void 0 && f.Height.encode(o.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = h();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.channels.push(u.IdentifiedChannel.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            N.height = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        channels: Array.isArray(o == null ? void 0 : o.channels) ? o.channels.map((P) => u.IdentifiedChannel.fromJSON(P)) : [],
        pagination: (0, A.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0,
        height: (0, A.isSet)(o.height) ? f.Height.fromJSON(o.height) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.channels ? P.channels = o.channels.map((m) => m ? u.IdentifiedChannel.toJSON(m) : void 0) : P.channels = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), o.height !== void 0 && (P.height = o.height ? f.Height.toJSON(o.height) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = h();
      return P.channels = ((m = o.channels) == null ? void 0 : m.map((R) => u.IdentifiedChannel.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P.height = o.height !== void 0 && o.height !== null ? f.Height.fromPartial(o.height) : void 0, P;
    }
  };
  function S() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelClientStateRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = S();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), P;
    },
    fromPartial(o) {
      const P = S();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P;
    }
  };
  function _() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryChannelClientStateResponse = {
    encode(o, P = T.Writer.create()) {
      return o.identifiedClientState !== void 0 && f.IdentifiedClientState.encode(o.identifiedClientState, P.uint32(10).fork()).ldelim(), o.proof.length !== 0 && P.uint32(18).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = _();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.identifiedClientState = f.IdentifiedClientState.decode(m, m.uint32());
            break;
          case 2:
            N.proof = m.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        identifiedClientState: (0, A.isSet)(o.identifiedClientState) ? f.IdentifiedClientState.fromJSON(o.identifiedClientState) : void 0,
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.identifiedClientState !== void 0 && (P.identifiedClientState = o.identifiedClientState ? f.IdentifiedClientState.toJSON(o.identifiedClientState) : void 0), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = _();
      return P.identifiedClientState = o.identifiedClientState !== void 0 && o.identifiedClientState !== null ? f.IdentifiedClientState.fromPartial(o.identifiedClientState) : void 0, P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  function d() {
    return {
      portId: "",
      channelId: "",
      revisionNumber: A.Long.UZERO,
      revisionHeight: A.Long.UZERO
    };
  }
  e.QueryChannelConsensusStateRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), o.revisionNumber.isZero() || P.uint32(24).uint64(o.revisionNumber), o.revisionHeight.isZero() || P.uint32(32).uint64(o.revisionHeight), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = d();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            N.revisionNumber = m.uint64();
            break;
          case 4:
            N.revisionHeight = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        revisionNumber: (0, A.isSet)(o.revisionNumber) ? A.Long.fromValue(o.revisionNumber) : A.Long.UZERO,
        revisionHeight: (0, A.isSet)(o.revisionHeight) ? A.Long.fromValue(o.revisionHeight) : A.Long.UZERO
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.revisionNumber !== void 0 && (P.revisionNumber = (o.revisionNumber || A.Long.UZERO).toString()), o.revisionHeight !== void 0 && (P.revisionHeight = (o.revisionHeight || A.Long.UZERO).toString()), P;
    },
    fromPartial(o) {
      const P = d();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.revisionNumber = o.revisionNumber !== void 0 && o.revisionNumber !== null ? A.Long.fromValue(o.revisionNumber) : A.Long.UZERO, P.revisionHeight = o.revisionHeight !== void 0 && o.revisionHeight !== null ? A.Long.fromValue(o.revisionHeight) : A.Long.UZERO, P;
    }
  };
  function p() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryChannelConsensusStateResponse = {
    encode(o, P = T.Writer.create()) {
      return o.consensusState !== void 0 && O.Any.encode(o.consensusState, P.uint32(10).fork()).ldelim(), o.clientId !== "" && P.uint32(18).string(o.clientId), o.proof.length !== 0 && P.uint32(26).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(34).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = p();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.consensusState = O.Any.decode(m, m.uint32());
            break;
          case 2:
            N.clientId = m.string();
            break;
          case 3:
            N.proof = m.bytes();
            break;
          case 4:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        consensusState: (0, A.isSet)(o.consensusState) ? O.Any.fromJSON(o.consensusState) : void 0,
        clientId: (0, A.isSet)(o.clientId) ? String(o.clientId) : "",
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.consensusState !== void 0 && (P.consensusState = o.consensusState ? O.Any.toJSON(o.consensusState) : void 0), o.clientId !== void 0 && (P.clientId = o.clientId), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = p();
      return P.consensusState = o.consensusState !== void 0 && o.consensusState !== null ? O.Any.fromPartial(o.consensusState) : void 0, P.clientId = o.clientId ?? "", P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  function g() {
    return {
      portId: "",
      channelId: "",
      sequence: A.Long.UZERO
    };
  }
  e.QueryPacketCommitmentRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), o.sequence.isZero() || P.uint32(24).uint64(o.sequence), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = g();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            N.sequence = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        sequence: (0, A.isSet)(o.sequence) ? A.Long.fromValue(o.sequence) : A.Long.UZERO
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.sequence !== void 0 && (P.sequence = (o.sequence || A.Long.UZERO).toString()), P;
    },
    fromPartial(o) {
      const P = g();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.sequence = o.sequence !== void 0 && o.sequence !== null ? A.Long.fromValue(o.sequence) : A.Long.UZERO, P;
    }
  };
  function J() {
    return {
      commitment: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryPacketCommitmentResponse = {
    encode(o, P = T.Writer.create()) {
      return o.commitment.length !== 0 && P.uint32(10).bytes(o.commitment), o.proof.length !== 0 && P.uint32(18).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = J();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.commitment = m.bytes();
            break;
          case 2:
            N.proof = m.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        commitment: (0, A.isSet)(o.commitment) ? (0, A.bytesFromBase64)(o.commitment) : new Uint8Array(),
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.commitment !== void 0 && (P.commitment = (0, A.base64FromBytes)(o.commitment !== void 0 ? o.commitment : new Uint8Array())), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = J();
      return P.commitment = o.commitment ?? new Uint8Array(), P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  function B() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0
    };
  }
  e.QueryPacketCommitmentsRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = B();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        pagination: (0, A.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = B();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function I() {
    return {
      commitments: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryPacketCommitmentsResponse = {
    encode(o, P = T.Writer.create()) {
      for (const m of o.commitments)
        u.PacketState.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), o.height !== void 0 && f.Height.encode(o.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = I();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.commitments.push(u.PacketState.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            N.height = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        commitments: Array.isArray(o == null ? void 0 : o.commitments) ? o.commitments.map((P) => u.PacketState.fromJSON(P)) : [],
        pagination: (0, A.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0,
        height: (0, A.isSet)(o.height) ? f.Height.fromJSON(o.height) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.commitments ? P.commitments = o.commitments.map((m) => m ? u.PacketState.toJSON(m) : void 0) : P.commitments = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), o.height !== void 0 && (P.height = o.height ? f.Height.toJSON(o.height) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = I();
      return P.commitments = ((m = o.commitments) == null ? void 0 : m.map((R) => u.PacketState.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P.height = o.height !== void 0 && o.height !== null ? f.Height.fromPartial(o.height) : void 0, P;
    }
  };
  function Z() {
    return {
      portId: "",
      channelId: "",
      sequence: A.Long.UZERO
    };
  }
  e.QueryPacketReceiptRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), o.sequence.isZero() || P.uint32(24).uint64(o.sequence), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = Z();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            N.sequence = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        sequence: (0, A.isSet)(o.sequence) ? A.Long.fromValue(o.sequence) : A.Long.UZERO
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.sequence !== void 0 && (P.sequence = (o.sequence || A.Long.UZERO).toString()), P;
    },
    fromPartial(o) {
      const P = Z();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.sequence = o.sequence !== void 0 && o.sequence !== null ? A.Long.fromValue(o.sequence) : A.Long.UZERO, P;
    }
  };
  function t() {
    return {
      received: !1,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryPacketReceiptResponse = {
    encode(o, P = T.Writer.create()) {
      return o.received === !0 && P.uint32(16).bool(o.received), o.proof.length !== 0 && P.uint32(26).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(34).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = t();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 2:
            N.received = m.bool();
            break;
          case 3:
            N.proof = m.bytes();
            break;
          case 4:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        received: (0, A.isSet)(o.received) ? !!o.received : !1,
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.received !== void 0 && (P.received = o.received), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = t();
      return P.received = o.received ?? !1, P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  function y() {
    return {
      portId: "",
      channelId: "",
      sequence: A.Long.UZERO
    };
  }
  e.QueryPacketAcknowledgementRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), o.sequence.isZero() || P.uint32(24).uint64(o.sequence), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = y();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            N.sequence = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        sequence: (0, A.isSet)(o.sequence) ? A.Long.fromValue(o.sequence) : A.Long.UZERO
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.sequence !== void 0 && (P.sequence = (o.sequence || A.Long.UZERO).toString()), P;
    },
    fromPartial(o) {
      const P = y();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.sequence = o.sequence !== void 0 && o.sequence !== null ? A.Long.fromValue(o.sequence) : A.Long.UZERO, P;
    }
  };
  function E() {
    return {
      acknowledgement: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryPacketAcknowledgementResponse = {
    encode(o, P = T.Writer.create()) {
      return o.acknowledgement.length !== 0 && P.uint32(10).bytes(o.acknowledgement), o.proof.length !== 0 && P.uint32(18).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = E();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.acknowledgement = m.bytes();
            break;
          case 2:
            N.proof = m.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        acknowledgement: (0, A.isSet)(o.acknowledgement) ? (0, A.bytesFromBase64)(o.acknowledgement) : new Uint8Array(),
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.acknowledgement !== void 0 && (P.acknowledgement = (0, A.base64FromBytes)(o.acknowledgement !== void 0 ? o.acknowledgement : new Uint8Array())), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = E();
      return P.acknowledgement = o.acknowledgement ?? new Uint8Array(), P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  function H() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0,
      packetCommitmentSequences: []
    };
  }
  e.QueryPacketAcknowledgementsRequest = {
    encode(o, P = T.Writer.create()) {
      o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(26).fork()).ldelim(), P.uint32(34).fork();
      for (const m of o.packetCommitmentSequences)
        P.uint64(m);
      return P.ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = H();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          case 4:
            if ((Q & 7) === 2) {
              const K = m.uint32() + m.pos;
              for (; m.pos < K; )
                N.packetCommitmentSequences.push(m.uint64());
            } else
              N.packetCommitmentSequences.push(m.uint64());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        pagination: (0, A.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0,
        packetCommitmentSequences: Array.isArray(o == null ? void 0 : o.packetCommitmentSequences) ? o.packetCommitmentSequences.map((P) => A.Long.fromValue(P)) : []
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), o.packetCommitmentSequences ? P.packetCommitmentSequences = o.packetCommitmentSequences.map((m) => (m || A.Long.UZERO).toString()) : P.packetCommitmentSequences = [], P;
    },
    fromPartial(o) {
      var m;
      const P = H();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P.packetCommitmentSequences = ((m = o.packetCommitmentSequences) == null ? void 0 : m.map((R) => A.Long.fromValue(R))) || [], P;
    }
  };
  function a() {
    return {
      acknowledgements: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryPacketAcknowledgementsResponse = {
    encode(o, P = T.Writer.create()) {
      for (const m of o.acknowledgements)
        u.PacketState.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), o.height !== void 0 && f.Height.encode(o.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = a();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.acknowledgements.push(u.PacketState.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            N.height = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        acknowledgements: Array.isArray(o == null ? void 0 : o.acknowledgements) ? o.acknowledgements.map((P) => u.PacketState.fromJSON(P)) : [],
        pagination: (0, A.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0,
        height: (0, A.isSet)(o.height) ? f.Height.fromJSON(o.height) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.acknowledgements ? P.acknowledgements = o.acknowledgements.map((m) => m ? u.PacketState.toJSON(m) : void 0) : P.acknowledgements = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), o.height !== void 0 && (P.height = o.height ? f.Height.toJSON(o.height) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = a();
      return P.acknowledgements = ((m = o.acknowledgements) == null ? void 0 : m.map((R) => u.PacketState.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P.height = o.height !== void 0 && o.height !== null ? f.Height.fromPartial(o.height) : void 0, P;
    }
  };
  function l() {
    return {
      portId: "",
      channelId: "",
      packetCommitmentSequences: []
    };
  }
  e.QueryUnreceivedPacketsRequest = {
    encode(o, P = T.Writer.create()) {
      o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), P.uint32(26).fork();
      for (const m of o.packetCommitmentSequences)
        P.uint64(m);
      return P.ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = l();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            if ((Q & 7) === 2) {
              const K = m.uint32() + m.pos;
              for (; m.pos < K; )
                N.packetCommitmentSequences.push(m.uint64());
            } else
              N.packetCommitmentSequences.push(m.uint64());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        packetCommitmentSequences: Array.isArray(o == null ? void 0 : o.packetCommitmentSequences) ? o.packetCommitmentSequences.map((P) => A.Long.fromValue(P)) : []
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.packetCommitmentSequences ? P.packetCommitmentSequences = o.packetCommitmentSequences.map((m) => (m || A.Long.UZERO).toString()) : P.packetCommitmentSequences = [], P;
    },
    fromPartial(o) {
      var m;
      const P = l();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.packetCommitmentSequences = ((m = o.packetCommitmentSequences) == null ? void 0 : m.map((R) => A.Long.fromValue(R))) || [], P;
    }
  };
  function C() {
    return {
      sequences: [],
      height: void 0
    };
  }
  e.QueryUnreceivedPacketsResponse = {
    encode(o, P = T.Writer.create()) {
      P.uint32(10).fork();
      for (const m of o.sequences)
        P.uint64(m);
      return P.ldelim(), o.height !== void 0 && f.Height.encode(o.height, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = C();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            if ((Q & 7) === 2) {
              const K = m.uint32() + m.pos;
              for (; m.pos < K; )
                N.sequences.push(m.uint64());
            } else
              N.sequences.push(m.uint64());
            break;
          case 2:
            N.height = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        sequences: Array.isArray(o == null ? void 0 : o.sequences) ? o.sequences.map((P) => A.Long.fromValue(P)) : [],
        height: (0, A.isSet)(o.height) ? f.Height.fromJSON(o.height) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.sequences ? P.sequences = o.sequences.map((m) => (m || A.Long.UZERO).toString()) : P.sequences = [], o.height !== void 0 && (P.height = o.height ? f.Height.toJSON(o.height) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = C();
      return P.sequences = ((m = o.sequences) == null ? void 0 : m.map((R) => A.Long.fromValue(R))) || [], P.height = o.height !== void 0 && o.height !== null ? f.Height.fromPartial(o.height) : void 0, P;
    }
  };
  function v() {
    return {
      portId: "",
      channelId: "",
      packetAckSequences: []
    };
  }
  e.QueryUnreceivedAcksRequest = {
    encode(o, P = T.Writer.create()) {
      o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), P.uint32(26).fork();
      for (const m of o.packetAckSequences)
        P.uint64(m);
      return P.ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = v();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          case 3:
            if ((Q & 7) === 2) {
              const K = m.uint32() + m.pos;
              for (; m.pos < K; )
                N.packetAckSequences.push(m.uint64());
            } else
              N.packetAckSequences.push(m.uint64());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : "",
        packetAckSequences: Array.isArray(o == null ? void 0 : o.packetAckSequences) ? o.packetAckSequences.map((P) => A.Long.fromValue(P)) : []
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), o.packetAckSequences ? P.packetAckSequences = o.packetAckSequences.map((m) => (m || A.Long.UZERO).toString()) : P.packetAckSequences = [], P;
    },
    fromPartial(o) {
      var m;
      const P = v();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P.packetAckSequences = ((m = o.packetAckSequences) == null ? void 0 : m.map((R) => A.Long.fromValue(R))) || [], P;
    }
  };
  function k() {
    return {
      sequences: [],
      height: void 0
    };
  }
  e.QueryUnreceivedAcksResponse = {
    encode(o, P = T.Writer.create()) {
      P.uint32(10).fork();
      for (const m of o.sequences)
        P.uint64(m);
      return P.ldelim(), o.height !== void 0 && f.Height.encode(o.height, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = k();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            if ((Q & 7) === 2) {
              const K = m.uint32() + m.pos;
              for (; m.pos < K; )
                N.sequences.push(m.uint64());
            } else
              N.sequences.push(m.uint64());
            break;
          case 2:
            N.height = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        sequences: Array.isArray(o == null ? void 0 : o.sequences) ? o.sequences.map((P) => A.Long.fromValue(P)) : [],
        height: (0, A.isSet)(o.height) ? f.Height.fromJSON(o.height) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.sequences ? P.sequences = o.sequences.map((m) => (m || A.Long.UZERO).toString()) : P.sequences = [], o.height !== void 0 && (P.height = o.height ? f.Height.toJSON(o.height) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = k();
      return P.sequences = ((m = o.sequences) == null ? void 0 : m.map((R) => A.Long.fromValue(R))) || [], P.height = o.height !== void 0 && o.height !== null ? f.Height.fromPartial(o.height) : void 0, P;
    }
  };
  function U() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryNextSequenceReceiveRequest = {
    encode(o, P = T.Writer.create()) {
      return o.portId !== "" && P.uint32(10).string(o.portId), o.channelId !== "" && P.uint32(18).string(o.channelId), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = U();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.portId = m.string();
            break;
          case 2:
            N.channelId = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        portId: (0, A.isSet)(o.portId) ? String(o.portId) : "",
        channelId: (0, A.isSet)(o.channelId) ? String(o.channelId) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.portId !== void 0 && (P.portId = o.portId), o.channelId !== void 0 && (P.channelId = o.channelId), P;
    },
    fromPartial(o) {
      const P = U();
      return P.portId = o.portId ?? "", P.channelId = o.channelId ?? "", P;
    }
  };
  function F() {
    return {
      nextSequenceReceive: A.Long.UZERO,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryNextSequenceReceiveResponse = {
    encode(o, P = T.Writer.create()) {
      return o.nextSequenceReceive.isZero() || P.uint32(8).uint64(o.nextSequenceReceive), o.proof.length !== 0 && P.uint32(18).bytes(o.proof), o.proofHeight !== void 0 && f.Height.encode(o.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof T.Reader ? o : new T.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = F();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.nextSequenceReceive = m.uint64();
            break;
          case 2:
            N.proof = m.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        nextSequenceReceive: (0, A.isSet)(o.nextSequenceReceive) ? A.Long.fromValue(o.nextSequenceReceive) : A.Long.UZERO,
        proof: (0, A.isSet)(o.proof) ? (0, A.bytesFromBase64)(o.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(o.proofHeight) ? f.Height.fromJSON(o.proofHeight) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.nextSequenceReceive !== void 0 && (P.nextSequenceReceive = (o.nextSequenceReceive || A.Long.UZERO).toString()), o.proof !== void 0 && (P.proof = (0, A.base64FromBytes)(o.proof !== void 0 ? o.proof : new Uint8Array())), o.proofHeight !== void 0 && (P.proofHeight = o.proofHeight ? f.Height.toJSON(o.proofHeight) : void 0), P;
    },
    fromPartial(o) {
      const P = F();
      return P.nextSequenceReceive = o.nextSequenceReceive !== void 0 && o.nextSequenceReceive !== null ? A.Long.fromValue(o.nextSequenceReceive) : A.Long.UZERO, P.proof = o.proof ?? new Uint8Array(), P.proofHeight = o.proofHeight !== void 0 && o.proofHeight !== null ? f.Height.fromPartial(o.proofHeight) : void 0, P;
    }
  };
  class q {
    constructor(P) {
      this.rpc = P, this.Channel = this.Channel.bind(this), this.Channels = this.Channels.bind(this), this.ConnectionChannels = this.ConnectionChannels.bind(this), this.ChannelClientState = this.ChannelClientState.bind(this), this.ChannelConsensusState = this.ChannelConsensusState.bind(this), this.PacketCommitment = this.PacketCommitment.bind(this), this.PacketCommitments = this.PacketCommitments.bind(this), this.PacketReceipt = this.PacketReceipt.bind(this), this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this), this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this), this.UnreceivedPackets = this.UnreceivedPackets.bind(this), this.UnreceivedAcks = this.UnreceivedAcks.bind(this), this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
    }
    Channel(P) {
      const m = e.QueryChannelRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channel", m).then((N) => e.QueryChannelResponse.decode(new T.Reader(N)));
    }
    Channels(P = {
      pagination: void 0
    }) {
      const m = e.QueryChannelsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channels", m).then((N) => e.QueryChannelsResponse.decode(new T.Reader(N)));
    }
    ConnectionChannels(P) {
      const m = e.QueryConnectionChannelsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", m).then((N) => e.QueryConnectionChannelsResponse.decode(new T.Reader(N)));
    }
    ChannelClientState(P) {
      const m = e.QueryChannelClientStateRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", m).then((N) => e.QueryChannelClientStateResponse.decode(new T.Reader(N)));
    }
    ChannelConsensusState(P) {
      const m = e.QueryChannelConsensusStateRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", m).then((N) => e.QueryChannelConsensusStateResponse.decode(new T.Reader(N)));
    }
    PacketCommitment(P) {
      const m = e.QueryPacketCommitmentRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", m).then((N) => e.QueryPacketCommitmentResponse.decode(new T.Reader(N)));
    }
    PacketCommitments(P) {
      const m = e.QueryPacketCommitmentsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", m).then((N) => e.QueryPacketCommitmentsResponse.decode(new T.Reader(N)));
    }
    PacketReceipt(P) {
      const m = e.QueryPacketReceiptRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", m).then((N) => e.QueryPacketReceiptResponse.decode(new T.Reader(N)));
    }
    PacketAcknowledgement(P) {
      const m = e.QueryPacketAcknowledgementRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", m).then((N) => e.QueryPacketAcknowledgementResponse.decode(new T.Reader(N)));
    }
    PacketAcknowledgements(P) {
      const m = e.QueryPacketAcknowledgementsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", m).then((N) => e.QueryPacketAcknowledgementsResponse.decode(new T.Reader(N)));
    }
    UnreceivedPackets(P) {
      const m = e.QueryUnreceivedPacketsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", m).then((N) => e.QueryUnreceivedPacketsResponse.decode(new T.Reader(N)));
    }
    UnreceivedAcks(P) {
      const m = e.QueryUnreceivedAcksRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", m).then((N) => e.QueryUnreceivedAcksResponse.decode(new T.Reader(N)));
    }
    NextSequenceReceive(P) {
      const m = e.QueryNextSequenceReceiveRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", m).then((N) => e.QueryNextSequenceReceiveResponse.decode(new T.Reader(N)));
    }
  }
  e.QueryClientImpl = q;
})(Iu);
var wu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(H, a, l, C) {
    C === void 0 && (C = l);
    var v = Object.getOwnPropertyDescriptor(a, l);
    (!v || ("get" in v ? !a.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return a[l];
    } }), Object.defineProperty(H, C, v);
  } : function(H, a, l, C) {
    C === void 0 && (C = l), H[C] = a[l];
  }), c = G && G.__setModuleDefault || (Object.create ? function(H, a) {
    Object.defineProperty(H, "default", { enumerable: !0, value: a });
  } : function(H, a) {
    H.default = a;
  }), i = G && G.__importStar || function(H) {
    if (H && H.__esModule)
      return H;
    var a = {};
    if (H != null)
      for (var l in H)
        l !== "default" && Object.prototype.hasOwnProperty.call(H, l) && n(a, H, l);
    return c(a, H), a;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryUpgradedConsensusStateResponse = e.QueryUpgradedConsensusStateRequest = e.QueryUpgradedClientStateResponse = e.QueryUpgradedClientStateRequest = e.QueryClientParamsResponse = e.QueryClientParamsRequest = e.QueryClientStatusResponse = e.QueryClientStatusRequest = e.QueryConsensusStateHeightsResponse = e.QueryConsensusStateHeightsRequest = e.QueryConsensusStatesResponse = e.QueryConsensusStatesRequest = e.QueryConsensusStateResponse = e.QueryConsensusStateRequest = e.QueryClientStatesResponse = e.QueryClientStatesRequest = e.QueryClientStateResponse = e.QueryClientStateRequest = e.protobufPackage = void 0;
  const r = Re, u = Se, f = In, O = oe, A = i(ie);
  e.protobufPackage = "ibc.core.client.v1";
  function T() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStateRequest = {
    encode(H, a = A.Writer.create()) {
      return H.clientId !== "" && a.uint32(10).string(H.clientId), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = T();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientId = l.string();
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientId: (0, O.isSet)(H.clientId) ? String(H.clientId) : ""
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientId !== void 0 && (a.clientId = H.clientId), a;
    },
    fromPartial(H) {
      const a = T();
      return a.clientId = H.clientId ?? "", a;
    }
  };
  function L() {
    return {
      clientState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryClientStateResponse = {
    encode(H, a = A.Writer.create()) {
      return H.clientState !== void 0 && u.Any.encode(H.clientState, a.uint32(10).fork()).ldelim(), H.proof.length !== 0 && a.uint32(18).bytes(H.proof), H.proofHeight !== void 0 && f.Height.encode(H.proofHeight, a.uint32(26).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = L();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientState = u.Any.decode(l, l.uint32());
            break;
          case 2:
            v.proof = l.bytes();
            break;
          case 3:
            v.proofHeight = f.Height.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientState: (0, O.isSet)(H.clientState) ? u.Any.fromJSON(H.clientState) : void 0,
        proof: (0, O.isSet)(H.proof) ? (0, O.bytesFromBase64)(H.proof) : new Uint8Array(),
        proofHeight: (0, O.isSet)(H.proofHeight) ? f.Height.fromJSON(H.proofHeight) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientState !== void 0 && (a.clientState = H.clientState ? u.Any.toJSON(H.clientState) : void 0), H.proof !== void 0 && (a.proof = (0, O.base64FromBytes)(H.proof !== void 0 ? H.proof : new Uint8Array())), H.proofHeight !== void 0 && (a.proofHeight = H.proofHeight ? f.Height.toJSON(H.proofHeight) : void 0), a;
    },
    fromPartial(H) {
      const a = L();
      return a.clientState = H.clientState !== void 0 && H.clientState !== null ? u.Any.fromPartial(H.clientState) : void 0, a.proof = H.proof ?? new Uint8Array(), a.proofHeight = H.proofHeight !== void 0 && H.proofHeight !== null ? f.Height.fromPartial(H.proofHeight) : void 0, a;
    }
  };
  function M() {
    return {
      pagination: void 0
    };
  }
  e.QueryClientStatesRequest = {
    encode(H, a = A.Writer.create()) {
      return H.pagination !== void 0 && r.PageRequest.encode(H.pagination, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = M();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.pagination = r.PageRequest.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        pagination: (0, O.isSet)(H.pagination) ? r.PageRequest.fromJSON(H.pagination) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      const a = M();
      return a.pagination = H.pagination !== void 0 && H.pagination !== null ? r.PageRequest.fromPartial(H.pagination) : void 0, a;
    }
  };
  function V() {
    return {
      clientStates: [],
      pagination: void 0
    };
  }
  e.QueryClientStatesResponse = {
    encode(H, a = A.Writer.create()) {
      for (const l of H.clientStates)
        f.IdentifiedClientState.encode(l, a.uint32(10).fork()).ldelim();
      return H.pagination !== void 0 && r.PageResponse.encode(H.pagination, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = V();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientStates.push(f.IdentifiedClientState.decode(l, l.uint32()));
            break;
          case 2:
            v.pagination = r.PageResponse.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientStates: Array.isArray(H == null ? void 0 : H.clientStates) ? H.clientStates.map((a) => f.IdentifiedClientState.fromJSON(a)) : [],
        pagination: (0, O.isSet)(H.pagination) ? r.PageResponse.fromJSON(H.pagination) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientStates ? a.clientStates = H.clientStates.map((l) => l ? f.IdentifiedClientState.toJSON(l) : void 0) : a.clientStates = [], H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      var l;
      const a = V();
      return a.clientStates = ((l = H.clientStates) == null ? void 0 : l.map((C) => f.IdentifiedClientState.fromPartial(C))) || [], a.pagination = H.pagination !== void 0 && H.pagination !== null ? r.PageResponse.fromPartial(H.pagination) : void 0, a;
    }
  };
  function D() {
    return {
      clientId: "",
      revisionNumber: O.Long.UZERO,
      revisionHeight: O.Long.UZERO,
      latestHeight: !1
    };
  }
  e.QueryConsensusStateRequest = {
    encode(H, a = A.Writer.create()) {
      return H.clientId !== "" && a.uint32(10).string(H.clientId), H.revisionNumber.isZero() || a.uint32(16).uint64(H.revisionNumber), H.revisionHeight.isZero() || a.uint32(24).uint64(H.revisionHeight), H.latestHeight === !0 && a.uint32(32).bool(H.latestHeight), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = D();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientId = l.string();
            break;
          case 2:
            v.revisionNumber = l.uint64();
            break;
          case 3:
            v.revisionHeight = l.uint64();
            break;
          case 4:
            v.latestHeight = l.bool();
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientId: (0, O.isSet)(H.clientId) ? String(H.clientId) : "",
        revisionNumber: (0, O.isSet)(H.revisionNumber) ? O.Long.fromValue(H.revisionNumber) : O.Long.UZERO,
        revisionHeight: (0, O.isSet)(H.revisionHeight) ? O.Long.fromValue(H.revisionHeight) : O.Long.UZERO,
        latestHeight: (0, O.isSet)(H.latestHeight) ? !!H.latestHeight : !1
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientId !== void 0 && (a.clientId = H.clientId), H.revisionNumber !== void 0 && (a.revisionNumber = (H.revisionNumber || O.Long.UZERO).toString()), H.revisionHeight !== void 0 && (a.revisionHeight = (H.revisionHeight || O.Long.UZERO).toString()), H.latestHeight !== void 0 && (a.latestHeight = H.latestHeight), a;
    },
    fromPartial(H) {
      const a = D();
      return a.clientId = H.clientId ?? "", a.revisionNumber = H.revisionNumber !== void 0 && H.revisionNumber !== null ? O.Long.fromValue(H.revisionNumber) : O.Long.UZERO, a.revisionHeight = H.revisionHeight !== void 0 && H.revisionHeight !== null ? O.Long.fromValue(H.revisionHeight) : O.Long.UZERO, a.latestHeight = H.latestHeight ?? !1, a;
    }
  };
  function b() {
    return {
      consensusState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConsensusStateResponse = {
    encode(H, a = A.Writer.create()) {
      return H.consensusState !== void 0 && u.Any.encode(H.consensusState, a.uint32(10).fork()).ldelim(), H.proof.length !== 0 && a.uint32(18).bytes(H.proof), H.proofHeight !== void 0 && f.Height.encode(H.proofHeight, a.uint32(26).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = b();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.consensusState = u.Any.decode(l, l.uint32());
            break;
          case 2:
            v.proof = l.bytes();
            break;
          case 3:
            v.proofHeight = f.Height.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        consensusState: (0, O.isSet)(H.consensusState) ? u.Any.fromJSON(H.consensusState) : void 0,
        proof: (0, O.isSet)(H.proof) ? (0, O.bytesFromBase64)(H.proof) : new Uint8Array(),
        proofHeight: (0, O.isSet)(H.proofHeight) ? f.Height.fromJSON(H.proofHeight) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.consensusState !== void 0 && (a.consensusState = H.consensusState ? u.Any.toJSON(H.consensusState) : void 0), H.proof !== void 0 && (a.proof = (0, O.base64FromBytes)(H.proof !== void 0 ? H.proof : new Uint8Array())), H.proofHeight !== void 0 && (a.proofHeight = H.proofHeight ? f.Height.toJSON(H.proofHeight) : void 0), a;
    },
    fromPartial(H) {
      const a = b();
      return a.consensusState = H.consensusState !== void 0 && H.consensusState !== null ? u.Any.fromPartial(H.consensusState) : void 0, a.proof = H.proof ?? new Uint8Array(), a.proofHeight = H.proofHeight !== void 0 && H.proofHeight !== null ? f.Height.fromPartial(H.proofHeight) : void 0, a;
    }
  };
  function h() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStatesRequest = {
    encode(H, a = A.Writer.create()) {
      return H.clientId !== "" && a.uint32(10).string(H.clientId), H.pagination !== void 0 && r.PageRequest.encode(H.pagination, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = h();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientId = l.string();
            break;
          case 2:
            v.pagination = r.PageRequest.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientId: (0, O.isSet)(H.clientId) ? String(H.clientId) : "",
        pagination: (0, O.isSet)(H.pagination) ? r.PageRequest.fromJSON(H.pagination) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientId !== void 0 && (a.clientId = H.clientId), H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      const a = h();
      return a.clientId = H.clientId ?? "", a.pagination = H.pagination !== void 0 && H.pagination !== null ? r.PageRequest.fromPartial(H.pagination) : void 0, a;
    }
  };
  function S() {
    return {
      consensusStates: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStatesResponse = {
    encode(H, a = A.Writer.create()) {
      for (const l of H.consensusStates)
        f.ConsensusStateWithHeight.encode(l, a.uint32(10).fork()).ldelim();
      return H.pagination !== void 0 && r.PageResponse.encode(H.pagination, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = S();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.consensusStates.push(f.ConsensusStateWithHeight.decode(l, l.uint32()));
            break;
          case 2:
            v.pagination = r.PageResponse.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        consensusStates: Array.isArray(H == null ? void 0 : H.consensusStates) ? H.consensusStates.map((a) => f.ConsensusStateWithHeight.fromJSON(a)) : [],
        pagination: (0, O.isSet)(H.pagination) ? r.PageResponse.fromJSON(H.pagination) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.consensusStates ? a.consensusStates = H.consensusStates.map((l) => l ? f.ConsensusStateWithHeight.toJSON(l) : void 0) : a.consensusStates = [], H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      var l;
      const a = S();
      return a.consensusStates = ((l = H.consensusStates) == null ? void 0 : l.map((C) => f.ConsensusStateWithHeight.fromPartial(C))) || [], a.pagination = H.pagination !== void 0 && H.pagination !== null ? r.PageResponse.fromPartial(H.pagination) : void 0, a;
    }
  };
  function _() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsRequest = {
    encode(H, a = A.Writer.create()) {
      return H.clientId !== "" && a.uint32(10).string(H.clientId), H.pagination !== void 0 && r.PageRequest.encode(H.pagination, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = _();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientId = l.string();
            break;
          case 2:
            v.pagination = r.PageRequest.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientId: (0, O.isSet)(H.clientId) ? String(H.clientId) : "",
        pagination: (0, O.isSet)(H.pagination) ? r.PageRequest.fromJSON(H.pagination) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientId !== void 0 && (a.clientId = H.clientId), H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      const a = _();
      return a.clientId = H.clientId ?? "", a.pagination = H.pagination !== void 0 && H.pagination !== null ? r.PageRequest.fromPartial(H.pagination) : void 0, a;
    }
  };
  function d() {
    return {
      consensusStateHeights: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsResponse = {
    encode(H, a = A.Writer.create()) {
      for (const l of H.consensusStateHeights)
        f.Height.encode(l, a.uint32(10).fork()).ldelim();
      return H.pagination !== void 0 && r.PageResponse.encode(H.pagination, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = d();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.consensusStateHeights.push(f.Height.decode(l, l.uint32()));
            break;
          case 2:
            v.pagination = r.PageResponse.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        consensusStateHeights: Array.isArray(H == null ? void 0 : H.consensusStateHeights) ? H.consensusStateHeights.map((a) => f.Height.fromJSON(a)) : [],
        pagination: (0, O.isSet)(H.pagination) ? r.PageResponse.fromJSON(H.pagination) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.consensusStateHeights ? a.consensusStateHeights = H.consensusStateHeights.map((l) => l ? f.Height.toJSON(l) : void 0) : a.consensusStateHeights = [], H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      var l;
      const a = d();
      return a.consensusStateHeights = ((l = H.consensusStateHeights) == null ? void 0 : l.map((C) => f.Height.fromPartial(C))) || [], a.pagination = H.pagination !== void 0 && H.pagination !== null ? r.PageResponse.fromPartial(H.pagination) : void 0, a;
    }
  };
  function p() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStatusRequest = {
    encode(H, a = A.Writer.create()) {
      return H.clientId !== "" && a.uint32(10).string(H.clientId), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = p();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.clientId = l.string();
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        clientId: (0, O.isSet)(H.clientId) ? String(H.clientId) : ""
      };
    },
    toJSON(H) {
      const a = {};
      return H.clientId !== void 0 && (a.clientId = H.clientId), a;
    },
    fromPartial(H) {
      const a = p();
      return a.clientId = H.clientId ?? "", a;
    }
  };
  function g() {
    return {
      status: ""
    };
  }
  e.QueryClientStatusResponse = {
    encode(H, a = A.Writer.create()) {
      return H.status !== "" && a.uint32(10).string(H.status), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = g();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.status = l.string();
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        status: (0, O.isSet)(H.status) ? String(H.status) : ""
      };
    },
    toJSON(H) {
      const a = {};
      return H.status !== void 0 && (a.status = H.status), a;
    },
    fromPartial(H) {
      const a = g();
      return a.status = H.status ?? "", a;
    }
  };
  function J() {
    return {};
  }
  e.QueryClientParamsRequest = {
    encode(H, a = A.Writer.create()) {
      return a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = J();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {};
    },
    toJSON(H) {
      return {};
    },
    fromPartial(H) {
      return J();
    }
  };
  function B() {
    return {
      params: void 0
    };
  }
  e.QueryClientParamsResponse = {
    encode(H, a = A.Writer.create()) {
      return H.params !== void 0 && f.Params.encode(H.params, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = B();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.params = f.Params.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        params: (0, O.isSet)(H.params) ? f.Params.fromJSON(H.params) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.params !== void 0 && (a.params = H.params ? f.Params.toJSON(H.params) : void 0), a;
    },
    fromPartial(H) {
      const a = B();
      return a.params = H.params !== void 0 && H.params !== null ? f.Params.fromPartial(H.params) : void 0, a;
    }
  };
  function I() {
    return {};
  }
  e.QueryUpgradedClientStateRequest = {
    encode(H, a = A.Writer.create()) {
      return a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = I();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {};
    },
    toJSON(H) {
      return {};
    },
    fromPartial(H) {
      return I();
    }
  };
  function Z() {
    return {
      upgradedClientState: void 0
    };
  }
  e.QueryUpgradedClientStateResponse = {
    encode(H, a = A.Writer.create()) {
      return H.upgradedClientState !== void 0 && u.Any.encode(H.upgradedClientState, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = Z();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.upgradedClientState = u.Any.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        upgradedClientState: (0, O.isSet)(H.upgradedClientState) ? u.Any.fromJSON(H.upgradedClientState) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.upgradedClientState !== void 0 && (a.upgradedClientState = H.upgradedClientState ? u.Any.toJSON(H.upgradedClientState) : void 0), a;
    },
    fromPartial(H) {
      const a = Z();
      return a.upgradedClientState = H.upgradedClientState !== void 0 && H.upgradedClientState !== null ? u.Any.fromPartial(H.upgradedClientState) : void 0, a;
    }
  };
  function t() {
    return {};
  }
  e.QueryUpgradedConsensusStateRequest = {
    encode(H, a = A.Writer.create()) {
      return a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = t();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {};
    },
    toJSON(H) {
      return {};
    },
    fromPartial(H) {
      return t();
    }
  };
  function y() {
    return {
      upgradedConsensusState: void 0
    };
  }
  e.QueryUpgradedConsensusStateResponse = {
    encode(H, a = A.Writer.create()) {
      return H.upgradedConsensusState !== void 0 && u.Any.encode(H.upgradedConsensusState, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const l = H instanceof A.Reader ? H : new A.Reader(H);
      let C = a === void 0 ? l.len : l.pos + a;
      const v = y();
      for (; l.pos < C; ) {
        const k = l.uint32();
        switch (k >>> 3) {
          case 1:
            v.upgradedConsensusState = u.Any.decode(l, l.uint32());
            break;
          default:
            l.skipType(k & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(H) {
      return {
        upgradedConsensusState: (0, O.isSet)(H.upgradedConsensusState) ? u.Any.fromJSON(H.upgradedConsensusState) : void 0
      };
    },
    toJSON(H) {
      const a = {};
      return H.upgradedConsensusState !== void 0 && (a.upgradedConsensusState = H.upgradedConsensusState ? u.Any.toJSON(H.upgradedConsensusState) : void 0), a;
    },
    fromPartial(H) {
      const a = y();
      return a.upgradedConsensusState = H.upgradedConsensusState !== void 0 && H.upgradedConsensusState !== null ? u.Any.fromPartial(H.upgradedConsensusState) : void 0, a;
    }
  };
  class E {
    constructor(a) {
      this.rpc = a, this.ClientState = this.ClientState.bind(this), this.ClientStates = this.ClientStates.bind(this), this.ConsensusState = this.ConsensusState.bind(this), this.ConsensusStates = this.ConsensusStates.bind(this), this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this), this.ClientStatus = this.ClientStatus.bind(this), this.ClientParams = this.ClientParams.bind(this), this.UpgradedClientState = this.UpgradedClientState.bind(this), this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
    }
    ClientState(a) {
      const l = e.QueryClientStateRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientState", l).then((v) => e.QueryClientStateResponse.decode(new A.Reader(v)));
    }
    ClientStates(a = {
      pagination: void 0
    }) {
      const l = e.QueryClientStatesRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStates", l).then((v) => e.QueryClientStatesResponse.decode(new A.Reader(v)));
    }
    ConsensusState(a) {
      const l = e.QueryConsensusStateRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", l).then((v) => e.QueryConsensusStateResponse.decode(new A.Reader(v)));
    }
    ConsensusStates(a) {
      const l = e.QueryConsensusStatesRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", l).then((v) => e.QueryConsensusStatesResponse.decode(new A.Reader(v)));
    }
    ConsensusStateHeights(a) {
      const l = e.QueryConsensusStateHeightsRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", l).then((v) => e.QueryConsensusStateHeightsResponse.decode(new A.Reader(v)));
    }
    ClientStatus(a) {
      const l = e.QueryClientStatusRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", l).then((v) => e.QueryClientStatusResponse.decode(new A.Reader(v)));
    }
    ClientParams(a = {}) {
      const l = e.QueryClientParamsRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientParams", l).then((v) => e.QueryClientParamsResponse.decode(new A.Reader(v)));
    }
    UpgradedClientState(a = {}) {
      const l = e.QueryUpgradedClientStateRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", l).then((v) => e.QueryUpgradedClientStateResponse.decode(new A.Reader(v)));
    }
    UpgradedConsensusState(a = {}) {
      const l = e.QueryUpgradedConsensusStateRequest.encode(a).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", l).then((v) => e.QueryUpgradedConsensusStateResponse.decode(new A.Reader(v)));
    }
  }
  e.QueryClientImpl = E;
})(wu);
var bu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(I, Z, t, y) {
    y === void 0 && (y = t);
    var E = Object.getOwnPropertyDescriptor(Z, t);
    (!E || ("get" in E ? !Z.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
      return Z[t];
    } }), Object.defineProperty(I, y, E);
  } : function(I, Z, t, y) {
    y === void 0 && (y = t), I[y] = Z[t];
  }), c = G && G.__setModuleDefault || (Object.create ? function(I, Z) {
    Object.defineProperty(I, "default", { enumerable: !0, value: Z });
  } : function(I, Z) {
    I.default = Z;
  }), i = G && G.__importStar || function(I) {
    if (I && I.__esModule)
      return I;
    var Z = {};
    if (I != null)
      for (var t in I)
        t !== "default" && Object.prototype.hasOwnProperty.call(I, t) && n(Z, I, t);
    return c(Z, I), Z;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryConnectionParamsResponse = e.QueryConnectionParamsRequest = e.QueryConnectionConsensusStateResponse = e.QueryConnectionConsensusStateRequest = e.QueryConnectionClientStateResponse = e.QueryConnectionClientStateRequest = e.QueryClientConnectionsResponse = e.QueryClientConnectionsRequest = e.QueryConnectionsResponse = e.QueryConnectionsRequest = e.QueryConnectionResponse = e.QueryConnectionRequest = e.protobufPackage = void 0;
  const r = Re, u = ta, f = In, O = Se, A = oe, T = i(ie);
  e.protobufPackage = "ibc.core.connection.v1";
  function L() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionRequest = {
    encode(I, Z = T.Writer.create()) {
      return I.connectionId !== "" && Z.uint32(10).string(I.connectionId), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = L();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.connectionId = t.string();
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        connectionId: (0, A.isSet)(I.connectionId) ? String(I.connectionId) : ""
      };
    },
    toJSON(I) {
      const Z = {};
      return I.connectionId !== void 0 && (Z.connectionId = I.connectionId), Z;
    },
    fromPartial(I) {
      const Z = L();
      return Z.connectionId = I.connectionId ?? "", Z;
    }
  };
  function M() {
    return {
      connection: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConnectionResponse = {
    encode(I, Z = T.Writer.create()) {
      return I.connection !== void 0 && u.ConnectionEnd.encode(I.connection, Z.uint32(10).fork()).ldelim(), I.proof.length !== 0 && Z.uint32(18).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, Z.uint32(26).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = M();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.connection = u.ConnectionEnd.decode(t, t.uint32());
            break;
          case 2:
            E.proof = t.bytes();
            break;
          case 3:
            E.proofHeight = f.Height.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        connection: (0, A.isSet)(I.connection) ? u.ConnectionEnd.fromJSON(I.connection) : void 0,
        proof: (0, A.isSet)(I.proof) ? (0, A.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.connection !== void 0 && (Z.connection = I.connection ? u.ConnectionEnd.toJSON(I.connection) : void 0), I.proof !== void 0 && (Z.proof = (0, A.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (Z.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), Z;
    },
    fromPartial(I) {
      const Z = M();
      return Z.connection = I.connection !== void 0 && I.connection !== null ? u.ConnectionEnd.fromPartial(I.connection) : void 0, Z.proof = I.proof ?? new Uint8Array(), Z.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, Z;
    }
  };
  function V() {
    return {
      pagination: void 0
    };
  }
  e.QueryConnectionsRequest = {
    encode(I, Z = T.Writer.create()) {
      return I.pagination !== void 0 && r.PageRequest.encode(I.pagination, Z.uint32(10).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = V();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.pagination = r.PageRequest.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        pagination: (0, A.isSet)(I.pagination) ? r.PageRequest.fromJSON(I.pagination) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.pagination !== void 0 && (Z.pagination = I.pagination ? r.PageRequest.toJSON(I.pagination) : void 0), Z;
    },
    fromPartial(I) {
      const Z = V();
      return Z.pagination = I.pagination !== void 0 && I.pagination !== null ? r.PageRequest.fromPartial(I.pagination) : void 0, Z;
    }
  };
  function D() {
    return {
      connections: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryConnectionsResponse = {
    encode(I, Z = T.Writer.create()) {
      for (const t of I.connections)
        u.IdentifiedConnection.encode(t, Z.uint32(10).fork()).ldelim();
      return I.pagination !== void 0 && r.PageResponse.encode(I.pagination, Z.uint32(18).fork()).ldelim(), I.height !== void 0 && f.Height.encode(I.height, Z.uint32(26).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = D();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.connections.push(u.IdentifiedConnection.decode(t, t.uint32()));
            break;
          case 2:
            E.pagination = r.PageResponse.decode(t, t.uint32());
            break;
          case 3:
            E.height = f.Height.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        connections: Array.isArray(I == null ? void 0 : I.connections) ? I.connections.map((Z) => u.IdentifiedConnection.fromJSON(Z)) : [],
        pagination: (0, A.isSet)(I.pagination) ? r.PageResponse.fromJSON(I.pagination) : void 0,
        height: (0, A.isSet)(I.height) ? f.Height.fromJSON(I.height) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.connections ? Z.connections = I.connections.map((t) => t ? u.IdentifiedConnection.toJSON(t) : void 0) : Z.connections = [], I.pagination !== void 0 && (Z.pagination = I.pagination ? r.PageResponse.toJSON(I.pagination) : void 0), I.height !== void 0 && (Z.height = I.height ? f.Height.toJSON(I.height) : void 0), Z;
    },
    fromPartial(I) {
      var t;
      const Z = D();
      return Z.connections = ((t = I.connections) == null ? void 0 : t.map((y) => u.IdentifiedConnection.fromPartial(y))) || [], Z.pagination = I.pagination !== void 0 && I.pagination !== null ? r.PageResponse.fromPartial(I.pagination) : void 0, Z.height = I.height !== void 0 && I.height !== null ? f.Height.fromPartial(I.height) : void 0, Z;
    }
  };
  function b() {
    return {
      clientId: ""
    };
  }
  e.QueryClientConnectionsRequest = {
    encode(I, Z = T.Writer.create()) {
      return I.clientId !== "" && Z.uint32(10).string(I.clientId), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = b();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.clientId = t.string();
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        clientId: (0, A.isSet)(I.clientId) ? String(I.clientId) : ""
      };
    },
    toJSON(I) {
      const Z = {};
      return I.clientId !== void 0 && (Z.clientId = I.clientId), Z;
    },
    fromPartial(I) {
      const Z = b();
      return Z.clientId = I.clientId ?? "", Z;
    }
  };
  function h() {
    return {
      connectionPaths: [],
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryClientConnectionsResponse = {
    encode(I, Z = T.Writer.create()) {
      for (const t of I.connectionPaths)
        Z.uint32(10).string(t);
      return I.proof.length !== 0 && Z.uint32(18).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, Z.uint32(26).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = h();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.connectionPaths.push(t.string());
            break;
          case 2:
            E.proof = t.bytes();
            break;
          case 3:
            E.proofHeight = f.Height.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        connectionPaths: Array.isArray(I == null ? void 0 : I.connectionPaths) ? I.connectionPaths.map((Z) => String(Z)) : [],
        proof: (0, A.isSet)(I.proof) ? (0, A.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.connectionPaths ? Z.connectionPaths = I.connectionPaths.map((t) => t) : Z.connectionPaths = [], I.proof !== void 0 && (Z.proof = (0, A.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (Z.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), Z;
    },
    fromPartial(I) {
      var t;
      const Z = h();
      return Z.connectionPaths = ((t = I.connectionPaths) == null ? void 0 : t.map((y) => y)) || [], Z.proof = I.proof ?? new Uint8Array(), Z.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, Z;
    }
  };
  function S() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionClientStateRequest = {
    encode(I, Z = T.Writer.create()) {
      return I.connectionId !== "" && Z.uint32(10).string(I.connectionId), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = S();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.connectionId = t.string();
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        connectionId: (0, A.isSet)(I.connectionId) ? String(I.connectionId) : ""
      };
    },
    toJSON(I) {
      const Z = {};
      return I.connectionId !== void 0 && (Z.connectionId = I.connectionId), Z;
    },
    fromPartial(I) {
      const Z = S();
      return Z.connectionId = I.connectionId ?? "", Z;
    }
  };
  function _() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConnectionClientStateResponse = {
    encode(I, Z = T.Writer.create()) {
      return I.identifiedClientState !== void 0 && f.IdentifiedClientState.encode(I.identifiedClientState, Z.uint32(10).fork()).ldelim(), I.proof.length !== 0 && Z.uint32(18).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, Z.uint32(26).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = _();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.identifiedClientState = f.IdentifiedClientState.decode(t, t.uint32());
            break;
          case 2:
            E.proof = t.bytes();
            break;
          case 3:
            E.proofHeight = f.Height.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        identifiedClientState: (0, A.isSet)(I.identifiedClientState) ? f.IdentifiedClientState.fromJSON(I.identifiedClientState) : void 0,
        proof: (0, A.isSet)(I.proof) ? (0, A.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.identifiedClientState !== void 0 && (Z.identifiedClientState = I.identifiedClientState ? f.IdentifiedClientState.toJSON(I.identifiedClientState) : void 0), I.proof !== void 0 && (Z.proof = (0, A.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (Z.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), Z;
    },
    fromPartial(I) {
      const Z = _();
      return Z.identifiedClientState = I.identifiedClientState !== void 0 && I.identifiedClientState !== null ? f.IdentifiedClientState.fromPartial(I.identifiedClientState) : void 0, Z.proof = I.proof ?? new Uint8Array(), Z.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, Z;
    }
  };
  function d() {
    return {
      connectionId: "",
      revisionNumber: A.Long.UZERO,
      revisionHeight: A.Long.UZERO
    };
  }
  e.QueryConnectionConsensusStateRequest = {
    encode(I, Z = T.Writer.create()) {
      return I.connectionId !== "" && Z.uint32(10).string(I.connectionId), I.revisionNumber.isZero() || Z.uint32(16).uint64(I.revisionNumber), I.revisionHeight.isZero() || Z.uint32(24).uint64(I.revisionHeight), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = d();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.connectionId = t.string();
            break;
          case 2:
            E.revisionNumber = t.uint64();
            break;
          case 3:
            E.revisionHeight = t.uint64();
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        connectionId: (0, A.isSet)(I.connectionId) ? String(I.connectionId) : "",
        revisionNumber: (0, A.isSet)(I.revisionNumber) ? A.Long.fromValue(I.revisionNumber) : A.Long.UZERO,
        revisionHeight: (0, A.isSet)(I.revisionHeight) ? A.Long.fromValue(I.revisionHeight) : A.Long.UZERO
      };
    },
    toJSON(I) {
      const Z = {};
      return I.connectionId !== void 0 && (Z.connectionId = I.connectionId), I.revisionNumber !== void 0 && (Z.revisionNumber = (I.revisionNumber || A.Long.UZERO).toString()), I.revisionHeight !== void 0 && (Z.revisionHeight = (I.revisionHeight || A.Long.UZERO).toString()), Z;
    },
    fromPartial(I) {
      const Z = d();
      return Z.connectionId = I.connectionId ?? "", Z.revisionNumber = I.revisionNumber !== void 0 && I.revisionNumber !== null ? A.Long.fromValue(I.revisionNumber) : A.Long.UZERO, Z.revisionHeight = I.revisionHeight !== void 0 && I.revisionHeight !== null ? A.Long.fromValue(I.revisionHeight) : A.Long.UZERO, Z;
    }
  };
  function p() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConnectionConsensusStateResponse = {
    encode(I, Z = T.Writer.create()) {
      return I.consensusState !== void 0 && O.Any.encode(I.consensusState, Z.uint32(10).fork()).ldelim(), I.clientId !== "" && Z.uint32(18).string(I.clientId), I.proof.length !== 0 && Z.uint32(26).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, Z.uint32(34).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = p();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.consensusState = O.Any.decode(t, t.uint32());
            break;
          case 2:
            E.clientId = t.string();
            break;
          case 3:
            E.proof = t.bytes();
            break;
          case 4:
            E.proofHeight = f.Height.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        consensusState: (0, A.isSet)(I.consensusState) ? O.Any.fromJSON(I.consensusState) : void 0,
        clientId: (0, A.isSet)(I.clientId) ? String(I.clientId) : "",
        proof: (0, A.isSet)(I.proof) ? (0, A.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, A.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.consensusState !== void 0 && (Z.consensusState = I.consensusState ? O.Any.toJSON(I.consensusState) : void 0), I.clientId !== void 0 && (Z.clientId = I.clientId), I.proof !== void 0 && (Z.proof = (0, A.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (Z.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), Z;
    },
    fromPartial(I) {
      const Z = p();
      return Z.consensusState = I.consensusState !== void 0 && I.consensusState !== null ? O.Any.fromPartial(I.consensusState) : void 0, Z.clientId = I.clientId ?? "", Z.proof = I.proof ?? new Uint8Array(), Z.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, Z;
    }
  };
  function g() {
    return {};
  }
  e.QueryConnectionParamsRequest = {
    encode(I, Z = T.Writer.create()) {
      return Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = g();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {};
    },
    toJSON(I) {
      return {};
    },
    fromPartial(I) {
      return g();
    }
  };
  function J() {
    return {
      params: void 0
    };
  }
  e.QueryConnectionParamsResponse = {
    encode(I, Z = T.Writer.create()) {
      return I.params !== void 0 && f.Params.encode(I.params, Z.uint32(10).fork()).ldelim(), Z;
    },
    decode(I, Z) {
      const t = I instanceof T.Reader ? I : new T.Reader(I);
      let y = Z === void 0 ? t.len : t.pos + Z;
      const E = J();
      for (; t.pos < y; ) {
        const H = t.uint32();
        switch (H >>> 3) {
          case 1:
            E.params = f.Params.decode(t, t.uint32());
            break;
          default:
            t.skipType(H & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(I) {
      return {
        params: (0, A.isSet)(I.params) ? f.Params.fromJSON(I.params) : void 0
      };
    },
    toJSON(I) {
      const Z = {};
      return I.params !== void 0 && (Z.params = I.params ? f.Params.toJSON(I.params) : void 0), Z;
    },
    fromPartial(I) {
      const Z = J();
      return Z.params = I.params !== void 0 && I.params !== null ? f.Params.fromPartial(I.params) : void 0, Z;
    }
  };
  class B {
    constructor(Z) {
      this.rpc = Z, this.Connection = this.Connection.bind(this), this.Connections = this.Connections.bind(this), this.ClientConnections = this.ClientConnections.bind(this), this.ConnectionClientState = this.ConnectionClientState.bind(this), this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this), this.ConnectionParams = this.ConnectionParams.bind(this);
    }
    Connection(Z) {
      const t = e.QueryConnectionRequest.encode(Z).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connection", t).then((E) => e.QueryConnectionResponse.decode(new T.Reader(E)));
    }
    Connections(Z = {
      pagination: void 0
    }) {
      const t = e.QueryConnectionsRequest.encode(Z).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connections", t).then((E) => e.QueryConnectionsResponse.decode(new T.Reader(E)));
    }
    ClientConnections(Z) {
      const t = e.QueryClientConnectionsRequest.encode(Z).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", t).then((E) => e.QueryClientConnectionsResponse.decode(new T.Reader(E)));
    }
    ConnectionClientState(Z) {
      const t = e.QueryConnectionClientStateRequest.encode(Z).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", t).then((E) => e.QueryConnectionClientStateResponse.decode(new T.Reader(E)));
    }
    ConnectionConsensusState(Z) {
      const t = e.QueryConnectionConsensusStateRequest.encode(Z).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", t).then((E) => e.QueryConnectionConsensusStateResponse.decode(new T.Reader(E)));
    }
    ConnectionParams(Z = {}) {
      const t = e.QueryConnectionParamsRequest.encode(Z).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", t).then((E) => e.QueryConnectionParamsResponse.decode(new T.Reader(E)));
    }
  }
  e.QueryClientImpl = B;
})(bu);
var Bu = {}, rt = {}, ia = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(M, V, D, b) {
    b === void 0 && (b = D);
    var h = Object.getOwnPropertyDescriptor(V, D);
    (!h || ("get" in h ? !V.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return V[D];
    } }), Object.defineProperty(M, b, h);
  } : function(M, V, D, b) {
    b === void 0 && (b = D), M[b] = V[D];
  }), c = G && G.__setModuleDefault || (Object.create ? function(M, V) {
    Object.defineProperty(M, "default", { enumerable: !0, value: V });
  } : function(M, V) {
    M.default = V;
  }), i = G && G.__importStar || function(M) {
    if (M && M.__esModule)
      return M;
    var V = {};
    if (M != null)
      for (var D in M)
        D !== "default" && Object.prototype.hasOwnProperty.call(M, D) && n(V, M, D);
    return c(V, M), V;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ProofOps = e.ProofOp = e.DominoOp = e.ValueOp = e.Proof = e.protobufPackage = void 0;
  const r = oe, u = i(ie);
  e.protobufPackage = "tendermint.crypto";
  function f() {
    return {
      total: r.Long.ZERO,
      index: r.Long.ZERO,
      leafHash: new Uint8Array(),
      aunts: []
    };
  }
  e.Proof = {
    encode(M, V = u.Writer.create()) {
      M.total.isZero() || V.uint32(8).int64(M.total), M.index.isZero() || V.uint32(16).int64(M.index), M.leafHash.length !== 0 && V.uint32(26).bytes(M.leafHash);
      for (const D of M.aunts)
        V.uint32(34).bytes(D);
      return V;
    },
    decode(M, V) {
      const D = M instanceof u.Reader ? M : new u.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = f();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.total = D.int64();
            break;
          case 2:
            h.index = D.int64();
            break;
          case 3:
            h.leafHash = D.bytes();
            break;
          case 4:
            h.aunts.push(D.bytes());
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        total: (0, r.isSet)(M.total) ? r.Long.fromValue(M.total) : r.Long.ZERO,
        index: (0, r.isSet)(M.index) ? r.Long.fromValue(M.index) : r.Long.ZERO,
        leafHash: (0, r.isSet)(M.leafHash) ? (0, r.bytesFromBase64)(M.leafHash) : new Uint8Array(),
        aunts: Array.isArray(M == null ? void 0 : M.aunts) ? M.aunts.map((V) => (0, r.bytesFromBase64)(V)) : []
      };
    },
    toJSON(M) {
      const V = {};
      return M.total !== void 0 && (V.total = (M.total || r.Long.ZERO).toString()), M.index !== void 0 && (V.index = (M.index || r.Long.ZERO).toString()), M.leafHash !== void 0 && (V.leafHash = (0, r.base64FromBytes)(M.leafHash !== void 0 ? M.leafHash : new Uint8Array())), M.aunts ? V.aunts = M.aunts.map((D) => (0, r.base64FromBytes)(D !== void 0 ? D : new Uint8Array())) : V.aunts = [], V;
    },
    fromPartial(M) {
      var D;
      const V = f();
      return V.total = M.total !== void 0 && M.total !== null ? r.Long.fromValue(M.total) : r.Long.ZERO, V.index = M.index !== void 0 && M.index !== null ? r.Long.fromValue(M.index) : r.Long.ZERO, V.leafHash = M.leafHash ?? new Uint8Array(), V.aunts = ((D = M.aunts) == null ? void 0 : D.map((b) => b)) || [], V;
    }
  };
  function O() {
    return {
      key: new Uint8Array(),
      proof: void 0
    };
  }
  e.ValueOp = {
    encode(M, V = u.Writer.create()) {
      return M.key.length !== 0 && V.uint32(10).bytes(M.key), M.proof !== void 0 && e.Proof.encode(M.proof, V.uint32(18).fork()).ldelim(), V;
    },
    decode(M, V) {
      const D = M instanceof u.Reader ? M : new u.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = O();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.key = D.bytes();
            break;
          case 2:
            h.proof = e.Proof.decode(D, D.uint32());
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        key: (0, r.isSet)(M.key) ? (0, r.bytesFromBase64)(M.key) : new Uint8Array(),
        proof: (0, r.isSet)(M.proof) ? e.Proof.fromJSON(M.proof) : void 0
      };
    },
    toJSON(M) {
      const V = {};
      return M.key !== void 0 && (V.key = (0, r.base64FromBytes)(M.key !== void 0 ? M.key : new Uint8Array())), M.proof !== void 0 && (V.proof = M.proof ? e.Proof.toJSON(M.proof) : void 0), V;
    },
    fromPartial(M) {
      const V = O();
      return V.key = M.key ?? new Uint8Array(), V.proof = M.proof !== void 0 && M.proof !== null ? e.Proof.fromPartial(M.proof) : void 0, V;
    }
  };
  function A() {
    return {
      key: "",
      input: "",
      output: ""
    };
  }
  e.DominoOp = {
    encode(M, V = u.Writer.create()) {
      return M.key !== "" && V.uint32(10).string(M.key), M.input !== "" && V.uint32(18).string(M.input), M.output !== "" && V.uint32(26).string(M.output), V;
    },
    decode(M, V) {
      const D = M instanceof u.Reader ? M : new u.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = A();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.key = D.string();
            break;
          case 2:
            h.input = D.string();
            break;
          case 3:
            h.output = D.string();
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        key: (0, r.isSet)(M.key) ? String(M.key) : "",
        input: (0, r.isSet)(M.input) ? String(M.input) : "",
        output: (0, r.isSet)(M.output) ? String(M.output) : ""
      };
    },
    toJSON(M) {
      const V = {};
      return M.key !== void 0 && (V.key = M.key), M.input !== void 0 && (V.input = M.input), M.output !== void 0 && (V.output = M.output), V;
    },
    fromPartial(M) {
      const V = A();
      return V.key = M.key ?? "", V.input = M.input ?? "", V.output = M.output ?? "", V;
    }
  };
  function T() {
    return {
      type: "",
      key: new Uint8Array(),
      data: new Uint8Array()
    };
  }
  e.ProofOp = {
    encode(M, V = u.Writer.create()) {
      return M.type !== "" && V.uint32(10).string(M.type), M.key.length !== 0 && V.uint32(18).bytes(M.key), M.data.length !== 0 && V.uint32(26).bytes(M.data), V;
    },
    decode(M, V) {
      const D = M instanceof u.Reader ? M : new u.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = T();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.type = D.string();
            break;
          case 2:
            h.key = D.bytes();
            break;
          case 3:
            h.data = D.bytes();
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        type: (0, r.isSet)(M.type) ? String(M.type) : "",
        key: (0, r.isSet)(M.key) ? (0, r.bytesFromBase64)(M.key) : new Uint8Array(),
        data: (0, r.isSet)(M.data) ? (0, r.bytesFromBase64)(M.data) : new Uint8Array()
      };
    },
    toJSON(M) {
      const V = {};
      return M.type !== void 0 && (V.type = M.type), M.key !== void 0 && (V.key = (0, r.base64FromBytes)(M.key !== void 0 ? M.key : new Uint8Array())), M.data !== void 0 && (V.data = (0, r.base64FromBytes)(M.data !== void 0 ? M.data : new Uint8Array())), V;
    },
    fromPartial(M) {
      const V = T();
      return V.type = M.type ?? "", V.key = M.key ?? new Uint8Array(), V.data = M.data ?? new Uint8Array(), V;
    }
  };
  function L() {
    return {
      ops: []
    };
  }
  e.ProofOps = {
    encode(M, V = u.Writer.create()) {
      for (const D of M.ops)
        e.ProofOp.encode(D, V.uint32(10).fork()).ldelim();
      return V;
    },
    decode(M, V) {
      const D = M instanceof u.Reader ? M : new u.Reader(M);
      let b = V === void 0 ? D.len : D.pos + V;
      const h = L();
      for (; D.pos < b; ) {
        const S = D.uint32();
        switch (S >>> 3) {
          case 1:
            h.ops.push(e.ProofOp.decode(D, D.uint32()));
            break;
          default:
            D.skipType(S & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(M) {
      return {
        ops: Array.isArray(M == null ? void 0 : M.ops) ? M.ops.map((V) => e.ProofOp.fromJSON(V)) : []
      };
    },
    toJSON(M) {
      const V = {};
      return M.ops ? V.ops = M.ops.map((D) => D ? e.ProofOp.toJSON(D) : void 0) : V.ops = [], V;
    },
    fromPartial(M) {
      var D;
      const V = L();
      return V.ops = ((D = M.ops) == null ? void 0 : D.map((b) => e.ProofOp.fromPartial(b))) || [], V;
    }
  };
})(ia);
var Hn = {}, Lh = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), Hh = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), qh = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && Lh(n, e, c);
  return Hh(n, e), n;
};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.Consensus = Hn.App = Hn.protobufPackage = void 0;
const Oe = oe, Pt = qh(ie);
Hn.protobufPackage = "tendermint.version";
function Ls() {
  return {
    protocol: Oe.Long.UZERO,
    software: ""
  };
}
Hn.App = {
  encode(e, n = Pt.Writer.create()) {
    return e.protocol.isZero() || n.uint32(8).uint64(e.protocol), e.software !== "" && n.uint32(18).string(e.software), n;
  },
  decode(e, n) {
    const c = e instanceof Pt.Reader ? e : new Pt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Ls();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.protocol = c.uint64();
          break;
        case 2:
          r.software = c.string();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      protocol: (0, Oe.isSet)(e.protocol) ? Oe.Long.fromValue(e.protocol) : Oe.Long.UZERO,
      software: (0, Oe.isSet)(e.software) ? String(e.software) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.protocol !== void 0 && (n.protocol = (e.protocol || Oe.Long.UZERO).toString()), e.software !== void 0 && (n.software = e.software), n;
  },
  fromPartial(e) {
    const n = Ls();
    return n.protocol = e.protocol !== void 0 && e.protocol !== null ? Oe.Long.fromValue(e.protocol) : Oe.Long.UZERO, n.software = e.software ?? "", n;
  }
};
function Hs() {
  return {
    block: Oe.Long.UZERO,
    app: Oe.Long.UZERO
  };
}
Hn.Consensus = {
  encode(e, n = Pt.Writer.create()) {
    return e.block.isZero() || n.uint32(8).uint64(e.block), e.app.isZero() || n.uint32(16).uint64(e.app), n;
  },
  decode(e, n) {
    const c = e instanceof Pt.Reader ? e : new Pt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Hs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.block = c.uint64();
          break;
        case 2:
          r.app = c.uint64();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      block: (0, Oe.isSet)(e.block) ? Oe.Long.fromValue(e.block) : Oe.Long.UZERO,
      app: (0, Oe.isSet)(e.app) ? Oe.Long.fromValue(e.app) : Oe.Long.UZERO
    };
  },
  toJSON(e) {
    const n = {};
    return e.block !== void 0 && (n.block = (e.block || Oe.Long.UZERO).toString()), e.app !== void 0 && (n.app = (e.app || Oe.Long.UZERO).toString()), n;
  },
  fromPartial(e) {
    const n = Hs();
    return n.block = e.block !== void 0 && e.block !== null ? Oe.Long.fromValue(e.block) : Oe.Long.UZERO, n.app = e.app !== void 0 && e.app !== null ? Oe.Long.fromValue(e.app) : Oe.Long.UZERO, n;
  }
};
var fi = {}, jn = {}, Wh = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), Zh = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Qh = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && Wh(n, e, c);
  return Zh(n, e), n;
};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.PublicKey = jn.protobufPackage = void 0;
const no = Qh(ie), ct = oe;
jn.protobufPackage = "tendermint.crypto";
function qs() {
  return {
    ed25519: void 0,
    secp256k1: void 0
  };
}
jn.PublicKey = {
  encode(e, n = no.Writer.create()) {
    return e.ed25519 !== void 0 && n.uint32(10).bytes(e.ed25519), e.secp256k1 !== void 0 && n.uint32(18).bytes(e.secp256k1), n;
  },
  decode(e, n) {
    const c = e instanceof no.Reader ? e : new no.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = qs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.ed25519 = c.bytes();
          break;
        case 2:
          r.secp256k1 = c.bytes();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      ed25519: (0, ct.isSet)(e.ed25519) ? (0, ct.bytesFromBase64)(e.ed25519) : void 0,
      secp256k1: (0, ct.isSet)(e.secp256k1) ? (0, ct.bytesFromBase64)(e.secp256k1) : void 0
    };
  },
  toJSON(e) {
    const n = {};
    return e.ed25519 !== void 0 && (n.ed25519 = e.ed25519 !== void 0 ? (0, ct.base64FromBytes)(e.ed25519) : void 0), e.secp256k1 !== void 0 && (n.secp256k1 = e.secp256k1 !== void 0 ? (0, ct.base64FromBytes)(e.secp256k1) : void 0), n;
  },
  fromPartial(e) {
    const n = qs();
    return n.ed25519 = e.ed25519 ?? void 0, n.secp256k1 = e.secp256k1 ?? void 0, n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(L, M, V, D) {
    D === void 0 && (D = V);
    var b = Object.getOwnPropertyDescriptor(M, V);
    (!b || ("get" in b ? !M.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return M[V];
    } }), Object.defineProperty(L, D, b);
  } : function(L, M, V, D) {
    D === void 0 && (D = V), L[D] = M[V];
  }), c = G && G.__setModuleDefault || (Object.create ? function(L, M) {
    Object.defineProperty(L, "default", { enumerable: !0, value: M });
  } : function(L, M) {
    L.default = M;
  }), i = G && G.__importStar || function(L) {
    if (L && L.__esModule)
      return L;
    var M = {};
    if (L != null)
      for (var V in L)
        V !== "default" && Object.prototype.hasOwnProperty.call(L, V) && n(M, L, V);
    return c(M, L), M;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SimpleValidator = e.Validator = e.ValidatorSet = e.protobufPackage = void 0;
  const r = jn, u = oe, f = i(ie);
  e.protobufPackage = "tendermint.types";
  function O() {
    return {
      validators: [],
      proposer: void 0,
      totalVotingPower: u.Long.ZERO
    };
  }
  e.ValidatorSet = {
    encode(L, M = f.Writer.create()) {
      for (const V of L.validators)
        e.Validator.encode(V, M.uint32(10).fork()).ldelim();
      return L.proposer !== void 0 && e.Validator.encode(L.proposer, M.uint32(18).fork()).ldelim(), L.totalVotingPower.isZero() || M.uint32(24).int64(L.totalVotingPower), M;
    },
    decode(L, M) {
      const V = L instanceof f.Reader ? L : new f.Reader(L);
      let D = M === void 0 ? V.len : V.pos + M;
      const b = O();
      for (; V.pos < D; ) {
        const h = V.uint32();
        switch (h >>> 3) {
          case 1:
            b.validators.push(e.Validator.decode(V, V.uint32()));
            break;
          case 2:
            b.proposer = e.Validator.decode(V, V.uint32());
            break;
          case 3:
            b.totalVotingPower = V.int64();
            break;
          default:
            V.skipType(h & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(L) {
      return {
        validators: Array.isArray(L == null ? void 0 : L.validators) ? L.validators.map((M) => e.Validator.fromJSON(M)) : [],
        proposer: (0, u.isSet)(L.proposer) ? e.Validator.fromJSON(L.proposer) : void 0,
        totalVotingPower: (0, u.isSet)(L.totalVotingPower) ? u.Long.fromValue(L.totalVotingPower) : u.Long.ZERO
      };
    },
    toJSON(L) {
      const M = {};
      return L.validators ? M.validators = L.validators.map((V) => V ? e.Validator.toJSON(V) : void 0) : M.validators = [], L.proposer !== void 0 && (M.proposer = L.proposer ? e.Validator.toJSON(L.proposer) : void 0), L.totalVotingPower !== void 0 && (M.totalVotingPower = (L.totalVotingPower || u.Long.ZERO).toString()), M;
    },
    fromPartial(L) {
      var V;
      const M = O();
      return M.validators = ((V = L.validators) == null ? void 0 : V.map((D) => e.Validator.fromPartial(D))) || [], M.proposer = L.proposer !== void 0 && L.proposer !== null ? e.Validator.fromPartial(L.proposer) : void 0, M.totalVotingPower = L.totalVotingPower !== void 0 && L.totalVotingPower !== null ? u.Long.fromValue(L.totalVotingPower) : u.Long.ZERO, M;
    }
  };
  function A() {
    return {
      address: new Uint8Array(),
      pubKey: void 0,
      votingPower: u.Long.ZERO,
      proposerPriority: u.Long.ZERO
    };
  }
  e.Validator = {
    encode(L, M = f.Writer.create()) {
      return L.address.length !== 0 && M.uint32(10).bytes(L.address), L.pubKey !== void 0 && r.PublicKey.encode(L.pubKey, M.uint32(18).fork()).ldelim(), L.votingPower.isZero() || M.uint32(24).int64(L.votingPower), L.proposerPriority.isZero() || M.uint32(32).int64(L.proposerPriority), M;
    },
    decode(L, M) {
      const V = L instanceof f.Reader ? L : new f.Reader(L);
      let D = M === void 0 ? V.len : V.pos + M;
      const b = A();
      for (; V.pos < D; ) {
        const h = V.uint32();
        switch (h >>> 3) {
          case 1:
            b.address = V.bytes();
            break;
          case 2:
            b.pubKey = r.PublicKey.decode(V, V.uint32());
            break;
          case 3:
            b.votingPower = V.int64();
            break;
          case 4:
            b.proposerPriority = V.int64();
            break;
          default:
            V.skipType(h & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(L) {
      return {
        address: (0, u.isSet)(L.address) ? (0, u.bytesFromBase64)(L.address) : new Uint8Array(),
        pubKey: (0, u.isSet)(L.pubKey) ? r.PublicKey.fromJSON(L.pubKey) : void 0,
        votingPower: (0, u.isSet)(L.votingPower) ? u.Long.fromValue(L.votingPower) : u.Long.ZERO,
        proposerPriority: (0, u.isSet)(L.proposerPriority) ? u.Long.fromValue(L.proposerPriority) : u.Long.ZERO
      };
    },
    toJSON(L) {
      const M = {};
      return L.address !== void 0 && (M.address = (0, u.base64FromBytes)(L.address !== void 0 ? L.address : new Uint8Array())), L.pubKey !== void 0 && (M.pubKey = L.pubKey ? r.PublicKey.toJSON(L.pubKey) : void 0), L.votingPower !== void 0 && (M.votingPower = (L.votingPower || u.Long.ZERO).toString()), L.proposerPriority !== void 0 && (M.proposerPriority = (L.proposerPriority || u.Long.ZERO).toString()), M;
    },
    fromPartial(L) {
      const M = A();
      return M.address = L.address ?? new Uint8Array(), M.pubKey = L.pubKey !== void 0 && L.pubKey !== null ? r.PublicKey.fromPartial(L.pubKey) : void 0, M.votingPower = L.votingPower !== void 0 && L.votingPower !== null ? u.Long.fromValue(L.votingPower) : u.Long.ZERO, M.proposerPriority = L.proposerPriority !== void 0 && L.proposerPriority !== null ? u.Long.fromValue(L.proposerPriority) : u.Long.ZERO, M;
    }
  };
  function T() {
    return {
      pubKey: void 0,
      votingPower: u.Long.ZERO
    };
  }
  e.SimpleValidator = {
    encode(L, M = f.Writer.create()) {
      return L.pubKey !== void 0 && r.PublicKey.encode(L.pubKey, M.uint32(10).fork()).ldelim(), L.votingPower.isZero() || M.uint32(16).int64(L.votingPower), M;
    },
    decode(L, M) {
      const V = L instanceof f.Reader ? L : new f.Reader(L);
      let D = M === void 0 ? V.len : V.pos + M;
      const b = T();
      for (; V.pos < D; ) {
        const h = V.uint32();
        switch (h >>> 3) {
          case 1:
            b.pubKey = r.PublicKey.decode(V, V.uint32());
            break;
          case 2:
            b.votingPower = V.int64();
            break;
          default:
            V.skipType(h & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(L) {
      return {
        pubKey: (0, u.isSet)(L.pubKey) ? r.PublicKey.fromJSON(L.pubKey) : void 0,
        votingPower: (0, u.isSet)(L.votingPower) ? u.Long.fromValue(L.votingPower) : u.Long.ZERO
      };
    },
    toJSON(L) {
      const M = {};
      return L.pubKey !== void 0 && (M.pubKey = L.pubKey ? r.PublicKey.toJSON(L.pubKey) : void 0), L.votingPower !== void 0 && (M.votingPower = (L.votingPower || u.Long.ZERO).toString()), M;
    },
    fromPartial(L) {
      const M = T();
      return M.pubKey = L.pubKey !== void 0 && L.pubKey !== null ? r.PublicKey.fromPartial(L.pubKey) : void 0, M.votingPower = L.votingPower !== void 0 && L.votingPower !== null ? u.Long.fromValue(L.votingPower) : u.Long.ZERO, M;
    }
  };
})(fi);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(a, l, C, v) {
    v === void 0 && (v = C);
    var k = Object.getOwnPropertyDescriptor(l, C);
    (!k || ("get" in k ? !l.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return l[C];
    } }), Object.defineProperty(a, v, k);
  } : function(a, l, C, v) {
    v === void 0 && (v = C), a[v] = l[C];
  }), c = G && G.__setModuleDefault || (Object.create ? function(a, l) {
    Object.defineProperty(a, "default", { enumerable: !0, value: l });
  } : function(a, l) {
    a.default = l;
  }), i = G && G.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var l = {};
    if (a != null)
      for (var C in a)
        C !== "default" && Object.prototype.hasOwnProperty.call(a, C) && n(l, a, C);
    return c(l, a), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TxProof = e.BlockMeta = e.LightBlock = e.SignedHeader = e.Proposal = e.CommitSig = e.Commit = e.Vote = e.Data = e.Header = e.BlockID = e.Part = e.PartSetHeader = e.signedMsgTypeToJSON = e.signedMsgTypeFromJSON = e.SignedMsgType = e.blockIDFlagToJSON = e.blockIDFlagFromJSON = e.BlockIDFlag = e.protobufPackage = void 0;
  const r = ia, u = Hn, f = _e, O = fi, A = oe, T = i(ie);
  e.protobufPackage = "tendermint.types";
  var L;
  (function(a) {
    a[a.BLOCK_ID_FLAG_UNKNOWN = 0] = "BLOCK_ID_FLAG_UNKNOWN", a[a.BLOCK_ID_FLAG_ABSENT = 1] = "BLOCK_ID_FLAG_ABSENT", a[a.BLOCK_ID_FLAG_COMMIT = 2] = "BLOCK_ID_FLAG_COMMIT", a[a.BLOCK_ID_FLAG_NIL = 3] = "BLOCK_ID_FLAG_NIL", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(L = e.BlockIDFlag || (e.BlockIDFlag = {}));
  function M(a) {
    switch (a) {
      case 0:
      case "BLOCK_ID_FLAG_UNKNOWN":
        return L.BLOCK_ID_FLAG_UNKNOWN;
      case 1:
      case "BLOCK_ID_FLAG_ABSENT":
        return L.BLOCK_ID_FLAG_ABSENT;
      case 2:
      case "BLOCK_ID_FLAG_COMMIT":
        return L.BLOCK_ID_FLAG_COMMIT;
      case 3:
      case "BLOCK_ID_FLAG_NIL":
        return L.BLOCK_ID_FLAG_NIL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return L.UNRECOGNIZED;
    }
  }
  e.blockIDFlagFromJSON = M;
  function V(a) {
    switch (a) {
      case L.BLOCK_ID_FLAG_UNKNOWN:
        return "BLOCK_ID_FLAG_UNKNOWN";
      case L.BLOCK_ID_FLAG_ABSENT:
        return "BLOCK_ID_FLAG_ABSENT";
      case L.BLOCK_ID_FLAG_COMMIT:
        return "BLOCK_ID_FLAG_COMMIT";
      case L.BLOCK_ID_FLAG_NIL:
        return "BLOCK_ID_FLAG_NIL";
      case L.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.blockIDFlagToJSON = V;
  var D;
  (function(a) {
    a[a.SIGNED_MSG_TYPE_UNKNOWN = 0] = "SIGNED_MSG_TYPE_UNKNOWN", a[a.SIGNED_MSG_TYPE_PREVOTE = 1] = "SIGNED_MSG_TYPE_PREVOTE", a[a.SIGNED_MSG_TYPE_PRECOMMIT = 2] = "SIGNED_MSG_TYPE_PRECOMMIT", a[a.SIGNED_MSG_TYPE_PROPOSAL = 32] = "SIGNED_MSG_TYPE_PROPOSAL", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(D = e.SignedMsgType || (e.SignedMsgType = {}));
  function b(a) {
    switch (a) {
      case 0:
      case "SIGNED_MSG_TYPE_UNKNOWN":
        return D.SIGNED_MSG_TYPE_UNKNOWN;
      case 1:
      case "SIGNED_MSG_TYPE_PREVOTE":
        return D.SIGNED_MSG_TYPE_PREVOTE;
      case 2:
      case "SIGNED_MSG_TYPE_PRECOMMIT":
        return D.SIGNED_MSG_TYPE_PRECOMMIT;
      case 32:
      case "SIGNED_MSG_TYPE_PROPOSAL":
        return D.SIGNED_MSG_TYPE_PROPOSAL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return D.UNRECOGNIZED;
    }
  }
  e.signedMsgTypeFromJSON = b;
  function h(a) {
    switch (a) {
      case D.SIGNED_MSG_TYPE_UNKNOWN:
        return "SIGNED_MSG_TYPE_UNKNOWN";
      case D.SIGNED_MSG_TYPE_PREVOTE:
        return "SIGNED_MSG_TYPE_PREVOTE";
      case D.SIGNED_MSG_TYPE_PRECOMMIT:
        return "SIGNED_MSG_TYPE_PRECOMMIT";
      case D.SIGNED_MSG_TYPE_PROPOSAL:
        return "SIGNED_MSG_TYPE_PROPOSAL";
      case D.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.signedMsgTypeToJSON = h;
  function S() {
    return {
      total: 0,
      hash: new Uint8Array()
    };
  }
  e.PartSetHeader = {
    encode(a, l = T.Writer.create()) {
      return a.total !== 0 && l.uint32(8).uint32(a.total), a.hash.length !== 0 && l.uint32(18).bytes(a.hash), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = S();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.total = C.uint32();
            break;
          case 2:
            k.hash = C.bytes();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        total: (0, A.isSet)(a.total) ? Number(a.total) : 0,
        hash: (0, A.isSet)(a.hash) ? (0, A.bytesFromBase64)(a.hash) : new Uint8Array()
      };
    },
    toJSON(a) {
      const l = {};
      return a.total !== void 0 && (l.total = Math.round(a.total)), a.hash !== void 0 && (l.hash = (0, A.base64FromBytes)(a.hash !== void 0 ? a.hash : new Uint8Array())), l;
    },
    fromPartial(a) {
      const l = S();
      return l.total = a.total ?? 0, l.hash = a.hash ?? new Uint8Array(), l;
    }
  };
  function _() {
    return {
      index: 0,
      bytes: new Uint8Array(),
      proof: void 0
    };
  }
  e.Part = {
    encode(a, l = T.Writer.create()) {
      return a.index !== 0 && l.uint32(8).uint32(a.index), a.bytes.length !== 0 && l.uint32(18).bytes(a.bytes), a.proof !== void 0 && r.Proof.encode(a.proof, l.uint32(26).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = _();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.index = C.uint32();
            break;
          case 2:
            k.bytes = C.bytes();
            break;
          case 3:
            k.proof = r.Proof.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        index: (0, A.isSet)(a.index) ? Number(a.index) : 0,
        bytes: (0, A.isSet)(a.bytes) ? (0, A.bytesFromBase64)(a.bytes) : new Uint8Array(),
        proof: (0, A.isSet)(a.proof) ? r.Proof.fromJSON(a.proof) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.index !== void 0 && (l.index = Math.round(a.index)), a.bytes !== void 0 && (l.bytes = (0, A.base64FromBytes)(a.bytes !== void 0 ? a.bytes : new Uint8Array())), a.proof !== void 0 && (l.proof = a.proof ? r.Proof.toJSON(a.proof) : void 0), l;
    },
    fromPartial(a) {
      const l = _();
      return l.index = a.index ?? 0, l.bytes = a.bytes ?? new Uint8Array(), l.proof = a.proof !== void 0 && a.proof !== null ? r.Proof.fromPartial(a.proof) : void 0, l;
    }
  };
  function d() {
    return {
      hash: new Uint8Array(),
      partSetHeader: void 0
    };
  }
  e.BlockID = {
    encode(a, l = T.Writer.create()) {
      return a.hash.length !== 0 && l.uint32(10).bytes(a.hash), a.partSetHeader !== void 0 && e.PartSetHeader.encode(a.partSetHeader, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = d();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.hash = C.bytes();
            break;
          case 2:
            k.partSetHeader = e.PartSetHeader.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        hash: (0, A.isSet)(a.hash) ? (0, A.bytesFromBase64)(a.hash) : new Uint8Array(),
        partSetHeader: (0, A.isSet)(a.partSetHeader) ? e.PartSetHeader.fromJSON(a.partSetHeader) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.hash !== void 0 && (l.hash = (0, A.base64FromBytes)(a.hash !== void 0 ? a.hash : new Uint8Array())), a.partSetHeader !== void 0 && (l.partSetHeader = a.partSetHeader ? e.PartSetHeader.toJSON(a.partSetHeader) : void 0), l;
    },
    fromPartial(a) {
      const l = d();
      return l.hash = a.hash ?? new Uint8Array(), l.partSetHeader = a.partSetHeader !== void 0 && a.partSetHeader !== null ? e.PartSetHeader.fromPartial(a.partSetHeader) : void 0, l;
    }
  };
  function p() {
    return {
      version: void 0,
      chainId: "",
      height: A.Long.ZERO,
      time: void 0,
      lastBlockId: void 0,
      lastCommitHash: new Uint8Array(),
      dataHash: new Uint8Array(),
      validatorsHash: new Uint8Array(),
      nextValidatorsHash: new Uint8Array(),
      consensusHash: new Uint8Array(),
      appHash: new Uint8Array(),
      lastResultsHash: new Uint8Array(),
      evidenceHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.Header = {
    encode(a, l = T.Writer.create()) {
      return a.version !== void 0 && u.Consensus.encode(a.version, l.uint32(10).fork()).ldelim(), a.chainId !== "" && l.uint32(18).string(a.chainId), a.height.isZero() || l.uint32(24).int64(a.height), a.time !== void 0 && f.Timestamp.encode(a.time, l.uint32(34).fork()).ldelim(), a.lastBlockId !== void 0 && e.BlockID.encode(a.lastBlockId, l.uint32(42).fork()).ldelim(), a.lastCommitHash.length !== 0 && l.uint32(50).bytes(a.lastCommitHash), a.dataHash.length !== 0 && l.uint32(58).bytes(a.dataHash), a.validatorsHash.length !== 0 && l.uint32(66).bytes(a.validatorsHash), a.nextValidatorsHash.length !== 0 && l.uint32(74).bytes(a.nextValidatorsHash), a.consensusHash.length !== 0 && l.uint32(82).bytes(a.consensusHash), a.appHash.length !== 0 && l.uint32(90).bytes(a.appHash), a.lastResultsHash.length !== 0 && l.uint32(98).bytes(a.lastResultsHash), a.evidenceHash.length !== 0 && l.uint32(106).bytes(a.evidenceHash), a.proposerAddress.length !== 0 && l.uint32(114).bytes(a.proposerAddress), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = p();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.version = u.Consensus.decode(C, C.uint32());
            break;
          case 2:
            k.chainId = C.string();
            break;
          case 3:
            k.height = C.int64();
            break;
          case 4:
            k.time = f.Timestamp.decode(C, C.uint32());
            break;
          case 5:
            k.lastBlockId = e.BlockID.decode(C, C.uint32());
            break;
          case 6:
            k.lastCommitHash = C.bytes();
            break;
          case 7:
            k.dataHash = C.bytes();
            break;
          case 8:
            k.validatorsHash = C.bytes();
            break;
          case 9:
            k.nextValidatorsHash = C.bytes();
            break;
          case 10:
            k.consensusHash = C.bytes();
            break;
          case 11:
            k.appHash = C.bytes();
            break;
          case 12:
            k.lastResultsHash = C.bytes();
            break;
          case 13:
            k.evidenceHash = C.bytes();
            break;
          case 14:
            k.proposerAddress = C.bytes();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        version: (0, A.isSet)(a.version) ? u.Consensus.fromJSON(a.version) : void 0,
        chainId: (0, A.isSet)(a.chainId) ? String(a.chainId) : "",
        height: (0, A.isSet)(a.height) ? A.Long.fromValue(a.height) : A.Long.ZERO,
        time: (0, A.isSet)(a.time) ? (0, A.fromJsonTimestamp)(a.time) : void 0,
        lastBlockId: (0, A.isSet)(a.lastBlockId) ? e.BlockID.fromJSON(a.lastBlockId) : void 0,
        lastCommitHash: (0, A.isSet)(a.lastCommitHash) ? (0, A.bytesFromBase64)(a.lastCommitHash) : new Uint8Array(),
        dataHash: (0, A.isSet)(a.dataHash) ? (0, A.bytesFromBase64)(a.dataHash) : new Uint8Array(),
        validatorsHash: (0, A.isSet)(a.validatorsHash) ? (0, A.bytesFromBase64)(a.validatorsHash) : new Uint8Array(),
        nextValidatorsHash: (0, A.isSet)(a.nextValidatorsHash) ? (0, A.bytesFromBase64)(a.nextValidatorsHash) : new Uint8Array(),
        consensusHash: (0, A.isSet)(a.consensusHash) ? (0, A.bytesFromBase64)(a.consensusHash) : new Uint8Array(),
        appHash: (0, A.isSet)(a.appHash) ? (0, A.bytesFromBase64)(a.appHash) : new Uint8Array(),
        lastResultsHash: (0, A.isSet)(a.lastResultsHash) ? (0, A.bytesFromBase64)(a.lastResultsHash) : new Uint8Array(),
        evidenceHash: (0, A.isSet)(a.evidenceHash) ? (0, A.bytesFromBase64)(a.evidenceHash) : new Uint8Array(),
        proposerAddress: (0, A.isSet)(a.proposerAddress) ? (0, A.bytesFromBase64)(a.proposerAddress) : new Uint8Array()
      };
    },
    toJSON(a) {
      const l = {};
      return a.version !== void 0 && (l.version = a.version ? u.Consensus.toJSON(a.version) : void 0), a.chainId !== void 0 && (l.chainId = a.chainId), a.height !== void 0 && (l.height = (a.height || A.Long.ZERO).toString()), a.time !== void 0 && (l.time = (0, A.fromTimestamp)(a.time).toISOString()), a.lastBlockId !== void 0 && (l.lastBlockId = a.lastBlockId ? e.BlockID.toJSON(a.lastBlockId) : void 0), a.lastCommitHash !== void 0 && (l.lastCommitHash = (0, A.base64FromBytes)(a.lastCommitHash !== void 0 ? a.lastCommitHash : new Uint8Array())), a.dataHash !== void 0 && (l.dataHash = (0, A.base64FromBytes)(a.dataHash !== void 0 ? a.dataHash : new Uint8Array())), a.validatorsHash !== void 0 && (l.validatorsHash = (0, A.base64FromBytes)(a.validatorsHash !== void 0 ? a.validatorsHash : new Uint8Array())), a.nextValidatorsHash !== void 0 && (l.nextValidatorsHash = (0, A.base64FromBytes)(a.nextValidatorsHash !== void 0 ? a.nextValidatorsHash : new Uint8Array())), a.consensusHash !== void 0 && (l.consensusHash = (0, A.base64FromBytes)(a.consensusHash !== void 0 ? a.consensusHash : new Uint8Array())), a.appHash !== void 0 && (l.appHash = (0, A.base64FromBytes)(a.appHash !== void 0 ? a.appHash : new Uint8Array())), a.lastResultsHash !== void 0 && (l.lastResultsHash = (0, A.base64FromBytes)(a.lastResultsHash !== void 0 ? a.lastResultsHash : new Uint8Array())), a.evidenceHash !== void 0 && (l.evidenceHash = (0, A.base64FromBytes)(a.evidenceHash !== void 0 ? a.evidenceHash : new Uint8Array())), a.proposerAddress !== void 0 && (l.proposerAddress = (0, A.base64FromBytes)(a.proposerAddress !== void 0 ? a.proposerAddress : new Uint8Array())), l;
    },
    fromPartial(a) {
      const l = p();
      return l.version = a.version !== void 0 && a.version !== null ? u.Consensus.fromPartial(a.version) : void 0, l.chainId = a.chainId ?? "", l.height = a.height !== void 0 && a.height !== null ? A.Long.fromValue(a.height) : A.Long.ZERO, l.time = a.time !== void 0 && a.time !== null ? f.Timestamp.fromPartial(a.time) : void 0, l.lastBlockId = a.lastBlockId !== void 0 && a.lastBlockId !== null ? e.BlockID.fromPartial(a.lastBlockId) : void 0, l.lastCommitHash = a.lastCommitHash ?? new Uint8Array(), l.dataHash = a.dataHash ?? new Uint8Array(), l.validatorsHash = a.validatorsHash ?? new Uint8Array(), l.nextValidatorsHash = a.nextValidatorsHash ?? new Uint8Array(), l.consensusHash = a.consensusHash ?? new Uint8Array(), l.appHash = a.appHash ?? new Uint8Array(), l.lastResultsHash = a.lastResultsHash ?? new Uint8Array(), l.evidenceHash = a.evidenceHash ?? new Uint8Array(), l.proposerAddress = a.proposerAddress ?? new Uint8Array(), l;
    }
  };
  function g() {
    return {
      txs: []
    };
  }
  e.Data = {
    encode(a, l = T.Writer.create()) {
      for (const C of a.txs)
        l.uint32(10).bytes(C);
      return l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = g();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.txs.push(C.bytes());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        txs: Array.isArray(a == null ? void 0 : a.txs) ? a.txs.map((l) => (0, A.bytesFromBase64)(l)) : []
      };
    },
    toJSON(a) {
      const l = {};
      return a.txs ? l.txs = a.txs.map((C) => (0, A.base64FromBytes)(C !== void 0 ? C : new Uint8Array())) : l.txs = [], l;
    },
    fromPartial(a) {
      var C;
      const l = g();
      return l.txs = ((C = a.txs) == null ? void 0 : C.map((v) => v)) || [], l;
    }
  };
  function J() {
    return {
      type: 0,
      height: A.Long.ZERO,
      round: 0,
      blockId: void 0,
      timestamp: void 0,
      validatorAddress: new Uint8Array(),
      validatorIndex: 0,
      signature: new Uint8Array()
    };
  }
  e.Vote = {
    encode(a, l = T.Writer.create()) {
      return a.type !== 0 && l.uint32(8).int32(a.type), a.height.isZero() || l.uint32(16).int64(a.height), a.round !== 0 && l.uint32(24).int32(a.round), a.blockId !== void 0 && e.BlockID.encode(a.blockId, l.uint32(34).fork()).ldelim(), a.timestamp !== void 0 && f.Timestamp.encode(a.timestamp, l.uint32(42).fork()).ldelim(), a.validatorAddress.length !== 0 && l.uint32(50).bytes(a.validatorAddress), a.validatorIndex !== 0 && l.uint32(56).int32(a.validatorIndex), a.signature.length !== 0 && l.uint32(66).bytes(a.signature), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = J();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.type = C.int32();
            break;
          case 2:
            k.height = C.int64();
            break;
          case 3:
            k.round = C.int32();
            break;
          case 4:
            k.blockId = e.BlockID.decode(C, C.uint32());
            break;
          case 5:
            k.timestamp = f.Timestamp.decode(C, C.uint32());
            break;
          case 6:
            k.validatorAddress = C.bytes();
            break;
          case 7:
            k.validatorIndex = C.int32();
            break;
          case 8:
            k.signature = C.bytes();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        type: (0, A.isSet)(a.type) ? b(a.type) : 0,
        height: (0, A.isSet)(a.height) ? A.Long.fromValue(a.height) : A.Long.ZERO,
        round: (0, A.isSet)(a.round) ? Number(a.round) : 0,
        blockId: (0, A.isSet)(a.blockId) ? e.BlockID.fromJSON(a.blockId) : void 0,
        timestamp: (0, A.isSet)(a.timestamp) ? (0, A.fromJsonTimestamp)(a.timestamp) : void 0,
        validatorAddress: (0, A.isSet)(a.validatorAddress) ? (0, A.bytesFromBase64)(a.validatorAddress) : new Uint8Array(),
        validatorIndex: (0, A.isSet)(a.validatorIndex) ? Number(a.validatorIndex) : 0,
        signature: (0, A.isSet)(a.signature) ? (0, A.bytesFromBase64)(a.signature) : new Uint8Array()
      };
    },
    toJSON(a) {
      const l = {};
      return a.type !== void 0 && (l.type = h(a.type)), a.height !== void 0 && (l.height = (a.height || A.Long.ZERO).toString()), a.round !== void 0 && (l.round = Math.round(a.round)), a.blockId !== void 0 && (l.blockId = a.blockId ? e.BlockID.toJSON(a.blockId) : void 0), a.timestamp !== void 0 && (l.timestamp = (0, A.fromTimestamp)(a.timestamp).toISOString()), a.validatorAddress !== void 0 && (l.validatorAddress = (0, A.base64FromBytes)(a.validatorAddress !== void 0 ? a.validatorAddress : new Uint8Array())), a.validatorIndex !== void 0 && (l.validatorIndex = Math.round(a.validatorIndex)), a.signature !== void 0 && (l.signature = (0, A.base64FromBytes)(a.signature !== void 0 ? a.signature : new Uint8Array())), l;
    },
    fromPartial(a) {
      const l = J();
      return l.type = a.type ?? 0, l.height = a.height !== void 0 && a.height !== null ? A.Long.fromValue(a.height) : A.Long.ZERO, l.round = a.round ?? 0, l.blockId = a.blockId !== void 0 && a.blockId !== null ? e.BlockID.fromPartial(a.blockId) : void 0, l.timestamp = a.timestamp !== void 0 && a.timestamp !== null ? f.Timestamp.fromPartial(a.timestamp) : void 0, l.validatorAddress = a.validatorAddress ?? new Uint8Array(), l.validatorIndex = a.validatorIndex ?? 0, l.signature = a.signature ?? new Uint8Array(), l;
    }
  };
  function B() {
    return {
      height: A.Long.ZERO,
      round: 0,
      blockId: void 0,
      signatures: []
    };
  }
  e.Commit = {
    encode(a, l = T.Writer.create()) {
      a.height.isZero() || l.uint32(8).int64(a.height), a.round !== 0 && l.uint32(16).int32(a.round), a.blockId !== void 0 && e.BlockID.encode(a.blockId, l.uint32(26).fork()).ldelim();
      for (const C of a.signatures)
        e.CommitSig.encode(C, l.uint32(34).fork()).ldelim();
      return l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = B();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.height = C.int64();
            break;
          case 2:
            k.round = C.int32();
            break;
          case 3:
            k.blockId = e.BlockID.decode(C, C.uint32());
            break;
          case 4:
            k.signatures.push(e.CommitSig.decode(C, C.uint32()));
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        height: (0, A.isSet)(a.height) ? A.Long.fromValue(a.height) : A.Long.ZERO,
        round: (0, A.isSet)(a.round) ? Number(a.round) : 0,
        blockId: (0, A.isSet)(a.blockId) ? e.BlockID.fromJSON(a.blockId) : void 0,
        signatures: Array.isArray(a == null ? void 0 : a.signatures) ? a.signatures.map((l) => e.CommitSig.fromJSON(l)) : []
      };
    },
    toJSON(a) {
      const l = {};
      return a.height !== void 0 && (l.height = (a.height || A.Long.ZERO).toString()), a.round !== void 0 && (l.round = Math.round(a.round)), a.blockId !== void 0 && (l.blockId = a.blockId ? e.BlockID.toJSON(a.blockId) : void 0), a.signatures ? l.signatures = a.signatures.map((C) => C ? e.CommitSig.toJSON(C) : void 0) : l.signatures = [], l;
    },
    fromPartial(a) {
      var C;
      const l = B();
      return l.height = a.height !== void 0 && a.height !== null ? A.Long.fromValue(a.height) : A.Long.ZERO, l.round = a.round ?? 0, l.blockId = a.blockId !== void 0 && a.blockId !== null ? e.BlockID.fromPartial(a.blockId) : void 0, l.signatures = ((C = a.signatures) == null ? void 0 : C.map((v) => e.CommitSig.fromPartial(v))) || [], l;
    }
  };
  function I() {
    return {
      blockIdFlag: 0,
      validatorAddress: new Uint8Array(),
      timestamp: void 0,
      signature: new Uint8Array()
    };
  }
  e.CommitSig = {
    encode(a, l = T.Writer.create()) {
      return a.blockIdFlag !== 0 && l.uint32(8).int32(a.blockIdFlag), a.validatorAddress.length !== 0 && l.uint32(18).bytes(a.validatorAddress), a.timestamp !== void 0 && f.Timestamp.encode(a.timestamp, l.uint32(26).fork()).ldelim(), a.signature.length !== 0 && l.uint32(34).bytes(a.signature), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = I();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.blockIdFlag = C.int32();
            break;
          case 2:
            k.validatorAddress = C.bytes();
            break;
          case 3:
            k.timestamp = f.Timestamp.decode(C, C.uint32());
            break;
          case 4:
            k.signature = C.bytes();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        blockIdFlag: (0, A.isSet)(a.blockIdFlag) ? M(a.blockIdFlag) : 0,
        validatorAddress: (0, A.isSet)(a.validatorAddress) ? (0, A.bytesFromBase64)(a.validatorAddress) : new Uint8Array(),
        timestamp: (0, A.isSet)(a.timestamp) ? (0, A.fromJsonTimestamp)(a.timestamp) : void 0,
        signature: (0, A.isSet)(a.signature) ? (0, A.bytesFromBase64)(a.signature) : new Uint8Array()
      };
    },
    toJSON(a) {
      const l = {};
      return a.blockIdFlag !== void 0 && (l.blockIdFlag = V(a.blockIdFlag)), a.validatorAddress !== void 0 && (l.validatorAddress = (0, A.base64FromBytes)(a.validatorAddress !== void 0 ? a.validatorAddress : new Uint8Array())), a.timestamp !== void 0 && (l.timestamp = (0, A.fromTimestamp)(a.timestamp).toISOString()), a.signature !== void 0 && (l.signature = (0, A.base64FromBytes)(a.signature !== void 0 ? a.signature : new Uint8Array())), l;
    },
    fromPartial(a) {
      const l = I();
      return l.blockIdFlag = a.blockIdFlag ?? 0, l.validatorAddress = a.validatorAddress ?? new Uint8Array(), l.timestamp = a.timestamp !== void 0 && a.timestamp !== null ? f.Timestamp.fromPartial(a.timestamp) : void 0, l.signature = a.signature ?? new Uint8Array(), l;
    }
  };
  function Z() {
    return {
      type: 0,
      height: A.Long.ZERO,
      round: 0,
      polRound: 0,
      blockId: void 0,
      timestamp: void 0,
      signature: new Uint8Array()
    };
  }
  e.Proposal = {
    encode(a, l = T.Writer.create()) {
      return a.type !== 0 && l.uint32(8).int32(a.type), a.height.isZero() || l.uint32(16).int64(a.height), a.round !== 0 && l.uint32(24).int32(a.round), a.polRound !== 0 && l.uint32(32).int32(a.polRound), a.blockId !== void 0 && e.BlockID.encode(a.blockId, l.uint32(42).fork()).ldelim(), a.timestamp !== void 0 && f.Timestamp.encode(a.timestamp, l.uint32(50).fork()).ldelim(), a.signature.length !== 0 && l.uint32(58).bytes(a.signature), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = Z();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.type = C.int32();
            break;
          case 2:
            k.height = C.int64();
            break;
          case 3:
            k.round = C.int32();
            break;
          case 4:
            k.polRound = C.int32();
            break;
          case 5:
            k.blockId = e.BlockID.decode(C, C.uint32());
            break;
          case 6:
            k.timestamp = f.Timestamp.decode(C, C.uint32());
            break;
          case 7:
            k.signature = C.bytes();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        type: (0, A.isSet)(a.type) ? b(a.type) : 0,
        height: (0, A.isSet)(a.height) ? A.Long.fromValue(a.height) : A.Long.ZERO,
        round: (0, A.isSet)(a.round) ? Number(a.round) : 0,
        polRound: (0, A.isSet)(a.polRound) ? Number(a.polRound) : 0,
        blockId: (0, A.isSet)(a.blockId) ? e.BlockID.fromJSON(a.blockId) : void 0,
        timestamp: (0, A.isSet)(a.timestamp) ? (0, A.fromJsonTimestamp)(a.timestamp) : void 0,
        signature: (0, A.isSet)(a.signature) ? (0, A.bytesFromBase64)(a.signature) : new Uint8Array()
      };
    },
    toJSON(a) {
      const l = {};
      return a.type !== void 0 && (l.type = h(a.type)), a.height !== void 0 && (l.height = (a.height || A.Long.ZERO).toString()), a.round !== void 0 && (l.round = Math.round(a.round)), a.polRound !== void 0 && (l.polRound = Math.round(a.polRound)), a.blockId !== void 0 && (l.blockId = a.blockId ? e.BlockID.toJSON(a.blockId) : void 0), a.timestamp !== void 0 && (l.timestamp = (0, A.fromTimestamp)(a.timestamp).toISOString()), a.signature !== void 0 && (l.signature = (0, A.base64FromBytes)(a.signature !== void 0 ? a.signature : new Uint8Array())), l;
    },
    fromPartial(a) {
      const l = Z();
      return l.type = a.type ?? 0, l.height = a.height !== void 0 && a.height !== null ? A.Long.fromValue(a.height) : A.Long.ZERO, l.round = a.round ?? 0, l.polRound = a.polRound ?? 0, l.blockId = a.blockId !== void 0 && a.blockId !== null ? e.BlockID.fromPartial(a.blockId) : void 0, l.timestamp = a.timestamp !== void 0 && a.timestamp !== null ? f.Timestamp.fromPartial(a.timestamp) : void 0, l.signature = a.signature ?? new Uint8Array(), l;
    }
  };
  function t() {
    return {
      header: void 0,
      commit: void 0
    };
  }
  e.SignedHeader = {
    encode(a, l = T.Writer.create()) {
      return a.header !== void 0 && e.Header.encode(a.header, l.uint32(10).fork()).ldelim(), a.commit !== void 0 && e.Commit.encode(a.commit, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = t();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.header = e.Header.decode(C, C.uint32());
            break;
          case 2:
            k.commit = e.Commit.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        header: (0, A.isSet)(a.header) ? e.Header.fromJSON(a.header) : void 0,
        commit: (0, A.isSet)(a.commit) ? e.Commit.fromJSON(a.commit) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.header !== void 0 && (l.header = a.header ? e.Header.toJSON(a.header) : void 0), a.commit !== void 0 && (l.commit = a.commit ? e.Commit.toJSON(a.commit) : void 0), l;
    },
    fromPartial(a) {
      const l = t();
      return l.header = a.header !== void 0 && a.header !== null ? e.Header.fromPartial(a.header) : void 0, l.commit = a.commit !== void 0 && a.commit !== null ? e.Commit.fromPartial(a.commit) : void 0, l;
    }
  };
  function y() {
    return {
      signedHeader: void 0,
      validatorSet: void 0
    };
  }
  e.LightBlock = {
    encode(a, l = T.Writer.create()) {
      return a.signedHeader !== void 0 && e.SignedHeader.encode(a.signedHeader, l.uint32(10).fork()).ldelim(), a.validatorSet !== void 0 && O.ValidatorSet.encode(a.validatorSet, l.uint32(18).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = y();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.signedHeader = e.SignedHeader.decode(C, C.uint32());
            break;
          case 2:
            k.validatorSet = O.ValidatorSet.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        signedHeader: (0, A.isSet)(a.signedHeader) ? e.SignedHeader.fromJSON(a.signedHeader) : void 0,
        validatorSet: (0, A.isSet)(a.validatorSet) ? O.ValidatorSet.fromJSON(a.validatorSet) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.signedHeader !== void 0 && (l.signedHeader = a.signedHeader ? e.SignedHeader.toJSON(a.signedHeader) : void 0), a.validatorSet !== void 0 && (l.validatorSet = a.validatorSet ? O.ValidatorSet.toJSON(a.validatorSet) : void 0), l;
    },
    fromPartial(a) {
      const l = y();
      return l.signedHeader = a.signedHeader !== void 0 && a.signedHeader !== null ? e.SignedHeader.fromPartial(a.signedHeader) : void 0, l.validatorSet = a.validatorSet !== void 0 && a.validatorSet !== null ? O.ValidatorSet.fromPartial(a.validatorSet) : void 0, l;
    }
  };
  function E() {
    return {
      blockId: void 0,
      blockSize: A.Long.ZERO,
      header: void 0,
      numTxs: A.Long.ZERO
    };
  }
  e.BlockMeta = {
    encode(a, l = T.Writer.create()) {
      return a.blockId !== void 0 && e.BlockID.encode(a.blockId, l.uint32(10).fork()).ldelim(), a.blockSize.isZero() || l.uint32(16).int64(a.blockSize), a.header !== void 0 && e.Header.encode(a.header, l.uint32(26).fork()).ldelim(), a.numTxs.isZero() || l.uint32(32).int64(a.numTxs), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = E();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.blockId = e.BlockID.decode(C, C.uint32());
            break;
          case 2:
            k.blockSize = C.int64();
            break;
          case 3:
            k.header = e.Header.decode(C, C.uint32());
            break;
          case 4:
            k.numTxs = C.int64();
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        blockId: (0, A.isSet)(a.blockId) ? e.BlockID.fromJSON(a.blockId) : void 0,
        blockSize: (0, A.isSet)(a.blockSize) ? A.Long.fromValue(a.blockSize) : A.Long.ZERO,
        header: (0, A.isSet)(a.header) ? e.Header.fromJSON(a.header) : void 0,
        numTxs: (0, A.isSet)(a.numTxs) ? A.Long.fromValue(a.numTxs) : A.Long.ZERO
      };
    },
    toJSON(a) {
      const l = {};
      return a.blockId !== void 0 && (l.blockId = a.blockId ? e.BlockID.toJSON(a.blockId) : void 0), a.blockSize !== void 0 && (l.blockSize = (a.blockSize || A.Long.ZERO).toString()), a.header !== void 0 && (l.header = a.header ? e.Header.toJSON(a.header) : void 0), a.numTxs !== void 0 && (l.numTxs = (a.numTxs || A.Long.ZERO).toString()), l;
    },
    fromPartial(a) {
      const l = E();
      return l.blockId = a.blockId !== void 0 && a.blockId !== null ? e.BlockID.fromPartial(a.blockId) : void 0, l.blockSize = a.blockSize !== void 0 && a.blockSize !== null ? A.Long.fromValue(a.blockSize) : A.Long.ZERO, l.header = a.header !== void 0 && a.header !== null ? e.Header.fromPartial(a.header) : void 0, l.numTxs = a.numTxs !== void 0 && a.numTxs !== null ? A.Long.fromValue(a.numTxs) : A.Long.ZERO, l;
    }
  };
  function H() {
    return {
      rootHash: new Uint8Array(),
      data: new Uint8Array(),
      proof: void 0
    };
  }
  e.TxProof = {
    encode(a, l = T.Writer.create()) {
      return a.rootHash.length !== 0 && l.uint32(10).bytes(a.rootHash), a.data.length !== 0 && l.uint32(18).bytes(a.data), a.proof !== void 0 && r.Proof.encode(a.proof, l.uint32(26).fork()).ldelim(), l;
    },
    decode(a, l) {
      const C = a instanceof T.Reader ? a : new T.Reader(a);
      let v = l === void 0 ? C.len : C.pos + l;
      const k = H();
      for (; C.pos < v; ) {
        const U = C.uint32();
        switch (U >>> 3) {
          case 1:
            k.rootHash = C.bytes();
            break;
          case 2:
            k.data = C.bytes();
            break;
          case 3:
            k.proof = r.Proof.decode(C, C.uint32());
            break;
          default:
            C.skipType(U & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(a) {
      return {
        rootHash: (0, A.isSet)(a.rootHash) ? (0, A.bytesFromBase64)(a.rootHash) : new Uint8Array(),
        data: (0, A.isSet)(a.data) ? (0, A.bytesFromBase64)(a.data) : new Uint8Array(),
        proof: (0, A.isSet)(a.proof) ? r.Proof.fromJSON(a.proof) : void 0
      };
    },
    toJSON(a) {
      const l = {};
      return a.rootHash !== void 0 && (l.rootHash = (0, A.base64FromBytes)(a.rootHash !== void 0 ? a.rootHash : new Uint8Array())), a.data !== void 0 && (l.data = (0, A.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), a.proof !== void 0 && (l.proof = a.proof ? r.Proof.toJSON(a.proof) : void 0), l;
    },
    fromPartial(a) {
      const l = H();
      return l.rootHash = a.rootHash ?? new Uint8Array(), l.data = a.data ?? new Uint8Array(), l.proof = a.proof !== void 0 && a.proof !== null ? r.Proof.fromPartial(a.proof) : void 0, l;
    }
  };
})(rt);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(d, p, g, J) {
    J === void 0 && (J = g);
    var B = Object.getOwnPropertyDescriptor(p, g);
    (!B || ("get" in B ? !p.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return p[g];
    } }), Object.defineProperty(d, J, B);
  } : function(d, p, g, J) {
    J === void 0 && (J = g), d[J] = p[g];
  }), c = G && G.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), i = G && G.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var g in d)
        g !== "default" && Object.prototype.hasOwnProperty.call(d, g) && n(p, d, g);
    return c(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Fraction = e.Header = e.Misbehaviour = e.ConsensusState = e.ClientState = e.protobufPackage = void 0;
  const r = en, u = In, f = ra, O = _e, A = je, T = rt, L = fi, M = oe, V = i(ie);
  e.protobufPackage = "ibc.lightclients.tendermint.v1";
  function D() {
    return {
      chainId: "",
      trustLevel: void 0,
      trustingPeriod: void 0,
      unbondingPeriod: void 0,
      maxClockDrift: void 0,
      frozenHeight: void 0,
      latestHeight: void 0,
      proofSpecs: [],
      upgradePath: [],
      allowUpdateAfterExpiry: !1,
      allowUpdateAfterMisbehaviour: !1
    };
  }
  e.ClientState = {
    encode(d, p = V.Writer.create()) {
      d.chainId !== "" && p.uint32(10).string(d.chainId), d.trustLevel !== void 0 && e.Fraction.encode(d.trustLevel, p.uint32(18).fork()).ldelim(), d.trustingPeriod !== void 0 && r.Duration.encode(d.trustingPeriod, p.uint32(26).fork()).ldelim(), d.unbondingPeriod !== void 0 && r.Duration.encode(d.unbondingPeriod, p.uint32(34).fork()).ldelim(), d.maxClockDrift !== void 0 && r.Duration.encode(d.maxClockDrift, p.uint32(42).fork()).ldelim(), d.frozenHeight !== void 0 && u.Height.encode(d.frozenHeight, p.uint32(50).fork()).ldelim(), d.latestHeight !== void 0 && u.Height.encode(d.latestHeight, p.uint32(58).fork()).ldelim();
      for (const g of d.proofSpecs)
        f.ProofSpec.encode(g, p.uint32(66).fork()).ldelim();
      for (const g of d.upgradePath)
        p.uint32(74).string(g);
      return d.allowUpdateAfterExpiry === !0 && p.uint32(80).bool(d.allowUpdateAfterExpiry), d.allowUpdateAfterMisbehaviour === !0 && p.uint32(88).bool(d.allowUpdateAfterMisbehaviour), p;
    },
    decode(d, p) {
      const g = d instanceof V.Reader ? d : new V.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = D();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.chainId = g.string();
            break;
          case 2:
            B.trustLevel = e.Fraction.decode(g, g.uint32());
            break;
          case 3:
            B.trustingPeriod = r.Duration.decode(g, g.uint32());
            break;
          case 4:
            B.unbondingPeriod = r.Duration.decode(g, g.uint32());
            break;
          case 5:
            B.maxClockDrift = r.Duration.decode(g, g.uint32());
            break;
          case 6:
            B.frozenHeight = u.Height.decode(g, g.uint32());
            break;
          case 7:
            B.latestHeight = u.Height.decode(g, g.uint32());
            break;
          case 8:
            B.proofSpecs.push(f.ProofSpec.decode(g, g.uint32()));
            break;
          case 9:
            B.upgradePath.push(g.string());
            break;
          case 10:
            B.allowUpdateAfterExpiry = g.bool();
            break;
          case 11:
            B.allowUpdateAfterMisbehaviour = g.bool();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        chainId: (0, M.isSet)(d.chainId) ? String(d.chainId) : "",
        trustLevel: (0, M.isSet)(d.trustLevel) ? e.Fraction.fromJSON(d.trustLevel) : void 0,
        trustingPeriod: (0, M.isSet)(d.trustingPeriod) ? r.Duration.fromJSON(d.trustingPeriod) : void 0,
        unbondingPeriod: (0, M.isSet)(d.unbondingPeriod) ? r.Duration.fromJSON(d.unbondingPeriod) : void 0,
        maxClockDrift: (0, M.isSet)(d.maxClockDrift) ? r.Duration.fromJSON(d.maxClockDrift) : void 0,
        frozenHeight: (0, M.isSet)(d.frozenHeight) ? u.Height.fromJSON(d.frozenHeight) : void 0,
        latestHeight: (0, M.isSet)(d.latestHeight) ? u.Height.fromJSON(d.latestHeight) : void 0,
        proofSpecs: Array.isArray(d == null ? void 0 : d.proofSpecs) ? d.proofSpecs.map((p) => f.ProofSpec.fromJSON(p)) : [],
        upgradePath: Array.isArray(d == null ? void 0 : d.upgradePath) ? d.upgradePath.map((p) => String(p)) : [],
        allowUpdateAfterExpiry: (0, M.isSet)(d.allowUpdateAfterExpiry) ? !!d.allowUpdateAfterExpiry : !1,
        allowUpdateAfterMisbehaviour: (0, M.isSet)(d.allowUpdateAfterMisbehaviour) ? !!d.allowUpdateAfterMisbehaviour : !1
      };
    },
    toJSON(d) {
      const p = {};
      return d.chainId !== void 0 && (p.chainId = d.chainId), d.trustLevel !== void 0 && (p.trustLevel = d.trustLevel ? e.Fraction.toJSON(d.trustLevel) : void 0), d.trustingPeriod !== void 0 && (p.trustingPeriod = d.trustingPeriod ? r.Duration.toJSON(d.trustingPeriod) : void 0), d.unbondingPeriod !== void 0 && (p.unbondingPeriod = d.unbondingPeriod ? r.Duration.toJSON(d.unbondingPeriod) : void 0), d.maxClockDrift !== void 0 && (p.maxClockDrift = d.maxClockDrift ? r.Duration.toJSON(d.maxClockDrift) : void 0), d.frozenHeight !== void 0 && (p.frozenHeight = d.frozenHeight ? u.Height.toJSON(d.frozenHeight) : void 0), d.latestHeight !== void 0 && (p.latestHeight = d.latestHeight ? u.Height.toJSON(d.latestHeight) : void 0), d.proofSpecs ? p.proofSpecs = d.proofSpecs.map((g) => g ? f.ProofSpec.toJSON(g) : void 0) : p.proofSpecs = [], d.upgradePath ? p.upgradePath = d.upgradePath.map((g) => g) : p.upgradePath = [], d.allowUpdateAfterExpiry !== void 0 && (p.allowUpdateAfterExpiry = d.allowUpdateAfterExpiry), d.allowUpdateAfterMisbehaviour !== void 0 && (p.allowUpdateAfterMisbehaviour = d.allowUpdateAfterMisbehaviour), p;
    },
    fromPartial(d) {
      var g, J;
      const p = D();
      return p.chainId = d.chainId ?? "", p.trustLevel = d.trustLevel !== void 0 && d.trustLevel !== null ? e.Fraction.fromPartial(d.trustLevel) : void 0, p.trustingPeriod = d.trustingPeriod !== void 0 && d.trustingPeriod !== null ? r.Duration.fromPartial(d.trustingPeriod) : void 0, p.unbondingPeriod = d.unbondingPeriod !== void 0 && d.unbondingPeriod !== null ? r.Duration.fromPartial(d.unbondingPeriod) : void 0, p.maxClockDrift = d.maxClockDrift !== void 0 && d.maxClockDrift !== null ? r.Duration.fromPartial(d.maxClockDrift) : void 0, p.frozenHeight = d.frozenHeight !== void 0 && d.frozenHeight !== null ? u.Height.fromPartial(d.frozenHeight) : void 0, p.latestHeight = d.latestHeight !== void 0 && d.latestHeight !== null ? u.Height.fromPartial(d.latestHeight) : void 0, p.proofSpecs = ((g = d.proofSpecs) == null ? void 0 : g.map((B) => f.ProofSpec.fromPartial(B))) || [], p.upgradePath = ((J = d.upgradePath) == null ? void 0 : J.map((B) => B)) || [], p.allowUpdateAfterExpiry = d.allowUpdateAfterExpiry ?? !1, p.allowUpdateAfterMisbehaviour = d.allowUpdateAfterMisbehaviour ?? !1, p;
    }
  };
  function b() {
    return {
      timestamp: void 0,
      root: void 0,
      nextValidatorsHash: new Uint8Array()
    };
  }
  e.ConsensusState = {
    encode(d, p = V.Writer.create()) {
      return d.timestamp !== void 0 && O.Timestamp.encode(d.timestamp, p.uint32(10).fork()).ldelim(), d.root !== void 0 && A.MerkleRoot.encode(d.root, p.uint32(18).fork()).ldelim(), d.nextValidatorsHash.length !== 0 && p.uint32(26).bytes(d.nextValidatorsHash), p;
    },
    decode(d, p) {
      const g = d instanceof V.Reader ? d : new V.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = b();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.timestamp = O.Timestamp.decode(g, g.uint32());
            break;
          case 2:
            B.root = A.MerkleRoot.decode(g, g.uint32());
            break;
          case 3:
            B.nextValidatorsHash = g.bytes();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        timestamp: (0, M.isSet)(d.timestamp) ? (0, M.fromJsonTimestamp)(d.timestamp) : void 0,
        root: (0, M.isSet)(d.root) ? A.MerkleRoot.fromJSON(d.root) : void 0,
        nextValidatorsHash: (0, M.isSet)(d.nextValidatorsHash) ? (0, M.bytesFromBase64)(d.nextValidatorsHash) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.timestamp !== void 0 && (p.timestamp = (0, M.fromTimestamp)(d.timestamp).toISOString()), d.root !== void 0 && (p.root = d.root ? A.MerkleRoot.toJSON(d.root) : void 0), d.nextValidatorsHash !== void 0 && (p.nextValidatorsHash = (0, M.base64FromBytes)(d.nextValidatorsHash !== void 0 ? d.nextValidatorsHash : new Uint8Array())), p;
    },
    fromPartial(d) {
      const p = b();
      return p.timestamp = d.timestamp !== void 0 && d.timestamp !== null ? O.Timestamp.fromPartial(d.timestamp) : void 0, p.root = d.root !== void 0 && d.root !== null ? A.MerkleRoot.fromPartial(d.root) : void 0, p.nextValidatorsHash = d.nextValidatorsHash ?? new Uint8Array(), p;
    }
  };
  function h() {
    return {
      clientId: "",
      header1: void 0,
      header2: void 0
    };
  }
  e.Misbehaviour = {
    encode(d, p = V.Writer.create()) {
      return d.clientId !== "" && p.uint32(10).string(d.clientId), d.header1 !== void 0 && e.Header.encode(d.header1, p.uint32(18).fork()).ldelim(), d.header2 !== void 0 && e.Header.encode(d.header2, p.uint32(26).fork()).ldelim(), p;
    },
    decode(d, p) {
      const g = d instanceof V.Reader ? d : new V.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = h();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.clientId = g.string();
            break;
          case 2:
            B.header1 = e.Header.decode(g, g.uint32());
            break;
          case 3:
            B.header2 = e.Header.decode(g, g.uint32());
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        clientId: (0, M.isSet)(d.clientId) ? String(d.clientId) : "",
        header1: (0, M.isSet)(d.header1) ? e.Header.fromJSON(d.header1) : void 0,
        header2: (0, M.isSet)(d.header2) ? e.Header.fromJSON(d.header2) : void 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.clientId !== void 0 && (p.clientId = d.clientId), d.header1 !== void 0 && (p.header1 = d.header1 ? e.Header.toJSON(d.header1) : void 0), d.header2 !== void 0 && (p.header2 = d.header2 ? e.Header.toJSON(d.header2) : void 0), p;
    },
    fromPartial(d) {
      const p = h();
      return p.clientId = d.clientId ?? "", p.header1 = d.header1 !== void 0 && d.header1 !== null ? e.Header.fromPartial(d.header1) : void 0, p.header2 = d.header2 !== void 0 && d.header2 !== null ? e.Header.fromPartial(d.header2) : void 0, p;
    }
  };
  function S() {
    return {
      signedHeader: void 0,
      validatorSet: void 0,
      trustedHeight: void 0,
      trustedValidators: void 0
    };
  }
  e.Header = {
    encode(d, p = V.Writer.create()) {
      return d.signedHeader !== void 0 && T.SignedHeader.encode(d.signedHeader, p.uint32(10).fork()).ldelim(), d.validatorSet !== void 0 && L.ValidatorSet.encode(d.validatorSet, p.uint32(18).fork()).ldelim(), d.trustedHeight !== void 0 && u.Height.encode(d.trustedHeight, p.uint32(26).fork()).ldelim(), d.trustedValidators !== void 0 && L.ValidatorSet.encode(d.trustedValidators, p.uint32(34).fork()).ldelim(), p;
    },
    decode(d, p) {
      const g = d instanceof V.Reader ? d : new V.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = S();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.signedHeader = T.SignedHeader.decode(g, g.uint32());
            break;
          case 2:
            B.validatorSet = L.ValidatorSet.decode(g, g.uint32());
            break;
          case 3:
            B.trustedHeight = u.Height.decode(g, g.uint32());
            break;
          case 4:
            B.trustedValidators = L.ValidatorSet.decode(g, g.uint32());
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        signedHeader: (0, M.isSet)(d.signedHeader) ? T.SignedHeader.fromJSON(d.signedHeader) : void 0,
        validatorSet: (0, M.isSet)(d.validatorSet) ? L.ValidatorSet.fromJSON(d.validatorSet) : void 0,
        trustedHeight: (0, M.isSet)(d.trustedHeight) ? u.Height.fromJSON(d.trustedHeight) : void 0,
        trustedValidators: (0, M.isSet)(d.trustedValidators) ? L.ValidatorSet.fromJSON(d.trustedValidators) : void 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.signedHeader !== void 0 && (p.signedHeader = d.signedHeader ? T.SignedHeader.toJSON(d.signedHeader) : void 0), d.validatorSet !== void 0 && (p.validatorSet = d.validatorSet ? L.ValidatorSet.toJSON(d.validatorSet) : void 0), d.trustedHeight !== void 0 && (p.trustedHeight = d.trustedHeight ? u.Height.toJSON(d.trustedHeight) : void 0), d.trustedValidators !== void 0 && (p.trustedValidators = d.trustedValidators ? L.ValidatorSet.toJSON(d.trustedValidators) : void 0), p;
    },
    fromPartial(d) {
      const p = S();
      return p.signedHeader = d.signedHeader !== void 0 && d.signedHeader !== null ? T.SignedHeader.fromPartial(d.signedHeader) : void 0, p.validatorSet = d.validatorSet !== void 0 && d.validatorSet !== null ? L.ValidatorSet.fromPartial(d.validatorSet) : void 0, p.trustedHeight = d.trustedHeight !== void 0 && d.trustedHeight !== null ? u.Height.fromPartial(d.trustedHeight) : void 0, p.trustedValidators = d.trustedValidators !== void 0 && d.trustedValidators !== null ? L.ValidatorSet.fromPartial(d.trustedValidators) : void 0, p;
    }
  };
  function _() {
    return {
      numerator: M.Long.UZERO,
      denominator: M.Long.UZERO
    };
  }
  e.Fraction = {
    encode(d, p = V.Writer.create()) {
      return d.numerator.isZero() || p.uint32(8).uint64(d.numerator), d.denominator.isZero() || p.uint32(16).uint64(d.denominator), p;
    },
    decode(d, p) {
      const g = d instanceof V.Reader ? d : new V.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = _();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.numerator = g.uint64();
            break;
          case 2:
            B.denominator = g.uint64();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        numerator: (0, M.isSet)(d.numerator) ? M.Long.fromValue(d.numerator) : M.Long.UZERO,
        denominator: (0, M.isSet)(d.denominator) ? M.Long.fromValue(d.denominator) : M.Long.UZERO
      };
    },
    toJSON(d) {
      const p = {};
      return d.numerator !== void 0 && (p.numerator = (d.numerator || M.Long.UZERO).toString()), d.denominator !== void 0 && (p.denominator = (d.denominator || M.Long.UZERO).toString()), p;
    },
    fromPartial(d) {
      const p = _();
      return p.numerator = d.numerator !== void 0 && d.numerator !== null ? M.Long.fromValue(d.numerator) : M.Long.UZERO, p.denominator = d.denominator !== void 0 && d.denominator !== null ? M.Long.fromValue(d.denominator) : M.Long.UZERO, p;
    }
  };
})(Bu);
var Fh = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(li, "__esModule", { value: !0 });
li.setupIbcExtension = void 0;
const Sr = Ve, Gh = _n, $h = Cu, Kh = ci, to = Iu, ro = wu, Ws = bu, Ju = Bu, Nn = Fh(An), Pe = Le;
function io(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return Ju.ClientState.decode(e.value);
}
function zh(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return Ju.ConsensusState.decode(e.value);
}
function Yh(e) {
  const n = (0, Pe.createProtobufRpcClient)(e), c = new to.QueryClientImpl(n), i = new ro.QueryClientImpl(n), r = new Ws.QueryClientImpl(n), u = new $h.QueryClientImpl(n);
  return {
    ibc: {
      channel: {
        channel: async (f, O) => c.Channel({
          portId: f,
          channelId: O
        }),
        channels: async (f) => c.Channels({
          pagination: (0, Pe.createPagination)(f)
        }),
        allChannels: async () => {
          var T;
          const f = [];
          let O, A;
          do
            O = await c.Channels({
              pagination: (0, Pe.createPagination)(A)
            }), f.push(...O.channels), A = (T = O.pagination) == null ? void 0 : T.nextKey;
          while (A && A.length);
          return {
            channels: f,
            height: O.height
          };
        },
        connectionChannels: async (f, O) => c.ConnectionChannels({
          connection: f,
          pagination: (0, Pe.createPagination)(O)
        }),
        allConnectionChannels: async (f) => {
          var L;
          const O = [];
          let A, T;
          do
            A = await c.ConnectionChannels({
              connection: f,
              pagination: (0, Pe.createPagination)(T)
            }), O.push(...A.channels), T = (L = A.pagination) == null ? void 0 : L.nextKey;
          while (T && T.length);
          return {
            channels: O,
            height: A.height
          };
        },
        clientState: async (f, O) => c.ChannelClientState({
          portId: f,
          channelId: O
        }),
        consensusState: async (f, O, A, T) => c.ChannelConsensusState({
          portId: f,
          channelId: O,
          revisionNumber: Nn.default.fromNumber(A, !0),
          revisionHeight: Nn.default.fromNumber(T, !0)
        }),
        packetCommitment: async (f, O, A) => c.PacketCommitment({
          portId: f,
          channelId: O,
          sequence: Nn.default.fromNumber(A, !0)
        }),
        packetCommitments: async (f, O, A) => c.PacketCommitments({
          channelId: O,
          portId: f,
          pagination: (0, Pe.createPagination)(A)
        }),
        allPacketCommitments: async (f, O) => {
          var M;
          const A = [];
          let T, L;
          do
            T = await c.PacketCommitments({
              channelId: O,
              portId: f,
              pagination: (0, Pe.createPagination)(L)
            }), A.push(...T.commitments), L = (M = T.pagination) == null ? void 0 : M.nextKey;
          while (L && L.length);
          return {
            commitments: A,
            height: T.height
          };
        },
        packetReceipt: async (f, O, A) => c.PacketReceipt({
          portId: f,
          channelId: O,
          sequence: Nn.default.fromNumber(A, !0)
        }),
        packetAcknowledgement: async (f, O, A) => c.PacketAcknowledgement({
          portId: f,
          channelId: O,
          sequence: Nn.default.fromNumber(A, !0)
        }),
        packetAcknowledgements: async (f, O, A) => {
          const T = to.QueryPacketAcknowledgementsRequest.fromPartial({
            portId: f,
            channelId: O,
            pagination: (0, Pe.createPagination)(A)
          });
          return c.PacketAcknowledgements(T);
        },
        allPacketAcknowledgements: async (f, O) => {
          var M;
          const A = [];
          let T, L;
          do {
            const V = to.QueryPacketAcknowledgementsRequest.fromPartial({
              channelId: O,
              portId: f,
              pagination: (0, Pe.createPagination)(L)
            });
            T = await c.PacketAcknowledgements(V), A.push(...T.acknowledgements), L = (M = T.pagination) == null ? void 0 : M.nextKey;
          } while (L && L.length);
          return {
            acknowledgements: A,
            height: T.height
          };
        },
        unreceivedPackets: async (f, O, A) => c.UnreceivedPackets({
          portId: f,
          channelId: O,
          packetCommitmentSequences: A.map((T) => Nn.default.fromNumber(T, !0))
        }),
        unreceivedAcks: async (f, O, A) => c.UnreceivedAcks({
          portId: f,
          channelId: O,
          packetAckSequences: A.map((T) => Nn.default.fromNumber(T, !0))
        }),
        nextSequenceReceive: async (f, O) => c.NextSequenceReceive({
          portId: f,
          channelId: O
        })
      },
      client: {
        state: async (f) => i.ClientState({ clientId: f }),
        states: async (f) => i.ClientStates({
          pagination: (0, Pe.createPagination)(f)
        }),
        allStates: async () => {
          var T;
          const f = [];
          let O, A;
          do
            O = await i.ClientStates({
              pagination: (0, Pe.createPagination)(A)
            }), f.push(...O.clientStates), A = (T = O.pagination) == null ? void 0 : T.nextKey;
          while (A && A.length);
          return {
            clientStates: f
          };
        },
        consensusState: async (f, O) => i.ConsensusState(ro.QueryConsensusStateRequest.fromPartial({
          clientId: f,
          revisionHeight: O !== void 0 ? Nn.default.fromNumber(O, !0) : void 0,
          latestHeight: O === void 0
        })),
        consensusStates: async (f, O) => i.ConsensusStates({
          clientId: f,
          pagination: (0, Pe.createPagination)(O)
        }),
        allConsensusStates: async (f) => {
          var L;
          const O = [];
          let A, T;
          do
            A = await i.ConsensusStates({
              clientId: f,
              pagination: (0, Pe.createPagination)(T)
            }), O.push(...A.consensusStates), T = (L = A.pagination) == null ? void 0 : L.nextKey;
          while (T && T.length);
          return {
            consensusStates: O
          };
        },
        params: async () => i.ClientParams({}),
        stateTm: async (f) => {
          const O = await i.ClientState({ clientId: f });
          return io(O.clientState);
        },
        statesTm: async (f) => {
          const { clientStates: O } = await i.ClientStates({
            pagination: (0, Pe.createPagination)(f)
          });
          return O.map(({ clientState: A }) => io(A));
        },
        allStatesTm: async () => {
          var T;
          const f = [];
          let O, A;
          do
            O = await i.ClientStates({
              pagination: (0, Pe.createPagination)(A)
            }), f.push(...O.clientStates), A = (T = O.pagination) == null ? void 0 : T.nextKey;
          while (A && A.length);
          return f.map(({ clientState: L }) => io(L));
        },
        consensusStateTm: async (f, O) => {
          const A = await i.ConsensusState(ro.QueryConsensusStateRequest.fromPartial({
            clientId: f,
            revisionHeight: O == null ? void 0 : O.revisionHeight,
            revisionNumber: O == null ? void 0 : O.revisionNumber,
            latestHeight: O === void 0
          }));
          return zh(A.consensusState);
        }
      },
      connection: {
        connection: async (f) => r.Connection({
          connectionId: f
        }),
        connections: async (f) => r.Connections({
          pagination: (0, Pe.createPagination)(f)
        }),
        allConnections: async () => {
          var T;
          const f = [];
          let O, A;
          do
            O = await r.Connections({
              pagination: (0, Pe.createPagination)(A)
            }), f.push(...O.connections), A = (T = O.pagination) == null ? void 0 : T.nextKey;
          while (A && A.length);
          return {
            connections: f,
            height: O.height
          };
        },
        clientConnections: async (f) => r.ClientConnections({
          clientId: f
        }),
        clientState: async (f) => r.ConnectionClientState({
          connectionId: f
        }),
        consensusState: async (f, O) => r.ConnectionConsensusState(Ws.QueryConnectionConsensusStateRequest.fromPartial({
          connectionId: f,
          revisionHeight: Nn.default.fromNumber(O, !0)
        }))
      },
      transfer: {
        denomTrace: async (f) => u.DenomTrace({ hash: f }),
        denomTraces: async (f) => u.DenomTraces({
          pagination: (0, Pe.createPagination)(f)
        }),
        allDenomTraces: async () => {
          var T;
          const f = [];
          let O, A;
          do
            O = await u.DenomTraces({
              pagination: (0, Pe.createPagination)(A)
            }), f.push(...O.denomTraces), A = (T = O.pagination) == null ? void 0 : T.nextKey;
          while (A && A.length);
          return {
            denomTraces: f
          };
        },
        params: async () => u.Params({})
      },
      verified: {
        channel: {
          channel: async (f, O) => {
            const A = (0, Sr.toAscii)(`channelEnds/ports/${f}/channels/${O}`), { value: T } = await e.queryStoreVerified("ibc", A);
            return T.length ? Kh.Channel.decode(T) : null;
          },
          packetCommitment: async (f, O, A) => {
            const T = (0, Sr.toAscii)(`commitments/ports/${f}/channels/${O}/packets/${A}`), { value: L } = await e.queryStoreVerified("ibc", T);
            return L;
          },
          packetAcknowledgement: async (f, O, A) => {
            const T = (0, Sr.toAscii)(`acks/ports/${f}/channels/${O}/acknowledgements/${A}`), { value: L } = await e.queryStoreVerified("ibc", T);
            return L;
          },
          nextSequenceReceive: async (f, O) => {
            const A = (0, Sr.toAscii)(`seqAcks/ports/${f}/channels/${O}/nextSequenceAck`), { value: T } = await e.queryStoreVerified("ibc", A);
            return T.length ? Gh.Uint64.fromBytes(T).toNumber() : null;
          }
        }
      }
    }
  };
}
li.setupIbcExtension = Yh;
var pi = {}, Du = {}, qn = {}, Xh = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), xh = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), jh = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && Xh(n, e, c);
  return xh(n, e), n;
};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.Params = qn.Minter = qn.protobufPackage = void 0;
const Qe = oe, vt = jh(ie);
qn.protobufPackage = "cosmos.mint.v1beta1";
function Zs() {
  return {
    inflation: "",
    annualProvisions: ""
  };
}
qn.Minter = {
  encode(e, n = vt.Writer.create()) {
    return e.inflation !== "" && n.uint32(10).string(e.inflation), e.annualProvisions !== "" && n.uint32(18).string(e.annualProvisions), n;
  },
  decode(e, n) {
    const c = e instanceof vt.Reader ? e : new vt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Zs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.inflation = c.string();
          break;
        case 2:
          r.annualProvisions = c.string();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      inflation: (0, Qe.isSet)(e.inflation) ? String(e.inflation) : "",
      annualProvisions: (0, Qe.isSet)(e.annualProvisions) ? String(e.annualProvisions) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.inflation !== void 0 && (n.inflation = e.inflation), e.annualProvisions !== void 0 && (n.annualProvisions = e.annualProvisions), n;
  },
  fromPartial(e) {
    const n = Zs();
    return n.inflation = e.inflation ?? "", n.annualProvisions = e.annualProvisions ?? "", n;
  }
};
function Qs() {
  return {
    mintDenom: "",
    inflationRateChange: "",
    inflationMax: "",
    inflationMin: "",
    goalBonded: "",
    blocksPerYear: Qe.Long.UZERO
  };
}
qn.Params = {
  encode(e, n = vt.Writer.create()) {
    return e.mintDenom !== "" && n.uint32(10).string(e.mintDenom), e.inflationRateChange !== "" && n.uint32(18).string(e.inflationRateChange), e.inflationMax !== "" && n.uint32(26).string(e.inflationMax), e.inflationMin !== "" && n.uint32(34).string(e.inflationMin), e.goalBonded !== "" && n.uint32(42).string(e.goalBonded), e.blocksPerYear.isZero() || n.uint32(48).uint64(e.blocksPerYear), n;
  },
  decode(e, n) {
    const c = e instanceof vt.Reader ? e : new vt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Qs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.mintDenom = c.string();
          break;
        case 2:
          r.inflationRateChange = c.string();
          break;
        case 3:
          r.inflationMax = c.string();
          break;
        case 4:
          r.inflationMin = c.string();
          break;
        case 5:
          r.goalBonded = c.string();
          break;
        case 6:
          r.blocksPerYear = c.uint64();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      mintDenom: (0, Qe.isSet)(e.mintDenom) ? String(e.mintDenom) : "",
      inflationRateChange: (0, Qe.isSet)(e.inflationRateChange) ? String(e.inflationRateChange) : "",
      inflationMax: (0, Qe.isSet)(e.inflationMax) ? String(e.inflationMax) : "",
      inflationMin: (0, Qe.isSet)(e.inflationMin) ? String(e.inflationMin) : "",
      goalBonded: (0, Qe.isSet)(e.goalBonded) ? String(e.goalBonded) : "",
      blocksPerYear: (0, Qe.isSet)(e.blocksPerYear) ? Qe.Long.fromValue(e.blocksPerYear) : Qe.Long.UZERO
    };
  },
  toJSON(e) {
    const n = {};
    return e.mintDenom !== void 0 && (n.mintDenom = e.mintDenom), e.inflationRateChange !== void 0 && (n.inflationRateChange = e.inflationRateChange), e.inflationMax !== void 0 && (n.inflationMax = e.inflationMax), e.inflationMin !== void 0 && (n.inflationMin = e.inflationMin), e.goalBonded !== void 0 && (n.goalBonded = e.goalBonded), e.blocksPerYear !== void 0 && (n.blocksPerYear = (e.blocksPerYear || Qe.Long.UZERO).toString()), n;
  },
  fromPartial(e) {
    const n = Qs();
    return n.mintDenom = e.mintDenom ?? "", n.inflationRateChange = e.inflationRateChange ?? "", n.inflationMax = e.inflationMax ?? "", n.inflationMin = e.inflationMin ?? "", n.goalBonded = e.goalBonded ?? "", n.blocksPerYear = e.blocksPerYear !== void 0 && e.blocksPerYear !== null ? Qe.Long.fromValue(e.blocksPerYear) : Qe.Long.UZERO, n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(b, h, S, _) {
    _ === void 0 && (_ = S);
    var d = Object.getOwnPropertyDescriptor(h, S);
    (!d || ("get" in d ? !h.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return h[S];
    } }), Object.defineProperty(b, _, d);
  } : function(b, h, S, _) {
    _ === void 0 && (_ = S), b[_] = h[S];
  }), c = G && G.__setModuleDefault || (Object.create ? function(b, h) {
    Object.defineProperty(b, "default", { enumerable: !0, value: h });
  } : function(b, h) {
    b.default = h;
  }), i = G && G.__importStar || function(b) {
    if (b && b.__esModule)
      return b;
    var h = {};
    if (b != null)
      for (var S in b)
        S !== "default" && Object.prototype.hasOwnProperty.call(b, S) && n(h, b, S);
    return c(h, b), h;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAnnualProvisionsResponse = e.QueryAnnualProvisionsRequest = e.QueryInflationResponse = e.QueryInflationRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const r = qn, u = i(ie), f = oe;
  e.protobufPackage = "cosmos.mint.v1beta1";
  function O() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(b, h = u.Writer.create()) {
      return h;
    },
    decode(b, h) {
      const S = b instanceof u.Reader ? b : new u.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = O();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return O();
    }
  };
  function A() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(b, h = u.Writer.create()) {
      return b.params !== void 0 && r.Params.encode(b.params, h.uint32(10).fork()).ldelim(), h;
    },
    decode(b, h) {
      const S = b instanceof u.Reader ? b : new u.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = A();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.params = r.Params.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        params: (0, f.isSet)(b.params) ? r.Params.fromJSON(b.params) : void 0
      };
    },
    toJSON(b) {
      const h = {};
      return b.params !== void 0 && (h.params = b.params ? r.Params.toJSON(b.params) : void 0), h;
    },
    fromPartial(b) {
      const h = A();
      return h.params = b.params !== void 0 && b.params !== null ? r.Params.fromPartial(b.params) : void 0, h;
    }
  };
  function T() {
    return {};
  }
  e.QueryInflationRequest = {
    encode(b, h = u.Writer.create()) {
      return h;
    },
    decode(b, h) {
      const S = b instanceof u.Reader ? b : new u.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = T();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return T();
    }
  };
  function L() {
    return {
      inflation: new Uint8Array()
    };
  }
  e.QueryInflationResponse = {
    encode(b, h = u.Writer.create()) {
      return b.inflation.length !== 0 && h.uint32(10).bytes(b.inflation), h;
    },
    decode(b, h) {
      const S = b instanceof u.Reader ? b : new u.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = L();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.inflation = S.bytes();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        inflation: (0, f.isSet)(b.inflation) ? (0, f.bytesFromBase64)(b.inflation) : new Uint8Array()
      };
    },
    toJSON(b) {
      const h = {};
      return b.inflation !== void 0 && (h.inflation = (0, f.base64FromBytes)(b.inflation !== void 0 ? b.inflation : new Uint8Array())), h;
    },
    fromPartial(b) {
      const h = L();
      return h.inflation = b.inflation ?? new Uint8Array(), h;
    }
  };
  function M() {
    return {};
  }
  e.QueryAnnualProvisionsRequest = {
    encode(b, h = u.Writer.create()) {
      return h;
    },
    decode(b, h) {
      const S = b instanceof u.Reader ? b : new u.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = M();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {};
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return M();
    }
  };
  function V() {
    return {
      annualProvisions: new Uint8Array()
    };
  }
  e.QueryAnnualProvisionsResponse = {
    encode(b, h = u.Writer.create()) {
      return b.annualProvisions.length !== 0 && h.uint32(10).bytes(b.annualProvisions), h;
    },
    decode(b, h) {
      const S = b instanceof u.Reader ? b : new u.Reader(b);
      let _ = h === void 0 ? S.len : S.pos + h;
      const d = V();
      for (; S.pos < _; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.annualProvisions = S.bytes();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(b) {
      return {
        annualProvisions: (0, f.isSet)(b.annualProvisions) ? (0, f.bytesFromBase64)(b.annualProvisions) : new Uint8Array()
      };
    },
    toJSON(b) {
      const h = {};
      return b.annualProvisions !== void 0 && (h.annualProvisions = (0, f.base64FromBytes)(b.annualProvisions !== void 0 ? b.annualProvisions : new Uint8Array())), h;
    },
    fromPartial(b) {
      const h = V();
      return h.annualProvisions = b.annualProvisions ?? new Uint8Array(), h;
    }
  };
  class D {
    constructor(h) {
      this.rpc = h, this.Params = this.Params.bind(this), this.Inflation = this.Inflation.bind(this), this.AnnualProvisions = this.AnnualProvisions.bind(this);
    }
    Params(h = {}) {
      const S = e.QueryParamsRequest.encode(h).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Params", S).then((d) => e.QueryParamsResponse.decode(new u.Reader(d)));
    }
    Inflation(h = {}) {
      const S = e.QueryInflationRequest.encode(h).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", S).then((d) => e.QueryInflationResponse.decode(new u.Reader(d)));
    }
    AnnualProvisions(h = {}) {
      const S = e.QueryAnnualProvisionsRequest.encode(h).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", S).then((d) => e.QueryAnnualProvisionsResponse.decode(new u.Reader(d)));
    }
  }
  e.QueryClientImpl = D;
})(Du);
Object.defineProperty(pi, "__esModule", { value: !0 });
pi.setupMintExtension = void 0;
const em = yn, nm = Du, Gn = Le;
function tm(e) {
  const n = (0, Gn.createProtobufRpcClient)(e), c = new nm.QueryClientImpl(n);
  return {
    mint: {
      params: async () => {
        const { params: i } = await c.Params({});
        return (0, em.assert)(i), {
          blocksPerYear: i.blocksPerYear,
          goalBonded: (0, Gn.decodeCosmosSdkDecFromProto)(i.goalBonded),
          inflationMin: (0, Gn.decodeCosmosSdkDecFromProto)(i.inflationMin),
          inflationMax: (0, Gn.decodeCosmosSdkDecFromProto)(i.inflationMax),
          inflationRateChange: (0, Gn.decodeCosmosSdkDecFromProto)(i.inflationRateChange),
          mintDenom: i.mintDenom
        };
      },
      inflation: async () => {
        const { inflation: i } = await c.Inflation({});
        return (0, Gn.decodeCosmosSdkDecFromProto)(i);
      },
      annualProvisions: async () => {
        const { annualProvisions: i } = await c.AnnualProvisions({});
        return (0, Gn.decodeCosmosSdkDecFromProto)(i);
      }
    }
  };
}
pi.setupMintExtension = tm;
var bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.createSlashingAminoConverters = bt.isAminoMsgUnjail = void 0;
function rm(e) {
  return e.type === "cosmos-sdk/MsgUnjail";
}
bt.isAminoMsgUnjail = rm;
function im() {
  throw new Error("Not implemented");
}
bt.createSlashingAminoConverters = im;
var hi = {}, Uu = {}, Wn = {}, om = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), am = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), sm = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && om(n, e, c);
  return am(n, e), n;
};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.Params = Wn.ValidatorSigningInfo = Wn.protobufPackage = void 0;
const oo = _e, Ft = en, se = oe, kt = sm(ie);
Wn.protobufPackage = "cosmos.slashing.v1beta1";
function Fs() {
  return {
    address: "",
    startHeight: se.Long.ZERO,
    indexOffset: se.Long.ZERO,
    jailedUntil: void 0,
    tombstoned: !1,
    missedBlocksCounter: se.Long.ZERO
  };
}
Wn.ValidatorSigningInfo = {
  encode(e, n = kt.Writer.create()) {
    return e.address !== "" && n.uint32(10).string(e.address), e.startHeight.isZero() || n.uint32(16).int64(e.startHeight), e.indexOffset.isZero() || n.uint32(24).int64(e.indexOffset), e.jailedUntil !== void 0 && oo.Timestamp.encode(e.jailedUntil, n.uint32(34).fork()).ldelim(), e.tombstoned === !0 && n.uint32(40).bool(e.tombstoned), e.missedBlocksCounter.isZero() || n.uint32(48).int64(e.missedBlocksCounter), n;
  },
  decode(e, n) {
    const c = e instanceof kt.Reader ? e : new kt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Fs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.address = c.string();
          break;
        case 2:
          r.startHeight = c.int64();
          break;
        case 3:
          r.indexOffset = c.int64();
          break;
        case 4:
          r.jailedUntil = oo.Timestamp.decode(c, c.uint32());
          break;
        case 5:
          r.tombstoned = c.bool();
          break;
        case 6:
          r.missedBlocksCounter = c.int64();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      address: (0, se.isSet)(e.address) ? String(e.address) : "",
      startHeight: (0, se.isSet)(e.startHeight) ? se.Long.fromValue(e.startHeight) : se.Long.ZERO,
      indexOffset: (0, se.isSet)(e.indexOffset) ? se.Long.fromValue(e.indexOffset) : se.Long.ZERO,
      jailedUntil: (0, se.isSet)(e.jailedUntil) ? (0, se.fromJsonTimestamp)(e.jailedUntil) : void 0,
      tombstoned: (0, se.isSet)(e.tombstoned) ? !!e.tombstoned : !1,
      missedBlocksCounter: (0, se.isSet)(e.missedBlocksCounter) ? se.Long.fromValue(e.missedBlocksCounter) : se.Long.ZERO
    };
  },
  toJSON(e) {
    const n = {};
    return e.address !== void 0 && (n.address = e.address), e.startHeight !== void 0 && (n.startHeight = (e.startHeight || se.Long.ZERO).toString()), e.indexOffset !== void 0 && (n.indexOffset = (e.indexOffset || se.Long.ZERO).toString()), e.jailedUntil !== void 0 && (n.jailedUntil = (0, se.fromTimestamp)(e.jailedUntil).toISOString()), e.tombstoned !== void 0 && (n.tombstoned = e.tombstoned), e.missedBlocksCounter !== void 0 && (n.missedBlocksCounter = (e.missedBlocksCounter || se.Long.ZERO).toString()), n;
  },
  fromPartial(e) {
    const n = Fs();
    return n.address = e.address ?? "", n.startHeight = e.startHeight !== void 0 && e.startHeight !== null ? se.Long.fromValue(e.startHeight) : se.Long.ZERO, n.indexOffset = e.indexOffset !== void 0 && e.indexOffset !== null ? se.Long.fromValue(e.indexOffset) : se.Long.ZERO, n.jailedUntil = e.jailedUntil !== void 0 && e.jailedUntil !== null ? oo.Timestamp.fromPartial(e.jailedUntil) : void 0, n.tombstoned = e.tombstoned ?? !1, n.missedBlocksCounter = e.missedBlocksCounter !== void 0 && e.missedBlocksCounter !== null ? se.Long.fromValue(e.missedBlocksCounter) : se.Long.ZERO, n;
  }
};
function Gs() {
  return {
    signedBlocksWindow: se.Long.ZERO,
    minSignedPerWindow: new Uint8Array(),
    downtimeJailDuration: void 0,
    slashFractionDoubleSign: new Uint8Array(),
    slashFractionDowntime: new Uint8Array()
  };
}
Wn.Params = {
  encode(e, n = kt.Writer.create()) {
    return e.signedBlocksWindow.isZero() || n.uint32(8).int64(e.signedBlocksWindow), e.minSignedPerWindow.length !== 0 && n.uint32(18).bytes(e.minSignedPerWindow), e.downtimeJailDuration !== void 0 && Ft.Duration.encode(e.downtimeJailDuration, n.uint32(26).fork()).ldelim(), e.slashFractionDoubleSign.length !== 0 && n.uint32(34).bytes(e.slashFractionDoubleSign), e.slashFractionDowntime.length !== 0 && n.uint32(42).bytes(e.slashFractionDowntime), n;
  },
  decode(e, n) {
    const c = e instanceof kt.Reader ? e : new kt.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = Gs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.signedBlocksWindow = c.int64();
          break;
        case 2:
          r.minSignedPerWindow = c.bytes();
          break;
        case 3:
          r.downtimeJailDuration = Ft.Duration.decode(c, c.uint32());
          break;
        case 4:
          r.slashFractionDoubleSign = c.bytes();
          break;
        case 5:
          r.slashFractionDowntime = c.bytes();
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      signedBlocksWindow: (0, se.isSet)(e.signedBlocksWindow) ? se.Long.fromValue(e.signedBlocksWindow) : se.Long.ZERO,
      minSignedPerWindow: (0, se.isSet)(e.minSignedPerWindow) ? (0, se.bytesFromBase64)(e.minSignedPerWindow) : new Uint8Array(),
      downtimeJailDuration: (0, se.isSet)(e.downtimeJailDuration) ? Ft.Duration.fromJSON(e.downtimeJailDuration) : void 0,
      slashFractionDoubleSign: (0, se.isSet)(e.slashFractionDoubleSign) ? (0, se.bytesFromBase64)(e.slashFractionDoubleSign) : new Uint8Array(),
      slashFractionDowntime: (0, se.isSet)(e.slashFractionDowntime) ? (0, se.bytesFromBase64)(e.slashFractionDowntime) : new Uint8Array()
    };
  },
  toJSON(e) {
    const n = {};
    return e.signedBlocksWindow !== void 0 && (n.signedBlocksWindow = (e.signedBlocksWindow || se.Long.ZERO).toString()), e.minSignedPerWindow !== void 0 && (n.minSignedPerWindow = (0, se.base64FromBytes)(e.minSignedPerWindow !== void 0 ? e.minSignedPerWindow : new Uint8Array())), e.downtimeJailDuration !== void 0 && (n.downtimeJailDuration = e.downtimeJailDuration ? Ft.Duration.toJSON(e.downtimeJailDuration) : void 0), e.slashFractionDoubleSign !== void 0 && (n.slashFractionDoubleSign = (0, se.base64FromBytes)(e.slashFractionDoubleSign !== void 0 ? e.slashFractionDoubleSign : new Uint8Array())), e.slashFractionDowntime !== void 0 && (n.slashFractionDowntime = (0, se.base64FromBytes)(e.slashFractionDowntime !== void 0 ? e.slashFractionDowntime : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Gs();
    return n.signedBlocksWindow = e.signedBlocksWindow !== void 0 && e.signedBlocksWindow !== null ? se.Long.fromValue(e.signedBlocksWindow) : se.Long.ZERO, n.minSignedPerWindow = e.minSignedPerWindow ?? new Uint8Array(), n.downtimeJailDuration = e.downtimeJailDuration !== void 0 && e.downtimeJailDuration !== null ? Ft.Duration.fromPartial(e.downtimeJailDuration) : void 0, n.slashFractionDoubleSign = e.slashFractionDoubleSign ?? new Uint8Array(), n.slashFractionDowntime = e.slashFractionDowntime ?? new Uint8Array(), n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(h, S, _, d) {
    d === void 0 && (d = _);
    var p = Object.getOwnPropertyDescriptor(S, _);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[_];
    } }), Object.defineProperty(h, d, p);
  } : function(h, S, _, d) {
    d === void 0 && (d = _), h[d] = S[_];
  }), c = G && G.__setModuleDefault || (Object.create ? function(h, S) {
    Object.defineProperty(h, "default", { enumerable: !0, value: S });
  } : function(h, S) {
    h.default = S;
  }), i = G && G.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var S = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && n(S, h, _);
    return c(S, h), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySigningInfosResponse = e.QuerySigningInfosRequest = e.QuerySigningInfoResponse = e.QuerySigningInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const r = Re, u = Wn, f = i(ie), O = oe;
  e.protobufPackage = "cosmos.slashing.v1beta1";
  function A() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(h, S = f.Writer.create()) {
      return S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = A();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {};
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return A();
    }
  };
  function T() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(h, S = f.Writer.create()) {
      return h.params !== void 0 && u.Params.encode(h.params, S.uint32(10).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = T();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.params = u.Params.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        params: (0, O.isSet)(h.params) ? u.Params.fromJSON(h.params) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.params !== void 0 && (S.params = h.params ? u.Params.toJSON(h.params) : void 0), S;
    },
    fromPartial(h) {
      const S = T();
      return S.params = h.params !== void 0 && h.params !== null ? u.Params.fromPartial(h.params) : void 0, S;
    }
  };
  function L() {
    return {
      consAddress: ""
    };
  }
  e.QuerySigningInfoRequest = {
    encode(h, S = f.Writer.create()) {
      return h.consAddress !== "" && S.uint32(10).string(h.consAddress), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = L();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.consAddress = _.string();
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        consAddress: (0, O.isSet)(h.consAddress) ? String(h.consAddress) : ""
      };
    },
    toJSON(h) {
      const S = {};
      return h.consAddress !== void 0 && (S.consAddress = h.consAddress), S;
    },
    fromPartial(h) {
      const S = L();
      return S.consAddress = h.consAddress ?? "", S;
    }
  };
  function M() {
    return {
      valSigningInfo: void 0
    };
  }
  e.QuerySigningInfoResponse = {
    encode(h, S = f.Writer.create()) {
      return h.valSigningInfo !== void 0 && u.ValidatorSigningInfo.encode(h.valSigningInfo, S.uint32(10).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = M();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.valSigningInfo = u.ValidatorSigningInfo.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        valSigningInfo: (0, O.isSet)(h.valSigningInfo) ? u.ValidatorSigningInfo.fromJSON(h.valSigningInfo) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.valSigningInfo !== void 0 && (S.valSigningInfo = h.valSigningInfo ? u.ValidatorSigningInfo.toJSON(h.valSigningInfo) : void 0), S;
    },
    fromPartial(h) {
      const S = M();
      return S.valSigningInfo = h.valSigningInfo !== void 0 && h.valSigningInfo !== null ? u.ValidatorSigningInfo.fromPartial(h.valSigningInfo) : void 0, S;
    }
  };
  function V() {
    return {
      pagination: void 0
    };
  }
  e.QuerySigningInfosRequest = {
    encode(h, S = f.Writer.create()) {
      return h.pagination !== void 0 && r.PageRequest.encode(h.pagination, S.uint32(10).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = V();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.pagination = r.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        pagination: (0, O.isSet)(h.pagination) ? r.PageRequest.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageRequest.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      const S = V();
      return S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageRequest.fromPartial(h.pagination) : void 0, S;
    }
  };
  function D() {
    return {
      info: [],
      pagination: void 0
    };
  }
  e.QuerySigningInfosResponse = {
    encode(h, S = f.Writer.create()) {
      for (const _ of h.info)
        u.ValidatorSigningInfo.encode(_, S.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && r.PageResponse.encode(h.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(h, S) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = D();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.info.push(u.ValidatorSigningInfo.decode(_, _.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        info: Array.isArray(h == null ? void 0 : h.info) ? h.info.map((S) => u.ValidatorSigningInfo.fromJSON(S)) : [],
        pagination: (0, O.isSet)(h.pagination) ? r.PageResponse.fromJSON(h.pagination) : void 0
      };
    },
    toJSON(h) {
      const S = {};
      return h.info ? S.info = h.info.map((_) => _ ? u.ValidatorSigningInfo.toJSON(_) : void 0) : S.info = [], h.pagination !== void 0 && (S.pagination = h.pagination ? r.PageResponse.toJSON(h.pagination) : void 0), S;
    },
    fromPartial(h) {
      var _;
      const S = D();
      return S.info = ((_ = h.info) == null ? void 0 : _.map((d) => u.ValidatorSigningInfo.fromPartial(d))) || [], S.pagination = h.pagination !== void 0 && h.pagination !== null ? r.PageResponse.fromPartial(h.pagination) : void 0, S;
    }
  };
  class b {
    constructor(S) {
      this.rpc = S, this.Params = this.Params.bind(this), this.SigningInfo = this.SigningInfo.bind(this), this.SigningInfos = this.SigningInfos.bind(this);
    }
    Params(S = {}) {
      const _ = e.QueryParamsRequest.encode(S).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", _).then((p) => e.QueryParamsResponse.decode(new f.Reader(p)));
    }
    SigningInfo(S) {
      const _ = e.QuerySigningInfoRequest.encode(S).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", _).then((p) => e.QuerySigningInfoResponse.decode(new f.Reader(p)));
    }
    SigningInfos(S = {
      pagination: void 0
    }) {
      const _ = e.QuerySigningInfosRequest.encode(S).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", _).then((p) => e.QuerySigningInfosResponse.decode(new f.Reader(p)));
    }
  }
  e.QueryClientImpl = b;
})(Uu);
Object.defineProperty(hi, "__esModule", { value: !0 });
hi.setupSlashingExtension = void 0;
const dm = Uu, $s = Le;
function um(e) {
  const n = (0, $s.createProtobufRpcClient)(e), c = new dm.QueryClientImpl(n);
  return {
    slashing: {
      signingInfo: async (i) => await c.SigningInfo({
        consAddress: i
      }),
      signingInfos: async (i) => await c.SigningInfos({
        pagination: (0, $s.createPagination)(i)
      }),
      params: async () => await c.Params({})
    }
  };
}
hi.setupSlashingExtension = um;
var Be = {};
Object.defineProperty(Be, "__esModule", { value: !0 });
Be.createStakingAminoConverters = Be.isAminoMsgUndelegate = Be.isAminoMsgBeginRedelegate = Be.isAminoMsgDelegate = Be.isAminoMsgEditValidator = Be.isAminoMsgCreateValidator = Be.protoDecimalToJson = void 0;
const Mu = _n, Ks = tt, wn = yn;
function zt(e) {
  const n = Mu.Decimal.fromAtomics(e, 18), [c, i] = n.toString().split(".");
  return `${c}.${(i ?? "").padEnd(18, "0")}`;
}
Be.protoDecimalToJson = zt;
function Or(e) {
  return Mu.Decimal.fromUserInput(e, 18).atomics;
}
function cm(e) {
  return e.type === "cosmos-sdk/MsgCreateValidator";
}
Be.isAminoMsgCreateValidator = cm;
function lm(e) {
  return e.type === "cosmos-sdk/MsgEditValidator";
}
Be.isAminoMsgEditValidator = lm;
function fm(e) {
  return e.type === "cosmos-sdk/MsgDelegate";
}
Be.isAminoMsgDelegate = fm;
function pm(e) {
  return e.type === "cosmos-sdk/MsgBeginRedelegate";
}
Be.isAminoMsgBeginRedelegate = pm;
function hm(e) {
  return e.type === "cosmos-sdk/MsgUndelegate";
}
Be.isAminoMsgUndelegate = hm;
function mm() {
  return {
    "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
      aminoType: "cosmos-sdk/MsgBeginRedelegate",
      toAmino: ({ delegatorAddress: e, validatorSrcAddress: n, validatorDstAddress: c, amount: i }) => ((0, wn.assertDefinedAndNotNull)(i, "missing amount"), {
        delegator_address: e,
        validator_src_address: n,
        validator_dst_address: c,
        amount: i
      }),
      fromAmino: ({ delegator_address: e, validator_src_address: n, validator_dst_address: c, amount: i }) => ({
        delegatorAddress: e,
        validatorSrcAddress: n,
        validatorDstAddress: c,
        amount: i
      })
    },
    "/cosmos.staking.v1beta1.MsgCreateValidator": {
      aminoType: "cosmos-sdk/MsgCreateValidator",
      toAmino: ({ description: e, commission: n, minSelfDelegation: c, delegatorAddress: i, validatorAddress: r, pubkey: u, value: f }) => ((0, wn.assertDefinedAndNotNull)(e, "missing description"), (0, wn.assertDefinedAndNotNull)(n, "missing commission"), (0, wn.assertDefinedAndNotNull)(u, "missing pubkey"), (0, wn.assertDefinedAndNotNull)(f, "missing value"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        commission: {
          rate: zt(n.rate),
          max_rate: zt(n.maxRate),
          max_change_rate: zt(n.maxChangeRate)
        },
        min_self_delegation: c,
        delegator_address: i,
        validator_address: r,
        pubkey: (0, Ks.decodePubkey)(u),
        value: f
      }),
      fromAmino: ({ description: e, commission: n, min_self_delegation: c, delegator_address: i, validator_address: r, pubkey: u, value: f }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        commission: {
          rate: Or(n.rate),
          maxRate: Or(n.max_rate),
          maxChangeRate: Or(n.max_change_rate)
        },
        minSelfDelegation: c,
        delegatorAddress: i,
        validatorAddress: r,
        pubkey: (0, Ks.encodePubkey)(u),
        value: f
      })
    },
    "/cosmos.staking.v1beta1.MsgDelegate": {
      aminoType: "cosmos-sdk/MsgDelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: n, amount: c }) => ((0, wn.assertDefinedAndNotNull)(c, "missing amount"), {
        delegator_address: e,
        validator_address: n,
        amount: c
      }),
      fromAmino: ({ delegator_address: e, validator_address: n, amount: c }) => ({
        delegatorAddress: e,
        validatorAddress: n,
        amount: c
      })
    },
    "/cosmos.staking.v1beta1.MsgEditValidator": {
      aminoType: "cosmos-sdk/MsgEditValidator",
      toAmino: ({ description: e, commissionRate: n, minSelfDelegation: c, validatorAddress: i }) => ((0, wn.assertDefinedAndNotNull)(e, "missing description"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commission_rate: n ? zt(n) : void 0,
        // empty string in the protobuf document means "do not change"
        min_self_delegation: c || void 0,
        validator_address: i
      }),
      fromAmino: ({ description: e, commission_rate: n, min_self_delegation: c, validator_address: i }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commissionRate: n ? Or(n) : "",
        // empty string in the protobuf document means "do not change"
        minSelfDelegation: c ?? "",
        validatorAddress: i
      })
    },
    "/cosmos.staking.v1beta1.MsgUndelegate": {
      aminoType: "cosmos-sdk/MsgUndelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: n, amount: c }) => ((0, wn.assertDefinedAndNotNull)(c, "missing amount"), {
        delegator_address: e,
        validator_address: n,
        amount: c
      }),
      fromAmino: ({ delegator_address: e, validator_address: n, amount: c }) => ({
        delegatorAddress: e,
        validatorAddress: n,
        amount: c
      })
    }
  };
}
Be.createStakingAminoConverters = mm;
var Ge = {}, oa = {}, aa = {}, sa = {}, Vu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(D, b, h, S) {
    S === void 0 && (S = h);
    var _ = Object.getOwnPropertyDescriptor(b, h);
    (!_ || ("get" in _ ? !b.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return b[h];
    } }), Object.defineProperty(D, S, _);
  } : function(D, b, h, S) {
    S === void 0 && (S = h), D[S] = b[h];
  }), c = G && G.__setModuleDefault || (Object.create ? function(D, b) {
    Object.defineProperty(D, "default", { enumerable: !0, value: b });
  } : function(D, b) {
    D.default = b;
  }), i = G && G.__importStar || function(D) {
    if (D && D.__esModule)
      return D;
    var b = {};
    if (D != null)
      for (var h in D)
        h !== "default" && Object.prototype.hasOwnProperty.call(D, h) && n(b, D, h);
    return c(b, D), b;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.HashedParams = e.VersionParams = e.ValidatorParams = e.EvidenceParams = e.BlockParams = e.ConsensusParams = e.protobufPackage = void 0;
  const r = en, u = oe, f = i(ie);
  e.protobufPackage = "tendermint.types";
  function O() {
    return {
      block: void 0,
      evidence: void 0,
      validator: void 0,
      version: void 0
    };
  }
  e.ConsensusParams = {
    encode(D, b = f.Writer.create()) {
      return D.block !== void 0 && e.BlockParams.encode(D.block, b.uint32(10).fork()).ldelim(), D.evidence !== void 0 && e.EvidenceParams.encode(D.evidence, b.uint32(18).fork()).ldelim(), D.validator !== void 0 && e.ValidatorParams.encode(D.validator, b.uint32(26).fork()).ldelim(), D.version !== void 0 && e.VersionParams.encode(D.version, b.uint32(34).fork()).ldelim(), b;
    },
    decode(D, b) {
      const h = D instanceof f.Reader ? D : new f.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = O();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.block = e.BlockParams.decode(h, h.uint32());
            break;
          case 2:
            _.evidence = e.EvidenceParams.decode(h, h.uint32());
            break;
          case 3:
            _.validator = e.ValidatorParams.decode(h, h.uint32());
            break;
          case 4:
            _.version = e.VersionParams.decode(h, h.uint32());
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        block: (0, u.isSet)(D.block) ? e.BlockParams.fromJSON(D.block) : void 0,
        evidence: (0, u.isSet)(D.evidence) ? e.EvidenceParams.fromJSON(D.evidence) : void 0,
        validator: (0, u.isSet)(D.validator) ? e.ValidatorParams.fromJSON(D.validator) : void 0,
        version: (0, u.isSet)(D.version) ? e.VersionParams.fromJSON(D.version) : void 0
      };
    },
    toJSON(D) {
      const b = {};
      return D.block !== void 0 && (b.block = D.block ? e.BlockParams.toJSON(D.block) : void 0), D.evidence !== void 0 && (b.evidence = D.evidence ? e.EvidenceParams.toJSON(D.evidence) : void 0), D.validator !== void 0 && (b.validator = D.validator ? e.ValidatorParams.toJSON(D.validator) : void 0), D.version !== void 0 && (b.version = D.version ? e.VersionParams.toJSON(D.version) : void 0), b;
    },
    fromPartial(D) {
      const b = O();
      return b.block = D.block !== void 0 && D.block !== null ? e.BlockParams.fromPartial(D.block) : void 0, b.evidence = D.evidence !== void 0 && D.evidence !== null ? e.EvidenceParams.fromPartial(D.evidence) : void 0, b.validator = D.validator !== void 0 && D.validator !== null ? e.ValidatorParams.fromPartial(D.validator) : void 0, b.version = D.version !== void 0 && D.version !== null ? e.VersionParams.fromPartial(D.version) : void 0, b;
    }
  };
  function A() {
    return {
      maxBytes: u.Long.ZERO,
      maxGas: u.Long.ZERO
    };
  }
  e.BlockParams = {
    encode(D, b = f.Writer.create()) {
      return D.maxBytes.isZero() || b.uint32(8).int64(D.maxBytes), D.maxGas.isZero() || b.uint32(16).int64(D.maxGas), b;
    },
    decode(D, b) {
      const h = D instanceof f.Reader ? D : new f.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = A();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.maxBytes = h.int64();
            break;
          case 2:
            _.maxGas = h.int64();
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        maxBytes: (0, u.isSet)(D.maxBytes) ? u.Long.fromValue(D.maxBytes) : u.Long.ZERO,
        maxGas: (0, u.isSet)(D.maxGas) ? u.Long.fromValue(D.maxGas) : u.Long.ZERO
      };
    },
    toJSON(D) {
      const b = {};
      return D.maxBytes !== void 0 && (b.maxBytes = (D.maxBytes || u.Long.ZERO).toString()), D.maxGas !== void 0 && (b.maxGas = (D.maxGas || u.Long.ZERO).toString()), b;
    },
    fromPartial(D) {
      const b = A();
      return b.maxBytes = D.maxBytes !== void 0 && D.maxBytes !== null ? u.Long.fromValue(D.maxBytes) : u.Long.ZERO, b.maxGas = D.maxGas !== void 0 && D.maxGas !== null ? u.Long.fromValue(D.maxGas) : u.Long.ZERO, b;
    }
  };
  function T() {
    return {
      maxAgeNumBlocks: u.Long.ZERO,
      maxAgeDuration: void 0,
      maxBytes: u.Long.ZERO
    };
  }
  e.EvidenceParams = {
    encode(D, b = f.Writer.create()) {
      return D.maxAgeNumBlocks.isZero() || b.uint32(8).int64(D.maxAgeNumBlocks), D.maxAgeDuration !== void 0 && r.Duration.encode(D.maxAgeDuration, b.uint32(18).fork()).ldelim(), D.maxBytes.isZero() || b.uint32(24).int64(D.maxBytes), b;
    },
    decode(D, b) {
      const h = D instanceof f.Reader ? D : new f.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = T();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.maxAgeNumBlocks = h.int64();
            break;
          case 2:
            _.maxAgeDuration = r.Duration.decode(h, h.uint32());
            break;
          case 3:
            _.maxBytes = h.int64();
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        maxAgeNumBlocks: (0, u.isSet)(D.maxAgeNumBlocks) ? u.Long.fromValue(D.maxAgeNumBlocks) : u.Long.ZERO,
        maxAgeDuration: (0, u.isSet)(D.maxAgeDuration) ? r.Duration.fromJSON(D.maxAgeDuration) : void 0,
        maxBytes: (0, u.isSet)(D.maxBytes) ? u.Long.fromValue(D.maxBytes) : u.Long.ZERO
      };
    },
    toJSON(D) {
      const b = {};
      return D.maxAgeNumBlocks !== void 0 && (b.maxAgeNumBlocks = (D.maxAgeNumBlocks || u.Long.ZERO).toString()), D.maxAgeDuration !== void 0 && (b.maxAgeDuration = D.maxAgeDuration ? r.Duration.toJSON(D.maxAgeDuration) : void 0), D.maxBytes !== void 0 && (b.maxBytes = (D.maxBytes || u.Long.ZERO).toString()), b;
    },
    fromPartial(D) {
      const b = T();
      return b.maxAgeNumBlocks = D.maxAgeNumBlocks !== void 0 && D.maxAgeNumBlocks !== null ? u.Long.fromValue(D.maxAgeNumBlocks) : u.Long.ZERO, b.maxAgeDuration = D.maxAgeDuration !== void 0 && D.maxAgeDuration !== null ? r.Duration.fromPartial(D.maxAgeDuration) : void 0, b.maxBytes = D.maxBytes !== void 0 && D.maxBytes !== null ? u.Long.fromValue(D.maxBytes) : u.Long.ZERO, b;
    }
  };
  function L() {
    return {
      pubKeyTypes: []
    };
  }
  e.ValidatorParams = {
    encode(D, b = f.Writer.create()) {
      for (const h of D.pubKeyTypes)
        b.uint32(10).string(h);
      return b;
    },
    decode(D, b) {
      const h = D instanceof f.Reader ? D : new f.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = L();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.pubKeyTypes.push(h.string());
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        pubKeyTypes: Array.isArray(D == null ? void 0 : D.pubKeyTypes) ? D.pubKeyTypes.map((b) => String(b)) : []
      };
    },
    toJSON(D) {
      const b = {};
      return D.pubKeyTypes ? b.pubKeyTypes = D.pubKeyTypes.map((h) => h) : b.pubKeyTypes = [], b;
    },
    fromPartial(D) {
      var h;
      const b = L();
      return b.pubKeyTypes = ((h = D.pubKeyTypes) == null ? void 0 : h.map((S) => S)) || [], b;
    }
  };
  function M() {
    return {
      app: u.Long.UZERO
    };
  }
  e.VersionParams = {
    encode(D, b = f.Writer.create()) {
      return D.app.isZero() || b.uint32(8).uint64(D.app), b;
    },
    decode(D, b) {
      const h = D instanceof f.Reader ? D : new f.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = M();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.app = h.uint64();
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        app: (0, u.isSet)(D.app) ? u.Long.fromValue(D.app) : u.Long.UZERO
      };
    },
    toJSON(D) {
      const b = {};
      return D.app !== void 0 && (b.app = (D.app || u.Long.UZERO).toString()), b;
    },
    fromPartial(D) {
      const b = M();
      return b.app = D.app !== void 0 && D.app !== null ? u.Long.fromValue(D.app) : u.Long.UZERO, b;
    }
  };
  function V() {
    return {
      blockMaxBytes: u.Long.ZERO,
      blockMaxGas: u.Long.ZERO
    };
  }
  e.HashedParams = {
    encode(D, b = f.Writer.create()) {
      return D.blockMaxBytes.isZero() || b.uint32(8).int64(D.blockMaxBytes), D.blockMaxGas.isZero() || b.uint32(16).int64(D.blockMaxGas), b;
    },
    decode(D, b) {
      const h = D instanceof f.Reader ? D : new f.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = V();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.blockMaxBytes = h.int64();
            break;
          case 2:
            _.blockMaxGas = h.int64();
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        blockMaxBytes: (0, u.isSet)(D.blockMaxBytes) ? u.Long.fromValue(D.blockMaxBytes) : u.Long.ZERO,
        blockMaxGas: (0, u.isSet)(D.blockMaxGas) ? u.Long.fromValue(D.blockMaxGas) : u.Long.ZERO
      };
    },
    toJSON(D) {
      const b = {};
      return D.blockMaxBytes !== void 0 && (b.blockMaxBytes = (D.blockMaxBytes || u.Long.ZERO).toString()), D.blockMaxGas !== void 0 && (b.blockMaxGas = (D.blockMaxGas || u.Long.ZERO).toString()), b;
    },
    fromPartial(D) {
      const b = V();
      return b.blockMaxBytes = D.blockMaxBytes !== void 0 && D.blockMaxBytes !== null ? u.Long.fromValue(D.blockMaxBytes) : u.Long.ZERO, b.blockMaxGas = D.blockMaxGas !== void 0 && D.blockMaxGas !== null ? u.Long.fromValue(D.blockMaxGas) : u.Long.ZERO, b;
    }
  };
})(Vu);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(s, w, W, Y) {
    Y === void 0 && (Y = W);
    var $ = Object.getOwnPropertyDescriptor(w, W);
    (!$ || ("get" in $ ? !w.__esModule : $.writable || $.configurable)) && ($ = { enumerable: !0, get: function() {
      return w[W];
    } }), Object.defineProperty(s, Y, $);
  } : function(s, w, W, Y) {
    Y === void 0 && (Y = W), s[Y] = w[W];
  }), c = G && G.__setModuleDefault || (Object.create ? function(s, w) {
    Object.defineProperty(s, "default", { enumerable: !0, value: w });
  } : function(s, w) {
    s.default = w;
  }), i = G && G.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var w = {};
    if (s != null)
      for (var W in s)
        W !== "default" && Object.prototype.hasOwnProperty.call(s, W) && n(w, s, W);
    return c(w, s), w;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ResponsePrepareProposal = e.ResponseApplySnapshotChunk = e.ResponseLoadSnapshotChunk = e.ResponseOfferSnapshot = e.ResponseListSnapshots = e.ResponseCommit = e.ResponseEndBlock = e.ResponseDeliverTx = e.ResponseCheckTx = e.ResponseBeginBlock = e.ResponseQuery = e.ResponseInitChain = e.ResponseInfo = e.ResponseFlush = e.ResponseEcho = e.ResponseException = e.Response = e.RequestProcessProposal = e.RequestPrepareProposal = e.RequestApplySnapshotChunk = e.RequestLoadSnapshotChunk = e.RequestOfferSnapshot = e.RequestListSnapshots = e.RequestCommit = e.RequestEndBlock = e.RequestDeliverTx = e.RequestCheckTx = e.RequestBeginBlock = e.RequestQuery = e.RequestInitChain = e.RequestInfo = e.RequestFlush = e.RequestEcho = e.Request = e.misbehaviorTypeToJSON = e.misbehaviorTypeFromJSON = e.MisbehaviorType = e.responseProcessProposal_ProposalStatusToJSON = e.responseProcessProposal_ProposalStatusFromJSON = e.ResponseProcessProposal_ProposalStatus = e.responseApplySnapshotChunk_ResultToJSON = e.responseApplySnapshotChunk_ResultFromJSON = e.ResponseApplySnapshotChunk_Result = e.responseOfferSnapshot_ResultToJSON = e.responseOfferSnapshot_ResultFromJSON = e.ResponseOfferSnapshot_Result = e.checkTxTypeToJSON = e.checkTxTypeFromJSON = e.CheckTxType = e.protobufPackage = void 0, e.ABCIApplicationClientImpl = e.Snapshot = e.Misbehavior = e.ExtendedVoteInfo = e.VoteInfo = e.ValidatorUpdate = e.Validator = e.TxResult = e.EventAttribute = e.Event = e.ExtendedCommitInfo = e.CommitInfo = e.ResponseProcessProposal = void 0;
  const r = _e, u = Vu, f = rt, O = ia, A = jn, T = oe, L = i(ie);
  e.protobufPackage = "tendermint.abci";
  var M;
  (function(s) {
    s[s.NEW = 0] = "NEW", s[s.RECHECK = 1] = "RECHECK", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = e.CheckTxType || (e.CheckTxType = {}));
  function V(s) {
    switch (s) {
      case 0:
      case "NEW":
        return M.NEW;
      case 1:
      case "RECHECK":
        return M.RECHECK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  e.checkTxTypeFromJSON = V;
  function D(s) {
    switch (s) {
      case M.NEW:
        return "NEW";
      case M.RECHECK:
        return "RECHECK";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.checkTxTypeToJSON = D;
  var b;
  (function(s) {
    s[s.UNKNOWN = 0] = "UNKNOWN", s[s.ACCEPT = 1] = "ACCEPT", s[s.ABORT = 2] = "ABORT", s[s.REJECT = 3] = "REJECT", s[s.REJECT_FORMAT = 4] = "REJECT_FORMAT", s[s.REJECT_SENDER = 5] = "REJECT_SENDER", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(b = e.ResponseOfferSnapshot_Result || (e.ResponseOfferSnapshot_Result = {}));
  function h(s) {
    switch (s) {
      case 0:
      case "UNKNOWN":
        return b.UNKNOWN;
      case 1:
      case "ACCEPT":
        return b.ACCEPT;
      case 2:
      case "ABORT":
        return b.ABORT;
      case 3:
      case "REJECT":
        return b.REJECT;
      case 4:
      case "REJECT_FORMAT":
        return b.REJECT_FORMAT;
      case 5:
      case "REJECT_SENDER":
        return b.REJECT_SENDER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return b.UNRECOGNIZED;
    }
  }
  e.responseOfferSnapshot_ResultFromJSON = h;
  function S(s) {
    switch (s) {
      case b.UNKNOWN:
        return "UNKNOWN";
      case b.ACCEPT:
        return "ACCEPT";
      case b.ABORT:
        return "ABORT";
      case b.REJECT:
        return "REJECT";
      case b.REJECT_FORMAT:
        return "REJECT_FORMAT";
      case b.REJECT_SENDER:
        return "REJECT_SENDER";
      case b.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseOfferSnapshot_ResultToJSON = S;
  var _;
  (function(s) {
    s[s.UNKNOWN = 0] = "UNKNOWN", s[s.ACCEPT = 1] = "ACCEPT", s[s.ABORT = 2] = "ABORT", s[s.RETRY = 3] = "RETRY", s[s.RETRY_SNAPSHOT = 4] = "RETRY_SNAPSHOT", s[s.REJECT_SNAPSHOT = 5] = "REJECT_SNAPSHOT", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(_ = e.ResponseApplySnapshotChunk_Result || (e.ResponseApplySnapshotChunk_Result = {}));
  function d(s) {
    switch (s) {
      case 0:
      case "UNKNOWN":
        return _.UNKNOWN;
      case 1:
      case "ACCEPT":
        return _.ACCEPT;
      case 2:
      case "ABORT":
        return _.ABORT;
      case 3:
      case "RETRY":
        return _.RETRY;
      case 4:
      case "RETRY_SNAPSHOT":
        return _.RETRY_SNAPSHOT;
      case 5:
      case "REJECT_SNAPSHOT":
        return _.REJECT_SNAPSHOT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return _.UNRECOGNIZED;
    }
  }
  e.responseApplySnapshotChunk_ResultFromJSON = d;
  function p(s) {
    switch (s) {
      case _.UNKNOWN:
        return "UNKNOWN";
      case _.ACCEPT:
        return "ACCEPT";
      case _.ABORT:
        return "ABORT";
      case _.RETRY:
        return "RETRY";
      case _.RETRY_SNAPSHOT:
        return "RETRY_SNAPSHOT";
      case _.REJECT_SNAPSHOT:
        return "REJECT_SNAPSHOT";
      case _.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseApplySnapshotChunk_ResultToJSON = p;
  var g;
  (function(s) {
    s[s.UNKNOWN = 0] = "UNKNOWN", s[s.ACCEPT = 1] = "ACCEPT", s[s.REJECT = 2] = "REJECT", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(g = e.ResponseProcessProposal_ProposalStatus || (e.ResponseProcessProposal_ProposalStatus = {}));
  function J(s) {
    switch (s) {
      case 0:
      case "UNKNOWN":
        return g.UNKNOWN;
      case 1:
      case "ACCEPT":
        return g.ACCEPT;
      case 2:
      case "REJECT":
        return g.REJECT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return g.UNRECOGNIZED;
    }
  }
  e.responseProcessProposal_ProposalStatusFromJSON = J;
  function B(s) {
    switch (s) {
      case g.UNKNOWN:
        return "UNKNOWN";
      case g.ACCEPT:
        return "ACCEPT";
      case g.REJECT:
        return "REJECT";
      case g.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseProcessProposal_ProposalStatusToJSON = B;
  var I;
  (function(s) {
    s[s.UNKNOWN = 0] = "UNKNOWN", s[s.DUPLICATE_VOTE = 1] = "DUPLICATE_VOTE", s[s.LIGHT_CLIENT_ATTACK = 2] = "LIGHT_CLIENT_ATTACK", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(I = e.MisbehaviorType || (e.MisbehaviorType = {}));
  function Z(s) {
    switch (s) {
      case 0:
      case "UNKNOWN":
        return I.UNKNOWN;
      case 1:
      case "DUPLICATE_VOTE":
        return I.DUPLICATE_VOTE;
      case 2:
      case "LIGHT_CLIENT_ATTACK":
        return I.LIGHT_CLIENT_ATTACK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return I.UNRECOGNIZED;
    }
  }
  e.misbehaviorTypeFromJSON = Z;
  function t(s) {
    switch (s) {
      case I.UNKNOWN:
        return "UNKNOWN";
      case I.DUPLICATE_VOTE:
        return "DUPLICATE_VOTE";
      case I.LIGHT_CLIENT_ATTACK:
        return "LIGHT_CLIENT_ATTACK";
      case I.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.misbehaviorTypeToJSON = t;
  function y() {
    return {
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Request = {
    encode(s, w = L.Writer.create()) {
      return s.echo !== void 0 && e.RequestEcho.encode(s.echo, w.uint32(10).fork()).ldelim(), s.flush !== void 0 && e.RequestFlush.encode(s.flush, w.uint32(18).fork()).ldelim(), s.info !== void 0 && e.RequestInfo.encode(s.info, w.uint32(26).fork()).ldelim(), s.initChain !== void 0 && e.RequestInitChain.encode(s.initChain, w.uint32(42).fork()).ldelim(), s.query !== void 0 && e.RequestQuery.encode(s.query, w.uint32(50).fork()).ldelim(), s.beginBlock !== void 0 && e.RequestBeginBlock.encode(s.beginBlock, w.uint32(58).fork()).ldelim(), s.checkTx !== void 0 && e.RequestCheckTx.encode(s.checkTx, w.uint32(66).fork()).ldelim(), s.deliverTx !== void 0 && e.RequestDeliverTx.encode(s.deliverTx, w.uint32(74).fork()).ldelim(), s.endBlock !== void 0 && e.RequestEndBlock.encode(s.endBlock, w.uint32(82).fork()).ldelim(), s.commit !== void 0 && e.RequestCommit.encode(s.commit, w.uint32(90).fork()).ldelim(), s.listSnapshots !== void 0 && e.RequestListSnapshots.encode(s.listSnapshots, w.uint32(98).fork()).ldelim(), s.offerSnapshot !== void 0 && e.RequestOfferSnapshot.encode(s.offerSnapshot, w.uint32(106).fork()).ldelim(), s.loadSnapshotChunk !== void 0 && e.RequestLoadSnapshotChunk.encode(s.loadSnapshotChunk, w.uint32(114).fork()).ldelim(), s.applySnapshotChunk !== void 0 && e.RequestApplySnapshotChunk.encode(s.applySnapshotChunk, w.uint32(122).fork()).ldelim(), s.prepareProposal !== void 0 && e.RequestPrepareProposal.encode(s.prepareProposal, w.uint32(130).fork()).ldelim(), s.processProposal !== void 0 && e.RequestProcessProposal.encode(s.processProposal, w.uint32(138).fork()).ldelim(), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = y();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.echo = e.RequestEcho.decode(W, W.uint32());
            break;
          case 2:
            $.flush = e.RequestFlush.decode(W, W.uint32());
            break;
          case 3:
            $.info = e.RequestInfo.decode(W, W.uint32());
            break;
          case 5:
            $.initChain = e.RequestInitChain.decode(W, W.uint32());
            break;
          case 6:
            $.query = e.RequestQuery.decode(W, W.uint32());
            break;
          case 7:
            $.beginBlock = e.RequestBeginBlock.decode(W, W.uint32());
            break;
          case 8:
            $.checkTx = e.RequestCheckTx.decode(W, W.uint32());
            break;
          case 9:
            $.deliverTx = e.RequestDeliverTx.decode(W, W.uint32());
            break;
          case 10:
            $.endBlock = e.RequestEndBlock.decode(W, W.uint32());
            break;
          case 11:
            $.commit = e.RequestCommit.decode(W, W.uint32());
            break;
          case 12:
            $.listSnapshots = e.RequestListSnapshots.decode(W, W.uint32());
            break;
          case 13:
            $.offerSnapshot = e.RequestOfferSnapshot.decode(W, W.uint32());
            break;
          case 14:
            $.loadSnapshotChunk = e.RequestLoadSnapshotChunk.decode(W, W.uint32());
            break;
          case 15:
            $.applySnapshotChunk = e.RequestApplySnapshotChunk.decode(W, W.uint32());
            break;
          case 16:
            $.prepareProposal = e.RequestPrepareProposal.decode(W, W.uint32());
            break;
          case 17:
            $.processProposal = e.RequestProcessProposal.decode(W, W.uint32());
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        echo: (0, T.isSet)(s.echo) ? e.RequestEcho.fromJSON(s.echo) : void 0,
        flush: (0, T.isSet)(s.flush) ? e.RequestFlush.fromJSON(s.flush) : void 0,
        info: (0, T.isSet)(s.info) ? e.RequestInfo.fromJSON(s.info) : void 0,
        initChain: (0, T.isSet)(s.initChain) ? e.RequestInitChain.fromJSON(s.initChain) : void 0,
        query: (0, T.isSet)(s.query) ? e.RequestQuery.fromJSON(s.query) : void 0,
        beginBlock: (0, T.isSet)(s.beginBlock) ? e.RequestBeginBlock.fromJSON(s.beginBlock) : void 0,
        checkTx: (0, T.isSet)(s.checkTx) ? e.RequestCheckTx.fromJSON(s.checkTx) : void 0,
        deliverTx: (0, T.isSet)(s.deliverTx) ? e.RequestDeliverTx.fromJSON(s.deliverTx) : void 0,
        endBlock: (0, T.isSet)(s.endBlock) ? e.RequestEndBlock.fromJSON(s.endBlock) : void 0,
        commit: (0, T.isSet)(s.commit) ? e.RequestCommit.fromJSON(s.commit) : void 0,
        listSnapshots: (0, T.isSet)(s.listSnapshots) ? e.RequestListSnapshots.fromJSON(s.listSnapshots) : void 0,
        offerSnapshot: (0, T.isSet)(s.offerSnapshot) ? e.RequestOfferSnapshot.fromJSON(s.offerSnapshot) : void 0,
        loadSnapshotChunk: (0, T.isSet)(s.loadSnapshotChunk) ? e.RequestLoadSnapshotChunk.fromJSON(s.loadSnapshotChunk) : void 0,
        applySnapshotChunk: (0, T.isSet)(s.applySnapshotChunk) ? e.RequestApplySnapshotChunk.fromJSON(s.applySnapshotChunk) : void 0,
        prepareProposal: (0, T.isSet)(s.prepareProposal) ? e.RequestPrepareProposal.fromJSON(s.prepareProposal) : void 0,
        processProposal: (0, T.isSet)(s.processProposal) ? e.RequestProcessProposal.fromJSON(s.processProposal) : void 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.echo !== void 0 && (w.echo = s.echo ? e.RequestEcho.toJSON(s.echo) : void 0), s.flush !== void 0 && (w.flush = s.flush ? e.RequestFlush.toJSON(s.flush) : void 0), s.info !== void 0 && (w.info = s.info ? e.RequestInfo.toJSON(s.info) : void 0), s.initChain !== void 0 && (w.initChain = s.initChain ? e.RequestInitChain.toJSON(s.initChain) : void 0), s.query !== void 0 && (w.query = s.query ? e.RequestQuery.toJSON(s.query) : void 0), s.beginBlock !== void 0 && (w.beginBlock = s.beginBlock ? e.RequestBeginBlock.toJSON(s.beginBlock) : void 0), s.checkTx !== void 0 && (w.checkTx = s.checkTx ? e.RequestCheckTx.toJSON(s.checkTx) : void 0), s.deliverTx !== void 0 && (w.deliverTx = s.deliverTx ? e.RequestDeliverTx.toJSON(s.deliverTx) : void 0), s.endBlock !== void 0 && (w.endBlock = s.endBlock ? e.RequestEndBlock.toJSON(s.endBlock) : void 0), s.commit !== void 0 && (w.commit = s.commit ? e.RequestCommit.toJSON(s.commit) : void 0), s.listSnapshots !== void 0 && (w.listSnapshots = s.listSnapshots ? e.RequestListSnapshots.toJSON(s.listSnapshots) : void 0), s.offerSnapshot !== void 0 && (w.offerSnapshot = s.offerSnapshot ? e.RequestOfferSnapshot.toJSON(s.offerSnapshot) : void 0), s.loadSnapshotChunk !== void 0 && (w.loadSnapshotChunk = s.loadSnapshotChunk ? e.RequestLoadSnapshotChunk.toJSON(s.loadSnapshotChunk) : void 0), s.applySnapshotChunk !== void 0 && (w.applySnapshotChunk = s.applySnapshotChunk ? e.RequestApplySnapshotChunk.toJSON(s.applySnapshotChunk) : void 0), s.prepareProposal !== void 0 && (w.prepareProposal = s.prepareProposal ? e.RequestPrepareProposal.toJSON(s.prepareProposal) : void 0), s.processProposal !== void 0 && (w.processProposal = s.processProposal ? e.RequestProcessProposal.toJSON(s.processProposal) : void 0), w;
    },
    fromPartial(s) {
      const w = y();
      return w.echo = s.echo !== void 0 && s.echo !== null ? e.RequestEcho.fromPartial(s.echo) : void 0, w.flush = s.flush !== void 0 && s.flush !== null ? e.RequestFlush.fromPartial(s.flush) : void 0, w.info = s.info !== void 0 && s.info !== null ? e.RequestInfo.fromPartial(s.info) : void 0, w.initChain = s.initChain !== void 0 && s.initChain !== null ? e.RequestInitChain.fromPartial(s.initChain) : void 0, w.query = s.query !== void 0 && s.query !== null ? e.RequestQuery.fromPartial(s.query) : void 0, w.beginBlock = s.beginBlock !== void 0 && s.beginBlock !== null ? e.RequestBeginBlock.fromPartial(s.beginBlock) : void 0, w.checkTx = s.checkTx !== void 0 && s.checkTx !== null ? e.RequestCheckTx.fromPartial(s.checkTx) : void 0, w.deliverTx = s.deliverTx !== void 0 && s.deliverTx !== null ? e.RequestDeliverTx.fromPartial(s.deliverTx) : void 0, w.endBlock = s.endBlock !== void 0 && s.endBlock !== null ? e.RequestEndBlock.fromPartial(s.endBlock) : void 0, w.commit = s.commit !== void 0 && s.commit !== null ? e.RequestCommit.fromPartial(s.commit) : void 0, w.listSnapshots = s.listSnapshots !== void 0 && s.listSnapshots !== null ? e.RequestListSnapshots.fromPartial(s.listSnapshots) : void 0, w.offerSnapshot = s.offerSnapshot !== void 0 && s.offerSnapshot !== null ? e.RequestOfferSnapshot.fromPartial(s.offerSnapshot) : void 0, w.loadSnapshotChunk = s.loadSnapshotChunk !== void 0 && s.loadSnapshotChunk !== null ? e.RequestLoadSnapshotChunk.fromPartial(s.loadSnapshotChunk) : void 0, w.applySnapshotChunk = s.applySnapshotChunk !== void 0 && s.applySnapshotChunk !== null ? e.RequestApplySnapshotChunk.fromPartial(s.applySnapshotChunk) : void 0, w.prepareProposal = s.prepareProposal !== void 0 && s.prepareProposal !== null ? e.RequestPrepareProposal.fromPartial(s.prepareProposal) : void 0, w.processProposal = s.processProposal !== void 0 && s.processProposal !== null ? e.RequestProcessProposal.fromPartial(s.processProposal) : void 0, w;
    }
  };
  function E() {
    return {
      message: ""
    };
  }
  e.RequestEcho = {
    encode(s, w = L.Writer.create()) {
      return s.message !== "" && w.uint32(10).string(s.message), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = E();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.message = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        message: (0, T.isSet)(s.message) ? String(s.message) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.message !== void 0 && (w.message = s.message), w;
    },
    fromPartial(s) {
      const w = E();
      return w.message = s.message ?? "", w;
    }
  };
  function H() {
    return {};
  }
  e.RequestFlush = {
    encode(s, w = L.Writer.create()) {
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = H();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {};
    },
    toJSON(s) {
      return {};
    },
    fromPartial(s) {
      return H();
    }
  };
  function a() {
    return {
      version: "",
      blockVersion: T.Long.UZERO,
      p2pVersion: T.Long.UZERO,
      abciVersion: ""
    };
  }
  e.RequestInfo = {
    encode(s, w = L.Writer.create()) {
      return s.version !== "" && w.uint32(10).string(s.version), s.blockVersion.isZero() || w.uint32(16).uint64(s.blockVersion), s.p2pVersion.isZero() || w.uint32(24).uint64(s.p2pVersion), s.abciVersion !== "" && w.uint32(34).string(s.abciVersion), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = a();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.version = W.string();
            break;
          case 2:
            $.blockVersion = W.uint64();
            break;
          case 3:
            $.p2pVersion = W.uint64();
            break;
          case 4:
            $.abciVersion = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        version: (0, T.isSet)(s.version) ? String(s.version) : "",
        blockVersion: (0, T.isSet)(s.blockVersion) ? T.Long.fromValue(s.blockVersion) : T.Long.UZERO,
        p2pVersion: (0, T.isSet)(s.p2pVersion) ? T.Long.fromValue(s.p2pVersion) : T.Long.UZERO,
        abciVersion: (0, T.isSet)(s.abciVersion) ? String(s.abciVersion) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.version !== void 0 && (w.version = s.version), s.blockVersion !== void 0 && (w.blockVersion = (s.blockVersion || T.Long.UZERO).toString()), s.p2pVersion !== void 0 && (w.p2pVersion = (s.p2pVersion || T.Long.UZERO).toString()), s.abciVersion !== void 0 && (w.abciVersion = s.abciVersion), w;
    },
    fromPartial(s) {
      const w = a();
      return w.version = s.version ?? "", w.blockVersion = s.blockVersion !== void 0 && s.blockVersion !== null ? T.Long.fromValue(s.blockVersion) : T.Long.UZERO, w.p2pVersion = s.p2pVersion !== void 0 && s.p2pVersion !== null ? T.Long.fromValue(s.p2pVersion) : T.Long.UZERO, w.abciVersion = s.abciVersion ?? "", w;
    }
  };
  function l() {
    return {
      time: void 0,
      chainId: "",
      consensusParams: void 0,
      validators: [],
      appStateBytes: new Uint8Array(),
      initialHeight: T.Long.ZERO
    };
  }
  e.RequestInitChain = {
    encode(s, w = L.Writer.create()) {
      s.time !== void 0 && r.Timestamp.encode(s.time, w.uint32(10).fork()).ldelim(), s.chainId !== "" && w.uint32(18).string(s.chainId), s.consensusParams !== void 0 && u.ConsensusParams.encode(s.consensusParams, w.uint32(26).fork()).ldelim();
      for (const W of s.validators)
        e.ValidatorUpdate.encode(W, w.uint32(34).fork()).ldelim();
      return s.appStateBytes.length !== 0 && w.uint32(42).bytes(s.appStateBytes), s.initialHeight.isZero() || w.uint32(48).int64(s.initialHeight), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = l();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.time = r.Timestamp.decode(W, W.uint32());
            break;
          case 2:
            $.chainId = W.string();
            break;
          case 3:
            $.consensusParams = u.ConsensusParams.decode(W, W.uint32());
            break;
          case 4:
            $.validators.push(e.ValidatorUpdate.decode(W, W.uint32()));
            break;
          case 5:
            $.appStateBytes = W.bytes();
            break;
          case 6:
            $.initialHeight = W.int64();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        time: (0, T.isSet)(s.time) ? (0, T.fromJsonTimestamp)(s.time) : void 0,
        chainId: (0, T.isSet)(s.chainId) ? String(s.chainId) : "",
        consensusParams: (0, T.isSet)(s.consensusParams) ? u.ConsensusParams.fromJSON(s.consensusParams) : void 0,
        validators: Array.isArray(s == null ? void 0 : s.validators) ? s.validators.map((w) => e.ValidatorUpdate.fromJSON(w)) : [],
        appStateBytes: (0, T.isSet)(s.appStateBytes) ? (0, T.bytesFromBase64)(s.appStateBytes) : new Uint8Array(),
        initialHeight: (0, T.isSet)(s.initialHeight) ? T.Long.fromValue(s.initialHeight) : T.Long.ZERO
      };
    },
    toJSON(s) {
      const w = {};
      return s.time !== void 0 && (w.time = (0, T.fromTimestamp)(s.time).toISOString()), s.chainId !== void 0 && (w.chainId = s.chainId), s.consensusParams !== void 0 && (w.consensusParams = s.consensusParams ? u.ConsensusParams.toJSON(s.consensusParams) : void 0), s.validators ? w.validators = s.validators.map((W) => W ? e.ValidatorUpdate.toJSON(W) : void 0) : w.validators = [], s.appStateBytes !== void 0 && (w.appStateBytes = (0, T.base64FromBytes)(s.appStateBytes !== void 0 ? s.appStateBytes : new Uint8Array())), s.initialHeight !== void 0 && (w.initialHeight = (s.initialHeight || T.Long.ZERO).toString()), w;
    },
    fromPartial(s) {
      var W;
      const w = l();
      return w.time = s.time !== void 0 && s.time !== null ? r.Timestamp.fromPartial(s.time) : void 0, w.chainId = s.chainId ?? "", w.consensusParams = s.consensusParams !== void 0 && s.consensusParams !== null ? u.ConsensusParams.fromPartial(s.consensusParams) : void 0, w.validators = ((W = s.validators) == null ? void 0 : W.map((Y) => e.ValidatorUpdate.fromPartial(Y))) || [], w.appStateBytes = s.appStateBytes ?? new Uint8Array(), w.initialHeight = s.initialHeight !== void 0 && s.initialHeight !== null ? T.Long.fromValue(s.initialHeight) : T.Long.ZERO, w;
    }
  };
  function C() {
    return {
      data: new Uint8Array(),
      path: "",
      height: T.Long.ZERO,
      prove: !1
    };
  }
  e.RequestQuery = {
    encode(s, w = L.Writer.create()) {
      return s.data.length !== 0 && w.uint32(10).bytes(s.data), s.path !== "" && w.uint32(18).string(s.path), s.height.isZero() || w.uint32(24).int64(s.height), s.prove === !0 && w.uint32(32).bool(s.prove), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = C();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.data = W.bytes();
            break;
          case 2:
            $.path = W.string();
            break;
          case 3:
            $.height = W.int64();
            break;
          case 4:
            $.prove = W.bool();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        data: (0, T.isSet)(s.data) ? (0, T.bytesFromBase64)(s.data) : new Uint8Array(),
        path: (0, T.isSet)(s.path) ? String(s.path) : "",
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO,
        prove: (0, T.isSet)(s.prove) ? !!s.prove : !1
      };
    },
    toJSON(s) {
      const w = {};
      return s.data !== void 0 && (w.data = (0, T.base64FromBytes)(s.data !== void 0 ? s.data : new Uint8Array())), s.path !== void 0 && (w.path = s.path), s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), s.prove !== void 0 && (w.prove = s.prove), w;
    },
    fromPartial(s) {
      const w = C();
      return w.data = s.data ?? new Uint8Array(), w.path = s.path ?? "", w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w.prove = s.prove ?? !1, w;
    }
  };
  function v() {
    return {
      hash: new Uint8Array(),
      header: void 0,
      lastCommitInfo: void 0,
      byzantineValidators: []
    };
  }
  e.RequestBeginBlock = {
    encode(s, w = L.Writer.create()) {
      s.hash.length !== 0 && w.uint32(10).bytes(s.hash), s.header !== void 0 && f.Header.encode(s.header, w.uint32(18).fork()).ldelim(), s.lastCommitInfo !== void 0 && e.CommitInfo.encode(s.lastCommitInfo, w.uint32(26).fork()).ldelim();
      for (const W of s.byzantineValidators)
        e.Misbehavior.encode(W, w.uint32(34).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = v();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.hash = W.bytes();
            break;
          case 2:
            $.header = f.Header.decode(W, W.uint32());
            break;
          case 3:
            $.lastCommitInfo = e.CommitInfo.decode(W, W.uint32());
            break;
          case 4:
            $.byzantineValidators.push(e.Misbehavior.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        hash: (0, T.isSet)(s.hash) ? (0, T.bytesFromBase64)(s.hash) : new Uint8Array(),
        header: (0, T.isSet)(s.header) ? f.Header.fromJSON(s.header) : void 0,
        lastCommitInfo: (0, T.isSet)(s.lastCommitInfo) ? e.CommitInfo.fromJSON(s.lastCommitInfo) : void 0,
        byzantineValidators: Array.isArray(s == null ? void 0 : s.byzantineValidators) ? s.byzantineValidators.map((w) => e.Misbehavior.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.hash !== void 0 && (w.hash = (0, T.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), s.header !== void 0 && (w.header = s.header ? f.Header.toJSON(s.header) : void 0), s.lastCommitInfo !== void 0 && (w.lastCommitInfo = s.lastCommitInfo ? e.CommitInfo.toJSON(s.lastCommitInfo) : void 0), s.byzantineValidators ? w.byzantineValidators = s.byzantineValidators.map((W) => W ? e.Misbehavior.toJSON(W) : void 0) : w.byzantineValidators = [], w;
    },
    fromPartial(s) {
      var W;
      const w = v();
      return w.hash = s.hash ?? new Uint8Array(), w.header = s.header !== void 0 && s.header !== null ? f.Header.fromPartial(s.header) : void 0, w.lastCommitInfo = s.lastCommitInfo !== void 0 && s.lastCommitInfo !== null ? e.CommitInfo.fromPartial(s.lastCommitInfo) : void 0, w.byzantineValidators = ((W = s.byzantineValidators) == null ? void 0 : W.map((Y) => e.Misbehavior.fromPartial(Y))) || [], w;
    }
  };
  function k() {
    return {
      tx: new Uint8Array(),
      type: 0
    };
  }
  e.RequestCheckTx = {
    encode(s, w = L.Writer.create()) {
      return s.tx.length !== 0 && w.uint32(10).bytes(s.tx), s.type !== 0 && w.uint32(16).int32(s.type), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = k();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.tx = W.bytes();
            break;
          case 2:
            $.type = W.int32();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        tx: (0, T.isSet)(s.tx) ? (0, T.bytesFromBase64)(s.tx) : new Uint8Array(),
        type: (0, T.isSet)(s.type) ? V(s.type) : 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.tx !== void 0 && (w.tx = (0, T.base64FromBytes)(s.tx !== void 0 ? s.tx : new Uint8Array())), s.type !== void 0 && (w.type = D(s.type)), w;
    },
    fromPartial(s) {
      const w = k();
      return w.tx = s.tx ?? new Uint8Array(), w.type = s.type ?? 0, w;
    }
  };
  function U() {
    return {
      tx: new Uint8Array()
    };
  }
  e.RequestDeliverTx = {
    encode(s, w = L.Writer.create()) {
      return s.tx.length !== 0 && w.uint32(10).bytes(s.tx), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = U();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.tx = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        tx: (0, T.isSet)(s.tx) ? (0, T.bytesFromBase64)(s.tx) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.tx !== void 0 && (w.tx = (0, T.base64FromBytes)(s.tx !== void 0 ? s.tx : new Uint8Array())), w;
    },
    fromPartial(s) {
      const w = U();
      return w.tx = s.tx ?? new Uint8Array(), w;
    }
  };
  function F() {
    return {
      height: T.Long.ZERO
    };
  }
  e.RequestEndBlock = {
    encode(s, w = L.Writer.create()) {
      return s.height.isZero() || w.uint32(8).int64(s.height), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = F();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.height = W.int64();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO
      };
    },
    toJSON(s) {
      const w = {};
      return s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), w;
    },
    fromPartial(s) {
      const w = F();
      return w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w;
    }
  };
  function q() {
    return {};
  }
  e.RequestCommit = {
    encode(s, w = L.Writer.create()) {
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = q();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {};
    },
    toJSON(s) {
      return {};
    },
    fromPartial(s) {
      return q();
    }
  };
  function o() {
    return {};
  }
  e.RequestListSnapshots = {
    encode(s, w = L.Writer.create()) {
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = o();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {};
    },
    toJSON(s) {
      return {};
    },
    fromPartial(s) {
      return o();
    }
  };
  function P() {
    return {
      snapshot: void 0,
      appHash: new Uint8Array()
    };
  }
  e.RequestOfferSnapshot = {
    encode(s, w = L.Writer.create()) {
      return s.snapshot !== void 0 && e.Snapshot.encode(s.snapshot, w.uint32(10).fork()).ldelim(), s.appHash.length !== 0 && w.uint32(18).bytes(s.appHash), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = P();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.snapshot = e.Snapshot.decode(W, W.uint32());
            break;
          case 2:
            $.appHash = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        snapshot: (0, T.isSet)(s.snapshot) ? e.Snapshot.fromJSON(s.snapshot) : void 0,
        appHash: (0, T.isSet)(s.appHash) ? (0, T.bytesFromBase64)(s.appHash) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.snapshot !== void 0 && (w.snapshot = s.snapshot ? e.Snapshot.toJSON(s.snapshot) : void 0), s.appHash !== void 0 && (w.appHash = (0, T.base64FromBytes)(s.appHash !== void 0 ? s.appHash : new Uint8Array())), w;
    },
    fromPartial(s) {
      const w = P();
      return w.snapshot = s.snapshot !== void 0 && s.snapshot !== null ? e.Snapshot.fromPartial(s.snapshot) : void 0, w.appHash = s.appHash ?? new Uint8Array(), w;
    }
  };
  function m() {
    return {
      height: T.Long.UZERO,
      format: 0,
      chunk: 0
    };
  }
  e.RequestLoadSnapshotChunk = {
    encode(s, w = L.Writer.create()) {
      return s.height.isZero() || w.uint32(8).uint64(s.height), s.format !== 0 && w.uint32(16).uint32(s.format), s.chunk !== 0 && w.uint32(24).uint32(s.chunk), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = m();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.height = W.uint64();
            break;
          case 2:
            $.format = W.uint32();
            break;
          case 3:
            $.chunk = W.uint32();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.UZERO,
        format: (0, T.isSet)(s.format) ? Number(s.format) : 0,
        chunk: (0, T.isSet)(s.chunk) ? Number(s.chunk) : 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.height !== void 0 && (w.height = (s.height || T.Long.UZERO).toString()), s.format !== void 0 && (w.format = Math.round(s.format)), s.chunk !== void 0 && (w.chunk = Math.round(s.chunk)), w;
    },
    fromPartial(s) {
      const w = m();
      return w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.UZERO, w.format = s.format ?? 0, w.chunk = s.chunk ?? 0, w;
    }
  };
  function R() {
    return {
      index: 0,
      chunk: new Uint8Array(),
      sender: ""
    };
  }
  e.RequestApplySnapshotChunk = {
    encode(s, w = L.Writer.create()) {
      return s.index !== 0 && w.uint32(8).uint32(s.index), s.chunk.length !== 0 && w.uint32(18).bytes(s.chunk), s.sender !== "" && w.uint32(26).string(s.sender), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = R();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.index = W.uint32();
            break;
          case 2:
            $.chunk = W.bytes();
            break;
          case 3:
            $.sender = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        index: (0, T.isSet)(s.index) ? Number(s.index) : 0,
        chunk: (0, T.isSet)(s.chunk) ? (0, T.bytesFromBase64)(s.chunk) : new Uint8Array(),
        sender: (0, T.isSet)(s.sender) ? String(s.sender) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.index !== void 0 && (w.index = Math.round(s.index)), s.chunk !== void 0 && (w.chunk = (0, T.base64FromBytes)(s.chunk !== void 0 ? s.chunk : new Uint8Array())), s.sender !== void 0 && (w.sender = s.sender), w;
    },
    fromPartial(s) {
      const w = R();
      return w.index = s.index ?? 0, w.chunk = s.chunk ?? new Uint8Array(), w.sender = s.sender ?? "", w;
    }
  };
  function N() {
    return {
      maxTxBytes: T.Long.ZERO,
      txs: [],
      localLastCommit: void 0,
      misbehavior: [],
      height: T.Long.ZERO,
      time: void 0,
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestPrepareProposal = {
    encode(s, w = L.Writer.create()) {
      s.maxTxBytes.isZero() || w.uint32(8).int64(s.maxTxBytes);
      for (const W of s.txs)
        w.uint32(18).bytes(W);
      s.localLastCommit !== void 0 && e.ExtendedCommitInfo.encode(s.localLastCommit, w.uint32(26).fork()).ldelim();
      for (const W of s.misbehavior)
        e.Misbehavior.encode(W, w.uint32(34).fork()).ldelim();
      return s.height.isZero() || w.uint32(40).int64(s.height), s.time !== void 0 && r.Timestamp.encode(s.time, w.uint32(50).fork()).ldelim(), s.nextValidatorsHash.length !== 0 && w.uint32(58).bytes(s.nextValidatorsHash), s.proposerAddress.length !== 0 && w.uint32(66).bytes(s.proposerAddress), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = N();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.maxTxBytes = W.int64();
            break;
          case 2:
            $.txs.push(W.bytes());
            break;
          case 3:
            $.localLastCommit = e.ExtendedCommitInfo.decode(W, W.uint32());
            break;
          case 4:
            $.misbehavior.push(e.Misbehavior.decode(W, W.uint32()));
            break;
          case 5:
            $.height = W.int64();
            break;
          case 6:
            $.time = r.Timestamp.decode(W, W.uint32());
            break;
          case 7:
            $.nextValidatorsHash = W.bytes();
            break;
          case 8:
            $.proposerAddress = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        maxTxBytes: (0, T.isSet)(s.maxTxBytes) ? T.Long.fromValue(s.maxTxBytes) : T.Long.ZERO,
        txs: Array.isArray(s == null ? void 0 : s.txs) ? s.txs.map((w) => (0, T.bytesFromBase64)(w)) : [],
        localLastCommit: (0, T.isSet)(s.localLastCommit) ? e.ExtendedCommitInfo.fromJSON(s.localLastCommit) : void 0,
        misbehavior: Array.isArray(s == null ? void 0 : s.misbehavior) ? s.misbehavior.map((w) => e.Misbehavior.fromJSON(w)) : [],
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO,
        time: (0, T.isSet)(s.time) ? (0, T.fromJsonTimestamp)(s.time) : void 0,
        nextValidatorsHash: (0, T.isSet)(s.nextValidatorsHash) ? (0, T.bytesFromBase64)(s.nextValidatorsHash) : new Uint8Array(),
        proposerAddress: (0, T.isSet)(s.proposerAddress) ? (0, T.bytesFromBase64)(s.proposerAddress) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.maxTxBytes !== void 0 && (w.maxTxBytes = (s.maxTxBytes || T.Long.ZERO).toString()), s.txs ? w.txs = s.txs.map((W) => (0, T.base64FromBytes)(W !== void 0 ? W : new Uint8Array())) : w.txs = [], s.localLastCommit !== void 0 && (w.localLastCommit = s.localLastCommit ? e.ExtendedCommitInfo.toJSON(s.localLastCommit) : void 0), s.misbehavior ? w.misbehavior = s.misbehavior.map((W) => W ? e.Misbehavior.toJSON(W) : void 0) : w.misbehavior = [], s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), s.time !== void 0 && (w.time = (0, T.fromTimestamp)(s.time).toISOString()), s.nextValidatorsHash !== void 0 && (w.nextValidatorsHash = (0, T.base64FromBytes)(s.nextValidatorsHash !== void 0 ? s.nextValidatorsHash : new Uint8Array())), s.proposerAddress !== void 0 && (w.proposerAddress = (0, T.base64FromBytes)(s.proposerAddress !== void 0 ? s.proposerAddress : new Uint8Array())), w;
    },
    fromPartial(s) {
      var W, Y;
      const w = N();
      return w.maxTxBytes = s.maxTxBytes !== void 0 && s.maxTxBytes !== null ? T.Long.fromValue(s.maxTxBytes) : T.Long.ZERO, w.txs = ((W = s.txs) == null ? void 0 : W.map(($) => $)) || [], w.localLastCommit = s.localLastCommit !== void 0 && s.localLastCommit !== null ? e.ExtendedCommitInfo.fromPartial(s.localLastCommit) : void 0, w.misbehavior = ((Y = s.misbehavior) == null ? void 0 : Y.map(($) => e.Misbehavior.fromPartial($))) || [], w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w.time = s.time !== void 0 && s.time !== null ? r.Timestamp.fromPartial(s.time) : void 0, w.nextValidatorsHash = s.nextValidatorsHash ?? new Uint8Array(), w.proposerAddress = s.proposerAddress ?? new Uint8Array(), w;
    }
  };
  function Q() {
    return {
      txs: [],
      proposedLastCommit: void 0,
      misbehavior: [],
      hash: new Uint8Array(),
      height: T.Long.ZERO,
      time: void 0,
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestProcessProposal = {
    encode(s, w = L.Writer.create()) {
      for (const W of s.txs)
        w.uint32(10).bytes(W);
      s.proposedLastCommit !== void 0 && e.CommitInfo.encode(s.proposedLastCommit, w.uint32(18).fork()).ldelim();
      for (const W of s.misbehavior)
        e.Misbehavior.encode(W, w.uint32(26).fork()).ldelim();
      return s.hash.length !== 0 && w.uint32(34).bytes(s.hash), s.height.isZero() || w.uint32(40).int64(s.height), s.time !== void 0 && r.Timestamp.encode(s.time, w.uint32(50).fork()).ldelim(), s.nextValidatorsHash.length !== 0 && w.uint32(58).bytes(s.nextValidatorsHash), s.proposerAddress.length !== 0 && w.uint32(66).bytes(s.proposerAddress), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Q();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.txs.push(W.bytes());
            break;
          case 2:
            $.proposedLastCommit = e.CommitInfo.decode(W, W.uint32());
            break;
          case 3:
            $.misbehavior.push(e.Misbehavior.decode(W, W.uint32()));
            break;
          case 4:
            $.hash = W.bytes();
            break;
          case 5:
            $.height = W.int64();
            break;
          case 6:
            $.time = r.Timestamp.decode(W, W.uint32());
            break;
          case 7:
            $.nextValidatorsHash = W.bytes();
            break;
          case 8:
            $.proposerAddress = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        txs: Array.isArray(s == null ? void 0 : s.txs) ? s.txs.map((w) => (0, T.bytesFromBase64)(w)) : [],
        proposedLastCommit: (0, T.isSet)(s.proposedLastCommit) ? e.CommitInfo.fromJSON(s.proposedLastCommit) : void 0,
        misbehavior: Array.isArray(s == null ? void 0 : s.misbehavior) ? s.misbehavior.map((w) => e.Misbehavior.fromJSON(w)) : [],
        hash: (0, T.isSet)(s.hash) ? (0, T.bytesFromBase64)(s.hash) : new Uint8Array(),
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO,
        time: (0, T.isSet)(s.time) ? (0, T.fromJsonTimestamp)(s.time) : void 0,
        nextValidatorsHash: (0, T.isSet)(s.nextValidatorsHash) ? (0, T.bytesFromBase64)(s.nextValidatorsHash) : new Uint8Array(),
        proposerAddress: (0, T.isSet)(s.proposerAddress) ? (0, T.bytesFromBase64)(s.proposerAddress) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.txs ? w.txs = s.txs.map((W) => (0, T.base64FromBytes)(W !== void 0 ? W : new Uint8Array())) : w.txs = [], s.proposedLastCommit !== void 0 && (w.proposedLastCommit = s.proposedLastCommit ? e.CommitInfo.toJSON(s.proposedLastCommit) : void 0), s.misbehavior ? w.misbehavior = s.misbehavior.map((W) => W ? e.Misbehavior.toJSON(W) : void 0) : w.misbehavior = [], s.hash !== void 0 && (w.hash = (0, T.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), s.time !== void 0 && (w.time = (0, T.fromTimestamp)(s.time).toISOString()), s.nextValidatorsHash !== void 0 && (w.nextValidatorsHash = (0, T.base64FromBytes)(s.nextValidatorsHash !== void 0 ? s.nextValidatorsHash : new Uint8Array())), s.proposerAddress !== void 0 && (w.proposerAddress = (0, T.base64FromBytes)(s.proposerAddress !== void 0 ? s.proposerAddress : new Uint8Array())), w;
    },
    fromPartial(s) {
      var W, Y;
      const w = Q();
      return w.txs = ((W = s.txs) == null ? void 0 : W.map(($) => $)) || [], w.proposedLastCommit = s.proposedLastCommit !== void 0 && s.proposedLastCommit !== null ? e.CommitInfo.fromPartial(s.proposedLastCommit) : void 0, w.misbehavior = ((Y = s.misbehavior) == null ? void 0 : Y.map(($) => e.Misbehavior.fromPartial($))) || [], w.hash = s.hash ?? new Uint8Array(), w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w.time = s.time !== void 0 && s.time !== null ? r.Timestamp.fromPartial(s.time) : void 0, w.nextValidatorsHash = s.nextValidatorsHash ?? new Uint8Array(), w.proposerAddress = s.proposerAddress ?? new Uint8Array(), w;
    }
  };
  function K() {
    return {
      exception: void 0,
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Response = {
    encode(s, w = L.Writer.create()) {
      return s.exception !== void 0 && e.ResponseException.encode(s.exception, w.uint32(10).fork()).ldelim(), s.echo !== void 0 && e.ResponseEcho.encode(s.echo, w.uint32(18).fork()).ldelim(), s.flush !== void 0 && e.ResponseFlush.encode(s.flush, w.uint32(26).fork()).ldelim(), s.info !== void 0 && e.ResponseInfo.encode(s.info, w.uint32(34).fork()).ldelim(), s.initChain !== void 0 && e.ResponseInitChain.encode(s.initChain, w.uint32(50).fork()).ldelim(), s.query !== void 0 && e.ResponseQuery.encode(s.query, w.uint32(58).fork()).ldelim(), s.beginBlock !== void 0 && e.ResponseBeginBlock.encode(s.beginBlock, w.uint32(66).fork()).ldelim(), s.checkTx !== void 0 && e.ResponseCheckTx.encode(s.checkTx, w.uint32(74).fork()).ldelim(), s.deliverTx !== void 0 && e.ResponseDeliverTx.encode(s.deliverTx, w.uint32(82).fork()).ldelim(), s.endBlock !== void 0 && e.ResponseEndBlock.encode(s.endBlock, w.uint32(90).fork()).ldelim(), s.commit !== void 0 && e.ResponseCommit.encode(s.commit, w.uint32(98).fork()).ldelim(), s.listSnapshots !== void 0 && e.ResponseListSnapshots.encode(s.listSnapshots, w.uint32(106).fork()).ldelim(), s.offerSnapshot !== void 0 && e.ResponseOfferSnapshot.encode(s.offerSnapshot, w.uint32(114).fork()).ldelim(), s.loadSnapshotChunk !== void 0 && e.ResponseLoadSnapshotChunk.encode(s.loadSnapshotChunk, w.uint32(122).fork()).ldelim(), s.applySnapshotChunk !== void 0 && e.ResponseApplySnapshotChunk.encode(s.applySnapshotChunk, w.uint32(130).fork()).ldelim(), s.prepareProposal !== void 0 && e.ResponsePrepareProposal.encode(s.prepareProposal, w.uint32(138).fork()).ldelim(), s.processProposal !== void 0 && e.ResponseProcessProposal.encode(s.processProposal, w.uint32(146).fork()).ldelim(), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = K();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.exception = e.ResponseException.decode(W, W.uint32());
            break;
          case 2:
            $.echo = e.ResponseEcho.decode(W, W.uint32());
            break;
          case 3:
            $.flush = e.ResponseFlush.decode(W, W.uint32());
            break;
          case 4:
            $.info = e.ResponseInfo.decode(W, W.uint32());
            break;
          case 6:
            $.initChain = e.ResponseInitChain.decode(W, W.uint32());
            break;
          case 7:
            $.query = e.ResponseQuery.decode(W, W.uint32());
            break;
          case 8:
            $.beginBlock = e.ResponseBeginBlock.decode(W, W.uint32());
            break;
          case 9:
            $.checkTx = e.ResponseCheckTx.decode(W, W.uint32());
            break;
          case 10:
            $.deliverTx = e.ResponseDeliverTx.decode(W, W.uint32());
            break;
          case 11:
            $.endBlock = e.ResponseEndBlock.decode(W, W.uint32());
            break;
          case 12:
            $.commit = e.ResponseCommit.decode(W, W.uint32());
            break;
          case 13:
            $.listSnapshots = e.ResponseListSnapshots.decode(W, W.uint32());
            break;
          case 14:
            $.offerSnapshot = e.ResponseOfferSnapshot.decode(W, W.uint32());
            break;
          case 15:
            $.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.decode(W, W.uint32());
            break;
          case 16:
            $.applySnapshotChunk = e.ResponseApplySnapshotChunk.decode(W, W.uint32());
            break;
          case 17:
            $.prepareProposal = e.ResponsePrepareProposal.decode(W, W.uint32());
            break;
          case 18:
            $.processProposal = e.ResponseProcessProposal.decode(W, W.uint32());
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        exception: (0, T.isSet)(s.exception) ? e.ResponseException.fromJSON(s.exception) : void 0,
        echo: (0, T.isSet)(s.echo) ? e.ResponseEcho.fromJSON(s.echo) : void 0,
        flush: (0, T.isSet)(s.flush) ? e.ResponseFlush.fromJSON(s.flush) : void 0,
        info: (0, T.isSet)(s.info) ? e.ResponseInfo.fromJSON(s.info) : void 0,
        initChain: (0, T.isSet)(s.initChain) ? e.ResponseInitChain.fromJSON(s.initChain) : void 0,
        query: (0, T.isSet)(s.query) ? e.ResponseQuery.fromJSON(s.query) : void 0,
        beginBlock: (0, T.isSet)(s.beginBlock) ? e.ResponseBeginBlock.fromJSON(s.beginBlock) : void 0,
        checkTx: (0, T.isSet)(s.checkTx) ? e.ResponseCheckTx.fromJSON(s.checkTx) : void 0,
        deliverTx: (0, T.isSet)(s.deliverTx) ? e.ResponseDeliverTx.fromJSON(s.deliverTx) : void 0,
        endBlock: (0, T.isSet)(s.endBlock) ? e.ResponseEndBlock.fromJSON(s.endBlock) : void 0,
        commit: (0, T.isSet)(s.commit) ? e.ResponseCommit.fromJSON(s.commit) : void 0,
        listSnapshots: (0, T.isSet)(s.listSnapshots) ? e.ResponseListSnapshots.fromJSON(s.listSnapshots) : void 0,
        offerSnapshot: (0, T.isSet)(s.offerSnapshot) ? e.ResponseOfferSnapshot.fromJSON(s.offerSnapshot) : void 0,
        loadSnapshotChunk: (0, T.isSet)(s.loadSnapshotChunk) ? e.ResponseLoadSnapshotChunk.fromJSON(s.loadSnapshotChunk) : void 0,
        applySnapshotChunk: (0, T.isSet)(s.applySnapshotChunk) ? e.ResponseApplySnapshotChunk.fromJSON(s.applySnapshotChunk) : void 0,
        prepareProposal: (0, T.isSet)(s.prepareProposal) ? e.ResponsePrepareProposal.fromJSON(s.prepareProposal) : void 0,
        processProposal: (0, T.isSet)(s.processProposal) ? e.ResponseProcessProposal.fromJSON(s.processProposal) : void 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.exception !== void 0 && (w.exception = s.exception ? e.ResponseException.toJSON(s.exception) : void 0), s.echo !== void 0 && (w.echo = s.echo ? e.ResponseEcho.toJSON(s.echo) : void 0), s.flush !== void 0 && (w.flush = s.flush ? e.ResponseFlush.toJSON(s.flush) : void 0), s.info !== void 0 && (w.info = s.info ? e.ResponseInfo.toJSON(s.info) : void 0), s.initChain !== void 0 && (w.initChain = s.initChain ? e.ResponseInitChain.toJSON(s.initChain) : void 0), s.query !== void 0 && (w.query = s.query ? e.ResponseQuery.toJSON(s.query) : void 0), s.beginBlock !== void 0 && (w.beginBlock = s.beginBlock ? e.ResponseBeginBlock.toJSON(s.beginBlock) : void 0), s.checkTx !== void 0 && (w.checkTx = s.checkTx ? e.ResponseCheckTx.toJSON(s.checkTx) : void 0), s.deliverTx !== void 0 && (w.deliverTx = s.deliverTx ? e.ResponseDeliverTx.toJSON(s.deliverTx) : void 0), s.endBlock !== void 0 && (w.endBlock = s.endBlock ? e.ResponseEndBlock.toJSON(s.endBlock) : void 0), s.commit !== void 0 && (w.commit = s.commit ? e.ResponseCommit.toJSON(s.commit) : void 0), s.listSnapshots !== void 0 && (w.listSnapshots = s.listSnapshots ? e.ResponseListSnapshots.toJSON(s.listSnapshots) : void 0), s.offerSnapshot !== void 0 && (w.offerSnapshot = s.offerSnapshot ? e.ResponseOfferSnapshot.toJSON(s.offerSnapshot) : void 0), s.loadSnapshotChunk !== void 0 && (w.loadSnapshotChunk = s.loadSnapshotChunk ? e.ResponseLoadSnapshotChunk.toJSON(s.loadSnapshotChunk) : void 0), s.applySnapshotChunk !== void 0 && (w.applySnapshotChunk = s.applySnapshotChunk ? e.ResponseApplySnapshotChunk.toJSON(s.applySnapshotChunk) : void 0), s.prepareProposal !== void 0 && (w.prepareProposal = s.prepareProposal ? e.ResponsePrepareProposal.toJSON(s.prepareProposal) : void 0), s.processProposal !== void 0 && (w.processProposal = s.processProposal ? e.ResponseProcessProposal.toJSON(s.processProposal) : void 0), w;
    },
    fromPartial(s) {
      const w = K();
      return w.exception = s.exception !== void 0 && s.exception !== null ? e.ResponseException.fromPartial(s.exception) : void 0, w.echo = s.echo !== void 0 && s.echo !== null ? e.ResponseEcho.fromPartial(s.echo) : void 0, w.flush = s.flush !== void 0 && s.flush !== null ? e.ResponseFlush.fromPartial(s.flush) : void 0, w.info = s.info !== void 0 && s.info !== null ? e.ResponseInfo.fromPartial(s.info) : void 0, w.initChain = s.initChain !== void 0 && s.initChain !== null ? e.ResponseInitChain.fromPartial(s.initChain) : void 0, w.query = s.query !== void 0 && s.query !== null ? e.ResponseQuery.fromPartial(s.query) : void 0, w.beginBlock = s.beginBlock !== void 0 && s.beginBlock !== null ? e.ResponseBeginBlock.fromPartial(s.beginBlock) : void 0, w.checkTx = s.checkTx !== void 0 && s.checkTx !== null ? e.ResponseCheckTx.fromPartial(s.checkTx) : void 0, w.deliverTx = s.deliverTx !== void 0 && s.deliverTx !== null ? e.ResponseDeliverTx.fromPartial(s.deliverTx) : void 0, w.endBlock = s.endBlock !== void 0 && s.endBlock !== null ? e.ResponseEndBlock.fromPartial(s.endBlock) : void 0, w.commit = s.commit !== void 0 && s.commit !== null ? e.ResponseCommit.fromPartial(s.commit) : void 0, w.listSnapshots = s.listSnapshots !== void 0 && s.listSnapshots !== null ? e.ResponseListSnapshots.fromPartial(s.listSnapshots) : void 0, w.offerSnapshot = s.offerSnapshot !== void 0 && s.offerSnapshot !== null ? e.ResponseOfferSnapshot.fromPartial(s.offerSnapshot) : void 0, w.loadSnapshotChunk = s.loadSnapshotChunk !== void 0 && s.loadSnapshotChunk !== null ? e.ResponseLoadSnapshotChunk.fromPartial(s.loadSnapshotChunk) : void 0, w.applySnapshotChunk = s.applySnapshotChunk !== void 0 && s.applySnapshotChunk !== null ? e.ResponseApplySnapshotChunk.fromPartial(s.applySnapshotChunk) : void 0, w.prepareProposal = s.prepareProposal !== void 0 && s.prepareProposal !== null ? e.ResponsePrepareProposal.fromPartial(s.prepareProposal) : void 0, w.processProposal = s.processProposal !== void 0 && s.processProposal !== null ? e.ResponseProcessProposal.fromPartial(s.processProposal) : void 0, w;
    }
  };
  function z() {
    return {
      error: ""
    };
  }
  e.ResponseException = {
    encode(s, w = L.Writer.create()) {
      return s.error !== "" && w.uint32(10).string(s.error), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = z();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.error = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        error: (0, T.isSet)(s.error) ? String(s.error) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.error !== void 0 && (w.error = s.error), w;
    },
    fromPartial(s) {
      const w = z();
      return w.error = s.error ?? "", w;
    }
  };
  function re() {
    return {
      message: ""
    };
  }
  e.ResponseEcho = {
    encode(s, w = L.Writer.create()) {
      return s.message !== "" && w.uint32(10).string(s.message), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = re();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.message = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        message: (0, T.isSet)(s.message) ? String(s.message) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.message !== void 0 && (w.message = s.message), w;
    },
    fromPartial(s) {
      const w = re();
      return w.message = s.message ?? "", w;
    }
  };
  function Ea() {
    return {};
  }
  e.ResponseFlush = {
    encode(s, w = L.Writer.create()) {
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ea();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {};
    },
    toJSON(s) {
      return {};
    },
    fromPartial(s) {
      return Ea();
    }
  };
  function Ca() {
    return {
      data: "",
      version: "",
      appVersion: T.Long.UZERO,
      lastBlockHeight: T.Long.ZERO,
      lastBlockAppHash: new Uint8Array()
    };
  }
  e.ResponseInfo = {
    encode(s, w = L.Writer.create()) {
      return s.data !== "" && w.uint32(10).string(s.data), s.version !== "" && w.uint32(18).string(s.version), s.appVersion.isZero() || w.uint32(24).uint64(s.appVersion), s.lastBlockHeight.isZero() || w.uint32(32).int64(s.lastBlockHeight), s.lastBlockAppHash.length !== 0 && w.uint32(42).bytes(s.lastBlockAppHash), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ca();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.data = W.string();
            break;
          case 2:
            $.version = W.string();
            break;
          case 3:
            $.appVersion = W.uint64();
            break;
          case 4:
            $.lastBlockHeight = W.int64();
            break;
          case 5:
            $.lastBlockAppHash = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        data: (0, T.isSet)(s.data) ? String(s.data) : "",
        version: (0, T.isSet)(s.version) ? String(s.version) : "",
        appVersion: (0, T.isSet)(s.appVersion) ? T.Long.fromValue(s.appVersion) : T.Long.UZERO,
        lastBlockHeight: (0, T.isSet)(s.lastBlockHeight) ? T.Long.fromValue(s.lastBlockHeight) : T.Long.ZERO,
        lastBlockAppHash: (0, T.isSet)(s.lastBlockAppHash) ? (0, T.bytesFromBase64)(s.lastBlockAppHash) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.data !== void 0 && (w.data = s.data), s.version !== void 0 && (w.version = s.version), s.appVersion !== void 0 && (w.appVersion = (s.appVersion || T.Long.UZERO).toString()), s.lastBlockHeight !== void 0 && (w.lastBlockHeight = (s.lastBlockHeight || T.Long.ZERO).toString()), s.lastBlockAppHash !== void 0 && (w.lastBlockAppHash = (0, T.base64FromBytes)(s.lastBlockAppHash !== void 0 ? s.lastBlockAppHash : new Uint8Array())), w;
    },
    fromPartial(s) {
      const w = Ca();
      return w.data = s.data ?? "", w.version = s.version ?? "", w.appVersion = s.appVersion !== void 0 && s.appVersion !== null ? T.Long.fromValue(s.appVersion) : T.Long.UZERO, w.lastBlockHeight = s.lastBlockHeight !== void 0 && s.lastBlockHeight !== null ? T.Long.fromValue(s.lastBlockHeight) : T.Long.ZERO, w.lastBlockAppHash = s.lastBlockAppHash ?? new Uint8Array(), w;
    }
  };
  function Ia() {
    return {
      consensusParams: void 0,
      validators: [],
      appHash: new Uint8Array()
    };
  }
  e.ResponseInitChain = {
    encode(s, w = L.Writer.create()) {
      s.consensusParams !== void 0 && u.ConsensusParams.encode(s.consensusParams, w.uint32(10).fork()).ldelim();
      for (const W of s.validators)
        e.ValidatorUpdate.encode(W, w.uint32(18).fork()).ldelim();
      return s.appHash.length !== 0 && w.uint32(26).bytes(s.appHash), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ia();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.consensusParams = u.ConsensusParams.decode(W, W.uint32());
            break;
          case 2:
            $.validators.push(e.ValidatorUpdate.decode(W, W.uint32()));
            break;
          case 3:
            $.appHash = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        consensusParams: (0, T.isSet)(s.consensusParams) ? u.ConsensusParams.fromJSON(s.consensusParams) : void 0,
        validators: Array.isArray(s == null ? void 0 : s.validators) ? s.validators.map((w) => e.ValidatorUpdate.fromJSON(w)) : [],
        appHash: (0, T.isSet)(s.appHash) ? (0, T.bytesFromBase64)(s.appHash) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.consensusParams !== void 0 && (w.consensusParams = s.consensusParams ? u.ConsensusParams.toJSON(s.consensusParams) : void 0), s.validators ? w.validators = s.validators.map((W) => W ? e.ValidatorUpdate.toJSON(W) : void 0) : w.validators = [], s.appHash !== void 0 && (w.appHash = (0, T.base64FromBytes)(s.appHash !== void 0 ? s.appHash : new Uint8Array())), w;
    },
    fromPartial(s) {
      var W;
      const w = Ia();
      return w.consensusParams = s.consensusParams !== void 0 && s.consensusParams !== null ? u.ConsensusParams.fromPartial(s.consensusParams) : void 0, w.validators = ((W = s.validators) == null ? void 0 : W.map((Y) => e.ValidatorUpdate.fromPartial(Y))) || [], w.appHash = s.appHash ?? new Uint8Array(), w;
    }
  };
  function wa() {
    return {
      code: 0,
      log: "",
      info: "",
      index: T.Long.ZERO,
      key: new Uint8Array(),
      value: new Uint8Array(),
      proofOps: void 0,
      height: T.Long.ZERO,
      codespace: ""
    };
  }
  e.ResponseQuery = {
    encode(s, w = L.Writer.create()) {
      return s.code !== 0 && w.uint32(8).uint32(s.code), s.log !== "" && w.uint32(26).string(s.log), s.info !== "" && w.uint32(34).string(s.info), s.index.isZero() || w.uint32(40).int64(s.index), s.key.length !== 0 && w.uint32(50).bytes(s.key), s.value.length !== 0 && w.uint32(58).bytes(s.value), s.proofOps !== void 0 && O.ProofOps.encode(s.proofOps, w.uint32(66).fork()).ldelim(), s.height.isZero() || w.uint32(72).int64(s.height), s.codespace !== "" && w.uint32(82).string(s.codespace), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = wa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.code = W.uint32();
            break;
          case 3:
            $.log = W.string();
            break;
          case 4:
            $.info = W.string();
            break;
          case 5:
            $.index = W.int64();
            break;
          case 6:
            $.key = W.bytes();
            break;
          case 7:
            $.value = W.bytes();
            break;
          case 8:
            $.proofOps = O.ProofOps.decode(W, W.uint32());
            break;
          case 9:
            $.height = W.int64();
            break;
          case 10:
            $.codespace = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        code: (0, T.isSet)(s.code) ? Number(s.code) : 0,
        log: (0, T.isSet)(s.log) ? String(s.log) : "",
        info: (0, T.isSet)(s.info) ? String(s.info) : "",
        index: (0, T.isSet)(s.index) ? T.Long.fromValue(s.index) : T.Long.ZERO,
        key: (0, T.isSet)(s.key) ? (0, T.bytesFromBase64)(s.key) : new Uint8Array(),
        value: (0, T.isSet)(s.value) ? (0, T.bytesFromBase64)(s.value) : new Uint8Array(),
        proofOps: (0, T.isSet)(s.proofOps) ? O.ProofOps.fromJSON(s.proofOps) : void 0,
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO,
        codespace: (0, T.isSet)(s.codespace) ? String(s.codespace) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.code !== void 0 && (w.code = Math.round(s.code)), s.log !== void 0 && (w.log = s.log), s.info !== void 0 && (w.info = s.info), s.index !== void 0 && (w.index = (s.index || T.Long.ZERO).toString()), s.key !== void 0 && (w.key = (0, T.base64FromBytes)(s.key !== void 0 ? s.key : new Uint8Array())), s.value !== void 0 && (w.value = (0, T.base64FromBytes)(s.value !== void 0 ? s.value : new Uint8Array())), s.proofOps !== void 0 && (w.proofOps = s.proofOps ? O.ProofOps.toJSON(s.proofOps) : void 0), s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), s.codespace !== void 0 && (w.codespace = s.codespace), w;
    },
    fromPartial(s) {
      const w = wa();
      return w.code = s.code ?? 0, w.log = s.log ?? "", w.info = s.info ?? "", w.index = s.index !== void 0 && s.index !== null ? T.Long.fromValue(s.index) : T.Long.ZERO, w.key = s.key ?? new Uint8Array(), w.value = s.value ?? new Uint8Array(), w.proofOps = s.proofOps !== void 0 && s.proofOps !== null ? O.ProofOps.fromPartial(s.proofOps) : void 0, w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w.codespace = s.codespace ?? "", w;
    }
  };
  function ba() {
    return {
      events: []
    };
  }
  e.ResponseBeginBlock = {
    encode(s, w = L.Writer.create()) {
      for (const W of s.events)
        e.Event.encode(W, w.uint32(10).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = ba();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.events.push(e.Event.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        events: Array.isArray(s == null ? void 0 : s.events) ? s.events.map((w) => e.Event.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.events ? w.events = s.events.map((W) => W ? e.Event.toJSON(W) : void 0) : w.events = [], w;
    },
    fromPartial(s) {
      var W;
      const w = ba();
      return w.events = ((W = s.events) == null ? void 0 : W.map((Y) => e.Event.fromPartial(Y))) || [], w;
    }
  };
  function Ba() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: T.Long.ZERO,
      gasUsed: T.Long.ZERO,
      events: [],
      codespace: "",
      sender: "",
      priority: T.Long.ZERO,
      mempoolError: ""
    };
  }
  e.ResponseCheckTx = {
    encode(s, w = L.Writer.create()) {
      s.code !== 0 && w.uint32(8).uint32(s.code), s.data.length !== 0 && w.uint32(18).bytes(s.data), s.log !== "" && w.uint32(26).string(s.log), s.info !== "" && w.uint32(34).string(s.info), s.gasWanted.isZero() || w.uint32(40).int64(s.gasWanted), s.gasUsed.isZero() || w.uint32(48).int64(s.gasUsed);
      for (const W of s.events)
        e.Event.encode(W, w.uint32(58).fork()).ldelim();
      return s.codespace !== "" && w.uint32(66).string(s.codespace), s.sender !== "" && w.uint32(74).string(s.sender), s.priority.isZero() || w.uint32(80).int64(s.priority), s.mempoolError !== "" && w.uint32(90).string(s.mempoolError), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ba();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.code = W.uint32();
            break;
          case 2:
            $.data = W.bytes();
            break;
          case 3:
            $.log = W.string();
            break;
          case 4:
            $.info = W.string();
            break;
          case 5:
            $.gasWanted = W.int64();
            break;
          case 6:
            $.gasUsed = W.int64();
            break;
          case 7:
            $.events.push(e.Event.decode(W, W.uint32()));
            break;
          case 8:
            $.codespace = W.string();
            break;
          case 9:
            $.sender = W.string();
            break;
          case 10:
            $.priority = W.int64();
            break;
          case 11:
            $.mempoolError = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        code: (0, T.isSet)(s.code) ? Number(s.code) : 0,
        data: (0, T.isSet)(s.data) ? (0, T.bytesFromBase64)(s.data) : new Uint8Array(),
        log: (0, T.isSet)(s.log) ? String(s.log) : "",
        info: (0, T.isSet)(s.info) ? String(s.info) : "",
        gasWanted: (0, T.isSet)(s.gas_wanted) ? T.Long.fromValue(s.gas_wanted) : T.Long.ZERO,
        gasUsed: (0, T.isSet)(s.gas_used) ? T.Long.fromValue(s.gas_used) : T.Long.ZERO,
        events: Array.isArray(s == null ? void 0 : s.events) ? s.events.map((w) => e.Event.fromJSON(w)) : [],
        codespace: (0, T.isSet)(s.codespace) ? String(s.codespace) : "",
        sender: (0, T.isSet)(s.sender) ? String(s.sender) : "",
        priority: (0, T.isSet)(s.priority) ? T.Long.fromValue(s.priority) : T.Long.ZERO,
        mempoolError: (0, T.isSet)(s.mempoolError) ? String(s.mempoolError) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.code !== void 0 && (w.code = Math.round(s.code)), s.data !== void 0 && (w.data = (0, T.base64FromBytes)(s.data !== void 0 ? s.data : new Uint8Array())), s.log !== void 0 && (w.log = s.log), s.info !== void 0 && (w.info = s.info), s.gasWanted !== void 0 && (w.gas_wanted = (s.gasWanted || T.Long.ZERO).toString()), s.gasUsed !== void 0 && (w.gas_used = (s.gasUsed || T.Long.ZERO).toString()), s.events ? w.events = s.events.map((W) => W ? e.Event.toJSON(W) : void 0) : w.events = [], s.codespace !== void 0 && (w.codespace = s.codespace), s.sender !== void 0 && (w.sender = s.sender), s.priority !== void 0 && (w.priority = (s.priority || T.Long.ZERO).toString()), s.mempoolError !== void 0 && (w.mempoolError = s.mempoolError), w;
    },
    fromPartial(s) {
      var W;
      const w = Ba();
      return w.code = s.code ?? 0, w.data = s.data ?? new Uint8Array(), w.log = s.log ?? "", w.info = s.info ?? "", w.gasWanted = s.gasWanted !== void 0 && s.gasWanted !== null ? T.Long.fromValue(s.gasWanted) : T.Long.ZERO, w.gasUsed = s.gasUsed !== void 0 && s.gasUsed !== null ? T.Long.fromValue(s.gasUsed) : T.Long.ZERO, w.events = ((W = s.events) == null ? void 0 : W.map((Y) => e.Event.fromPartial(Y))) || [], w.codespace = s.codespace ?? "", w.sender = s.sender ?? "", w.priority = s.priority !== void 0 && s.priority !== null ? T.Long.fromValue(s.priority) : T.Long.ZERO, w.mempoolError = s.mempoolError ?? "", w;
    }
  };
  function Ja() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: T.Long.ZERO,
      gasUsed: T.Long.ZERO,
      events: [],
      codespace: ""
    };
  }
  e.ResponseDeliverTx = {
    encode(s, w = L.Writer.create()) {
      s.code !== 0 && w.uint32(8).uint32(s.code), s.data.length !== 0 && w.uint32(18).bytes(s.data), s.log !== "" && w.uint32(26).string(s.log), s.info !== "" && w.uint32(34).string(s.info), s.gasWanted.isZero() || w.uint32(40).int64(s.gasWanted), s.gasUsed.isZero() || w.uint32(48).int64(s.gasUsed);
      for (const W of s.events)
        e.Event.encode(W, w.uint32(58).fork()).ldelim();
      return s.codespace !== "" && w.uint32(66).string(s.codespace), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ja();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.code = W.uint32();
            break;
          case 2:
            $.data = W.bytes();
            break;
          case 3:
            $.log = W.string();
            break;
          case 4:
            $.info = W.string();
            break;
          case 5:
            $.gasWanted = W.int64();
            break;
          case 6:
            $.gasUsed = W.int64();
            break;
          case 7:
            $.events.push(e.Event.decode(W, W.uint32()));
            break;
          case 8:
            $.codespace = W.string();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        code: (0, T.isSet)(s.code) ? Number(s.code) : 0,
        data: (0, T.isSet)(s.data) ? (0, T.bytesFromBase64)(s.data) : new Uint8Array(),
        log: (0, T.isSet)(s.log) ? String(s.log) : "",
        info: (0, T.isSet)(s.info) ? String(s.info) : "",
        gasWanted: (0, T.isSet)(s.gas_wanted) ? T.Long.fromValue(s.gas_wanted) : T.Long.ZERO,
        gasUsed: (0, T.isSet)(s.gas_used) ? T.Long.fromValue(s.gas_used) : T.Long.ZERO,
        events: Array.isArray(s == null ? void 0 : s.events) ? s.events.map((w) => e.Event.fromJSON(w)) : [],
        codespace: (0, T.isSet)(s.codespace) ? String(s.codespace) : ""
      };
    },
    toJSON(s) {
      const w = {};
      return s.code !== void 0 && (w.code = Math.round(s.code)), s.data !== void 0 && (w.data = (0, T.base64FromBytes)(s.data !== void 0 ? s.data : new Uint8Array())), s.log !== void 0 && (w.log = s.log), s.info !== void 0 && (w.info = s.info), s.gasWanted !== void 0 && (w.gas_wanted = (s.gasWanted || T.Long.ZERO).toString()), s.gasUsed !== void 0 && (w.gas_used = (s.gasUsed || T.Long.ZERO).toString()), s.events ? w.events = s.events.map((W) => W ? e.Event.toJSON(W) : void 0) : w.events = [], s.codespace !== void 0 && (w.codespace = s.codespace), w;
    },
    fromPartial(s) {
      var W;
      const w = Ja();
      return w.code = s.code ?? 0, w.data = s.data ?? new Uint8Array(), w.log = s.log ?? "", w.info = s.info ?? "", w.gasWanted = s.gasWanted !== void 0 && s.gasWanted !== null ? T.Long.fromValue(s.gasWanted) : T.Long.ZERO, w.gasUsed = s.gasUsed !== void 0 && s.gasUsed !== null ? T.Long.fromValue(s.gasUsed) : T.Long.ZERO, w.events = ((W = s.events) == null ? void 0 : W.map((Y) => e.Event.fromPartial(Y))) || [], w.codespace = s.codespace ?? "", w;
    }
  };
  function Da() {
    return {
      validatorUpdates: [],
      consensusParamUpdates: void 0,
      events: []
    };
  }
  e.ResponseEndBlock = {
    encode(s, w = L.Writer.create()) {
      for (const W of s.validatorUpdates)
        e.ValidatorUpdate.encode(W, w.uint32(10).fork()).ldelim();
      s.consensusParamUpdates !== void 0 && u.ConsensusParams.encode(s.consensusParamUpdates, w.uint32(18).fork()).ldelim();
      for (const W of s.events)
        e.Event.encode(W, w.uint32(26).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Da();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.validatorUpdates.push(e.ValidatorUpdate.decode(W, W.uint32()));
            break;
          case 2:
            $.consensusParamUpdates = u.ConsensusParams.decode(W, W.uint32());
            break;
          case 3:
            $.events.push(e.Event.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        validatorUpdates: Array.isArray(s == null ? void 0 : s.validatorUpdates) ? s.validatorUpdates.map((w) => e.ValidatorUpdate.fromJSON(w)) : [],
        consensusParamUpdates: (0, T.isSet)(s.consensusParamUpdates) ? u.ConsensusParams.fromJSON(s.consensusParamUpdates) : void 0,
        events: Array.isArray(s == null ? void 0 : s.events) ? s.events.map((w) => e.Event.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.validatorUpdates ? w.validatorUpdates = s.validatorUpdates.map((W) => W ? e.ValidatorUpdate.toJSON(W) : void 0) : w.validatorUpdates = [], s.consensusParamUpdates !== void 0 && (w.consensusParamUpdates = s.consensusParamUpdates ? u.ConsensusParams.toJSON(s.consensusParamUpdates) : void 0), s.events ? w.events = s.events.map((W) => W ? e.Event.toJSON(W) : void 0) : w.events = [], w;
    },
    fromPartial(s) {
      var W, Y;
      const w = Da();
      return w.validatorUpdates = ((W = s.validatorUpdates) == null ? void 0 : W.map(($) => e.ValidatorUpdate.fromPartial($))) || [], w.consensusParamUpdates = s.consensusParamUpdates !== void 0 && s.consensusParamUpdates !== null ? u.ConsensusParams.fromPartial(s.consensusParamUpdates) : void 0, w.events = ((Y = s.events) == null ? void 0 : Y.map(($) => e.Event.fromPartial($))) || [], w;
    }
  };
  function Ua() {
    return {
      data: new Uint8Array(),
      retainHeight: T.Long.ZERO
    };
  }
  e.ResponseCommit = {
    encode(s, w = L.Writer.create()) {
      return s.data.length !== 0 && w.uint32(18).bytes(s.data), s.retainHeight.isZero() || w.uint32(24).int64(s.retainHeight), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ua();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 2:
            $.data = W.bytes();
            break;
          case 3:
            $.retainHeight = W.int64();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        data: (0, T.isSet)(s.data) ? (0, T.bytesFromBase64)(s.data) : new Uint8Array(),
        retainHeight: (0, T.isSet)(s.retainHeight) ? T.Long.fromValue(s.retainHeight) : T.Long.ZERO
      };
    },
    toJSON(s) {
      const w = {};
      return s.data !== void 0 && (w.data = (0, T.base64FromBytes)(s.data !== void 0 ? s.data : new Uint8Array())), s.retainHeight !== void 0 && (w.retainHeight = (s.retainHeight || T.Long.ZERO).toString()), w;
    },
    fromPartial(s) {
      const w = Ua();
      return w.data = s.data ?? new Uint8Array(), w.retainHeight = s.retainHeight !== void 0 && s.retainHeight !== null ? T.Long.fromValue(s.retainHeight) : T.Long.ZERO, w;
    }
  };
  function Ma() {
    return {
      snapshots: []
    };
  }
  e.ResponseListSnapshots = {
    encode(s, w = L.Writer.create()) {
      for (const W of s.snapshots)
        e.Snapshot.encode(W, w.uint32(10).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ma();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.snapshots.push(e.Snapshot.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        snapshots: Array.isArray(s == null ? void 0 : s.snapshots) ? s.snapshots.map((w) => e.Snapshot.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.snapshots ? w.snapshots = s.snapshots.map((W) => W ? e.Snapshot.toJSON(W) : void 0) : w.snapshots = [], w;
    },
    fromPartial(s) {
      var W;
      const w = Ma();
      return w.snapshots = ((W = s.snapshots) == null ? void 0 : W.map((Y) => e.Snapshot.fromPartial(Y))) || [], w;
    }
  };
  function Va() {
    return {
      result: 0
    };
  }
  e.ResponseOfferSnapshot = {
    encode(s, w = L.Writer.create()) {
      return s.result !== 0 && w.uint32(8).int32(s.result), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Va();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.result = W.int32();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        result: (0, T.isSet)(s.result) ? h(s.result) : 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.result !== void 0 && (w.result = S(s.result)), w;
    },
    fromPartial(s) {
      const w = Va();
      return w.result = s.result ?? 0, w;
    }
  };
  function La() {
    return {
      chunk: new Uint8Array()
    };
  }
  e.ResponseLoadSnapshotChunk = {
    encode(s, w = L.Writer.create()) {
      return s.chunk.length !== 0 && w.uint32(10).bytes(s.chunk), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = La();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.chunk = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        chunk: (0, T.isSet)(s.chunk) ? (0, T.bytesFromBase64)(s.chunk) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.chunk !== void 0 && (w.chunk = (0, T.base64FromBytes)(s.chunk !== void 0 ? s.chunk : new Uint8Array())), w;
    },
    fromPartial(s) {
      const w = La();
      return w.chunk = s.chunk ?? new Uint8Array(), w;
    }
  };
  function Ha() {
    return {
      result: 0,
      refetchChunks: [],
      rejectSenders: []
    };
  }
  e.ResponseApplySnapshotChunk = {
    encode(s, w = L.Writer.create()) {
      s.result !== 0 && w.uint32(8).int32(s.result), w.uint32(18).fork();
      for (const W of s.refetchChunks)
        w.uint32(W);
      w.ldelim();
      for (const W of s.rejectSenders)
        w.uint32(26).string(W);
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ha();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.result = W.int32();
            break;
          case 2:
            if ((x & 7) === 2) {
              const Fc = W.uint32() + W.pos;
              for (; W.pos < Fc; )
                $.refetchChunks.push(W.uint32());
            } else
              $.refetchChunks.push(W.uint32());
            break;
          case 3:
            $.rejectSenders.push(W.string());
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        result: (0, T.isSet)(s.result) ? d(s.result) : 0,
        refetchChunks: Array.isArray(s == null ? void 0 : s.refetchChunks) ? s.refetchChunks.map((w) => Number(w)) : [],
        rejectSenders: Array.isArray(s == null ? void 0 : s.rejectSenders) ? s.rejectSenders.map((w) => String(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.result !== void 0 && (w.result = p(s.result)), s.refetchChunks ? w.refetchChunks = s.refetchChunks.map((W) => Math.round(W)) : w.refetchChunks = [], s.rejectSenders ? w.rejectSenders = s.rejectSenders.map((W) => W) : w.rejectSenders = [], w;
    },
    fromPartial(s) {
      var W, Y;
      const w = Ha();
      return w.result = s.result ?? 0, w.refetchChunks = ((W = s.refetchChunks) == null ? void 0 : W.map(($) => $)) || [], w.rejectSenders = ((Y = s.rejectSenders) == null ? void 0 : Y.map(($) => $)) || [], w;
    }
  };
  function qa() {
    return {
      txs: []
    };
  }
  e.ResponsePrepareProposal = {
    encode(s, w = L.Writer.create()) {
      for (const W of s.txs)
        w.uint32(10).bytes(W);
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = qa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.txs.push(W.bytes());
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        txs: Array.isArray(s == null ? void 0 : s.txs) ? s.txs.map((w) => (0, T.bytesFromBase64)(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.txs ? w.txs = s.txs.map((W) => (0, T.base64FromBytes)(W !== void 0 ? W : new Uint8Array())) : w.txs = [], w;
    },
    fromPartial(s) {
      var W;
      const w = qa();
      return w.txs = ((W = s.txs) == null ? void 0 : W.map((Y) => Y)) || [], w;
    }
  };
  function Wa() {
    return {
      status: 0
    };
  }
  e.ResponseProcessProposal = {
    encode(s, w = L.Writer.create()) {
      return s.status !== 0 && w.uint32(8).int32(s.status), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Wa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.status = W.int32();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        status: (0, T.isSet)(s.status) ? J(s.status) : 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.status !== void 0 && (w.status = B(s.status)), w;
    },
    fromPartial(s) {
      const w = Wa();
      return w.status = s.status ?? 0, w;
    }
  };
  function Za() {
    return {
      round: 0,
      votes: []
    };
  }
  e.CommitInfo = {
    encode(s, w = L.Writer.create()) {
      s.round !== 0 && w.uint32(8).int32(s.round);
      for (const W of s.votes)
        e.VoteInfo.encode(W, w.uint32(18).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Za();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.round = W.int32();
            break;
          case 2:
            $.votes.push(e.VoteInfo.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        round: (0, T.isSet)(s.round) ? Number(s.round) : 0,
        votes: Array.isArray(s == null ? void 0 : s.votes) ? s.votes.map((w) => e.VoteInfo.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.round !== void 0 && (w.round = Math.round(s.round)), s.votes ? w.votes = s.votes.map((W) => W ? e.VoteInfo.toJSON(W) : void 0) : w.votes = [], w;
    },
    fromPartial(s) {
      var W;
      const w = Za();
      return w.round = s.round ?? 0, w.votes = ((W = s.votes) == null ? void 0 : W.map((Y) => e.VoteInfo.fromPartial(Y))) || [], w;
    }
  };
  function Qa() {
    return {
      round: 0,
      votes: []
    };
  }
  e.ExtendedCommitInfo = {
    encode(s, w = L.Writer.create()) {
      s.round !== 0 && w.uint32(8).int32(s.round);
      for (const W of s.votes)
        e.ExtendedVoteInfo.encode(W, w.uint32(18).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Qa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.round = W.int32();
            break;
          case 2:
            $.votes.push(e.ExtendedVoteInfo.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        round: (0, T.isSet)(s.round) ? Number(s.round) : 0,
        votes: Array.isArray(s == null ? void 0 : s.votes) ? s.votes.map((w) => e.ExtendedVoteInfo.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.round !== void 0 && (w.round = Math.round(s.round)), s.votes ? w.votes = s.votes.map((W) => W ? e.ExtendedVoteInfo.toJSON(W) : void 0) : w.votes = [], w;
    },
    fromPartial(s) {
      var W;
      const w = Qa();
      return w.round = s.round ?? 0, w.votes = ((W = s.votes) == null ? void 0 : W.map((Y) => e.ExtendedVoteInfo.fromPartial(Y))) || [], w;
    }
  };
  function Fa() {
    return {
      type: "",
      attributes: []
    };
  }
  e.Event = {
    encode(s, w = L.Writer.create()) {
      s.type !== "" && w.uint32(10).string(s.type);
      for (const W of s.attributes)
        e.EventAttribute.encode(W, w.uint32(18).fork()).ldelim();
      return w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Fa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.type = W.string();
            break;
          case 2:
            $.attributes.push(e.EventAttribute.decode(W, W.uint32()));
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        type: (0, T.isSet)(s.type) ? String(s.type) : "",
        attributes: Array.isArray(s == null ? void 0 : s.attributes) ? s.attributes.map((w) => e.EventAttribute.fromJSON(w)) : []
      };
    },
    toJSON(s) {
      const w = {};
      return s.type !== void 0 && (w.type = s.type), s.attributes ? w.attributes = s.attributes.map((W) => W ? e.EventAttribute.toJSON(W) : void 0) : w.attributes = [], w;
    },
    fromPartial(s) {
      var W;
      const w = Fa();
      return w.type = s.type ?? "", w.attributes = ((W = s.attributes) == null ? void 0 : W.map((Y) => e.EventAttribute.fromPartial(Y))) || [], w;
    }
  };
  function Ga() {
    return {
      key: "",
      value: "",
      index: !1
    };
  }
  e.EventAttribute = {
    encode(s, w = L.Writer.create()) {
      return s.key !== "" && w.uint32(10).string(s.key), s.value !== "" && w.uint32(18).string(s.value), s.index === !0 && w.uint32(24).bool(s.index), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ga();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.key = W.string();
            break;
          case 2:
            $.value = W.string();
            break;
          case 3:
            $.index = W.bool();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        key: (0, T.isSet)(s.key) ? String(s.key) : "",
        value: (0, T.isSet)(s.value) ? String(s.value) : "",
        index: (0, T.isSet)(s.index) ? !!s.index : !1
      };
    },
    toJSON(s) {
      const w = {};
      return s.key !== void 0 && (w.key = s.key), s.value !== void 0 && (w.value = s.value), s.index !== void 0 && (w.index = s.index), w;
    },
    fromPartial(s) {
      const w = Ga();
      return w.key = s.key ?? "", w.value = s.value ?? "", w.index = s.index ?? !1, w;
    }
  };
  function $a() {
    return {
      height: T.Long.ZERO,
      index: 0,
      tx: new Uint8Array(),
      result: void 0
    };
  }
  e.TxResult = {
    encode(s, w = L.Writer.create()) {
      return s.height.isZero() || w.uint32(8).int64(s.height), s.index !== 0 && w.uint32(16).uint32(s.index), s.tx.length !== 0 && w.uint32(26).bytes(s.tx), s.result !== void 0 && e.ResponseDeliverTx.encode(s.result, w.uint32(34).fork()).ldelim(), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = $a();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.height = W.int64();
            break;
          case 2:
            $.index = W.uint32();
            break;
          case 3:
            $.tx = W.bytes();
            break;
          case 4:
            $.result = e.ResponseDeliverTx.decode(W, W.uint32());
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO,
        index: (0, T.isSet)(s.index) ? Number(s.index) : 0,
        tx: (0, T.isSet)(s.tx) ? (0, T.bytesFromBase64)(s.tx) : new Uint8Array(),
        result: (0, T.isSet)(s.result) ? e.ResponseDeliverTx.fromJSON(s.result) : void 0
      };
    },
    toJSON(s) {
      const w = {};
      return s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), s.index !== void 0 && (w.index = Math.round(s.index)), s.tx !== void 0 && (w.tx = (0, T.base64FromBytes)(s.tx !== void 0 ? s.tx : new Uint8Array())), s.result !== void 0 && (w.result = s.result ? e.ResponseDeliverTx.toJSON(s.result) : void 0), w;
    },
    fromPartial(s) {
      const w = $a();
      return w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w.index = s.index ?? 0, w.tx = s.tx ?? new Uint8Array(), w.result = s.result !== void 0 && s.result !== null ? e.ResponseDeliverTx.fromPartial(s.result) : void 0, w;
    }
  };
  function Ka() {
    return {
      address: new Uint8Array(),
      power: T.Long.ZERO
    };
  }
  e.Validator = {
    encode(s, w = L.Writer.create()) {
      return s.address.length !== 0 && w.uint32(10).bytes(s.address), s.power.isZero() || w.uint32(24).int64(s.power), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ka();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.address = W.bytes();
            break;
          case 3:
            $.power = W.int64();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        address: (0, T.isSet)(s.address) ? (0, T.bytesFromBase64)(s.address) : new Uint8Array(),
        power: (0, T.isSet)(s.power) ? T.Long.fromValue(s.power) : T.Long.ZERO
      };
    },
    toJSON(s) {
      const w = {};
      return s.address !== void 0 && (w.address = (0, T.base64FromBytes)(s.address !== void 0 ? s.address : new Uint8Array())), s.power !== void 0 && (w.power = (s.power || T.Long.ZERO).toString()), w;
    },
    fromPartial(s) {
      const w = Ka();
      return w.address = s.address ?? new Uint8Array(), w.power = s.power !== void 0 && s.power !== null ? T.Long.fromValue(s.power) : T.Long.ZERO, w;
    }
  };
  function za() {
    return {
      pubKey: void 0,
      power: T.Long.ZERO
    };
  }
  e.ValidatorUpdate = {
    encode(s, w = L.Writer.create()) {
      return s.pubKey !== void 0 && A.PublicKey.encode(s.pubKey, w.uint32(10).fork()).ldelim(), s.power.isZero() || w.uint32(16).int64(s.power), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = za();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.pubKey = A.PublicKey.decode(W, W.uint32());
            break;
          case 2:
            $.power = W.int64();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        pubKey: (0, T.isSet)(s.pubKey) ? A.PublicKey.fromJSON(s.pubKey) : void 0,
        power: (0, T.isSet)(s.power) ? T.Long.fromValue(s.power) : T.Long.ZERO
      };
    },
    toJSON(s) {
      const w = {};
      return s.pubKey !== void 0 && (w.pubKey = s.pubKey ? A.PublicKey.toJSON(s.pubKey) : void 0), s.power !== void 0 && (w.power = (s.power || T.Long.ZERO).toString()), w;
    },
    fromPartial(s) {
      const w = za();
      return w.pubKey = s.pubKey !== void 0 && s.pubKey !== null ? A.PublicKey.fromPartial(s.pubKey) : void 0, w.power = s.power !== void 0 && s.power !== null ? T.Long.fromValue(s.power) : T.Long.ZERO, w;
    }
  };
  function Ya() {
    return {
      validator: void 0,
      signedLastBlock: !1
    };
  }
  e.VoteInfo = {
    encode(s, w = L.Writer.create()) {
      return s.validator !== void 0 && e.Validator.encode(s.validator, w.uint32(10).fork()).ldelim(), s.signedLastBlock === !0 && w.uint32(16).bool(s.signedLastBlock), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Ya();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.validator = e.Validator.decode(W, W.uint32());
            break;
          case 2:
            $.signedLastBlock = W.bool();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        validator: (0, T.isSet)(s.validator) ? e.Validator.fromJSON(s.validator) : void 0,
        signedLastBlock: (0, T.isSet)(s.signedLastBlock) ? !!s.signedLastBlock : !1
      };
    },
    toJSON(s) {
      const w = {};
      return s.validator !== void 0 && (w.validator = s.validator ? e.Validator.toJSON(s.validator) : void 0), s.signedLastBlock !== void 0 && (w.signedLastBlock = s.signedLastBlock), w;
    },
    fromPartial(s) {
      const w = Ya();
      return w.validator = s.validator !== void 0 && s.validator !== null ? e.Validator.fromPartial(s.validator) : void 0, w.signedLastBlock = s.signedLastBlock ?? !1, w;
    }
  };
  function Xa() {
    return {
      validator: void 0,
      signedLastBlock: !1,
      voteExtension: new Uint8Array()
    };
  }
  e.ExtendedVoteInfo = {
    encode(s, w = L.Writer.create()) {
      return s.validator !== void 0 && e.Validator.encode(s.validator, w.uint32(10).fork()).ldelim(), s.signedLastBlock === !0 && w.uint32(16).bool(s.signedLastBlock), s.voteExtension.length !== 0 && w.uint32(26).bytes(s.voteExtension), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = Xa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.validator = e.Validator.decode(W, W.uint32());
            break;
          case 2:
            $.signedLastBlock = W.bool();
            break;
          case 3:
            $.voteExtension = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        validator: (0, T.isSet)(s.validator) ? e.Validator.fromJSON(s.validator) : void 0,
        signedLastBlock: (0, T.isSet)(s.signedLastBlock) ? !!s.signedLastBlock : !1,
        voteExtension: (0, T.isSet)(s.voteExtension) ? (0, T.bytesFromBase64)(s.voteExtension) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.validator !== void 0 && (w.validator = s.validator ? e.Validator.toJSON(s.validator) : void 0), s.signedLastBlock !== void 0 && (w.signedLastBlock = s.signedLastBlock), s.voteExtension !== void 0 && (w.voteExtension = (0, T.base64FromBytes)(s.voteExtension !== void 0 ? s.voteExtension : new Uint8Array())), w;
    },
    fromPartial(s) {
      const w = Xa();
      return w.validator = s.validator !== void 0 && s.validator !== null ? e.Validator.fromPartial(s.validator) : void 0, w.signedLastBlock = s.signedLastBlock ?? !1, w.voteExtension = s.voteExtension ?? new Uint8Array(), w;
    }
  };
  function xa() {
    return {
      type: 0,
      validator: void 0,
      height: T.Long.ZERO,
      time: void 0,
      totalVotingPower: T.Long.ZERO
    };
  }
  e.Misbehavior = {
    encode(s, w = L.Writer.create()) {
      return s.type !== 0 && w.uint32(8).int32(s.type), s.validator !== void 0 && e.Validator.encode(s.validator, w.uint32(18).fork()).ldelim(), s.height.isZero() || w.uint32(24).int64(s.height), s.time !== void 0 && r.Timestamp.encode(s.time, w.uint32(34).fork()).ldelim(), s.totalVotingPower.isZero() || w.uint32(40).int64(s.totalVotingPower), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = xa();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.type = W.int32();
            break;
          case 2:
            $.validator = e.Validator.decode(W, W.uint32());
            break;
          case 3:
            $.height = W.int64();
            break;
          case 4:
            $.time = r.Timestamp.decode(W, W.uint32());
            break;
          case 5:
            $.totalVotingPower = W.int64();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        type: (0, T.isSet)(s.type) ? Z(s.type) : 0,
        validator: (0, T.isSet)(s.validator) ? e.Validator.fromJSON(s.validator) : void 0,
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.ZERO,
        time: (0, T.isSet)(s.time) ? (0, T.fromJsonTimestamp)(s.time) : void 0,
        totalVotingPower: (0, T.isSet)(s.totalVotingPower) ? T.Long.fromValue(s.totalVotingPower) : T.Long.ZERO
      };
    },
    toJSON(s) {
      const w = {};
      return s.type !== void 0 && (w.type = t(s.type)), s.validator !== void 0 && (w.validator = s.validator ? e.Validator.toJSON(s.validator) : void 0), s.height !== void 0 && (w.height = (s.height || T.Long.ZERO).toString()), s.time !== void 0 && (w.time = (0, T.fromTimestamp)(s.time).toISOString()), s.totalVotingPower !== void 0 && (w.totalVotingPower = (s.totalVotingPower || T.Long.ZERO).toString()), w;
    },
    fromPartial(s) {
      const w = xa();
      return w.type = s.type ?? 0, w.validator = s.validator !== void 0 && s.validator !== null ? e.Validator.fromPartial(s.validator) : void 0, w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.ZERO, w.time = s.time !== void 0 && s.time !== null ? r.Timestamp.fromPartial(s.time) : void 0, w.totalVotingPower = s.totalVotingPower !== void 0 && s.totalVotingPower !== null ? T.Long.fromValue(s.totalVotingPower) : T.Long.ZERO, w;
    }
  };
  function ja() {
    return {
      height: T.Long.UZERO,
      format: 0,
      chunks: 0,
      hash: new Uint8Array(),
      metadata: new Uint8Array()
    };
  }
  e.Snapshot = {
    encode(s, w = L.Writer.create()) {
      return s.height.isZero() || w.uint32(8).uint64(s.height), s.format !== 0 && w.uint32(16).uint32(s.format), s.chunks !== 0 && w.uint32(24).uint32(s.chunks), s.hash.length !== 0 && w.uint32(34).bytes(s.hash), s.metadata.length !== 0 && w.uint32(42).bytes(s.metadata), w;
    },
    decode(s, w) {
      const W = s instanceof L.Reader ? s : new L.Reader(s);
      let Y = w === void 0 ? W.len : W.pos + w;
      const $ = ja();
      for (; W.pos < Y; ) {
        const x = W.uint32();
        switch (x >>> 3) {
          case 1:
            $.height = W.uint64();
            break;
          case 2:
            $.format = W.uint32();
            break;
          case 3:
            $.chunks = W.uint32();
            break;
          case 4:
            $.hash = W.bytes();
            break;
          case 5:
            $.metadata = W.bytes();
            break;
          default:
            W.skipType(x & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(s) {
      return {
        height: (0, T.isSet)(s.height) ? T.Long.fromValue(s.height) : T.Long.UZERO,
        format: (0, T.isSet)(s.format) ? Number(s.format) : 0,
        chunks: (0, T.isSet)(s.chunks) ? Number(s.chunks) : 0,
        hash: (0, T.isSet)(s.hash) ? (0, T.bytesFromBase64)(s.hash) : new Uint8Array(),
        metadata: (0, T.isSet)(s.metadata) ? (0, T.bytesFromBase64)(s.metadata) : new Uint8Array()
      };
    },
    toJSON(s) {
      const w = {};
      return s.height !== void 0 && (w.height = (s.height || T.Long.UZERO).toString()), s.format !== void 0 && (w.format = Math.round(s.format)), s.chunks !== void 0 && (w.chunks = Math.round(s.chunks)), s.hash !== void 0 && (w.hash = (0, T.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), s.metadata !== void 0 && (w.metadata = (0, T.base64FromBytes)(s.metadata !== void 0 ? s.metadata : new Uint8Array())), w;
    },
    fromPartial(s) {
      const w = ja();
      return w.height = s.height !== void 0 && s.height !== null ? T.Long.fromValue(s.height) : T.Long.UZERO, w.format = s.format ?? 0, w.chunks = s.chunks ?? 0, w.hash = s.hash ?? new Uint8Array(), w.metadata = s.metadata ?? new Uint8Array(), w;
    }
  };
  class Qc {
    constructor(w) {
      this.rpc = w, this.Echo = this.Echo.bind(this), this.Flush = this.Flush.bind(this), this.Info = this.Info.bind(this), this.DeliverTx = this.DeliverTx.bind(this), this.CheckTx = this.CheckTx.bind(this), this.Query = this.Query.bind(this), this.Commit = this.Commit.bind(this), this.InitChain = this.InitChain.bind(this), this.BeginBlock = this.BeginBlock.bind(this), this.EndBlock = this.EndBlock.bind(this), this.ListSnapshots = this.ListSnapshots.bind(this), this.OfferSnapshot = this.OfferSnapshot.bind(this), this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this), this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this), this.PrepareProposal = this.PrepareProposal.bind(this), this.ProcessProposal = this.ProcessProposal.bind(this);
    }
    Echo(w) {
      const W = e.RequestEcho.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Echo", W).then(($) => e.ResponseEcho.decode(new L.Reader($)));
    }
    Flush(w = {}) {
      const W = e.RequestFlush.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Flush", W).then(($) => e.ResponseFlush.decode(new L.Reader($)));
    }
    Info(w) {
      const W = e.RequestInfo.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Info", W).then(($) => e.ResponseInfo.decode(new L.Reader($)));
    }
    DeliverTx(w) {
      const W = e.RequestDeliverTx.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", W).then(($) => e.ResponseDeliverTx.decode(new L.Reader($)));
    }
    CheckTx(w) {
      const W = e.RequestCheckTx.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", W).then(($) => e.ResponseCheckTx.decode(new L.Reader($)));
    }
    Query(w) {
      const W = e.RequestQuery.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Query", W).then(($) => e.ResponseQuery.decode(new L.Reader($)));
    }
    Commit(w = {}) {
      const W = e.RequestCommit.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Commit", W).then(($) => e.ResponseCommit.decode(new L.Reader($)));
    }
    InitChain(w) {
      const W = e.RequestInitChain.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", W).then(($) => e.ResponseInitChain.decode(new L.Reader($)));
    }
    BeginBlock(w) {
      const W = e.RequestBeginBlock.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", W).then(($) => e.ResponseBeginBlock.decode(new L.Reader($)));
    }
    EndBlock(w) {
      const W = e.RequestEndBlock.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", W).then(($) => e.ResponseEndBlock.decode(new L.Reader($)));
    }
    ListSnapshots(w = {}) {
      const W = e.RequestListSnapshots.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", W).then(($) => e.ResponseListSnapshots.decode(new L.Reader($)));
    }
    OfferSnapshot(w) {
      const W = e.RequestOfferSnapshot.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", W).then(($) => e.ResponseOfferSnapshot.decode(new L.Reader($)));
    }
    LoadSnapshotChunk(w) {
      const W = e.RequestLoadSnapshotChunk.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", W).then(($) => e.ResponseLoadSnapshotChunk.decode(new L.Reader($)));
    }
    ApplySnapshotChunk(w) {
      const W = e.RequestApplySnapshotChunk.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", W).then(($) => e.ResponseApplySnapshotChunk.decode(new L.Reader($)));
    }
    PrepareProposal(w) {
      const W = e.RequestPrepareProposal.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "PrepareProposal", W).then(($) => e.ResponsePrepareProposal.decode(new L.Reader($)));
    }
    ProcessProposal(w) {
      const W = e.RequestProcessProposal.encode(w).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ProcessProposal", W).then(($) => e.ResponseProcessProposal.decode(new L.Reader($)));
    }
  }
  e.ABCIApplicationClientImpl = Qc;
})(sa);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(m, R, N, Q) {
    Q === void 0 && (Q = N);
    var K = Object.getOwnPropertyDescriptor(R, N);
    (!K || ("get" in K ? !R.__esModule : K.writable || K.configurable)) && (K = { enumerable: !0, get: function() {
      return R[N];
    } }), Object.defineProperty(m, Q, K);
  } : function(m, R, N, Q) {
    Q === void 0 && (Q = N), m[Q] = R[N];
  }), c = G && G.__setModuleDefault || (Object.create ? function(m, R) {
    Object.defineProperty(m, "default", { enumerable: !0, value: R });
  } : function(m, R) {
    m.default = R;
  }), i = G && G.__importStar || function(m) {
    if (m && m.__esModule)
      return m;
    var R = {};
    if (m != null)
      for (var N in m)
        N !== "default" && Object.prototype.hasOwnProperty.call(m, N) && n(R, m, N);
    return c(R, m), R;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValidatorUpdates = e.Pool = e.RedelegationResponse = e.RedelegationEntryResponse = e.DelegationResponse = e.Params = e.Redelegation = e.RedelegationEntry = e.UnbondingDelegationEntry = e.UnbondingDelegation = e.Delegation = e.DVVTriplets = e.DVVTriplet = e.DVPairs = e.DVPair = e.ValAddresses = e.Validator = e.Description = e.Commission = e.CommissionRates = e.HistoricalInfo = e.infractionToJSON = e.infractionFromJSON = e.Infraction = e.bondStatusToJSON = e.bondStatusFromJSON = e.BondStatus = e.protobufPackage = void 0;
  const r = rt, u = _e, f = Se, O = en, A = Me, T = sa, L = oe, M = i(ie);
  e.protobufPackage = "cosmos.staking.v1beta1";
  var V;
  (function(m) {
    m[m.BOND_STATUS_UNSPECIFIED = 0] = "BOND_STATUS_UNSPECIFIED", m[m.BOND_STATUS_UNBONDED = 1] = "BOND_STATUS_UNBONDED", m[m.BOND_STATUS_UNBONDING = 2] = "BOND_STATUS_UNBONDING", m[m.BOND_STATUS_BONDED = 3] = "BOND_STATUS_BONDED", m[m.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = e.BondStatus || (e.BondStatus = {}));
  function D(m) {
    switch (m) {
      case 0:
      case "BOND_STATUS_UNSPECIFIED":
        return V.BOND_STATUS_UNSPECIFIED;
      case 1:
      case "BOND_STATUS_UNBONDED":
        return V.BOND_STATUS_UNBONDED;
      case 2:
      case "BOND_STATUS_UNBONDING":
        return V.BOND_STATUS_UNBONDING;
      case 3:
      case "BOND_STATUS_BONDED":
        return V.BOND_STATUS_BONDED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  e.bondStatusFromJSON = D;
  function b(m) {
    switch (m) {
      case V.BOND_STATUS_UNSPECIFIED:
        return "BOND_STATUS_UNSPECIFIED";
      case V.BOND_STATUS_UNBONDED:
        return "BOND_STATUS_UNBONDED";
      case V.BOND_STATUS_UNBONDING:
        return "BOND_STATUS_UNBONDING";
      case V.BOND_STATUS_BONDED:
        return "BOND_STATUS_BONDED";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.bondStatusToJSON = b;
  var h;
  (function(m) {
    m[m.INFRACTION_UNSPECIFIED = 0] = "INFRACTION_UNSPECIFIED", m[m.INFRACTION_DOUBLE_SIGN = 1] = "INFRACTION_DOUBLE_SIGN", m[m.INFRACTION_DOWNTIME = 2] = "INFRACTION_DOWNTIME", m[m.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(h = e.Infraction || (e.Infraction = {}));
  function S(m) {
    switch (m) {
      case 0:
      case "INFRACTION_UNSPECIFIED":
        return h.INFRACTION_UNSPECIFIED;
      case 1:
      case "INFRACTION_DOUBLE_SIGN":
        return h.INFRACTION_DOUBLE_SIGN;
      case 2:
      case "INFRACTION_DOWNTIME":
        return h.INFRACTION_DOWNTIME;
      case -1:
      case "UNRECOGNIZED":
      default:
        return h.UNRECOGNIZED;
    }
  }
  e.infractionFromJSON = S;
  function _(m) {
    switch (m) {
      case h.INFRACTION_UNSPECIFIED:
        return "INFRACTION_UNSPECIFIED";
      case h.INFRACTION_DOUBLE_SIGN:
        return "INFRACTION_DOUBLE_SIGN";
      case h.INFRACTION_DOWNTIME:
        return "INFRACTION_DOWNTIME";
      case h.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.infractionToJSON = _;
  function d() {
    return {
      header: void 0,
      valset: []
    };
  }
  e.HistoricalInfo = {
    encode(m, R = M.Writer.create()) {
      m.header !== void 0 && r.Header.encode(m.header, R.uint32(10).fork()).ldelim();
      for (const N of m.valset)
        e.Validator.encode(N, R.uint32(18).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = d();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.header = r.Header.decode(N, N.uint32());
            break;
          case 2:
            K.valset.push(e.Validator.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        header: (0, L.isSet)(m.header) ? r.Header.fromJSON(m.header) : void 0,
        valset: Array.isArray(m == null ? void 0 : m.valset) ? m.valset.map((R) => e.Validator.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.header !== void 0 && (R.header = m.header ? r.Header.toJSON(m.header) : void 0), m.valset ? R.valset = m.valset.map((N) => N ? e.Validator.toJSON(N) : void 0) : R.valset = [], R;
    },
    fromPartial(m) {
      var N;
      const R = d();
      return R.header = m.header !== void 0 && m.header !== null ? r.Header.fromPartial(m.header) : void 0, R.valset = ((N = m.valset) == null ? void 0 : N.map((Q) => e.Validator.fromPartial(Q))) || [], R;
    }
  };
  function p() {
    return {
      rate: "",
      maxRate: "",
      maxChangeRate: ""
    };
  }
  e.CommissionRates = {
    encode(m, R = M.Writer.create()) {
      return m.rate !== "" && R.uint32(10).string(m.rate), m.maxRate !== "" && R.uint32(18).string(m.maxRate), m.maxChangeRate !== "" && R.uint32(26).string(m.maxChangeRate), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = p();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.rate = N.string();
            break;
          case 2:
            K.maxRate = N.string();
            break;
          case 3:
            K.maxChangeRate = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        rate: (0, L.isSet)(m.rate) ? String(m.rate) : "",
        maxRate: (0, L.isSet)(m.maxRate) ? String(m.maxRate) : "",
        maxChangeRate: (0, L.isSet)(m.maxChangeRate) ? String(m.maxChangeRate) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.rate !== void 0 && (R.rate = m.rate), m.maxRate !== void 0 && (R.maxRate = m.maxRate), m.maxChangeRate !== void 0 && (R.maxChangeRate = m.maxChangeRate), R;
    },
    fromPartial(m) {
      const R = p();
      return R.rate = m.rate ?? "", R.maxRate = m.maxRate ?? "", R.maxChangeRate = m.maxChangeRate ?? "", R;
    }
  };
  function g() {
    return {
      commissionRates: void 0,
      updateTime: void 0
    };
  }
  e.Commission = {
    encode(m, R = M.Writer.create()) {
      return m.commissionRates !== void 0 && e.CommissionRates.encode(m.commissionRates, R.uint32(10).fork()).ldelim(), m.updateTime !== void 0 && u.Timestamp.encode(m.updateTime, R.uint32(18).fork()).ldelim(), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = g();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.commissionRates = e.CommissionRates.decode(N, N.uint32());
            break;
          case 2:
            K.updateTime = u.Timestamp.decode(N, N.uint32());
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        commissionRates: (0, L.isSet)(m.commissionRates) ? e.CommissionRates.fromJSON(m.commissionRates) : void 0,
        updateTime: (0, L.isSet)(m.updateTime) ? (0, L.fromJsonTimestamp)(m.updateTime) : void 0
      };
    },
    toJSON(m) {
      const R = {};
      return m.commissionRates !== void 0 && (R.commissionRates = m.commissionRates ? e.CommissionRates.toJSON(m.commissionRates) : void 0), m.updateTime !== void 0 && (R.updateTime = (0, L.fromTimestamp)(m.updateTime).toISOString()), R;
    },
    fromPartial(m) {
      const R = g();
      return R.commissionRates = m.commissionRates !== void 0 && m.commissionRates !== null ? e.CommissionRates.fromPartial(m.commissionRates) : void 0, R.updateTime = m.updateTime !== void 0 && m.updateTime !== null ? u.Timestamp.fromPartial(m.updateTime) : void 0, R;
    }
  };
  function J() {
    return {
      moniker: "",
      identity: "",
      website: "",
      securityContact: "",
      details: ""
    };
  }
  e.Description = {
    encode(m, R = M.Writer.create()) {
      return m.moniker !== "" && R.uint32(10).string(m.moniker), m.identity !== "" && R.uint32(18).string(m.identity), m.website !== "" && R.uint32(26).string(m.website), m.securityContact !== "" && R.uint32(34).string(m.securityContact), m.details !== "" && R.uint32(42).string(m.details), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = J();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.moniker = N.string();
            break;
          case 2:
            K.identity = N.string();
            break;
          case 3:
            K.website = N.string();
            break;
          case 4:
            K.securityContact = N.string();
            break;
          case 5:
            K.details = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        moniker: (0, L.isSet)(m.moniker) ? String(m.moniker) : "",
        identity: (0, L.isSet)(m.identity) ? String(m.identity) : "",
        website: (0, L.isSet)(m.website) ? String(m.website) : "",
        securityContact: (0, L.isSet)(m.securityContact) ? String(m.securityContact) : "",
        details: (0, L.isSet)(m.details) ? String(m.details) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.moniker !== void 0 && (R.moniker = m.moniker), m.identity !== void 0 && (R.identity = m.identity), m.website !== void 0 && (R.website = m.website), m.securityContact !== void 0 && (R.securityContact = m.securityContact), m.details !== void 0 && (R.details = m.details), R;
    },
    fromPartial(m) {
      const R = J();
      return R.moniker = m.moniker ?? "", R.identity = m.identity ?? "", R.website = m.website ?? "", R.securityContact = m.securityContact ?? "", R.details = m.details ?? "", R;
    }
  };
  function B() {
    return {
      operatorAddress: "",
      consensusPubkey: void 0,
      jailed: !1,
      status: 0,
      tokens: "",
      delegatorShares: "",
      description: void 0,
      unbondingHeight: L.Long.ZERO,
      unbondingTime: void 0,
      commission: void 0,
      minSelfDelegation: "",
      unbondingOnHoldRefCount: L.Long.ZERO,
      unbondingIds: []
    };
  }
  e.Validator = {
    encode(m, R = M.Writer.create()) {
      m.operatorAddress !== "" && R.uint32(10).string(m.operatorAddress), m.consensusPubkey !== void 0 && f.Any.encode(m.consensusPubkey, R.uint32(18).fork()).ldelim(), m.jailed === !0 && R.uint32(24).bool(m.jailed), m.status !== 0 && R.uint32(32).int32(m.status), m.tokens !== "" && R.uint32(42).string(m.tokens), m.delegatorShares !== "" && R.uint32(50).string(m.delegatorShares), m.description !== void 0 && e.Description.encode(m.description, R.uint32(58).fork()).ldelim(), m.unbondingHeight.isZero() || R.uint32(64).int64(m.unbondingHeight), m.unbondingTime !== void 0 && u.Timestamp.encode(m.unbondingTime, R.uint32(74).fork()).ldelim(), m.commission !== void 0 && e.Commission.encode(m.commission, R.uint32(82).fork()).ldelim(), m.minSelfDelegation !== "" && R.uint32(90).string(m.minSelfDelegation), m.unbondingOnHoldRefCount.isZero() || R.uint32(96).int64(m.unbondingOnHoldRefCount), R.uint32(106).fork();
      for (const N of m.unbondingIds)
        R.uint64(N);
      return R.ldelim(), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = B();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.operatorAddress = N.string();
            break;
          case 2:
            K.consensusPubkey = f.Any.decode(N, N.uint32());
            break;
          case 3:
            K.jailed = N.bool();
            break;
          case 4:
            K.status = N.int32();
            break;
          case 5:
            K.tokens = N.string();
            break;
          case 6:
            K.delegatorShares = N.string();
            break;
          case 7:
            K.description = e.Description.decode(N, N.uint32());
            break;
          case 8:
            K.unbondingHeight = N.int64();
            break;
          case 9:
            K.unbondingTime = u.Timestamp.decode(N, N.uint32());
            break;
          case 10:
            K.commission = e.Commission.decode(N, N.uint32());
            break;
          case 11:
            K.minSelfDelegation = N.string();
            break;
          case 12:
            K.unbondingOnHoldRefCount = N.int64();
            break;
          case 13:
            if ((z & 7) === 2) {
              const re = N.uint32() + N.pos;
              for (; N.pos < re; )
                K.unbondingIds.push(N.uint64());
            } else
              K.unbondingIds.push(N.uint64());
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        operatorAddress: (0, L.isSet)(m.operatorAddress) ? String(m.operatorAddress) : "",
        consensusPubkey: (0, L.isSet)(m.consensusPubkey) ? f.Any.fromJSON(m.consensusPubkey) : void 0,
        jailed: (0, L.isSet)(m.jailed) ? !!m.jailed : !1,
        status: (0, L.isSet)(m.status) ? D(m.status) : 0,
        tokens: (0, L.isSet)(m.tokens) ? String(m.tokens) : "",
        delegatorShares: (0, L.isSet)(m.delegatorShares) ? String(m.delegatorShares) : "",
        description: (0, L.isSet)(m.description) ? e.Description.fromJSON(m.description) : void 0,
        unbondingHeight: (0, L.isSet)(m.unbondingHeight) ? L.Long.fromValue(m.unbondingHeight) : L.Long.ZERO,
        unbondingTime: (0, L.isSet)(m.unbondingTime) ? (0, L.fromJsonTimestamp)(m.unbondingTime) : void 0,
        commission: (0, L.isSet)(m.commission) ? e.Commission.fromJSON(m.commission) : void 0,
        minSelfDelegation: (0, L.isSet)(m.minSelfDelegation) ? String(m.minSelfDelegation) : "",
        unbondingOnHoldRefCount: (0, L.isSet)(m.unbondingOnHoldRefCount) ? L.Long.fromValue(m.unbondingOnHoldRefCount) : L.Long.ZERO,
        unbondingIds: Array.isArray(m == null ? void 0 : m.unbondingIds) ? m.unbondingIds.map((R) => L.Long.fromValue(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.operatorAddress !== void 0 && (R.operatorAddress = m.operatorAddress), m.consensusPubkey !== void 0 && (R.consensusPubkey = m.consensusPubkey ? f.Any.toJSON(m.consensusPubkey) : void 0), m.jailed !== void 0 && (R.jailed = m.jailed), m.status !== void 0 && (R.status = b(m.status)), m.tokens !== void 0 && (R.tokens = m.tokens), m.delegatorShares !== void 0 && (R.delegatorShares = m.delegatorShares), m.description !== void 0 && (R.description = m.description ? e.Description.toJSON(m.description) : void 0), m.unbondingHeight !== void 0 && (R.unbondingHeight = (m.unbondingHeight || L.Long.ZERO).toString()), m.unbondingTime !== void 0 && (R.unbondingTime = (0, L.fromTimestamp)(m.unbondingTime).toISOString()), m.commission !== void 0 && (R.commission = m.commission ? e.Commission.toJSON(m.commission) : void 0), m.minSelfDelegation !== void 0 && (R.minSelfDelegation = m.minSelfDelegation), m.unbondingOnHoldRefCount !== void 0 && (R.unbondingOnHoldRefCount = (m.unbondingOnHoldRefCount || L.Long.ZERO).toString()), m.unbondingIds ? R.unbondingIds = m.unbondingIds.map((N) => (N || L.Long.UZERO).toString()) : R.unbondingIds = [], R;
    },
    fromPartial(m) {
      var N;
      const R = B();
      return R.operatorAddress = m.operatorAddress ?? "", R.consensusPubkey = m.consensusPubkey !== void 0 && m.consensusPubkey !== null ? f.Any.fromPartial(m.consensusPubkey) : void 0, R.jailed = m.jailed ?? !1, R.status = m.status ?? 0, R.tokens = m.tokens ?? "", R.delegatorShares = m.delegatorShares ?? "", R.description = m.description !== void 0 && m.description !== null ? e.Description.fromPartial(m.description) : void 0, R.unbondingHeight = m.unbondingHeight !== void 0 && m.unbondingHeight !== null ? L.Long.fromValue(m.unbondingHeight) : L.Long.ZERO, R.unbondingTime = m.unbondingTime !== void 0 && m.unbondingTime !== null ? u.Timestamp.fromPartial(m.unbondingTime) : void 0, R.commission = m.commission !== void 0 && m.commission !== null ? e.Commission.fromPartial(m.commission) : void 0, R.minSelfDelegation = m.minSelfDelegation ?? "", R.unbondingOnHoldRefCount = m.unbondingOnHoldRefCount !== void 0 && m.unbondingOnHoldRefCount !== null ? L.Long.fromValue(m.unbondingOnHoldRefCount) : L.Long.ZERO, R.unbondingIds = ((N = m.unbondingIds) == null ? void 0 : N.map((Q) => L.Long.fromValue(Q))) || [], R;
    }
  };
  function I() {
    return {
      addresses: []
    };
  }
  e.ValAddresses = {
    encode(m, R = M.Writer.create()) {
      for (const N of m.addresses)
        R.uint32(10).string(N);
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = I();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.addresses.push(N.string());
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        addresses: Array.isArray(m == null ? void 0 : m.addresses) ? m.addresses.map((R) => String(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.addresses ? R.addresses = m.addresses.map((N) => N) : R.addresses = [], R;
    },
    fromPartial(m) {
      var N;
      const R = I();
      return R.addresses = ((N = m.addresses) == null ? void 0 : N.map((Q) => Q)) || [], R;
    }
  };
  function Z() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.DVPair = {
    encode(m, R = M.Writer.create()) {
      return m.delegatorAddress !== "" && R.uint32(10).string(m.delegatorAddress), m.validatorAddress !== "" && R.uint32(18).string(m.validatorAddress), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = Z();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.delegatorAddress = N.string();
            break;
          case 2:
            K.validatorAddress = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        delegatorAddress: (0, L.isSet)(m.delegatorAddress) ? String(m.delegatorAddress) : "",
        validatorAddress: (0, L.isSet)(m.validatorAddress) ? String(m.validatorAddress) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.delegatorAddress !== void 0 && (R.delegatorAddress = m.delegatorAddress), m.validatorAddress !== void 0 && (R.validatorAddress = m.validatorAddress), R;
    },
    fromPartial(m) {
      const R = Z();
      return R.delegatorAddress = m.delegatorAddress ?? "", R.validatorAddress = m.validatorAddress ?? "", R;
    }
  };
  function t() {
    return {
      pairs: []
    };
  }
  e.DVPairs = {
    encode(m, R = M.Writer.create()) {
      for (const N of m.pairs)
        e.DVPair.encode(N, R.uint32(10).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = t();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.pairs.push(e.DVPair.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        pairs: Array.isArray(m == null ? void 0 : m.pairs) ? m.pairs.map((R) => e.DVPair.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.pairs ? R.pairs = m.pairs.map((N) => N ? e.DVPair.toJSON(N) : void 0) : R.pairs = [], R;
    },
    fromPartial(m) {
      var N;
      const R = t();
      return R.pairs = ((N = m.pairs) == null ? void 0 : N.map((Q) => e.DVPair.fromPartial(Q))) || [], R;
    }
  };
  function y() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: ""
    };
  }
  e.DVVTriplet = {
    encode(m, R = M.Writer.create()) {
      return m.delegatorAddress !== "" && R.uint32(10).string(m.delegatorAddress), m.validatorSrcAddress !== "" && R.uint32(18).string(m.validatorSrcAddress), m.validatorDstAddress !== "" && R.uint32(26).string(m.validatorDstAddress), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = y();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.delegatorAddress = N.string();
            break;
          case 2:
            K.validatorSrcAddress = N.string();
            break;
          case 3:
            K.validatorDstAddress = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        delegatorAddress: (0, L.isSet)(m.delegatorAddress) ? String(m.delegatorAddress) : "",
        validatorSrcAddress: (0, L.isSet)(m.validatorSrcAddress) ? String(m.validatorSrcAddress) : "",
        validatorDstAddress: (0, L.isSet)(m.validatorDstAddress) ? String(m.validatorDstAddress) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.delegatorAddress !== void 0 && (R.delegatorAddress = m.delegatorAddress), m.validatorSrcAddress !== void 0 && (R.validatorSrcAddress = m.validatorSrcAddress), m.validatorDstAddress !== void 0 && (R.validatorDstAddress = m.validatorDstAddress), R;
    },
    fromPartial(m) {
      const R = y();
      return R.delegatorAddress = m.delegatorAddress ?? "", R.validatorSrcAddress = m.validatorSrcAddress ?? "", R.validatorDstAddress = m.validatorDstAddress ?? "", R;
    }
  };
  function E() {
    return {
      triplets: []
    };
  }
  e.DVVTriplets = {
    encode(m, R = M.Writer.create()) {
      for (const N of m.triplets)
        e.DVVTriplet.encode(N, R.uint32(10).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = E();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.triplets.push(e.DVVTriplet.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        triplets: Array.isArray(m == null ? void 0 : m.triplets) ? m.triplets.map((R) => e.DVVTriplet.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.triplets ? R.triplets = m.triplets.map((N) => N ? e.DVVTriplet.toJSON(N) : void 0) : R.triplets = [], R;
    },
    fromPartial(m) {
      var N;
      const R = E();
      return R.triplets = ((N = m.triplets) == null ? void 0 : N.map((Q) => e.DVVTriplet.fromPartial(Q))) || [], R;
    }
  };
  function H() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      shares: ""
    };
  }
  e.Delegation = {
    encode(m, R = M.Writer.create()) {
      return m.delegatorAddress !== "" && R.uint32(10).string(m.delegatorAddress), m.validatorAddress !== "" && R.uint32(18).string(m.validatorAddress), m.shares !== "" && R.uint32(26).string(m.shares), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = H();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.delegatorAddress = N.string();
            break;
          case 2:
            K.validatorAddress = N.string();
            break;
          case 3:
            K.shares = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        delegatorAddress: (0, L.isSet)(m.delegatorAddress) ? String(m.delegatorAddress) : "",
        validatorAddress: (0, L.isSet)(m.validatorAddress) ? String(m.validatorAddress) : "",
        shares: (0, L.isSet)(m.shares) ? String(m.shares) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.delegatorAddress !== void 0 && (R.delegatorAddress = m.delegatorAddress), m.validatorAddress !== void 0 && (R.validatorAddress = m.validatorAddress), m.shares !== void 0 && (R.shares = m.shares), R;
    },
    fromPartial(m) {
      const R = H();
      return R.delegatorAddress = m.delegatorAddress ?? "", R.validatorAddress = m.validatorAddress ?? "", R.shares = m.shares ?? "", R;
    }
  };
  function a() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      entries: []
    };
  }
  e.UnbondingDelegation = {
    encode(m, R = M.Writer.create()) {
      m.delegatorAddress !== "" && R.uint32(10).string(m.delegatorAddress), m.validatorAddress !== "" && R.uint32(18).string(m.validatorAddress);
      for (const N of m.entries)
        e.UnbondingDelegationEntry.encode(N, R.uint32(26).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = a();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.delegatorAddress = N.string();
            break;
          case 2:
            K.validatorAddress = N.string();
            break;
          case 3:
            K.entries.push(e.UnbondingDelegationEntry.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        delegatorAddress: (0, L.isSet)(m.delegatorAddress) ? String(m.delegatorAddress) : "",
        validatorAddress: (0, L.isSet)(m.validatorAddress) ? String(m.validatorAddress) : "",
        entries: Array.isArray(m == null ? void 0 : m.entries) ? m.entries.map((R) => e.UnbondingDelegationEntry.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.delegatorAddress !== void 0 && (R.delegatorAddress = m.delegatorAddress), m.validatorAddress !== void 0 && (R.validatorAddress = m.validatorAddress), m.entries ? R.entries = m.entries.map((N) => N ? e.UnbondingDelegationEntry.toJSON(N) : void 0) : R.entries = [], R;
    },
    fromPartial(m) {
      var N;
      const R = a();
      return R.delegatorAddress = m.delegatorAddress ?? "", R.validatorAddress = m.validatorAddress ?? "", R.entries = ((N = m.entries) == null ? void 0 : N.map((Q) => e.UnbondingDelegationEntry.fromPartial(Q))) || [], R;
    }
  };
  function l() {
    return {
      creationHeight: L.Long.ZERO,
      completionTime: void 0,
      initialBalance: "",
      balance: "",
      unbondingId: L.Long.UZERO,
      unbondingOnHoldRefCount: L.Long.ZERO
    };
  }
  e.UnbondingDelegationEntry = {
    encode(m, R = M.Writer.create()) {
      return m.creationHeight.isZero() || R.uint32(8).int64(m.creationHeight), m.completionTime !== void 0 && u.Timestamp.encode(m.completionTime, R.uint32(18).fork()).ldelim(), m.initialBalance !== "" && R.uint32(26).string(m.initialBalance), m.balance !== "" && R.uint32(34).string(m.balance), m.unbondingId.isZero() || R.uint32(40).uint64(m.unbondingId), m.unbondingOnHoldRefCount.isZero() || R.uint32(48).int64(m.unbondingOnHoldRefCount), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = l();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.creationHeight = N.int64();
            break;
          case 2:
            K.completionTime = u.Timestamp.decode(N, N.uint32());
            break;
          case 3:
            K.initialBalance = N.string();
            break;
          case 4:
            K.balance = N.string();
            break;
          case 5:
            K.unbondingId = N.uint64();
            break;
          case 6:
            K.unbondingOnHoldRefCount = N.int64();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        creationHeight: (0, L.isSet)(m.creationHeight) ? L.Long.fromValue(m.creationHeight) : L.Long.ZERO,
        completionTime: (0, L.isSet)(m.completionTime) ? (0, L.fromJsonTimestamp)(m.completionTime) : void 0,
        initialBalance: (0, L.isSet)(m.initialBalance) ? String(m.initialBalance) : "",
        balance: (0, L.isSet)(m.balance) ? String(m.balance) : "",
        unbondingId: (0, L.isSet)(m.unbondingId) ? L.Long.fromValue(m.unbondingId) : L.Long.UZERO,
        unbondingOnHoldRefCount: (0, L.isSet)(m.unbondingOnHoldRefCount) ? L.Long.fromValue(m.unbondingOnHoldRefCount) : L.Long.ZERO
      };
    },
    toJSON(m) {
      const R = {};
      return m.creationHeight !== void 0 && (R.creationHeight = (m.creationHeight || L.Long.ZERO).toString()), m.completionTime !== void 0 && (R.completionTime = (0, L.fromTimestamp)(m.completionTime).toISOString()), m.initialBalance !== void 0 && (R.initialBalance = m.initialBalance), m.balance !== void 0 && (R.balance = m.balance), m.unbondingId !== void 0 && (R.unbondingId = (m.unbondingId || L.Long.UZERO).toString()), m.unbondingOnHoldRefCount !== void 0 && (R.unbondingOnHoldRefCount = (m.unbondingOnHoldRefCount || L.Long.ZERO).toString()), R;
    },
    fromPartial(m) {
      const R = l();
      return R.creationHeight = m.creationHeight !== void 0 && m.creationHeight !== null ? L.Long.fromValue(m.creationHeight) : L.Long.ZERO, R.completionTime = m.completionTime !== void 0 && m.completionTime !== null ? u.Timestamp.fromPartial(m.completionTime) : void 0, R.initialBalance = m.initialBalance ?? "", R.balance = m.balance ?? "", R.unbondingId = m.unbondingId !== void 0 && m.unbondingId !== null ? L.Long.fromValue(m.unbondingId) : L.Long.UZERO, R.unbondingOnHoldRefCount = m.unbondingOnHoldRefCount !== void 0 && m.unbondingOnHoldRefCount !== null ? L.Long.fromValue(m.unbondingOnHoldRefCount) : L.Long.ZERO, R;
    }
  };
  function C() {
    return {
      creationHeight: L.Long.ZERO,
      completionTime: void 0,
      initialBalance: "",
      sharesDst: "",
      unbondingId: L.Long.UZERO,
      unbondingOnHoldRefCount: L.Long.ZERO
    };
  }
  e.RedelegationEntry = {
    encode(m, R = M.Writer.create()) {
      return m.creationHeight.isZero() || R.uint32(8).int64(m.creationHeight), m.completionTime !== void 0 && u.Timestamp.encode(m.completionTime, R.uint32(18).fork()).ldelim(), m.initialBalance !== "" && R.uint32(26).string(m.initialBalance), m.sharesDst !== "" && R.uint32(34).string(m.sharesDst), m.unbondingId.isZero() || R.uint32(40).uint64(m.unbondingId), m.unbondingOnHoldRefCount.isZero() || R.uint32(48).int64(m.unbondingOnHoldRefCount), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = C();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.creationHeight = N.int64();
            break;
          case 2:
            K.completionTime = u.Timestamp.decode(N, N.uint32());
            break;
          case 3:
            K.initialBalance = N.string();
            break;
          case 4:
            K.sharesDst = N.string();
            break;
          case 5:
            K.unbondingId = N.uint64();
            break;
          case 6:
            K.unbondingOnHoldRefCount = N.int64();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        creationHeight: (0, L.isSet)(m.creationHeight) ? L.Long.fromValue(m.creationHeight) : L.Long.ZERO,
        completionTime: (0, L.isSet)(m.completionTime) ? (0, L.fromJsonTimestamp)(m.completionTime) : void 0,
        initialBalance: (0, L.isSet)(m.initialBalance) ? String(m.initialBalance) : "",
        sharesDst: (0, L.isSet)(m.sharesDst) ? String(m.sharesDst) : "",
        unbondingId: (0, L.isSet)(m.unbondingId) ? L.Long.fromValue(m.unbondingId) : L.Long.UZERO,
        unbondingOnHoldRefCount: (0, L.isSet)(m.unbondingOnHoldRefCount) ? L.Long.fromValue(m.unbondingOnHoldRefCount) : L.Long.ZERO
      };
    },
    toJSON(m) {
      const R = {};
      return m.creationHeight !== void 0 && (R.creationHeight = (m.creationHeight || L.Long.ZERO).toString()), m.completionTime !== void 0 && (R.completionTime = (0, L.fromTimestamp)(m.completionTime).toISOString()), m.initialBalance !== void 0 && (R.initialBalance = m.initialBalance), m.sharesDst !== void 0 && (R.sharesDst = m.sharesDst), m.unbondingId !== void 0 && (R.unbondingId = (m.unbondingId || L.Long.UZERO).toString()), m.unbondingOnHoldRefCount !== void 0 && (R.unbondingOnHoldRefCount = (m.unbondingOnHoldRefCount || L.Long.ZERO).toString()), R;
    },
    fromPartial(m) {
      const R = C();
      return R.creationHeight = m.creationHeight !== void 0 && m.creationHeight !== null ? L.Long.fromValue(m.creationHeight) : L.Long.ZERO, R.completionTime = m.completionTime !== void 0 && m.completionTime !== null ? u.Timestamp.fromPartial(m.completionTime) : void 0, R.initialBalance = m.initialBalance ?? "", R.sharesDst = m.sharesDst ?? "", R.unbondingId = m.unbondingId !== void 0 && m.unbondingId !== null ? L.Long.fromValue(m.unbondingId) : L.Long.UZERO, R.unbondingOnHoldRefCount = m.unbondingOnHoldRefCount !== void 0 && m.unbondingOnHoldRefCount !== null ? L.Long.fromValue(m.unbondingOnHoldRefCount) : L.Long.ZERO, R;
    }
  };
  function v() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      entries: []
    };
  }
  e.Redelegation = {
    encode(m, R = M.Writer.create()) {
      m.delegatorAddress !== "" && R.uint32(10).string(m.delegatorAddress), m.validatorSrcAddress !== "" && R.uint32(18).string(m.validatorSrcAddress), m.validatorDstAddress !== "" && R.uint32(26).string(m.validatorDstAddress);
      for (const N of m.entries)
        e.RedelegationEntry.encode(N, R.uint32(34).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = v();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.delegatorAddress = N.string();
            break;
          case 2:
            K.validatorSrcAddress = N.string();
            break;
          case 3:
            K.validatorDstAddress = N.string();
            break;
          case 4:
            K.entries.push(e.RedelegationEntry.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        delegatorAddress: (0, L.isSet)(m.delegatorAddress) ? String(m.delegatorAddress) : "",
        validatorSrcAddress: (0, L.isSet)(m.validatorSrcAddress) ? String(m.validatorSrcAddress) : "",
        validatorDstAddress: (0, L.isSet)(m.validatorDstAddress) ? String(m.validatorDstAddress) : "",
        entries: Array.isArray(m == null ? void 0 : m.entries) ? m.entries.map((R) => e.RedelegationEntry.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.delegatorAddress !== void 0 && (R.delegatorAddress = m.delegatorAddress), m.validatorSrcAddress !== void 0 && (R.validatorSrcAddress = m.validatorSrcAddress), m.validatorDstAddress !== void 0 && (R.validatorDstAddress = m.validatorDstAddress), m.entries ? R.entries = m.entries.map((N) => N ? e.RedelegationEntry.toJSON(N) : void 0) : R.entries = [], R;
    },
    fromPartial(m) {
      var N;
      const R = v();
      return R.delegatorAddress = m.delegatorAddress ?? "", R.validatorSrcAddress = m.validatorSrcAddress ?? "", R.validatorDstAddress = m.validatorDstAddress ?? "", R.entries = ((N = m.entries) == null ? void 0 : N.map((Q) => e.RedelegationEntry.fromPartial(Q))) || [], R;
    }
  };
  function k() {
    return {
      unbondingTime: void 0,
      maxValidators: 0,
      maxEntries: 0,
      historicalEntries: 0,
      bondDenom: "",
      minCommissionRate: ""
    };
  }
  e.Params = {
    encode(m, R = M.Writer.create()) {
      return m.unbondingTime !== void 0 && O.Duration.encode(m.unbondingTime, R.uint32(10).fork()).ldelim(), m.maxValidators !== 0 && R.uint32(16).uint32(m.maxValidators), m.maxEntries !== 0 && R.uint32(24).uint32(m.maxEntries), m.historicalEntries !== 0 && R.uint32(32).uint32(m.historicalEntries), m.bondDenom !== "" && R.uint32(42).string(m.bondDenom), m.minCommissionRate !== "" && R.uint32(50).string(m.minCommissionRate), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = k();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.unbondingTime = O.Duration.decode(N, N.uint32());
            break;
          case 2:
            K.maxValidators = N.uint32();
            break;
          case 3:
            K.maxEntries = N.uint32();
            break;
          case 4:
            K.historicalEntries = N.uint32();
            break;
          case 5:
            K.bondDenom = N.string();
            break;
          case 6:
            K.minCommissionRate = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        unbondingTime: (0, L.isSet)(m.unbondingTime) ? O.Duration.fromJSON(m.unbondingTime) : void 0,
        maxValidators: (0, L.isSet)(m.maxValidators) ? Number(m.maxValidators) : 0,
        maxEntries: (0, L.isSet)(m.maxEntries) ? Number(m.maxEntries) : 0,
        historicalEntries: (0, L.isSet)(m.historicalEntries) ? Number(m.historicalEntries) : 0,
        bondDenom: (0, L.isSet)(m.bondDenom) ? String(m.bondDenom) : "",
        minCommissionRate: (0, L.isSet)(m.minCommissionRate) ? String(m.minCommissionRate) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.unbondingTime !== void 0 && (R.unbondingTime = m.unbondingTime ? O.Duration.toJSON(m.unbondingTime) : void 0), m.maxValidators !== void 0 && (R.maxValidators = Math.round(m.maxValidators)), m.maxEntries !== void 0 && (R.maxEntries = Math.round(m.maxEntries)), m.historicalEntries !== void 0 && (R.historicalEntries = Math.round(m.historicalEntries)), m.bondDenom !== void 0 && (R.bondDenom = m.bondDenom), m.minCommissionRate !== void 0 && (R.minCommissionRate = m.minCommissionRate), R;
    },
    fromPartial(m) {
      const R = k();
      return R.unbondingTime = m.unbondingTime !== void 0 && m.unbondingTime !== null ? O.Duration.fromPartial(m.unbondingTime) : void 0, R.maxValidators = m.maxValidators ?? 0, R.maxEntries = m.maxEntries ?? 0, R.historicalEntries = m.historicalEntries ?? 0, R.bondDenom = m.bondDenom ?? "", R.minCommissionRate = m.minCommissionRate ?? "", R;
    }
  };
  function U() {
    return {
      delegation: void 0,
      balance: void 0
    };
  }
  e.DelegationResponse = {
    encode(m, R = M.Writer.create()) {
      return m.delegation !== void 0 && e.Delegation.encode(m.delegation, R.uint32(10).fork()).ldelim(), m.balance !== void 0 && A.Coin.encode(m.balance, R.uint32(18).fork()).ldelim(), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = U();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.delegation = e.Delegation.decode(N, N.uint32());
            break;
          case 2:
            K.balance = A.Coin.decode(N, N.uint32());
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        delegation: (0, L.isSet)(m.delegation) ? e.Delegation.fromJSON(m.delegation) : void 0,
        balance: (0, L.isSet)(m.balance) ? A.Coin.fromJSON(m.balance) : void 0
      };
    },
    toJSON(m) {
      const R = {};
      return m.delegation !== void 0 && (R.delegation = m.delegation ? e.Delegation.toJSON(m.delegation) : void 0), m.balance !== void 0 && (R.balance = m.balance ? A.Coin.toJSON(m.balance) : void 0), R;
    },
    fromPartial(m) {
      const R = U();
      return R.delegation = m.delegation !== void 0 && m.delegation !== null ? e.Delegation.fromPartial(m.delegation) : void 0, R.balance = m.balance !== void 0 && m.balance !== null ? A.Coin.fromPartial(m.balance) : void 0, R;
    }
  };
  function F() {
    return {
      redelegationEntry: void 0,
      balance: ""
    };
  }
  e.RedelegationEntryResponse = {
    encode(m, R = M.Writer.create()) {
      return m.redelegationEntry !== void 0 && e.RedelegationEntry.encode(m.redelegationEntry, R.uint32(10).fork()).ldelim(), m.balance !== "" && R.uint32(34).string(m.balance), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = F();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.redelegationEntry = e.RedelegationEntry.decode(N, N.uint32());
            break;
          case 4:
            K.balance = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        redelegationEntry: (0, L.isSet)(m.redelegationEntry) ? e.RedelegationEntry.fromJSON(m.redelegationEntry) : void 0,
        balance: (0, L.isSet)(m.balance) ? String(m.balance) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.redelegationEntry !== void 0 && (R.redelegationEntry = m.redelegationEntry ? e.RedelegationEntry.toJSON(m.redelegationEntry) : void 0), m.balance !== void 0 && (R.balance = m.balance), R;
    },
    fromPartial(m) {
      const R = F();
      return R.redelegationEntry = m.redelegationEntry !== void 0 && m.redelegationEntry !== null ? e.RedelegationEntry.fromPartial(m.redelegationEntry) : void 0, R.balance = m.balance ?? "", R;
    }
  };
  function q() {
    return {
      redelegation: void 0,
      entries: []
    };
  }
  e.RedelegationResponse = {
    encode(m, R = M.Writer.create()) {
      m.redelegation !== void 0 && e.Redelegation.encode(m.redelegation, R.uint32(10).fork()).ldelim();
      for (const N of m.entries)
        e.RedelegationEntryResponse.encode(N, R.uint32(18).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = q();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.redelegation = e.Redelegation.decode(N, N.uint32());
            break;
          case 2:
            K.entries.push(e.RedelegationEntryResponse.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        redelegation: (0, L.isSet)(m.redelegation) ? e.Redelegation.fromJSON(m.redelegation) : void 0,
        entries: Array.isArray(m == null ? void 0 : m.entries) ? m.entries.map((R) => e.RedelegationEntryResponse.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.redelegation !== void 0 && (R.redelegation = m.redelegation ? e.Redelegation.toJSON(m.redelegation) : void 0), m.entries ? R.entries = m.entries.map((N) => N ? e.RedelegationEntryResponse.toJSON(N) : void 0) : R.entries = [], R;
    },
    fromPartial(m) {
      var N;
      const R = q();
      return R.redelegation = m.redelegation !== void 0 && m.redelegation !== null ? e.Redelegation.fromPartial(m.redelegation) : void 0, R.entries = ((N = m.entries) == null ? void 0 : N.map((Q) => e.RedelegationEntryResponse.fromPartial(Q))) || [], R;
    }
  };
  function o() {
    return {
      notBondedTokens: "",
      bondedTokens: ""
    };
  }
  e.Pool = {
    encode(m, R = M.Writer.create()) {
      return m.notBondedTokens !== "" && R.uint32(10).string(m.notBondedTokens), m.bondedTokens !== "" && R.uint32(18).string(m.bondedTokens), R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = o();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.notBondedTokens = N.string();
            break;
          case 2:
            K.bondedTokens = N.string();
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        notBondedTokens: (0, L.isSet)(m.notBondedTokens) ? String(m.notBondedTokens) : "",
        bondedTokens: (0, L.isSet)(m.bondedTokens) ? String(m.bondedTokens) : ""
      };
    },
    toJSON(m) {
      const R = {};
      return m.notBondedTokens !== void 0 && (R.notBondedTokens = m.notBondedTokens), m.bondedTokens !== void 0 && (R.bondedTokens = m.bondedTokens), R;
    },
    fromPartial(m) {
      const R = o();
      return R.notBondedTokens = m.notBondedTokens ?? "", R.bondedTokens = m.bondedTokens ?? "", R;
    }
  };
  function P() {
    return {
      updates: []
    };
  }
  e.ValidatorUpdates = {
    encode(m, R = M.Writer.create()) {
      for (const N of m.updates)
        T.ValidatorUpdate.encode(N, R.uint32(10).fork()).ldelim();
      return R;
    },
    decode(m, R) {
      const N = m instanceof M.Reader ? m : new M.Reader(m);
      let Q = R === void 0 ? N.len : N.pos + R;
      const K = P();
      for (; N.pos < Q; ) {
        const z = N.uint32();
        switch (z >>> 3) {
          case 1:
            K.updates.push(T.ValidatorUpdate.decode(N, N.uint32()));
            break;
          default:
            N.skipType(z & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(m) {
      return {
        updates: Array.isArray(m == null ? void 0 : m.updates) ? m.updates.map((R) => T.ValidatorUpdate.fromJSON(R)) : []
      };
    },
    toJSON(m) {
      const R = {};
      return m.updates ? R.updates = m.updates.map((N) => N ? T.ValidatorUpdate.toJSON(N) : void 0) : R.updates = [], R;
    },
    fromPartial(m) {
      var N;
      const R = P();
      return R.updates = ((N = m.updates) == null ? void 0 : N.map((Q) => T.ValidatorUpdate.fromPartial(Q))) || [], R;
    }
  };
})(aa);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(t, y, E, H) {
    H === void 0 && (H = E);
    var a = Object.getOwnPropertyDescriptor(y, E);
    (!a || ("get" in a ? !y.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return y[E];
    } }), Object.defineProperty(t, H, a);
  } : function(t, y, E, H) {
    H === void 0 && (H = E), t[H] = y[E];
  }), c = G && G.__setModuleDefault || (Object.create ? function(t, y) {
    Object.defineProperty(t, "default", { enumerable: !0, value: y });
  } : function(t, y) {
    t.default = y;
  }), i = G && G.__importStar || function(t) {
    if (t && t.__esModule)
      return t;
    var y = {};
    if (t != null)
      for (var E in t)
        E !== "default" && Object.prototype.hasOwnProperty.call(t, E) && n(y, t, E);
    return c(y, t), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgCancelUnbondingDelegationResponse = e.MsgCancelUnbondingDelegation = e.MsgUndelegateResponse = e.MsgUndelegate = e.MsgBeginRedelegateResponse = e.MsgBeginRedelegate = e.MsgDelegateResponse = e.MsgDelegate = e.MsgEditValidatorResponse = e.MsgEditValidator = e.MsgCreateValidatorResponse = e.MsgCreateValidator = e.protobufPackage = void 0;
  const r = aa, u = Se, f = Me, O = _e, A = oe, T = i(ie);
  e.protobufPackage = "cosmos.staking.v1beta1";
  function L() {
    return {
      description: void 0,
      commission: void 0,
      minSelfDelegation: "",
      delegatorAddress: "",
      validatorAddress: "",
      pubkey: void 0,
      value: void 0
    };
  }
  e.MsgCreateValidator = {
    encode(t, y = T.Writer.create()) {
      return t.description !== void 0 && r.Description.encode(t.description, y.uint32(10).fork()).ldelim(), t.commission !== void 0 && r.CommissionRates.encode(t.commission, y.uint32(18).fork()).ldelim(), t.minSelfDelegation !== "" && y.uint32(26).string(t.minSelfDelegation), t.delegatorAddress !== "" && y.uint32(34).string(t.delegatorAddress), t.validatorAddress !== "" && y.uint32(42).string(t.validatorAddress), t.pubkey !== void 0 && u.Any.encode(t.pubkey, y.uint32(50).fork()).ldelim(), t.value !== void 0 && f.Coin.encode(t.value, y.uint32(58).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = L();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.description = r.Description.decode(E, E.uint32());
            break;
          case 2:
            a.commission = r.CommissionRates.decode(E, E.uint32());
            break;
          case 3:
            a.minSelfDelegation = E.string();
            break;
          case 4:
            a.delegatorAddress = E.string();
            break;
          case 5:
            a.validatorAddress = E.string();
            break;
          case 6:
            a.pubkey = u.Any.decode(E, E.uint32());
            break;
          case 7:
            a.value = f.Coin.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        description: (0, A.isSet)(t.description) ? r.Description.fromJSON(t.description) : void 0,
        commission: (0, A.isSet)(t.commission) ? r.CommissionRates.fromJSON(t.commission) : void 0,
        minSelfDelegation: (0, A.isSet)(t.minSelfDelegation) ? String(t.minSelfDelegation) : "",
        delegatorAddress: (0, A.isSet)(t.delegatorAddress) ? String(t.delegatorAddress) : "",
        validatorAddress: (0, A.isSet)(t.validatorAddress) ? String(t.validatorAddress) : "",
        pubkey: (0, A.isSet)(t.pubkey) ? u.Any.fromJSON(t.pubkey) : void 0,
        value: (0, A.isSet)(t.value) ? f.Coin.fromJSON(t.value) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.description !== void 0 && (y.description = t.description ? r.Description.toJSON(t.description) : void 0), t.commission !== void 0 && (y.commission = t.commission ? r.CommissionRates.toJSON(t.commission) : void 0), t.minSelfDelegation !== void 0 && (y.minSelfDelegation = t.minSelfDelegation), t.delegatorAddress !== void 0 && (y.delegatorAddress = t.delegatorAddress), t.validatorAddress !== void 0 && (y.validatorAddress = t.validatorAddress), t.pubkey !== void 0 && (y.pubkey = t.pubkey ? u.Any.toJSON(t.pubkey) : void 0), t.value !== void 0 && (y.value = t.value ? f.Coin.toJSON(t.value) : void 0), y;
    },
    fromPartial(t) {
      const y = L();
      return y.description = t.description !== void 0 && t.description !== null ? r.Description.fromPartial(t.description) : void 0, y.commission = t.commission !== void 0 && t.commission !== null ? r.CommissionRates.fromPartial(t.commission) : void 0, y.minSelfDelegation = t.minSelfDelegation ?? "", y.delegatorAddress = t.delegatorAddress ?? "", y.validatorAddress = t.validatorAddress ?? "", y.pubkey = t.pubkey !== void 0 && t.pubkey !== null ? u.Any.fromPartial(t.pubkey) : void 0, y.value = t.value !== void 0 && t.value !== null ? f.Coin.fromPartial(t.value) : void 0, y;
    }
  };
  function M() {
    return {};
  }
  e.MsgCreateValidatorResponse = {
    encode(t, y = T.Writer.create()) {
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = M();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {};
    },
    toJSON(t) {
      return {};
    },
    fromPartial(t) {
      return M();
    }
  };
  function V() {
    return {
      description: void 0,
      validatorAddress: "",
      commissionRate: "",
      minSelfDelegation: ""
    };
  }
  e.MsgEditValidator = {
    encode(t, y = T.Writer.create()) {
      return t.description !== void 0 && r.Description.encode(t.description, y.uint32(10).fork()).ldelim(), t.validatorAddress !== "" && y.uint32(18).string(t.validatorAddress), t.commissionRate !== "" && y.uint32(26).string(t.commissionRate), t.minSelfDelegation !== "" && y.uint32(34).string(t.minSelfDelegation), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = V();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.description = r.Description.decode(E, E.uint32());
            break;
          case 2:
            a.validatorAddress = E.string();
            break;
          case 3:
            a.commissionRate = E.string();
            break;
          case 4:
            a.minSelfDelegation = E.string();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        description: (0, A.isSet)(t.description) ? r.Description.fromJSON(t.description) : void 0,
        validatorAddress: (0, A.isSet)(t.validatorAddress) ? String(t.validatorAddress) : "",
        commissionRate: (0, A.isSet)(t.commissionRate) ? String(t.commissionRate) : "",
        minSelfDelegation: (0, A.isSet)(t.minSelfDelegation) ? String(t.minSelfDelegation) : ""
      };
    },
    toJSON(t) {
      const y = {};
      return t.description !== void 0 && (y.description = t.description ? r.Description.toJSON(t.description) : void 0), t.validatorAddress !== void 0 && (y.validatorAddress = t.validatorAddress), t.commissionRate !== void 0 && (y.commissionRate = t.commissionRate), t.minSelfDelegation !== void 0 && (y.minSelfDelegation = t.minSelfDelegation), y;
    },
    fromPartial(t) {
      const y = V();
      return y.description = t.description !== void 0 && t.description !== null ? r.Description.fromPartial(t.description) : void 0, y.validatorAddress = t.validatorAddress ?? "", y.commissionRate = t.commissionRate ?? "", y.minSelfDelegation = t.minSelfDelegation ?? "", y;
    }
  };
  function D() {
    return {};
  }
  e.MsgEditValidatorResponse = {
    encode(t, y = T.Writer.create()) {
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = D();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {};
    },
    toJSON(t) {
      return {};
    },
    fromPartial(t) {
      return D();
    }
  };
  function b() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: void 0
    };
  }
  e.MsgDelegate = {
    encode(t, y = T.Writer.create()) {
      return t.delegatorAddress !== "" && y.uint32(10).string(t.delegatorAddress), t.validatorAddress !== "" && y.uint32(18).string(t.validatorAddress), t.amount !== void 0 && f.Coin.encode(t.amount, y.uint32(26).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = b();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.delegatorAddress = E.string();
            break;
          case 2:
            a.validatorAddress = E.string();
            break;
          case 3:
            a.amount = f.Coin.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        delegatorAddress: (0, A.isSet)(t.delegatorAddress) ? String(t.delegatorAddress) : "",
        validatorAddress: (0, A.isSet)(t.validatorAddress) ? String(t.validatorAddress) : "",
        amount: (0, A.isSet)(t.amount) ? f.Coin.fromJSON(t.amount) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.delegatorAddress !== void 0 && (y.delegatorAddress = t.delegatorAddress), t.validatorAddress !== void 0 && (y.validatorAddress = t.validatorAddress), t.amount !== void 0 && (y.amount = t.amount ? f.Coin.toJSON(t.amount) : void 0), y;
    },
    fromPartial(t) {
      const y = b();
      return y.delegatorAddress = t.delegatorAddress ?? "", y.validatorAddress = t.validatorAddress ?? "", y.amount = t.amount !== void 0 && t.amount !== null ? f.Coin.fromPartial(t.amount) : void 0, y;
    }
  };
  function h() {
    return {};
  }
  e.MsgDelegateResponse = {
    encode(t, y = T.Writer.create()) {
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = h();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {};
    },
    toJSON(t) {
      return {};
    },
    fromPartial(t) {
      return h();
    }
  };
  function S() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      amount: void 0
    };
  }
  e.MsgBeginRedelegate = {
    encode(t, y = T.Writer.create()) {
      return t.delegatorAddress !== "" && y.uint32(10).string(t.delegatorAddress), t.validatorSrcAddress !== "" && y.uint32(18).string(t.validatorSrcAddress), t.validatorDstAddress !== "" && y.uint32(26).string(t.validatorDstAddress), t.amount !== void 0 && f.Coin.encode(t.amount, y.uint32(34).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = S();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.delegatorAddress = E.string();
            break;
          case 2:
            a.validatorSrcAddress = E.string();
            break;
          case 3:
            a.validatorDstAddress = E.string();
            break;
          case 4:
            a.amount = f.Coin.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        delegatorAddress: (0, A.isSet)(t.delegatorAddress) ? String(t.delegatorAddress) : "",
        validatorSrcAddress: (0, A.isSet)(t.validatorSrcAddress) ? String(t.validatorSrcAddress) : "",
        validatorDstAddress: (0, A.isSet)(t.validatorDstAddress) ? String(t.validatorDstAddress) : "",
        amount: (0, A.isSet)(t.amount) ? f.Coin.fromJSON(t.amount) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.delegatorAddress !== void 0 && (y.delegatorAddress = t.delegatorAddress), t.validatorSrcAddress !== void 0 && (y.validatorSrcAddress = t.validatorSrcAddress), t.validatorDstAddress !== void 0 && (y.validatorDstAddress = t.validatorDstAddress), t.amount !== void 0 && (y.amount = t.amount ? f.Coin.toJSON(t.amount) : void 0), y;
    },
    fromPartial(t) {
      const y = S();
      return y.delegatorAddress = t.delegatorAddress ?? "", y.validatorSrcAddress = t.validatorSrcAddress ?? "", y.validatorDstAddress = t.validatorDstAddress ?? "", y.amount = t.amount !== void 0 && t.amount !== null ? f.Coin.fromPartial(t.amount) : void 0, y;
    }
  };
  function _() {
    return {
      completionTime: void 0
    };
  }
  e.MsgBeginRedelegateResponse = {
    encode(t, y = T.Writer.create()) {
      return t.completionTime !== void 0 && O.Timestamp.encode(t.completionTime, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = _();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.completionTime = O.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        completionTime: (0, A.isSet)(t.completionTime) ? (0, A.fromJsonTimestamp)(t.completionTime) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.completionTime !== void 0 && (y.completionTime = (0, A.fromTimestamp)(t.completionTime).toISOString()), y;
    },
    fromPartial(t) {
      const y = _();
      return y.completionTime = t.completionTime !== void 0 && t.completionTime !== null ? O.Timestamp.fromPartial(t.completionTime) : void 0, y;
    }
  };
  function d() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: void 0
    };
  }
  e.MsgUndelegate = {
    encode(t, y = T.Writer.create()) {
      return t.delegatorAddress !== "" && y.uint32(10).string(t.delegatorAddress), t.validatorAddress !== "" && y.uint32(18).string(t.validatorAddress), t.amount !== void 0 && f.Coin.encode(t.amount, y.uint32(26).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = d();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.delegatorAddress = E.string();
            break;
          case 2:
            a.validatorAddress = E.string();
            break;
          case 3:
            a.amount = f.Coin.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        delegatorAddress: (0, A.isSet)(t.delegatorAddress) ? String(t.delegatorAddress) : "",
        validatorAddress: (0, A.isSet)(t.validatorAddress) ? String(t.validatorAddress) : "",
        amount: (0, A.isSet)(t.amount) ? f.Coin.fromJSON(t.amount) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.delegatorAddress !== void 0 && (y.delegatorAddress = t.delegatorAddress), t.validatorAddress !== void 0 && (y.validatorAddress = t.validatorAddress), t.amount !== void 0 && (y.amount = t.amount ? f.Coin.toJSON(t.amount) : void 0), y;
    },
    fromPartial(t) {
      const y = d();
      return y.delegatorAddress = t.delegatorAddress ?? "", y.validatorAddress = t.validatorAddress ?? "", y.amount = t.amount !== void 0 && t.amount !== null ? f.Coin.fromPartial(t.amount) : void 0, y;
    }
  };
  function p() {
    return {
      completionTime: void 0
    };
  }
  e.MsgUndelegateResponse = {
    encode(t, y = T.Writer.create()) {
      return t.completionTime !== void 0 && O.Timestamp.encode(t.completionTime, y.uint32(10).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = p();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.completionTime = O.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        completionTime: (0, A.isSet)(t.completionTime) ? (0, A.fromJsonTimestamp)(t.completionTime) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.completionTime !== void 0 && (y.completionTime = (0, A.fromTimestamp)(t.completionTime).toISOString()), y;
    },
    fromPartial(t) {
      const y = p();
      return y.completionTime = t.completionTime !== void 0 && t.completionTime !== null ? O.Timestamp.fromPartial(t.completionTime) : void 0, y;
    }
  };
  function g() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: void 0,
      creationHeight: A.Long.ZERO
    };
  }
  e.MsgCancelUnbondingDelegation = {
    encode(t, y = T.Writer.create()) {
      return t.delegatorAddress !== "" && y.uint32(10).string(t.delegatorAddress), t.validatorAddress !== "" && y.uint32(18).string(t.validatorAddress), t.amount !== void 0 && f.Coin.encode(t.amount, y.uint32(26).fork()).ldelim(), t.creationHeight.isZero() || y.uint32(32).int64(t.creationHeight), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = g();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.delegatorAddress = E.string();
            break;
          case 2:
            a.validatorAddress = E.string();
            break;
          case 3:
            a.amount = f.Coin.decode(E, E.uint32());
            break;
          case 4:
            a.creationHeight = E.int64();
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        delegatorAddress: (0, A.isSet)(t.delegatorAddress) ? String(t.delegatorAddress) : "",
        validatorAddress: (0, A.isSet)(t.validatorAddress) ? String(t.validatorAddress) : "",
        amount: (0, A.isSet)(t.amount) ? f.Coin.fromJSON(t.amount) : void 0,
        creationHeight: (0, A.isSet)(t.creationHeight) ? A.Long.fromValue(t.creationHeight) : A.Long.ZERO
      };
    },
    toJSON(t) {
      const y = {};
      return t.delegatorAddress !== void 0 && (y.delegatorAddress = t.delegatorAddress), t.validatorAddress !== void 0 && (y.validatorAddress = t.validatorAddress), t.amount !== void 0 && (y.amount = t.amount ? f.Coin.toJSON(t.amount) : void 0), t.creationHeight !== void 0 && (y.creationHeight = (t.creationHeight || A.Long.ZERO).toString()), y;
    },
    fromPartial(t) {
      const y = g();
      return y.delegatorAddress = t.delegatorAddress ?? "", y.validatorAddress = t.validatorAddress ?? "", y.amount = t.amount !== void 0 && t.amount !== null ? f.Coin.fromPartial(t.amount) : void 0, y.creationHeight = t.creationHeight !== void 0 && t.creationHeight !== null ? A.Long.fromValue(t.creationHeight) : A.Long.ZERO, y;
    }
  };
  function J() {
    return {};
  }
  e.MsgCancelUnbondingDelegationResponse = {
    encode(t, y = T.Writer.create()) {
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = J();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {};
    },
    toJSON(t) {
      return {};
    },
    fromPartial(t) {
      return J();
    }
  };
  function B() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(t, y = T.Writer.create()) {
      return t.authority !== "" && y.uint32(10).string(t.authority), t.params !== void 0 && r.Params.encode(t.params, y.uint32(18).fork()).ldelim(), y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = B();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          case 1:
            a.authority = E.string();
            break;
          case 2:
            a.params = r.Params.decode(E, E.uint32());
            break;
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {
        authority: (0, A.isSet)(t.authority) ? String(t.authority) : "",
        params: (0, A.isSet)(t.params) ? r.Params.fromJSON(t.params) : void 0
      };
    },
    toJSON(t) {
      const y = {};
      return t.authority !== void 0 && (y.authority = t.authority), t.params !== void 0 && (y.params = t.params ? r.Params.toJSON(t.params) : void 0), y;
    },
    fromPartial(t) {
      const y = B();
      return y.authority = t.authority ?? "", y.params = t.params !== void 0 && t.params !== null ? r.Params.fromPartial(t.params) : void 0, y;
    }
  };
  function I() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(t, y = T.Writer.create()) {
      return y;
    },
    decode(t, y) {
      const E = t instanceof T.Reader ? t : new T.Reader(t);
      let H = y === void 0 ? E.len : E.pos + y;
      const a = I();
      for (; E.pos < H; ) {
        const l = E.uint32();
        switch (l >>> 3) {
          default:
            E.skipType(l & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(t) {
      return {};
    },
    toJSON(t) {
      return {};
    },
    fromPartial(t) {
      return I();
    }
  };
  class Z {
    constructor(y) {
      this.rpc = y, this.CreateValidator = this.CreateValidator.bind(this), this.EditValidator = this.EditValidator.bind(this), this.Delegate = this.Delegate.bind(this), this.BeginRedelegate = this.BeginRedelegate.bind(this), this.Undelegate = this.Undelegate.bind(this), this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    CreateValidator(y) {
      const E = e.MsgCreateValidator.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", E).then((a) => e.MsgCreateValidatorResponse.decode(new T.Reader(a)));
    }
    EditValidator(y) {
      const E = e.MsgEditValidator.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", E).then((a) => e.MsgEditValidatorResponse.decode(new T.Reader(a)));
    }
    Delegate(y) {
      const E = e.MsgDelegate.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", E).then((a) => e.MsgDelegateResponse.decode(new T.Reader(a)));
    }
    BeginRedelegate(y) {
      const E = e.MsgBeginRedelegate.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", E).then((a) => e.MsgBeginRedelegateResponse.decode(new T.Reader(a)));
    }
    Undelegate(y) {
      const E = e.MsgUndelegate.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", E).then((a) => e.MsgUndelegateResponse.decode(new T.Reader(a)));
    }
    CancelUnbondingDelegation(y) {
      const E = e.MsgCancelUnbondingDelegation.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", E).then((a) => e.MsgCancelUnbondingDelegationResponse.decode(new T.Reader(a)));
    }
    UpdateParams(y) {
      const E = e.MsgUpdateParams.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", E).then((a) => e.MsgUpdateParamsResponse.decode(new T.Reader(a)));
    }
  }
  e.MsgClientImpl = Z;
})(oa);
Object.defineProperty(Ge, "__esModule", { value: !0 });
Ge.isMsgUndelegateEncodeObject = Ge.isMsgEditValidatorEncodeObject = Ge.isMsgDelegateEncodeObject = Ge.isMsgCreateValidatorEncodeObject = Ge.isMsgBeginRedelegateEncodeObject = Ge.stakingTypes = void 0;
const Gt = oa;
Ge.stakingTypes = [
  ["/cosmos.staking.v1beta1.MsgBeginRedelegate", Gt.MsgBeginRedelegate],
  ["/cosmos.staking.v1beta1.MsgCreateValidator", Gt.MsgCreateValidator],
  ["/cosmos.staking.v1beta1.MsgDelegate", Gt.MsgDelegate],
  ["/cosmos.staking.v1beta1.MsgEditValidator", Gt.MsgEditValidator],
  ["/cosmos.staking.v1beta1.MsgUndelegate", Gt.MsgUndelegate]
];
function gm(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}
Ge.isMsgBeginRedelegateEncodeObject = gm;
function ym(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
}
Ge.isMsgCreateValidatorEncodeObject = ym;
function Sm(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
}
Ge.isMsgDelegateEncodeObject = Sm;
function Om(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
}
Ge.isMsgEditValidatorEncodeObject = Om;
function Rm(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
}
Ge.isMsgUndelegateEncodeObject = Rm;
var mi = {}, Lu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(o, P, m, R) {
    R === void 0 && (R = m);
    var N = Object.getOwnPropertyDescriptor(P, m);
    (!N || ("get" in N ? !P.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return P[m];
    } }), Object.defineProperty(o, R, N);
  } : function(o, P, m, R) {
    R === void 0 && (R = m), o[R] = P[m];
  }), c = G && G.__setModuleDefault || (Object.create ? function(o, P) {
    Object.defineProperty(o, "default", { enumerable: !0, value: P });
  } : function(o, P) {
    o.default = P;
  }), i = G && G.__importStar || function(o) {
    if (o && o.__esModule)
      return o;
    var P = {};
    if (o != null)
      for (var m in o)
        m !== "default" && Object.prototype.hasOwnProperty.call(o, m) && n(P, o, m);
    return c(P, o), P;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryPoolResponse = e.QueryPoolRequest = e.QueryHistoricalInfoResponse = e.QueryHistoricalInfoRequest = e.QueryDelegatorValidatorResponse = e.QueryDelegatorValidatorRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryRedelegationsResponse = e.QueryRedelegationsRequest = e.QueryDelegatorUnbondingDelegationsResponse = e.QueryDelegatorUnbondingDelegationsRequest = e.QueryDelegatorDelegationsResponse = e.QueryDelegatorDelegationsRequest = e.QueryUnbondingDelegationResponse = e.QueryUnbondingDelegationRequest = e.QueryDelegationResponse = e.QueryDelegationRequest = e.QueryValidatorUnbondingDelegationsResponse = e.QueryValidatorUnbondingDelegationsRequest = e.QueryValidatorDelegationsResponse = e.QueryValidatorDelegationsRequest = e.QueryValidatorResponse = e.QueryValidatorRequest = e.QueryValidatorsResponse = e.QueryValidatorsRequest = e.protobufPackage = void 0;
  const r = Re, u = aa, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.staking.v1beta1";
  function A() {
    return {
      status: "",
      pagination: void 0
    };
  }
  e.QueryValidatorsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.status !== "" && P.uint32(10).string(o.status), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = A();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.status = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        status: (0, f.isSet)(o.status) ? String(o.status) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.status !== void 0 && (P.status = o.status), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = A();
      return P.status = o.status ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function T() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryValidatorsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.validators)
        u.Validator.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = T();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validators.push(u.Validator.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validators: Array.isArray(o == null ? void 0 : o.validators) ? o.validators.map((P) => u.Validator.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.validators ? P.validators = o.validators.map((m) => m ? u.Validator.toJSON(m) : void 0) : P.validators = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = T();
      return P.validators = ((m = o.validators) == null ? void 0 : m.map((R) => u.Validator.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function L() {
    return {
      validatorAddr: ""
    };
  }
  e.QueryValidatorRequest = {
    encode(o, P = O.Writer.create()) {
      return o.validatorAddr !== "" && P.uint32(10).string(o.validatorAddr), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = L();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validatorAddr: (0, f.isSet)(o.validatorAddr) ? String(o.validatorAddr) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.validatorAddr !== void 0 && (P.validatorAddr = o.validatorAddr), P;
    },
    fromPartial(o) {
      const P = L();
      return P.validatorAddr = o.validatorAddr ?? "", P;
    }
  };
  function M() {
    return {
      validator: void 0
    };
  }
  e.QueryValidatorResponse = {
    encode(o, P = O.Writer.create()) {
      return o.validator !== void 0 && u.Validator.encode(o.validator, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = M();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validator = u.Validator.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validator: (0, f.isSet)(o.validator) ? u.Validator.fromJSON(o.validator) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.validator !== void 0 && (P.validator = o.validator ? u.Validator.toJSON(o.validator) : void 0), P;
    },
    fromPartial(o) {
      const P = M();
      return P.validator = o.validator !== void 0 && o.validator !== null ? u.Validator.fromPartial(o.validator) : void 0, P;
    }
  };
  function V() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.validatorAddr !== "" && P.uint32(10).string(o.validatorAddr), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = V();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validatorAddr = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validatorAddr: (0, f.isSet)(o.validatorAddr) ? String(o.validatorAddr) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.validatorAddr !== void 0 && (P.validatorAddr = o.validatorAddr), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = V();
      return P.validatorAddr = o.validatorAddr ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function D() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.delegationResponses)
        u.DelegationResponse.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = D();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegationResponses.push(u.DelegationResponse.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegationResponses: Array.isArray(o == null ? void 0 : o.delegationResponses) ? o.delegationResponses.map((P) => u.DelegationResponse.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegationResponses ? P.delegationResponses = o.delegationResponses.map((m) => m ? u.DelegationResponse.toJSON(m) : void 0) : P.delegationResponses = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = D();
      return P.delegationResponses = ((m = o.delegationResponses) == null ? void 0 : m.map((R) => u.DelegationResponse.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function b() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.validatorAddr !== "" && P.uint32(10).string(o.validatorAddr), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = b();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validatorAddr = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validatorAddr: (0, f.isSet)(o.validatorAddr) ? String(o.validatorAddr) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.validatorAddr !== void 0 && (P.validatorAddr = o.validatorAddr), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = b();
      return P.validatorAddr = o.validatorAddr ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function h() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.unbondingResponses)
        u.UnbondingDelegation.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = h();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.unbondingResponses.push(u.UnbondingDelegation.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        unbondingResponses: Array.isArray(o == null ? void 0 : o.unbondingResponses) ? o.unbondingResponses.map((P) => u.UnbondingDelegation.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.unbondingResponses ? P.unbondingResponses = o.unbondingResponses.map((m) => m ? u.UnbondingDelegation.toJSON(m) : void 0) : P.unbondingResponses = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = h();
      return P.unbondingResponses = ((m = o.unbondingResponses) == null ? void 0 : m.map((R) => u.UnbondingDelegation.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function S() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegationRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.validatorAddr !== "" && P.uint32(18).string(o.validatorAddr), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = S();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        validatorAddr: (0, f.isSet)(o.validatorAddr) ? String(o.validatorAddr) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.validatorAddr !== void 0 && (P.validatorAddr = o.validatorAddr), P;
    },
    fromPartial(o) {
      const P = S();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.validatorAddr = o.validatorAddr ?? "", P;
    }
  };
  function _() {
    return {
      delegationResponse: void 0
    };
  }
  e.QueryDelegationResponse = {
    encode(o, P = O.Writer.create()) {
      return o.delegationResponse !== void 0 && u.DelegationResponse.encode(o.delegationResponse, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = _();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegationResponse = u.DelegationResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegationResponse: (0, f.isSet)(o.delegationResponse) ? u.DelegationResponse.fromJSON(o.delegationResponse) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegationResponse !== void 0 && (P.delegationResponse = o.delegationResponse ? u.DelegationResponse.toJSON(o.delegationResponse) : void 0), P;
    },
    fromPartial(o) {
      const P = _();
      return P.delegationResponse = o.delegationResponse !== void 0 && o.delegationResponse !== null ? u.DelegationResponse.fromPartial(o.delegationResponse) : void 0, P;
    }
  };
  function d() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryUnbondingDelegationRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.validatorAddr !== "" && P.uint32(18).string(o.validatorAddr), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = d();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        validatorAddr: (0, f.isSet)(o.validatorAddr) ? String(o.validatorAddr) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.validatorAddr !== void 0 && (P.validatorAddr = o.validatorAddr), P;
    },
    fromPartial(o) {
      const P = d();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.validatorAddr = o.validatorAddr ?? "", P;
    }
  };
  function p() {
    return {
      unbond: void 0
    };
  }
  e.QueryUnbondingDelegationResponse = {
    encode(o, P = O.Writer.create()) {
      return o.unbond !== void 0 && u.UnbondingDelegation.encode(o.unbond, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = p();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.unbond = u.UnbondingDelegation.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        unbond: (0, f.isSet)(o.unbond) ? u.UnbondingDelegation.fromJSON(o.unbond) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.unbond !== void 0 && (P.unbond = o.unbond ? u.UnbondingDelegation.toJSON(o.unbond) : void 0), P;
    },
    fromPartial(o) {
      const P = p();
      return P.unbond = o.unbond !== void 0 && o.unbond !== null ? u.UnbondingDelegation.fromPartial(o.unbond) : void 0, P;
    }
  };
  function g() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = g();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = g();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function J() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.delegationResponses)
        u.DelegationResponse.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = J();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegationResponses.push(u.DelegationResponse.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegationResponses: Array.isArray(o == null ? void 0 : o.delegationResponses) ? o.delegationResponses.map((P) => u.DelegationResponse.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegationResponses ? P.delegationResponses = o.delegationResponses.map((m) => m ? u.DelegationResponse.toJSON(m) : void 0) : P.delegationResponses = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = J();
      return P.delegationResponses = ((m = o.delegationResponses) == null ? void 0 : m.map((R) => u.DelegationResponse.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function B() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = B();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = B();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function I() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.unbondingResponses)
        u.UnbondingDelegation.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = I();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.unbondingResponses.push(u.UnbondingDelegation.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        unbondingResponses: Array.isArray(o == null ? void 0 : o.unbondingResponses) ? o.unbondingResponses.map((P) => u.UnbondingDelegation.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.unbondingResponses ? P.unbondingResponses = o.unbondingResponses.map((m) => m ? u.UnbondingDelegation.toJSON(m) : void 0) : P.unbondingResponses = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = I();
      return P.unbondingResponses = ((m = o.unbondingResponses) == null ? void 0 : m.map((R) => u.UnbondingDelegation.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function Z() {
    return {
      delegatorAddr: "",
      srcValidatorAddr: "",
      dstValidatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryRedelegationsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.srcValidatorAddr !== "" && P.uint32(18).string(o.srcValidatorAddr), o.dstValidatorAddr !== "" && P.uint32(26).string(o.dstValidatorAddr), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(34).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = Z();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.srcValidatorAddr = m.string();
            break;
          case 3:
            N.dstValidatorAddr = m.string();
            break;
          case 4:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        srcValidatorAddr: (0, f.isSet)(o.srcValidatorAddr) ? String(o.srcValidatorAddr) : "",
        dstValidatorAddr: (0, f.isSet)(o.dstValidatorAddr) ? String(o.dstValidatorAddr) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.srcValidatorAddr !== void 0 && (P.srcValidatorAddr = o.srcValidatorAddr), o.dstValidatorAddr !== void 0 && (P.dstValidatorAddr = o.dstValidatorAddr), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = Z();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.srcValidatorAddr = o.srcValidatorAddr ?? "", P.dstValidatorAddr = o.dstValidatorAddr ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function t() {
    return {
      redelegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryRedelegationsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.redelegationResponses)
        u.RedelegationResponse.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = t();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.redelegationResponses.push(u.RedelegationResponse.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        redelegationResponses: Array.isArray(o == null ? void 0 : o.redelegationResponses) ? o.redelegationResponses.map((P) => u.RedelegationResponse.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.redelegationResponses ? P.redelegationResponses = o.redelegationResponses.map((m) => m ? u.RedelegationResponse.toJSON(m) : void 0) : P.redelegationResponses = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = t();
      return P.redelegationResponses = ((m = o.redelegationResponses) == null ? void 0 : m.map((R) => u.RedelegationResponse.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function y() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = y();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        pagination: (0, f.isSet)(o.pagination) ? r.PageRequest.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      const P = y();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageRequest.fromPartial(o.pagination) : void 0, P;
    }
  };
  function E() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    encode(o, P = O.Writer.create()) {
      for (const m of o.validators)
        u.Validator.encode(m, P.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = E();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validators.push(u.Validator.decode(m, m.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validators: Array.isArray(o == null ? void 0 : o.validators) ? o.validators.map((P) => u.Validator.fromJSON(P)) : [],
        pagination: (0, f.isSet)(o.pagination) ? r.PageResponse.fromJSON(o.pagination) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.validators ? P.validators = o.validators.map((m) => m ? u.Validator.toJSON(m) : void 0) : P.validators = [], o.pagination !== void 0 && (P.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), P;
    },
    fromPartial(o) {
      var m;
      const P = E();
      return P.validators = ((m = o.validators) == null ? void 0 : m.map((R) => u.Validator.fromPartial(R))) || [], P.pagination = o.pagination !== void 0 && o.pagination !== null ? r.PageResponse.fromPartial(o.pagination) : void 0, P;
    }
  };
  function H() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegatorValidatorRequest = {
    encode(o, P = O.Writer.create()) {
      return o.delegatorAddr !== "" && P.uint32(10).string(o.delegatorAddr), o.validatorAddr !== "" && P.uint32(18).string(o.validatorAddr), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = H();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.delegatorAddr = m.string();
            break;
          case 2:
            N.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        delegatorAddr: (0, f.isSet)(o.delegatorAddr) ? String(o.delegatorAddr) : "",
        validatorAddr: (0, f.isSet)(o.validatorAddr) ? String(o.validatorAddr) : ""
      };
    },
    toJSON(o) {
      const P = {};
      return o.delegatorAddr !== void 0 && (P.delegatorAddr = o.delegatorAddr), o.validatorAddr !== void 0 && (P.validatorAddr = o.validatorAddr), P;
    },
    fromPartial(o) {
      const P = H();
      return P.delegatorAddr = o.delegatorAddr ?? "", P.validatorAddr = o.validatorAddr ?? "", P;
    }
  };
  function a() {
    return {
      validator: void 0
    };
  }
  e.QueryDelegatorValidatorResponse = {
    encode(o, P = O.Writer.create()) {
      return o.validator !== void 0 && u.Validator.encode(o.validator, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = a();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.validator = u.Validator.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        validator: (0, f.isSet)(o.validator) ? u.Validator.fromJSON(o.validator) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.validator !== void 0 && (P.validator = o.validator ? u.Validator.toJSON(o.validator) : void 0), P;
    },
    fromPartial(o) {
      const P = a();
      return P.validator = o.validator !== void 0 && o.validator !== null ? u.Validator.fromPartial(o.validator) : void 0, P;
    }
  };
  function l() {
    return {
      height: f.Long.ZERO
    };
  }
  e.QueryHistoricalInfoRequest = {
    encode(o, P = O.Writer.create()) {
      return o.height.isZero() || P.uint32(8).int64(o.height), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = l();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.height = m.int64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        height: (0, f.isSet)(o.height) ? f.Long.fromValue(o.height) : f.Long.ZERO
      };
    },
    toJSON(o) {
      const P = {};
      return o.height !== void 0 && (P.height = (o.height || f.Long.ZERO).toString()), P;
    },
    fromPartial(o) {
      const P = l();
      return P.height = o.height !== void 0 && o.height !== null ? f.Long.fromValue(o.height) : f.Long.ZERO, P;
    }
  };
  function C() {
    return {
      hist: void 0
    };
  }
  e.QueryHistoricalInfoResponse = {
    encode(o, P = O.Writer.create()) {
      return o.hist !== void 0 && u.HistoricalInfo.encode(o.hist, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = C();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.hist = u.HistoricalInfo.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        hist: (0, f.isSet)(o.hist) ? u.HistoricalInfo.fromJSON(o.hist) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.hist !== void 0 && (P.hist = o.hist ? u.HistoricalInfo.toJSON(o.hist) : void 0), P;
    },
    fromPartial(o) {
      const P = C();
      return P.hist = o.hist !== void 0 && o.hist !== null ? u.HistoricalInfo.fromPartial(o.hist) : void 0, P;
    }
  };
  function v() {
    return {};
  }
  e.QueryPoolRequest = {
    encode(o, P = O.Writer.create()) {
      return P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = v();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {};
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return v();
    }
  };
  function k() {
    return {
      pool: void 0
    };
  }
  e.QueryPoolResponse = {
    encode(o, P = O.Writer.create()) {
      return o.pool !== void 0 && u.Pool.encode(o.pool, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = k();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.pool = u.Pool.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        pool: (0, f.isSet)(o.pool) ? u.Pool.fromJSON(o.pool) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.pool !== void 0 && (P.pool = o.pool ? u.Pool.toJSON(o.pool) : void 0), P;
    },
    fromPartial(o) {
      const P = k();
      return P.pool = o.pool !== void 0 && o.pool !== null ? u.Pool.fromPartial(o.pool) : void 0, P;
    }
  };
  function U() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(o, P = O.Writer.create()) {
      return P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = U();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {};
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return U();
    }
  };
  function F() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(o, P = O.Writer.create()) {
      return o.params !== void 0 && u.Params.encode(o.params, P.uint32(10).fork()).ldelim(), P;
    },
    decode(o, P) {
      const m = o instanceof O.Reader ? o : new O.Reader(o);
      let R = P === void 0 ? m.len : m.pos + P;
      const N = F();
      for (; m.pos < R; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            N.params = u.Params.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(o) {
      return {
        params: (0, f.isSet)(o.params) ? u.Params.fromJSON(o.params) : void 0
      };
    },
    toJSON(o) {
      const P = {};
      return o.params !== void 0 && (P.params = o.params ? u.Params.toJSON(o.params) : void 0), P;
    },
    fromPartial(o) {
      const P = F();
      return P.params = o.params !== void 0 && o.params !== null ? u.Params.fromPartial(o.params) : void 0, P;
    }
  };
  class q {
    constructor(P) {
      this.rpc = P, this.Validators = this.Validators.bind(this), this.Validator = this.Validator.bind(this), this.ValidatorDelegations = this.ValidatorDelegations.bind(this), this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this), this.Delegation = this.Delegation.bind(this), this.UnbondingDelegation = this.UnbondingDelegation.bind(this), this.DelegatorDelegations = this.DelegatorDelegations.bind(this), this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this), this.Redelegations = this.Redelegations.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorValidator = this.DelegatorValidator.bind(this), this.HistoricalInfo = this.HistoricalInfo.bind(this), this.Pool = this.Pool.bind(this), this.Params = this.Params.bind(this);
    }
    Validators(P) {
      const m = e.QueryValidatorsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", m).then((N) => e.QueryValidatorsResponse.decode(new O.Reader(N)));
    }
    Validator(P) {
      const m = e.QueryValidatorRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", m).then((N) => e.QueryValidatorResponse.decode(new O.Reader(N)));
    }
    ValidatorDelegations(P) {
      const m = e.QueryValidatorDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", m).then((N) => e.QueryValidatorDelegationsResponse.decode(new O.Reader(N)));
    }
    ValidatorUnbondingDelegations(P) {
      const m = e.QueryValidatorUnbondingDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", m).then((N) => e.QueryValidatorUnbondingDelegationsResponse.decode(new O.Reader(N)));
    }
    Delegation(P) {
      const m = e.QueryDelegationRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", m).then((N) => e.QueryDelegationResponse.decode(new O.Reader(N)));
    }
    UnbondingDelegation(P) {
      const m = e.QueryUnbondingDelegationRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", m).then((N) => e.QueryUnbondingDelegationResponse.decode(new O.Reader(N)));
    }
    DelegatorDelegations(P) {
      const m = e.QueryDelegatorDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", m).then((N) => e.QueryDelegatorDelegationsResponse.decode(new O.Reader(N)));
    }
    DelegatorUnbondingDelegations(P) {
      const m = e.QueryDelegatorUnbondingDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", m).then((N) => e.QueryDelegatorUnbondingDelegationsResponse.decode(new O.Reader(N)));
    }
    Redelegations(P) {
      const m = e.QueryRedelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", m).then((N) => e.QueryRedelegationsResponse.decode(new O.Reader(N)));
    }
    DelegatorValidators(P) {
      const m = e.QueryDelegatorValidatorsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", m).then((N) => e.QueryDelegatorValidatorsResponse.decode(new O.Reader(N)));
    }
    DelegatorValidator(P) {
      const m = e.QueryDelegatorValidatorRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", m).then((N) => e.QueryDelegatorValidatorResponse.decode(new O.Reader(N)));
    }
    HistoricalInfo(P) {
      const m = e.QueryHistoricalInfoRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", m).then((N) => e.QueryHistoricalInfoResponse.decode(new O.Reader(N)));
    }
    Pool(P = {}) {
      const m = e.QueryPoolRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", m).then((N) => e.QueryPoolResponse.decode(new O.Reader(N)));
    }
    Params(P = {}) {
      const m = e.QueryParamsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Params", m).then((N) => e.QueryParamsResponse.decode(new O.Reader(N)));
    }
  }
  e.QueryClientImpl = q;
})(Lu);
var Pm = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.setupStakingExtension = void 0;
const vm = Lu, km = Pm(An), bn = Le;
function Am(e) {
  const n = (0, bn.createProtobufRpcClient)(e), c = new vm.QueryClientImpl(n);
  return {
    staking: {
      delegation: async (i, r) => await c.Delegation({
        delegatorAddr: i,
        validatorAddr: r
      }),
      delegatorDelegations: async (i, r) => await c.DelegatorDelegations({
        delegatorAddr: i,
        pagination: (0, bn.createPagination)(r)
      }),
      delegatorUnbondingDelegations: async (i, r) => await c.DelegatorUnbondingDelegations({
        delegatorAddr: i,
        pagination: (0, bn.createPagination)(r)
      }),
      delegatorValidator: async (i, r) => await c.DelegatorValidator({
        delegatorAddr: i,
        validatorAddr: r
      }),
      delegatorValidators: async (i, r) => await c.DelegatorValidators({
        delegatorAddr: i,
        pagination: (0, bn.createPagination)(r)
      }),
      historicalInfo: async (i) => await c.HistoricalInfo({
        height: km.default.fromNumber(i, !0)
      }),
      params: async () => await c.Params({}),
      pool: async () => await c.Pool({}),
      redelegations: async (i, r, u, f) => await c.Redelegations({
        delegatorAddr: i,
        srcValidatorAddr: r,
        dstValidatorAddr: u,
        pagination: (0, bn.createPagination)(f)
      }),
      unbondingDelegation: async (i, r) => await c.UnbondingDelegation({
        delegatorAddr: i,
        validatorAddr: r
      }),
      validator: async (i) => await c.Validator({ validatorAddr: i }),
      validatorDelegations: async (i, r) => await c.ValidatorDelegations({
        validatorAddr: i,
        pagination: (0, bn.createPagination)(r)
      }),
      validators: async (i, r) => await c.Validators({
        status: i,
        pagination: (0, bn.createPagination)(r)
      }),
      validatorUnbondingDelegations: async (i, r) => await c.ValidatorUnbondingDelegations({
        validatorAddr: i,
        pagination: (0, bn.createPagination)(r)
      })
    }
  };
}
mi.setupStakingExtension = Am;
var gi = {}, Hu = {}, da = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(d, p, g, J) {
    J === void 0 && (J = g);
    var B = Object.getOwnPropertyDescriptor(p, g);
    (!B || ("get" in B ? !p.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return p[g];
    } }), Object.defineProperty(d, J, B);
  } : function(d, p, g, J) {
    J === void 0 && (J = g), d[J] = p[g];
  }), c = G && G.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), i = G && G.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var g in d)
        g !== "default" && Object.prototype.hasOwnProperty.call(d, g) && n(p, d, g);
    return c(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SearchTxsResult = e.TxMsgData = e.MsgData = e.SimulationResponse = e.Result = e.GasInfo = e.Attribute = e.StringEvent = e.ABCIMessageLog = e.TxResponse = e.protobufPackage = void 0;
  const r = Se, u = sa, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.base.abci.v1beta1";
  function A() {
    return {
      height: f.Long.ZERO,
      txhash: "",
      codespace: "",
      code: 0,
      data: "",
      rawLog: "",
      logs: [],
      info: "",
      gasWanted: f.Long.ZERO,
      gasUsed: f.Long.ZERO,
      tx: void 0,
      timestamp: "",
      events: []
    };
  }
  e.TxResponse = {
    encode(d, p = O.Writer.create()) {
      d.height.isZero() || p.uint32(8).int64(d.height), d.txhash !== "" && p.uint32(18).string(d.txhash), d.codespace !== "" && p.uint32(26).string(d.codespace), d.code !== 0 && p.uint32(32).uint32(d.code), d.data !== "" && p.uint32(42).string(d.data), d.rawLog !== "" && p.uint32(50).string(d.rawLog);
      for (const g of d.logs)
        e.ABCIMessageLog.encode(g, p.uint32(58).fork()).ldelim();
      d.info !== "" && p.uint32(66).string(d.info), d.gasWanted.isZero() || p.uint32(72).int64(d.gasWanted), d.gasUsed.isZero() || p.uint32(80).int64(d.gasUsed), d.tx !== void 0 && r.Any.encode(d.tx, p.uint32(90).fork()).ldelim(), d.timestamp !== "" && p.uint32(98).string(d.timestamp);
      for (const g of d.events)
        u.Event.encode(g, p.uint32(106).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = A();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.height = g.int64();
            break;
          case 2:
            B.txhash = g.string();
            break;
          case 3:
            B.codespace = g.string();
            break;
          case 4:
            B.code = g.uint32();
            break;
          case 5:
            B.data = g.string();
            break;
          case 6:
            B.rawLog = g.string();
            break;
          case 7:
            B.logs.push(e.ABCIMessageLog.decode(g, g.uint32()));
            break;
          case 8:
            B.info = g.string();
            break;
          case 9:
            B.gasWanted = g.int64();
            break;
          case 10:
            B.gasUsed = g.int64();
            break;
          case 11:
            B.tx = r.Any.decode(g, g.uint32());
            break;
          case 12:
            B.timestamp = g.string();
            break;
          case 13:
            B.events.push(u.Event.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        height: (0, f.isSet)(d.height) ? f.Long.fromValue(d.height) : f.Long.ZERO,
        txhash: (0, f.isSet)(d.txhash) ? String(d.txhash) : "",
        codespace: (0, f.isSet)(d.codespace) ? String(d.codespace) : "",
        code: (0, f.isSet)(d.code) ? Number(d.code) : 0,
        data: (0, f.isSet)(d.data) ? String(d.data) : "",
        rawLog: (0, f.isSet)(d.rawLog) ? String(d.rawLog) : "",
        logs: Array.isArray(d == null ? void 0 : d.logs) ? d.logs.map((p) => e.ABCIMessageLog.fromJSON(p)) : [],
        info: (0, f.isSet)(d.info) ? String(d.info) : "",
        gasWanted: (0, f.isSet)(d.gasWanted) ? f.Long.fromValue(d.gasWanted) : f.Long.ZERO,
        gasUsed: (0, f.isSet)(d.gasUsed) ? f.Long.fromValue(d.gasUsed) : f.Long.ZERO,
        tx: (0, f.isSet)(d.tx) ? r.Any.fromJSON(d.tx) : void 0,
        timestamp: (0, f.isSet)(d.timestamp) ? String(d.timestamp) : "",
        events: Array.isArray(d == null ? void 0 : d.events) ? d.events.map((p) => u.Event.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.height !== void 0 && (p.height = (d.height || f.Long.ZERO).toString()), d.txhash !== void 0 && (p.txhash = d.txhash), d.codespace !== void 0 && (p.codespace = d.codespace), d.code !== void 0 && (p.code = Math.round(d.code)), d.data !== void 0 && (p.data = d.data), d.rawLog !== void 0 && (p.rawLog = d.rawLog), d.logs ? p.logs = d.logs.map((g) => g ? e.ABCIMessageLog.toJSON(g) : void 0) : p.logs = [], d.info !== void 0 && (p.info = d.info), d.gasWanted !== void 0 && (p.gasWanted = (d.gasWanted || f.Long.ZERO).toString()), d.gasUsed !== void 0 && (p.gasUsed = (d.gasUsed || f.Long.ZERO).toString()), d.tx !== void 0 && (p.tx = d.tx ? r.Any.toJSON(d.tx) : void 0), d.timestamp !== void 0 && (p.timestamp = d.timestamp), d.events ? p.events = d.events.map((g) => g ? u.Event.toJSON(g) : void 0) : p.events = [], p;
    },
    fromPartial(d) {
      var g, J;
      const p = A();
      return p.height = d.height !== void 0 && d.height !== null ? f.Long.fromValue(d.height) : f.Long.ZERO, p.txhash = d.txhash ?? "", p.codespace = d.codespace ?? "", p.code = d.code ?? 0, p.data = d.data ?? "", p.rawLog = d.rawLog ?? "", p.logs = ((g = d.logs) == null ? void 0 : g.map((B) => e.ABCIMessageLog.fromPartial(B))) || [], p.info = d.info ?? "", p.gasWanted = d.gasWanted !== void 0 && d.gasWanted !== null ? f.Long.fromValue(d.gasWanted) : f.Long.ZERO, p.gasUsed = d.gasUsed !== void 0 && d.gasUsed !== null ? f.Long.fromValue(d.gasUsed) : f.Long.ZERO, p.tx = d.tx !== void 0 && d.tx !== null ? r.Any.fromPartial(d.tx) : void 0, p.timestamp = d.timestamp ?? "", p.events = ((J = d.events) == null ? void 0 : J.map((B) => u.Event.fromPartial(B))) || [], p;
    }
  };
  function T() {
    return {
      msgIndex: 0,
      log: "",
      events: []
    };
  }
  e.ABCIMessageLog = {
    encode(d, p = O.Writer.create()) {
      d.msgIndex !== 0 && p.uint32(8).uint32(d.msgIndex), d.log !== "" && p.uint32(18).string(d.log);
      for (const g of d.events)
        e.StringEvent.encode(g, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = T();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.msgIndex = g.uint32();
            break;
          case 2:
            B.log = g.string();
            break;
          case 3:
            B.events.push(e.StringEvent.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        msgIndex: (0, f.isSet)(d.msgIndex) ? Number(d.msgIndex) : 0,
        log: (0, f.isSet)(d.log) ? String(d.log) : "",
        events: Array.isArray(d == null ? void 0 : d.events) ? d.events.map((p) => e.StringEvent.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.msgIndex !== void 0 && (p.msgIndex = Math.round(d.msgIndex)), d.log !== void 0 && (p.log = d.log), d.events ? p.events = d.events.map((g) => g ? e.StringEvent.toJSON(g) : void 0) : p.events = [], p;
    },
    fromPartial(d) {
      var g;
      const p = T();
      return p.msgIndex = d.msgIndex ?? 0, p.log = d.log ?? "", p.events = ((g = d.events) == null ? void 0 : g.map((J) => e.StringEvent.fromPartial(J))) || [], p;
    }
  };
  function L() {
    return {
      type: "",
      attributes: []
    };
  }
  e.StringEvent = {
    encode(d, p = O.Writer.create()) {
      d.type !== "" && p.uint32(10).string(d.type);
      for (const g of d.attributes)
        e.Attribute.encode(g, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = L();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.type = g.string();
            break;
          case 2:
            B.attributes.push(e.Attribute.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        type: (0, f.isSet)(d.type) ? String(d.type) : "",
        attributes: Array.isArray(d == null ? void 0 : d.attributes) ? d.attributes.map((p) => e.Attribute.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.type !== void 0 && (p.type = d.type), d.attributes ? p.attributes = d.attributes.map((g) => g ? e.Attribute.toJSON(g) : void 0) : p.attributes = [], p;
    },
    fromPartial(d) {
      var g;
      const p = L();
      return p.type = d.type ?? "", p.attributes = ((g = d.attributes) == null ? void 0 : g.map((J) => e.Attribute.fromPartial(J))) || [], p;
    }
  };
  function M() {
    return {
      key: "",
      value: ""
    };
  }
  e.Attribute = {
    encode(d, p = O.Writer.create()) {
      return d.key !== "" && p.uint32(10).string(d.key), d.value !== "" && p.uint32(18).string(d.value), p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = M();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.key = g.string();
            break;
          case 2:
            B.value = g.string();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        key: (0, f.isSet)(d.key) ? String(d.key) : "",
        value: (0, f.isSet)(d.value) ? String(d.value) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.key !== void 0 && (p.key = d.key), d.value !== void 0 && (p.value = d.value), p;
    },
    fromPartial(d) {
      const p = M();
      return p.key = d.key ?? "", p.value = d.value ?? "", p;
    }
  };
  function V() {
    return {
      gasWanted: f.Long.UZERO,
      gasUsed: f.Long.UZERO
    };
  }
  e.GasInfo = {
    encode(d, p = O.Writer.create()) {
      return d.gasWanted.isZero() || p.uint32(8).uint64(d.gasWanted), d.gasUsed.isZero() || p.uint32(16).uint64(d.gasUsed), p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = V();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.gasWanted = g.uint64();
            break;
          case 2:
            B.gasUsed = g.uint64();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        gasWanted: (0, f.isSet)(d.gasWanted) ? f.Long.fromValue(d.gasWanted) : f.Long.UZERO,
        gasUsed: (0, f.isSet)(d.gasUsed) ? f.Long.fromValue(d.gasUsed) : f.Long.UZERO
      };
    },
    toJSON(d) {
      const p = {};
      return d.gasWanted !== void 0 && (p.gasWanted = (d.gasWanted || f.Long.UZERO).toString()), d.gasUsed !== void 0 && (p.gasUsed = (d.gasUsed || f.Long.UZERO).toString()), p;
    },
    fromPartial(d) {
      const p = V();
      return p.gasWanted = d.gasWanted !== void 0 && d.gasWanted !== null ? f.Long.fromValue(d.gasWanted) : f.Long.UZERO, p.gasUsed = d.gasUsed !== void 0 && d.gasUsed !== null ? f.Long.fromValue(d.gasUsed) : f.Long.UZERO, p;
    }
  };
  function D() {
    return {
      data: new Uint8Array(),
      log: "",
      events: [],
      msgResponses: []
    };
  }
  e.Result = {
    encode(d, p = O.Writer.create()) {
      d.data.length !== 0 && p.uint32(10).bytes(d.data), d.log !== "" && p.uint32(18).string(d.log);
      for (const g of d.events)
        u.Event.encode(g, p.uint32(26).fork()).ldelim();
      for (const g of d.msgResponses)
        r.Any.encode(g, p.uint32(34).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = D();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.data = g.bytes();
            break;
          case 2:
            B.log = g.string();
            break;
          case 3:
            B.events.push(u.Event.decode(g, g.uint32()));
            break;
          case 4:
            B.msgResponses.push(r.Any.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        data: (0, f.isSet)(d.data) ? (0, f.bytesFromBase64)(d.data) : new Uint8Array(),
        log: (0, f.isSet)(d.log) ? String(d.log) : "",
        events: Array.isArray(d == null ? void 0 : d.events) ? d.events.map((p) => u.Event.fromJSON(p)) : [],
        msgResponses: Array.isArray(d == null ? void 0 : d.msgResponses) ? d.msgResponses.map((p) => r.Any.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.data !== void 0 && (p.data = (0, f.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), d.log !== void 0 && (p.log = d.log), d.events ? p.events = d.events.map((g) => g ? u.Event.toJSON(g) : void 0) : p.events = [], d.msgResponses ? p.msgResponses = d.msgResponses.map((g) => g ? r.Any.toJSON(g) : void 0) : p.msgResponses = [], p;
    },
    fromPartial(d) {
      var g, J;
      const p = D();
      return p.data = d.data ?? new Uint8Array(), p.log = d.log ?? "", p.events = ((g = d.events) == null ? void 0 : g.map((B) => u.Event.fromPartial(B))) || [], p.msgResponses = ((J = d.msgResponses) == null ? void 0 : J.map((B) => r.Any.fromPartial(B))) || [], p;
    }
  };
  function b() {
    return {
      gasInfo: void 0,
      result: void 0
    };
  }
  e.SimulationResponse = {
    encode(d, p = O.Writer.create()) {
      return d.gasInfo !== void 0 && e.GasInfo.encode(d.gasInfo, p.uint32(10).fork()).ldelim(), d.result !== void 0 && e.Result.encode(d.result, p.uint32(18).fork()).ldelim(), p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = b();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.gasInfo = e.GasInfo.decode(g, g.uint32());
            break;
          case 2:
            B.result = e.Result.decode(g, g.uint32());
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        gasInfo: (0, f.isSet)(d.gasInfo) ? e.GasInfo.fromJSON(d.gasInfo) : void 0,
        result: (0, f.isSet)(d.result) ? e.Result.fromJSON(d.result) : void 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.gasInfo !== void 0 && (p.gasInfo = d.gasInfo ? e.GasInfo.toJSON(d.gasInfo) : void 0), d.result !== void 0 && (p.result = d.result ? e.Result.toJSON(d.result) : void 0), p;
    },
    fromPartial(d) {
      const p = b();
      return p.gasInfo = d.gasInfo !== void 0 && d.gasInfo !== null ? e.GasInfo.fromPartial(d.gasInfo) : void 0, p.result = d.result !== void 0 && d.result !== null ? e.Result.fromPartial(d.result) : void 0, p;
    }
  };
  function h() {
    return {
      msgType: "",
      data: new Uint8Array()
    };
  }
  e.MsgData = {
    encode(d, p = O.Writer.create()) {
      return d.msgType !== "" && p.uint32(10).string(d.msgType), d.data.length !== 0 && p.uint32(18).bytes(d.data), p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = h();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.msgType = g.string();
            break;
          case 2:
            B.data = g.bytes();
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        msgType: (0, f.isSet)(d.msgType) ? String(d.msgType) : "",
        data: (0, f.isSet)(d.data) ? (0, f.bytesFromBase64)(d.data) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.msgType !== void 0 && (p.msgType = d.msgType), d.data !== void 0 && (p.data = (0, f.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), p;
    },
    fromPartial(d) {
      const p = h();
      return p.msgType = d.msgType ?? "", p.data = d.data ?? new Uint8Array(), p;
    }
  };
  function S() {
    return {
      data: [],
      msgResponses: []
    };
  }
  e.TxMsgData = {
    encode(d, p = O.Writer.create()) {
      for (const g of d.data)
        e.MsgData.encode(g, p.uint32(10).fork()).ldelim();
      for (const g of d.msgResponses)
        r.Any.encode(g, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = S();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.data.push(e.MsgData.decode(g, g.uint32()));
            break;
          case 2:
            B.msgResponses.push(r.Any.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        data: Array.isArray(d == null ? void 0 : d.data) ? d.data.map((p) => e.MsgData.fromJSON(p)) : [],
        msgResponses: Array.isArray(d == null ? void 0 : d.msgResponses) ? d.msgResponses.map((p) => r.Any.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.data ? p.data = d.data.map((g) => g ? e.MsgData.toJSON(g) : void 0) : p.data = [], d.msgResponses ? p.msgResponses = d.msgResponses.map((g) => g ? r.Any.toJSON(g) : void 0) : p.msgResponses = [], p;
    },
    fromPartial(d) {
      var g, J;
      const p = S();
      return p.data = ((g = d.data) == null ? void 0 : g.map((B) => e.MsgData.fromPartial(B))) || [], p.msgResponses = ((J = d.msgResponses) == null ? void 0 : J.map((B) => r.Any.fromPartial(B))) || [], p;
    }
  };
  function _() {
    return {
      totalCount: f.Long.UZERO,
      count: f.Long.UZERO,
      pageNumber: f.Long.UZERO,
      pageTotal: f.Long.UZERO,
      limit: f.Long.UZERO,
      txs: []
    };
  }
  e.SearchTxsResult = {
    encode(d, p = O.Writer.create()) {
      d.totalCount.isZero() || p.uint32(8).uint64(d.totalCount), d.count.isZero() || p.uint32(16).uint64(d.count), d.pageNumber.isZero() || p.uint32(24).uint64(d.pageNumber), d.pageTotal.isZero() || p.uint32(32).uint64(d.pageTotal), d.limit.isZero() || p.uint32(40).uint64(d.limit);
      for (const g of d.txs)
        e.TxResponse.encode(g, p.uint32(50).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const g = d instanceof O.Reader ? d : new O.Reader(d);
      let J = p === void 0 ? g.len : g.pos + p;
      const B = _();
      for (; g.pos < J; ) {
        const I = g.uint32();
        switch (I >>> 3) {
          case 1:
            B.totalCount = g.uint64();
            break;
          case 2:
            B.count = g.uint64();
            break;
          case 3:
            B.pageNumber = g.uint64();
            break;
          case 4:
            B.pageTotal = g.uint64();
            break;
          case 5:
            B.limit = g.uint64();
            break;
          case 6:
            B.txs.push(e.TxResponse.decode(g, g.uint32()));
            break;
          default:
            g.skipType(I & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(d) {
      return {
        totalCount: (0, f.isSet)(d.totalCount) ? f.Long.fromValue(d.totalCount) : f.Long.UZERO,
        count: (0, f.isSet)(d.count) ? f.Long.fromValue(d.count) : f.Long.UZERO,
        pageNumber: (0, f.isSet)(d.pageNumber) ? f.Long.fromValue(d.pageNumber) : f.Long.UZERO,
        pageTotal: (0, f.isSet)(d.pageTotal) ? f.Long.fromValue(d.pageTotal) : f.Long.UZERO,
        limit: (0, f.isSet)(d.limit) ? f.Long.fromValue(d.limit) : f.Long.UZERO,
        txs: Array.isArray(d == null ? void 0 : d.txs) ? d.txs.map((p) => e.TxResponse.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.totalCount !== void 0 && (p.totalCount = (d.totalCount || f.Long.UZERO).toString()), d.count !== void 0 && (p.count = (d.count || f.Long.UZERO).toString()), d.pageNumber !== void 0 && (p.pageNumber = (d.pageNumber || f.Long.UZERO).toString()), d.pageTotal !== void 0 && (p.pageTotal = (d.pageTotal || f.Long.UZERO).toString()), d.limit !== void 0 && (p.limit = (d.limit || f.Long.UZERO).toString()), d.txs ? p.txs = d.txs.map((g) => g ? e.TxResponse.toJSON(g) : void 0) : p.txs = [], p;
    },
    fromPartial(d) {
      var g;
      const p = _();
      return p.totalCount = d.totalCount !== void 0 && d.totalCount !== null ? f.Long.fromValue(d.totalCount) : f.Long.UZERO, p.count = d.count !== void 0 && d.count !== null ? f.Long.fromValue(d.count) : f.Long.UZERO, p.pageNumber = d.pageNumber !== void 0 && d.pageNumber !== null ? f.Long.fromValue(d.pageNumber) : f.Long.UZERO, p.pageTotal = d.pageTotal !== void 0 && d.pageTotal !== null ? f.Long.fromValue(d.pageTotal) : f.Long.UZERO, p.limit = d.limit !== void 0 && d.limit !== null ? f.Long.fromValue(d.limit) : f.Long.UZERO, p.txs = ((g = d.txs) == null ? void 0 : g.map((J) => e.TxResponse.fromPartial(J))) || [], p;
    }
  };
})(da);
var Bt = {}, qu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(D, b, h, S) {
    S === void 0 && (S = h);
    var _ = Object.getOwnPropertyDescriptor(b, h);
    (!_ || ("get" in _ ? !b.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return b[h];
    } }), Object.defineProperty(D, S, _);
  } : function(D, b, h, S) {
    S === void 0 && (S = h), D[S] = b[h];
  }), c = G && G.__setModuleDefault || (Object.create ? function(D, b) {
    Object.defineProperty(D, "default", { enumerable: !0, value: b });
  } : function(D, b) {
    D.default = b;
  }), i = G && G.__importStar || function(D) {
    if (D && D.__esModule)
      return D;
    var b = {};
    if (D != null)
      for (var h in D)
        h !== "default" && Object.prototype.hasOwnProperty.call(D, h) && n(b, D, h);
    return c(b, D), b;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.EvidenceList = e.LightClientAttackEvidence = e.DuplicateVoteEvidence = e.Evidence = e.protobufPackage = void 0;
  const r = rt, u = _e, f = fi, O = oe, A = i(ie);
  e.protobufPackage = "tendermint.types";
  function T() {
    return {
      duplicateVoteEvidence: void 0,
      lightClientAttackEvidence: void 0
    };
  }
  e.Evidence = {
    encode(D, b = A.Writer.create()) {
      return D.duplicateVoteEvidence !== void 0 && e.DuplicateVoteEvidence.encode(D.duplicateVoteEvidence, b.uint32(10).fork()).ldelim(), D.lightClientAttackEvidence !== void 0 && e.LightClientAttackEvidence.encode(D.lightClientAttackEvidence, b.uint32(18).fork()).ldelim(), b;
    },
    decode(D, b) {
      const h = D instanceof A.Reader ? D : new A.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = T();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.duplicateVoteEvidence = e.DuplicateVoteEvidence.decode(h, h.uint32());
            break;
          case 2:
            _.lightClientAttackEvidence = e.LightClientAttackEvidence.decode(h, h.uint32());
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        duplicateVoteEvidence: (0, O.isSet)(D.duplicateVoteEvidence) ? e.DuplicateVoteEvidence.fromJSON(D.duplicateVoteEvidence) : void 0,
        lightClientAttackEvidence: (0, O.isSet)(D.lightClientAttackEvidence) ? e.LightClientAttackEvidence.fromJSON(D.lightClientAttackEvidence) : void 0
      };
    },
    toJSON(D) {
      const b = {};
      return D.duplicateVoteEvidence !== void 0 && (b.duplicateVoteEvidence = D.duplicateVoteEvidence ? e.DuplicateVoteEvidence.toJSON(D.duplicateVoteEvidence) : void 0), D.lightClientAttackEvidence !== void 0 && (b.lightClientAttackEvidence = D.lightClientAttackEvidence ? e.LightClientAttackEvidence.toJSON(D.lightClientAttackEvidence) : void 0), b;
    },
    fromPartial(D) {
      const b = T();
      return b.duplicateVoteEvidence = D.duplicateVoteEvidence !== void 0 && D.duplicateVoteEvidence !== null ? e.DuplicateVoteEvidence.fromPartial(D.duplicateVoteEvidence) : void 0, b.lightClientAttackEvidence = D.lightClientAttackEvidence !== void 0 && D.lightClientAttackEvidence !== null ? e.LightClientAttackEvidence.fromPartial(D.lightClientAttackEvidence) : void 0, b;
    }
  };
  function L() {
    return {
      voteA: void 0,
      voteB: void 0,
      totalVotingPower: O.Long.ZERO,
      validatorPower: O.Long.ZERO,
      timestamp: void 0
    };
  }
  e.DuplicateVoteEvidence = {
    encode(D, b = A.Writer.create()) {
      return D.voteA !== void 0 && r.Vote.encode(D.voteA, b.uint32(10).fork()).ldelim(), D.voteB !== void 0 && r.Vote.encode(D.voteB, b.uint32(18).fork()).ldelim(), D.totalVotingPower.isZero() || b.uint32(24).int64(D.totalVotingPower), D.validatorPower.isZero() || b.uint32(32).int64(D.validatorPower), D.timestamp !== void 0 && u.Timestamp.encode(D.timestamp, b.uint32(42).fork()).ldelim(), b;
    },
    decode(D, b) {
      const h = D instanceof A.Reader ? D : new A.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = L();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.voteA = r.Vote.decode(h, h.uint32());
            break;
          case 2:
            _.voteB = r.Vote.decode(h, h.uint32());
            break;
          case 3:
            _.totalVotingPower = h.int64();
            break;
          case 4:
            _.validatorPower = h.int64();
            break;
          case 5:
            _.timestamp = u.Timestamp.decode(h, h.uint32());
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        voteA: (0, O.isSet)(D.voteA) ? r.Vote.fromJSON(D.voteA) : void 0,
        voteB: (0, O.isSet)(D.voteB) ? r.Vote.fromJSON(D.voteB) : void 0,
        totalVotingPower: (0, O.isSet)(D.totalVotingPower) ? O.Long.fromValue(D.totalVotingPower) : O.Long.ZERO,
        validatorPower: (0, O.isSet)(D.validatorPower) ? O.Long.fromValue(D.validatorPower) : O.Long.ZERO,
        timestamp: (0, O.isSet)(D.timestamp) ? (0, O.fromJsonTimestamp)(D.timestamp) : void 0
      };
    },
    toJSON(D) {
      const b = {};
      return D.voteA !== void 0 && (b.voteA = D.voteA ? r.Vote.toJSON(D.voteA) : void 0), D.voteB !== void 0 && (b.voteB = D.voteB ? r.Vote.toJSON(D.voteB) : void 0), D.totalVotingPower !== void 0 && (b.totalVotingPower = (D.totalVotingPower || O.Long.ZERO).toString()), D.validatorPower !== void 0 && (b.validatorPower = (D.validatorPower || O.Long.ZERO).toString()), D.timestamp !== void 0 && (b.timestamp = (0, O.fromTimestamp)(D.timestamp).toISOString()), b;
    },
    fromPartial(D) {
      const b = L();
      return b.voteA = D.voteA !== void 0 && D.voteA !== null ? r.Vote.fromPartial(D.voteA) : void 0, b.voteB = D.voteB !== void 0 && D.voteB !== null ? r.Vote.fromPartial(D.voteB) : void 0, b.totalVotingPower = D.totalVotingPower !== void 0 && D.totalVotingPower !== null ? O.Long.fromValue(D.totalVotingPower) : O.Long.ZERO, b.validatorPower = D.validatorPower !== void 0 && D.validatorPower !== null ? O.Long.fromValue(D.validatorPower) : O.Long.ZERO, b.timestamp = D.timestamp !== void 0 && D.timestamp !== null ? u.Timestamp.fromPartial(D.timestamp) : void 0, b;
    }
  };
  function M() {
    return {
      conflictingBlock: void 0,
      commonHeight: O.Long.ZERO,
      byzantineValidators: [],
      totalVotingPower: O.Long.ZERO,
      timestamp: void 0
    };
  }
  e.LightClientAttackEvidence = {
    encode(D, b = A.Writer.create()) {
      D.conflictingBlock !== void 0 && r.LightBlock.encode(D.conflictingBlock, b.uint32(10).fork()).ldelim(), D.commonHeight.isZero() || b.uint32(16).int64(D.commonHeight);
      for (const h of D.byzantineValidators)
        f.Validator.encode(h, b.uint32(26).fork()).ldelim();
      return D.totalVotingPower.isZero() || b.uint32(32).int64(D.totalVotingPower), D.timestamp !== void 0 && u.Timestamp.encode(D.timestamp, b.uint32(42).fork()).ldelim(), b;
    },
    decode(D, b) {
      const h = D instanceof A.Reader ? D : new A.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = M();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.conflictingBlock = r.LightBlock.decode(h, h.uint32());
            break;
          case 2:
            _.commonHeight = h.int64();
            break;
          case 3:
            _.byzantineValidators.push(f.Validator.decode(h, h.uint32()));
            break;
          case 4:
            _.totalVotingPower = h.int64();
            break;
          case 5:
            _.timestamp = u.Timestamp.decode(h, h.uint32());
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        conflictingBlock: (0, O.isSet)(D.conflictingBlock) ? r.LightBlock.fromJSON(D.conflictingBlock) : void 0,
        commonHeight: (0, O.isSet)(D.commonHeight) ? O.Long.fromValue(D.commonHeight) : O.Long.ZERO,
        byzantineValidators: Array.isArray(D == null ? void 0 : D.byzantineValidators) ? D.byzantineValidators.map((b) => f.Validator.fromJSON(b)) : [],
        totalVotingPower: (0, O.isSet)(D.totalVotingPower) ? O.Long.fromValue(D.totalVotingPower) : O.Long.ZERO,
        timestamp: (0, O.isSet)(D.timestamp) ? (0, O.fromJsonTimestamp)(D.timestamp) : void 0
      };
    },
    toJSON(D) {
      const b = {};
      return D.conflictingBlock !== void 0 && (b.conflictingBlock = D.conflictingBlock ? r.LightBlock.toJSON(D.conflictingBlock) : void 0), D.commonHeight !== void 0 && (b.commonHeight = (D.commonHeight || O.Long.ZERO).toString()), D.byzantineValidators ? b.byzantineValidators = D.byzantineValidators.map((h) => h ? f.Validator.toJSON(h) : void 0) : b.byzantineValidators = [], D.totalVotingPower !== void 0 && (b.totalVotingPower = (D.totalVotingPower || O.Long.ZERO).toString()), D.timestamp !== void 0 && (b.timestamp = (0, O.fromTimestamp)(D.timestamp).toISOString()), b;
    },
    fromPartial(D) {
      var h;
      const b = M();
      return b.conflictingBlock = D.conflictingBlock !== void 0 && D.conflictingBlock !== null ? r.LightBlock.fromPartial(D.conflictingBlock) : void 0, b.commonHeight = D.commonHeight !== void 0 && D.commonHeight !== null ? O.Long.fromValue(D.commonHeight) : O.Long.ZERO, b.byzantineValidators = ((h = D.byzantineValidators) == null ? void 0 : h.map((S) => f.Validator.fromPartial(S))) || [], b.totalVotingPower = D.totalVotingPower !== void 0 && D.totalVotingPower !== null ? O.Long.fromValue(D.totalVotingPower) : O.Long.ZERO, b.timestamp = D.timestamp !== void 0 && D.timestamp !== null ? u.Timestamp.fromPartial(D.timestamp) : void 0, b;
    }
  };
  function V() {
    return {
      evidence: []
    };
  }
  e.EvidenceList = {
    encode(D, b = A.Writer.create()) {
      for (const h of D.evidence)
        e.Evidence.encode(h, b.uint32(10).fork()).ldelim();
      return b;
    },
    decode(D, b) {
      const h = D instanceof A.Reader ? D : new A.Reader(D);
      let S = b === void 0 ? h.len : h.pos + b;
      const _ = V();
      for (; h.pos < S; ) {
        const d = h.uint32();
        switch (d >>> 3) {
          case 1:
            _.evidence.push(e.Evidence.decode(h, h.uint32()));
            break;
          default:
            h.skipType(d & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(D) {
      return {
        evidence: Array.isArray(D == null ? void 0 : D.evidence) ? D.evidence.map((b) => e.Evidence.fromJSON(b)) : []
      };
    },
    toJSON(D) {
      const b = {};
      return D.evidence ? b.evidence = D.evidence.map((h) => h ? e.Evidence.toJSON(h) : void 0) : b.evidence = [], b;
    },
    fromPartial(D) {
      var h;
      const b = V();
      return b.evidence = ((h = D.evidence) == null ? void 0 : h.map((S) => e.Evidence.fromPartial(S))) || [], b;
    }
  };
})(qu);
var _m = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), Nm = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Tm = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && _m(n, e, c);
  return Nm(n, e), n;
};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.Block = Bt.protobufPackage = void 0;
const Je = rt, $t = qu, ao = Tm(ie), Rr = oe;
Bt.protobufPackage = "tendermint.types";
function zs() {
  return {
    header: void 0,
    data: void 0,
    evidence: void 0,
    lastCommit: void 0
  };
}
Bt.Block = {
  encode(e, n = ao.Writer.create()) {
    return e.header !== void 0 && Je.Header.encode(e.header, n.uint32(10).fork()).ldelim(), e.data !== void 0 && Je.Data.encode(e.data, n.uint32(18).fork()).ldelim(), e.evidence !== void 0 && $t.EvidenceList.encode(e.evidence, n.uint32(26).fork()).ldelim(), e.lastCommit !== void 0 && Je.Commit.encode(e.lastCommit, n.uint32(34).fork()).ldelim(), n;
  },
  decode(e, n) {
    const c = e instanceof ao.Reader ? e : new ao.Reader(e);
    let i = n === void 0 ? c.len : c.pos + n;
    const r = zs();
    for (; c.pos < i; ) {
      const u = c.uint32();
      switch (u >>> 3) {
        case 1:
          r.header = Je.Header.decode(c, c.uint32());
          break;
        case 2:
          r.data = Je.Data.decode(c, c.uint32());
          break;
        case 3:
          r.evidence = $t.EvidenceList.decode(c, c.uint32());
          break;
        case 4:
          r.lastCommit = Je.Commit.decode(c, c.uint32());
          break;
        default:
          c.skipType(u & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      header: (0, Rr.isSet)(e.header) ? Je.Header.fromJSON(e.header) : void 0,
      data: (0, Rr.isSet)(e.data) ? Je.Data.fromJSON(e.data) : void 0,
      evidence: (0, Rr.isSet)(e.evidence) ? $t.EvidenceList.fromJSON(e.evidence) : void 0,
      lastCommit: (0, Rr.isSet)(e.lastCommit) ? Je.Commit.fromJSON(e.lastCommit) : void 0
    };
  },
  toJSON(e) {
    const n = {};
    return e.header !== void 0 && (n.header = e.header ? Je.Header.toJSON(e.header) : void 0), e.data !== void 0 && (n.data = e.data ? Je.Data.toJSON(e.data) : void 0), e.evidence !== void 0 && (n.evidence = e.evidence ? $t.EvidenceList.toJSON(e.evidence) : void 0), e.lastCommit !== void 0 && (n.lastCommit = e.lastCommit ? Je.Commit.toJSON(e.lastCommit) : void 0), n;
  },
  fromPartial(e) {
    const n = zs();
    return n.header = e.header !== void 0 && e.header !== null ? Je.Header.fromPartial(e.header) : void 0, n.data = e.data !== void 0 && e.data !== null ? Je.Data.fromPartial(e.data) : void 0, n.evidence = e.evidence !== void 0 && e.evidence !== null ? $t.EvidenceList.fromPartial(e.evidence) : void 0, n.lastCommit = e.lastCommit !== void 0 && e.lastCommit !== null ? Je.Commit.fromPartial(e.lastCommit) : void 0, n;
  }
};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(q, o, P, m) {
    m === void 0 && (m = P);
    var R = Object.getOwnPropertyDescriptor(o, P);
    (!R || ("get" in R ? !o.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return o[P];
    } }), Object.defineProperty(q, m, R);
  } : function(q, o, P, m) {
    m === void 0 && (m = P), q[m] = o[P];
  }), c = G && G.__setModuleDefault || (Object.create ? function(q, o) {
    Object.defineProperty(q, "default", { enumerable: !0, value: o });
  } : function(q, o) {
    q.default = o;
  }), i = G && G.__importStar || function(q) {
    if (q && q.__esModule)
      return q;
    var o = {};
    if (q != null)
      for (var P in q)
        P !== "default" && Object.prototype.hasOwnProperty.call(q, P) && n(o, q, P);
    return c(o, q), o;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ServiceClientImpl = e.TxDecodeAminoResponse = e.TxDecodeAminoRequest = e.TxEncodeAminoResponse = e.TxEncodeAminoRequest = e.TxEncodeResponse = e.TxEncodeRequest = e.TxDecodeResponse = e.TxDecodeRequest = e.GetBlockWithTxsResponse = e.GetBlockWithTxsRequest = e.GetTxResponse = e.GetTxRequest = e.SimulateResponse = e.SimulateRequest = e.BroadcastTxResponse = e.BroadcastTxRequest = e.GetTxsEventResponse = e.GetTxsEventRequest = e.broadcastModeToJSON = e.broadcastModeFromJSON = e.BroadcastMode = e.orderByToJSON = e.orderByFromJSON = e.OrderBy = e.protobufPackage = void 0;
  const r = er, u = Re, f = da, O = rt, A = Bt, T = oe, L = i(ie);
  e.protobufPackage = "cosmos.tx.v1beta1";
  var M;
  (function(q) {
    q[q.ORDER_BY_UNSPECIFIED = 0] = "ORDER_BY_UNSPECIFIED", q[q.ORDER_BY_ASC = 1] = "ORDER_BY_ASC", q[q.ORDER_BY_DESC = 2] = "ORDER_BY_DESC", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = e.OrderBy || (e.OrderBy = {}));
  function V(q) {
    switch (q) {
      case 0:
      case "ORDER_BY_UNSPECIFIED":
        return M.ORDER_BY_UNSPECIFIED;
      case 1:
      case "ORDER_BY_ASC":
        return M.ORDER_BY_ASC;
      case 2:
      case "ORDER_BY_DESC":
        return M.ORDER_BY_DESC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  e.orderByFromJSON = V;
  function D(q) {
    switch (q) {
      case M.ORDER_BY_UNSPECIFIED:
        return "ORDER_BY_UNSPECIFIED";
      case M.ORDER_BY_ASC:
        return "ORDER_BY_ASC";
      case M.ORDER_BY_DESC:
        return "ORDER_BY_DESC";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderByToJSON = D;
  var b;
  (function(q) {
    q[q.BROADCAST_MODE_UNSPECIFIED = 0] = "BROADCAST_MODE_UNSPECIFIED", q[q.BROADCAST_MODE_BLOCK = 1] = "BROADCAST_MODE_BLOCK", q[q.BROADCAST_MODE_SYNC = 2] = "BROADCAST_MODE_SYNC", q[q.BROADCAST_MODE_ASYNC = 3] = "BROADCAST_MODE_ASYNC", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(b = e.BroadcastMode || (e.BroadcastMode = {}));
  function h(q) {
    switch (q) {
      case 0:
      case "BROADCAST_MODE_UNSPECIFIED":
        return b.BROADCAST_MODE_UNSPECIFIED;
      case 1:
      case "BROADCAST_MODE_BLOCK":
        return b.BROADCAST_MODE_BLOCK;
      case 2:
      case "BROADCAST_MODE_SYNC":
        return b.BROADCAST_MODE_SYNC;
      case 3:
      case "BROADCAST_MODE_ASYNC":
        return b.BROADCAST_MODE_ASYNC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return b.UNRECOGNIZED;
    }
  }
  e.broadcastModeFromJSON = h;
  function S(q) {
    switch (q) {
      case b.BROADCAST_MODE_UNSPECIFIED:
        return "BROADCAST_MODE_UNSPECIFIED";
      case b.BROADCAST_MODE_BLOCK:
        return "BROADCAST_MODE_BLOCK";
      case b.BROADCAST_MODE_SYNC:
        return "BROADCAST_MODE_SYNC";
      case b.BROADCAST_MODE_ASYNC:
        return "BROADCAST_MODE_ASYNC";
      case b.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.broadcastModeToJSON = S;
  function _() {
    return {
      events: [],
      pagination: void 0,
      orderBy: 0,
      page: T.Long.UZERO,
      limit: T.Long.UZERO
    };
  }
  e.GetTxsEventRequest = {
    encode(q, o = L.Writer.create()) {
      for (const P of q.events)
        o.uint32(10).string(P);
      return q.pagination !== void 0 && u.PageRequest.encode(q.pagination, o.uint32(18).fork()).ldelim(), q.orderBy !== 0 && o.uint32(24).int32(q.orderBy), q.page.isZero() || o.uint32(32).uint64(q.page), q.limit.isZero() || o.uint32(40).uint64(q.limit), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = _();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.events.push(P.string());
            break;
          case 2:
            R.pagination = u.PageRequest.decode(P, P.uint32());
            break;
          case 3:
            R.orderBy = P.int32();
            break;
          case 4:
            R.page = P.uint64();
            break;
          case 5:
            R.limit = P.uint64();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        events: Array.isArray(q == null ? void 0 : q.events) ? q.events.map((o) => String(o)) : [],
        pagination: (0, T.isSet)(q.pagination) ? u.PageRequest.fromJSON(q.pagination) : void 0,
        orderBy: (0, T.isSet)(q.orderBy) ? V(q.orderBy) : 0,
        page: (0, T.isSet)(q.page) ? T.Long.fromValue(q.page) : T.Long.UZERO,
        limit: (0, T.isSet)(q.limit) ? T.Long.fromValue(q.limit) : T.Long.UZERO
      };
    },
    toJSON(q) {
      const o = {};
      return q.events ? o.events = q.events.map((P) => P) : o.events = [], q.pagination !== void 0 && (o.pagination = q.pagination ? u.PageRequest.toJSON(q.pagination) : void 0), q.orderBy !== void 0 && (o.orderBy = D(q.orderBy)), q.page !== void 0 && (o.page = (q.page || T.Long.UZERO).toString()), q.limit !== void 0 && (o.limit = (q.limit || T.Long.UZERO).toString()), o;
    },
    fromPartial(q) {
      var P;
      const o = _();
      return o.events = ((P = q.events) == null ? void 0 : P.map((m) => m)) || [], o.pagination = q.pagination !== void 0 && q.pagination !== null ? u.PageRequest.fromPartial(q.pagination) : void 0, o.orderBy = q.orderBy ?? 0, o.page = q.page !== void 0 && q.page !== null ? T.Long.fromValue(q.page) : T.Long.UZERO, o.limit = q.limit !== void 0 && q.limit !== null ? T.Long.fromValue(q.limit) : T.Long.UZERO, o;
    }
  };
  function d() {
    return {
      txs: [],
      txResponses: [],
      pagination: void 0,
      total: T.Long.UZERO
    };
  }
  e.GetTxsEventResponse = {
    encode(q, o = L.Writer.create()) {
      for (const P of q.txs)
        r.Tx.encode(P, o.uint32(10).fork()).ldelim();
      for (const P of q.txResponses)
        f.TxResponse.encode(P, o.uint32(18).fork()).ldelim();
      return q.pagination !== void 0 && u.PageResponse.encode(q.pagination, o.uint32(26).fork()).ldelim(), q.total.isZero() || o.uint32(32).uint64(q.total), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = d();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.txs.push(r.Tx.decode(P, P.uint32()));
            break;
          case 2:
            R.txResponses.push(f.TxResponse.decode(P, P.uint32()));
            break;
          case 3:
            R.pagination = u.PageResponse.decode(P, P.uint32());
            break;
          case 4:
            R.total = P.uint64();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        txs: Array.isArray(q == null ? void 0 : q.txs) ? q.txs.map((o) => r.Tx.fromJSON(o)) : [],
        txResponses: Array.isArray(q == null ? void 0 : q.txResponses) ? q.txResponses.map((o) => f.TxResponse.fromJSON(o)) : [],
        pagination: (0, T.isSet)(q.pagination) ? u.PageResponse.fromJSON(q.pagination) : void 0,
        total: (0, T.isSet)(q.total) ? T.Long.fromValue(q.total) : T.Long.UZERO
      };
    },
    toJSON(q) {
      const o = {};
      return q.txs ? o.txs = q.txs.map((P) => P ? r.Tx.toJSON(P) : void 0) : o.txs = [], q.txResponses ? o.txResponses = q.txResponses.map((P) => P ? f.TxResponse.toJSON(P) : void 0) : o.txResponses = [], q.pagination !== void 0 && (o.pagination = q.pagination ? u.PageResponse.toJSON(q.pagination) : void 0), q.total !== void 0 && (o.total = (q.total || T.Long.UZERO).toString()), o;
    },
    fromPartial(q) {
      var P, m;
      const o = d();
      return o.txs = ((P = q.txs) == null ? void 0 : P.map((R) => r.Tx.fromPartial(R))) || [], o.txResponses = ((m = q.txResponses) == null ? void 0 : m.map((R) => f.TxResponse.fromPartial(R))) || [], o.pagination = q.pagination !== void 0 && q.pagination !== null ? u.PageResponse.fromPartial(q.pagination) : void 0, o.total = q.total !== void 0 && q.total !== null ? T.Long.fromValue(q.total) : T.Long.UZERO, o;
    }
  };
  function p() {
    return {
      txBytes: new Uint8Array(),
      mode: 0
    };
  }
  e.BroadcastTxRequest = {
    encode(q, o = L.Writer.create()) {
      return q.txBytes.length !== 0 && o.uint32(10).bytes(q.txBytes), q.mode !== 0 && o.uint32(16).int32(q.mode), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = p();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.txBytes = P.bytes();
            break;
          case 2:
            R.mode = P.int32();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        txBytes: (0, T.isSet)(q.txBytes) ? (0, T.bytesFromBase64)(q.txBytes) : new Uint8Array(),
        mode: (0, T.isSet)(q.mode) ? h(q.mode) : 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.txBytes !== void 0 && (o.txBytes = (0, T.base64FromBytes)(q.txBytes !== void 0 ? q.txBytes : new Uint8Array())), q.mode !== void 0 && (o.mode = S(q.mode)), o;
    },
    fromPartial(q) {
      const o = p();
      return o.txBytes = q.txBytes ?? new Uint8Array(), o.mode = q.mode ?? 0, o;
    }
  };
  function g() {
    return {
      txResponse: void 0
    };
  }
  e.BroadcastTxResponse = {
    encode(q, o = L.Writer.create()) {
      return q.txResponse !== void 0 && f.TxResponse.encode(q.txResponse, o.uint32(10).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = g();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.txResponse = f.TxResponse.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        txResponse: (0, T.isSet)(q.txResponse) ? f.TxResponse.fromJSON(q.txResponse) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.txResponse !== void 0 && (o.txResponse = q.txResponse ? f.TxResponse.toJSON(q.txResponse) : void 0), o;
    },
    fromPartial(q) {
      const o = g();
      return o.txResponse = q.txResponse !== void 0 && q.txResponse !== null ? f.TxResponse.fromPartial(q.txResponse) : void 0, o;
    }
  };
  function J() {
    return {
      tx: void 0,
      txBytes: new Uint8Array()
    };
  }
  e.SimulateRequest = {
    encode(q, o = L.Writer.create()) {
      return q.tx !== void 0 && r.Tx.encode(q.tx, o.uint32(10).fork()).ldelim(), q.txBytes.length !== 0 && o.uint32(18).bytes(q.txBytes), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = J();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.tx = r.Tx.decode(P, P.uint32());
            break;
          case 2:
            R.txBytes = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        tx: (0, T.isSet)(q.tx) ? r.Tx.fromJSON(q.tx) : void 0,
        txBytes: (0, T.isSet)(q.txBytes) ? (0, T.bytesFromBase64)(q.txBytes) : new Uint8Array()
      };
    },
    toJSON(q) {
      const o = {};
      return q.tx !== void 0 && (o.tx = q.tx ? r.Tx.toJSON(q.tx) : void 0), q.txBytes !== void 0 && (o.txBytes = (0, T.base64FromBytes)(q.txBytes !== void 0 ? q.txBytes : new Uint8Array())), o;
    },
    fromPartial(q) {
      const o = J();
      return o.tx = q.tx !== void 0 && q.tx !== null ? r.Tx.fromPartial(q.tx) : void 0, o.txBytes = q.txBytes ?? new Uint8Array(), o;
    }
  };
  function B() {
    return {
      gasInfo: void 0,
      result: void 0
    };
  }
  e.SimulateResponse = {
    encode(q, o = L.Writer.create()) {
      return q.gasInfo !== void 0 && f.GasInfo.encode(q.gasInfo, o.uint32(10).fork()).ldelim(), q.result !== void 0 && f.Result.encode(q.result, o.uint32(18).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = B();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.gasInfo = f.GasInfo.decode(P, P.uint32());
            break;
          case 2:
            R.result = f.Result.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        gasInfo: (0, T.isSet)(q.gasInfo) ? f.GasInfo.fromJSON(q.gasInfo) : void 0,
        result: (0, T.isSet)(q.result) ? f.Result.fromJSON(q.result) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.gasInfo !== void 0 && (o.gasInfo = q.gasInfo ? f.GasInfo.toJSON(q.gasInfo) : void 0), q.result !== void 0 && (o.result = q.result ? f.Result.toJSON(q.result) : void 0), o;
    },
    fromPartial(q) {
      const o = B();
      return o.gasInfo = q.gasInfo !== void 0 && q.gasInfo !== null ? f.GasInfo.fromPartial(q.gasInfo) : void 0, o.result = q.result !== void 0 && q.result !== null ? f.Result.fromPartial(q.result) : void 0, o;
    }
  };
  function I() {
    return {
      hash: ""
    };
  }
  e.GetTxRequest = {
    encode(q, o = L.Writer.create()) {
      return q.hash !== "" && o.uint32(10).string(q.hash), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = I();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.hash = P.string();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        hash: (0, T.isSet)(q.hash) ? String(q.hash) : ""
      };
    },
    toJSON(q) {
      const o = {};
      return q.hash !== void 0 && (o.hash = q.hash), o;
    },
    fromPartial(q) {
      const o = I();
      return o.hash = q.hash ?? "", o;
    }
  };
  function Z() {
    return {
      tx: void 0,
      txResponse: void 0
    };
  }
  e.GetTxResponse = {
    encode(q, o = L.Writer.create()) {
      return q.tx !== void 0 && r.Tx.encode(q.tx, o.uint32(10).fork()).ldelim(), q.txResponse !== void 0 && f.TxResponse.encode(q.txResponse, o.uint32(18).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = Z();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.tx = r.Tx.decode(P, P.uint32());
            break;
          case 2:
            R.txResponse = f.TxResponse.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        tx: (0, T.isSet)(q.tx) ? r.Tx.fromJSON(q.tx) : void 0,
        txResponse: (0, T.isSet)(q.txResponse) ? f.TxResponse.fromJSON(q.txResponse) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.tx !== void 0 && (o.tx = q.tx ? r.Tx.toJSON(q.tx) : void 0), q.txResponse !== void 0 && (o.txResponse = q.txResponse ? f.TxResponse.toJSON(q.txResponse) : void 0), o;
    },
    fromPartial(q) {
      const o = Z();
      return o.tx = q.tx !== void 0 && q.tx !== null ? r.Tx.fromPartial(q.tx) : void 0, o.txResponse = q.txResponse !== void 0 && q.txResponse !== null ? f.TxResponse.fromPartial(q.txResponse) : void 0, o;
    }
  };
  function t() {
    return {
      height: T.Long.ZERO,
      pagination: void 0
    };
  }
  e.GetBlockWithTxsRequest = {
    encode(q, o = L.Writer.create()) {
      return q.height.isZero() || o.uint32(8).int64(q.height), q.pagination !== void 0 && u.PageRequest.encode(q.pagination, o.uint32(18).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = t();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.height = P.int64();
            break;
          case 2:
            R.pagination = u.PageRequest.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        height: (0, T.isSet)(q.height) ? T.Long.fromValue(q.height) : T.Long.ZERO,
        pagination: (0, T.isSet)(q.pagination) ? u.PageRequest.fromJSON(q.pagination) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.height !== void 0 && (o.height = (q.height || T.Long.ZERO).toString()), q.pagination !== void 0 && (o.pagination = q.pagination ? u.PageRequest.toJSON(q.pagination) : void 0), o;
    },
    fromPartial(q) {
      const o = t();
      return o.height = q.height !== void 0 && q.height !== null ? T.Long.fromValue(q.height) : T.Long.ZERO, o.pagination = q.pagination !== void 0 && q.pagination !== null ? u.PageRequest.fromPartial(q.pagination) : void 0, o;
    }
  };
  function y() {
    return {
      txs: [],
      blockId: void 0,
      block: void 0,
      pagination: void 0
    };
  }
  e.GetBlockWithTxsResponse = {
    encode(q, o = L.Writer.create()) {
      for (const P of q.txs)
        r.Tx.encode(P, o.uint32(10).fork()).ldelim();
      return q.blockId !== void 0 && O.BlockID.encode(q.blockId, o.uint32(18).fork()).ldelim(), q.block !== void 0 && A.Block.encode(q.block, o.uint32(26).fork()).ldelim(), q.pagination !== void 0 && u.PageResponse.encode(q.pagination, o.uint32(34).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = y();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.txs.push(r.Tx.decode(P, P.uint32()));
            break;
          case 2:
            R.blockId = O.BlockID.decode(P, P.uint32());
            break;
          case 3:
            R.block = A.Block.decode(P, P.uint32());
            break;
          case 4:
            R.pagination = u.PageResponse.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        txs: Array.isArray(q == null ? void 0 : q.txs) ? q.txs.map((o) => r.Tx.fromJSON(o)) : [],
        blockId: (0, T.isSet)(q.blockId) ? O.BlockID.fromJSON(q.blockId) : void 0,
        block: (0, T.isSet)(q.block) ? A.Block.fromJSON(q.block) : void 0,
        pagination: (0, T.isSet)(q.pagination) ? u.PageResponse.fromJSON(q.pagination) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.txs ? o.txs = q.txs.map((P) => P ? r.Tx.toJSON(P) : void 0) : o.txs = [], q.blockId !== void 0 && (o.blockId = q.blockId ? O.BlockID.toJSON(q.blockId) : void 0), q.block !== void 0 && (o.block = q.block ? A.Block.toJSON(q.block) : void 0), q.pagination !== void 0 && (o.pagination = q.pagination ? u.PageResponse.toJSON(q.pagination) : void 0), o;
    },
    fromPartial(q) {
      var P;
      const o = y();
      return o.txs = ((P = q.txs) == null ? void 0 : P.map((m) => r.Tx.fromPartial(m))) || [], o.blockId = q.blockId !== void 0 && q.blockId !== null ? O.BlockID.fromPartial(q.blockId) : void 0, o.block = q.block !== void 0 && q.block !== null ? A.Block.fromPartial(q.block) : void 0, o.pagination = q.pagination !== void 0 && q.pagination !== null ? u.PageResponse.fromPartial(q.pagination) : void 0, o;
    }
  };
  function E() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxDecodeRequest = {
    encode(q, o = L.Writer.create()) {
      return q.txBytes.length !== 0 && o.uint32(10).bytes(q.txBytes), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = E();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.txBytes = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        txBytes: (0, T.isSet)(q.txBytes) ? (0, T.bytesFromBase64)(q.txBytes) : new Uint8Array()
      };
    },
    toJSON(q) {
      const o = {};
      return q.txBytes !== void 0 && (o.txBytes = (0, T.base64FromBytes)(q.txBytes !== void 0 ? q.txBytes : new Uint8Array())), o;
    },
    fromPartial(q) {
      const o = E();
      return o.txBytes = q.txBytes ?? new Uint8Array(), o;
    }
  };
  function H() {
    return {
      tx: void 0
    };
  }
  e.TxDecodeResponse = {
    encode(q, o = L.Writer.create()) {
      return q.tx !== void 0 && r.Tx.encode(q.tx, o.uint32(10).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = H();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.tx = r.Tx.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        tx: (0, T.isSet)(q.tx) ? r.Tx.fromJSON(q.tx) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.tx !== void 0 && (o.tx = q.tx ? r.Tx.toJSON(q.tx) : void 0), o;
    },
    fromPartial(q) {
      const o = H();
      return o.tx = q.tx !== void 0 && q.tx !== null ? r.Tx.fromPartial(q.tx) : void 0, o;
    }
  };
  function a() {
    return {
      tx: void 0
    };
  }
  e.TxEncodeRequest = {
    encode(q, o = L.Writer.create()) {
      return q.tx !== void 0 && r.Tx.encode(q.tx, o.uint32(10).fork()).ldelim(), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = a();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.tx = r.Tx.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        tx: (0, T.isSet)(q.tx) ? r.Tx.fromJSON(q.tx) : void 0
      };
    },
    toJSON(q) {
      const o = {};
      return q.tx !== void 0 && (o.tx = q.tx ? r.Tx.toJSON(q.tx) : void 0), o;
    },
    fromPartial(q) {
      const o = a();
      return o.tx = q.tx !== void 0 && q.tx !== null ? r.Tx.fromPartial(q.tx) : void 0, o;
    }
  };
  function l() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxEncodeResponse = {
    encode(q, o = L.Writer.create()) {
      return q.txBytes.length !== 0 && o.uint32(10).bytes(q.txBytes), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = l();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.txBytes = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        txBytes: (0, T.isSet)(q.txBytes) ? (0, T.bytesFromBase64)(q.txBytes) : new Uint8Array()
      };
    },
    toJSON(q) {
      const o = {};
      return q.txBytes !== void 0 && (o.txBytes = (0, T.base64FromBytes)(q.txBytes !== void 0 ? q.txBytes : new Uint8Array())), o;
    },
    fromPartial(q) {
      const o = l();
      return o.txBytes = q.txBytes ?? new Uint8Array(), o;
    }
  };
  function C() {
    return {
      aminoJson: ""
    };
  }
  e.TxEncodeAminoRequest = {
    encode(q, o = L.Writer.create()) {
      return q.aminoJson !== "" && o.uint32(10).string(q.aminoJson), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = C();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.aminoJson = P.string();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        aminoJson: (0, T.isSet)(q.aminoJson) ? String(q.aminoJson) : ""
      };
    },
    toJSON(q) {
      const o = {};
      return q.aminoJson !== void 0 && (o.aminoJson = q.aminoJson), o;
    },
    fromPartial(q) {
      const o = C();
      return o.aminoJson = q.aminoJson ?? "", o;
    }
  };
  function v() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxEncodeAminoResponse = {
    encode(q, o = L.Writer.create()) {
      return q.aminoBinary.length !== 0 && o.uint32(10).bytes(q.aminoBinary), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = v();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.aminoBinary = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        aminoBinary: (0, T.isSet)(q.aminoBinary) ? (0, T.bytesFromBase64)(q.aminoBinary) : new Uint8Array()
      };
    },
    toJSON(q) {
      const o = {};
      return q.aminoBinary !== void 0 && (o.aminoBinary = (0, T.base64FromBytes)(q.aminoBinary !== void 0 ? q.aminoBinary : new Uint8Array())), o;
    },
    fromPartial(q) {
      const o = v();
      return o.aminoBinary = q.aminoBinary ?? new Uint8Array(), o;
    }
  };
  function k() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxDecodeAminoRequest = {
    encode(q, o = L.Writer.create()) {
      return q.aminoBinary.length !== 0 && o.uint32(10).bytes(q.aminoBinary), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = k();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.aminoBinary = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        aminoBinary: (0, T.isSet)(q.aminoBinary) ? (0, T.bytesFromBase64)(q.aminoBinary) : new Uint8Array()
      };
    },
    toJSON(q) {
      const o = {};
      return q.aminoBinary !== void 0 && (o.aminoBinary = (0, T.base64FromBytes)(q.aminoBinary !== void 0 ? q.aminoBinary : new Uint8Array())), o;
    },
    fromPartial(q) {
      const o = k();
      return o.aminoBinary = q.aminoBinary ?? new Uint8Array(), o;
    }
  };
  function U() {
    return {
      aminoJson: ""
    };
  }
  e.TxDecodeAminoResponse = {
    encode(q, o = L.Writer.create()) {
      return q.aminoJson !== "" && o.uint32(10).string(q.aminoJson), o;
    },
    decode(q, o) {
      const P = q instanceof L.Reader ? q : new L.Reader(q);
      let m = o === void 0 ? P.len : P.pos + o;
      const R = U();
      for (; P.pos < m; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            R.aminoJson = P.string();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return {
        aminoJson: (0, T.isSet)(q.aminoJson) ? String(q.aminoJson) : ""
      };
    },
    toJSON(q) {
      const o = {};
      return q.aminoJson !== void 0 && (o.aminoJson = q.aminoJson), o;
    },
    fromPartial(q) {
      const o = U();
      return o.aminoJson = q.aminoJson ?? "", o;
    }
  };
  class F {
    constructor(o) {
      this.rpc = o, this.Simulate = this.Simulate.bind(this), this.GetTx = this.GetTx.bind(this), this.BroadcastTx = this.BroadcastTx.bind(this), this.GetTxsEvent = this.GetTxsEvent.bind(this), this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this), this.TxDecode = this.TxDecode.bind(this), this.TxEncode = this.TxEncode.bind(this), this.TxEncodeAmino = this.TxEncodeAmino.bind(this), this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
    }
    Simulate(o) {
      const P = e.SimulateRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", P).then((R) => e.SimulateResponse.decode(new L.Reader(R)));
    }
    GetTx(o) {
      const P = e.GetTxRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", P).then((R) => e.GetTxResponse.decode(new L.Reader(R)));
    }
    BroadcastTx(o) {
      const P = e.BroadcastTxRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", P).then((R) => e.BroadcastTxResponse.decode(new L.Reader(R)));
    }
    GetTxsEvent(o) {
      const P = e.GetTxsEventRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", P).then((R) => e.GetTxsEventResponse.decode(new L.Reader(R)));
    }
    GetBlockWithTxs(o) {
      const P = e.GetBlockWithTxsRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", P).then((R) => e.GetBlockWithTxsResponse.decode(new L.Reader(R)));
    }
    TxDecode(o) {
      const P = e.TxDecodeRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", P).then((R) => e.TxDecodeResponse.decode(new L.Reader(R)));
    }
    TxEncode(o) {
      const P = e.TxEncodeRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", P).then((R) => e.TxEncodeResponse.decode(new L.Reader(R)));
    }
    TxEncodeAmino(o) {
      const P = e.TxEncodeAminoRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", P).then((R) => e.TxEncodeAminoResponse.decode(new L.Reader(R)));
    }
    TxDecodeAmino(o) {
      const P = e.TxDecodeAminoRequest.encode(o).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", P).then((R) => e.TxDecodeAminoResponse.decode(new L.Reader(R)));
    }
  }
  e.ServiceClientImpl = F;
})(Hu);
var Em = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gi, "__esModule", { value: !0 });
gi.setupTxExtension = void 0;
const Cm = tt, Im = Zo, Ys = Hu, Kt = er, wm = Em(An), bm = Le;
function Bm(e) {
  const n = (0, bm.createProtobufRpcClient)(e), c = new Ys.ServiceClientImpl(n);
  return {
    tx: {
      getTx: async (i) => {
        const r = {
          hash: i
        };
        return await c.GetTx(r);
      },
      simulate: async (i, r, u, f) => {
        const O = Kt.Tx.fromPartial({
          authInfo: Kt.AuthInfo.fromPartial({
            fee: Kt.Fee.fromPartial({}),
            signerInfos: [
              {
                publicKey: (0, Cm.encodePubkey)(u),
                sequence: wm.default.fromNumber(f, !0),
                modeInfo: { single: { mode: Im.SignMode.SIGN_MODE_UNSPECIFIED } }
              }
            ]
          }),
          body: Kt.TxBody.fromPartial({
            messages: Array.from(i),
            memo: r
          }),
          signatures: [new Uint8Array()]
        }), A = Ys.SimulateRequest.fromPartial({
          txBytes: Kt.Tx.encode(O).finish()
        });
        return await c.Simulate(A);
      }
    }
  };
}
gi.setupTxExtension = Bm;
var Jt = {}, Jm = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.createVestingAminoConverters = Jt.isAminoMsgCreateVestingAccount = void 0;
const Dm = Jm(An);
function Um(e) {
  return e.type === "cosmos-sdk/MsgCreateVestingAccount";
}
Jt.isAminoMsgCreateVestingAccount = Um;
function Mm() {
  return {
    "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
      aminoType: "cosmos-sdk/MsgCreateVestingAccount",
      toAmino: ({ fromAddress: e, toAddress: n, amount: c, endTime: i, delayed: r }) => ({
        from_address: e,
        to_address: n,
        amount: [...c],
        end_time: i.toString(),
        delayed: r
      }),
      fromAmino: ({ from_address: e, to_address: n, amount: c, end_time: i, delayed: r }) => ({
        fromAddress: e,
        toAddress: n,
        amount: [...c],
        endTime: Dm.default.fromString(i),
        delayed: r
      })
    }
  };
}
Jt.createVestingAminoConverters = Mm;
var yi = {}, Wu = {};
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(h, S, _, d) {
    d === void 0 && (d = _);
    var p = Object.getOwnPropertyDescriptor(S, _);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[_];
    } }), Object.defineProperty(h, d, p);
  } : function(h, S, _, d) {
    d === void 0 && (d = _), h[d] = S[_];
  }), c = G && G.__setModuleDefault || (Object.create ? function(h, S) {
    Object.defineProperty(h, "default", { enumerable: !0, value: S });
  } : function(h, S) {
    h.default = S;
  }), i = G && G.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var S = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && n(S, h, _);
    return c(S, h), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCreatePeriodicVestingAccountResponse = e.MsgCreatePeriodicVestingAccount = e.MsgCreatePermanentLockedAccountResponse = e.MsgCreatePermanentLockedAccount = e.MsgCreateVestingAccountResponse = e.MsgCreateVestingAccount = e.protobufPackage = void 0;
  const r = Me, u = Go, f = oe, O = i(ie);
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function A() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: [],
      endTime: f.Long.ZERO,
      delayed: !1
    };
  }
  e.MsgCreateVestingAccount = {
    encode(h, S = O.Writer.create()) {
      h.fromAddress !== "" && S.uint32(10).string(h.fromAddress), h.toAddress !== "" && S.uint32(18).string(h.toAddress);
      for (const _ of h.amount)
        r.Coin.encode(_, S.uint32(26).fork()).ldelim();
      return h.endTime.isZero() || S.uint32(32).int64(h.endTime), h.delayed === !0 && S.uint32(40).bool(h.delayed), S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = A();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.fromAddress = _.string();
            break;
          case 2:
            p.toAddress = _.string();
            break;
          case 3:
            p.amount.push(r.Coin.decode(_, _.uint32()));
            break;
          case 4:
            p.endTime = _.int64();
            break;
          case 5:
            p.delayed = _.bool();
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        fromAddress: (0, f.isSet)(h.fromAddress) ? String(h.fromAddress) : "",
        toAddress: (0, f.isSet)(h.toAddress) ? String(h.toAddress) : "",
        amount: Array.isArray(h == null ? void 0 : h.amount) ? h.amount.map((S) => r.Coin.fromJSON(S)) : [],
        endTime: (0, f.isSet)(h.endTime) ? f.Long.fromValue(h.endTime) : f.Long.ZERO,
        delayed: (0, f.isSet)(h.delayed) ? !!h.delayed : !1
      };
    },
    toJSON(h) {
      const S = {};
      return h.fromAddress !== void 0 && (S.fromAddress = h.fromAddress), h.toAddress !== void 0 && (S.toAddress = h.toAddress), h.amount ? S.amount = h.amount.map((_) => _ ? r.Coin.toJSON(_) : void 0) : S.amount = [], h.endTime !== void 0 && (S.endTime = (h.endTime || f.Long.ZERO).toString()), h.delayed !== void 0 && (S.delayed = h.delayed), S;
    },
    fromPartial(h) {
      var _;
      const S = A();
      return S.fromAddress = h.fromAddress ?? "", S.toAddress = h.toAddress ?? "", S.amount = ((_ = h.amount) == null ? void 0 : _.map((d) => r.Coin.fromPartial(d))) || [], S.endTime = h.endTime !== void 0 && h.endTime !== null ? f.Long.fromValue(h.endTime) : f.Long.ZERO, S.delayed = h.delayed ?? !1, S;
    }
  };
  function T() {
    return {};
  }
  e.MsgCreateVestingAccountResponse = {
    encode(h, S = O.Writer.create()) {
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = T();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {};
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return T();
    }
  };
  function L() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgCreatePermanentLockedAccount = {
    encode(h, S = O.Writer.create()) {
      h.fromAddress !== "" && S.uint32(10).string(h.fromAddress), h.toAddress !== "" && S.uint32(18).string(h.toAddress);
      for (const _ of h.amount)
        r.Coin.encode(_, S.uint32(26).fork()).ldelim();
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = L();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.fromAddress = _.string();
            break;
          case 2:
            p.toAddress = _.string();
            break;
          case 3:
            p.amount.push(r.Coin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        fromAddress: (0, f.isSet)(h.fromAddress) ? String(h.fromAddress) : "",
        toAddress: (0, f.isSet)(h.toAddress) ? String(h.toAddress) : "",
        amount: Array.isArray(h == null ? void 0 : h.amount) ? h.amount.map((S) => r.Coin.fromJSON(S)) : []
      };
    },
    toJSON(h) {
      const S = {};
      return h.fromAddress !== void 0 && (S.fromAddress = h.fromAddress), h.toAddress !== void 0 && (S.toAddress = h.toAddress), h.amount ? S.amount = h.amount.map((_) => _ ? r.Coin.toJSON(_) : void 0) : S.amount = [], S;
    },
    fromPartial(h) {
      var _;
      const S = L();
      return S.fromAddress = h.fromAddress ?? "", S.toAddress = h.toAddress ?? "", S.amount = ((_ = h.amount) == null ? void 0 : _.map((d) => r.Coin.fromPartial(d))) || [], S;
    }
  };
  function M() {
    return {};
  }
  e.MsgCreatePermanentLockedAccountResponse = {
    encode(h, S = O.Writer.create()) {
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = M();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {};
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return M();
    }
  };
  function V() {
    return {
      fromAddress: "",
      toAddress: "",
      startTime: f.Long.ZERO,
      vestingPeriods: []
    };
  }
  e.MsgCreatePeriodicVestingAccount = {
    encode(h, S = O.Writer.create()) {
      h.fromAddress !== "" && S.uint32(10).string(h.fromAddress), h.toAddress !== "" && S.uint32(18).string(h.toAddress), h.startTime.isZero() || S.uint32(24).int64(h.startTime);
      for (const _ of h.vestingPeriods)
        u.Period.encode(_, S.uint32(34).fork()).ldelim();
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = V();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          case 1:
            p.fromAddress = _.string();
            break;
          case 2:
            p.toAddress = _.string();
            break;
          case 3:
            p.startTime = _.int64();
            break;
          case 4:
            p.vestingPeriods.push(u.Period.decode(_, _.uint32()));
            break;
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {
        fromAddress: (0, f.isSet)(h.fromAddress) ? String(h.fromAddress) : "",
        toAddress: (0, f.isSet)(h.toAddress) ? String(h.toAddress) : "",
        startTime: (0, f.isSet)(h.startTime) ? f.Long.fromValue(h.startTime) : f.Long.ZERO,
        vestingPeriods: Array.isArray(h == null ? void 0 : h.vestingPeriods) ? h.vestingPeriods.map((S) => u.Period.fromJSON(S)) : []
      };
    },
    toJSON(h) {
      const S = {};
      return h.fromAddress !== void 0 && (S.fromAddress = h.fromAddress), h.toAddress !== void 0 && (S.toAddress = h.toAddress), h.startTime !== void 0 && (S.startTime = (h.startTime || f.Long.ZERO).toString()), h.vestingPeriods ? S.vestingPeriods = h.vestingPeriods.map((_) => _ ? u.Period.toJSON(_) : void 0) : S.vestingPeriods = [], S;
    },
    fromPartial(h) {
      var _;
      const S = V();
      return S.fromAddress = h.fromAddress ?? "", S.toAddress = h.toAddress ?? "", S.startTime = h.startTime !== void 0 && h.startTime !== null ? f.Long.fromValue(h.startTime) : f.Long.ZERO, S.vestingPeriods = ((_ = h.vestingPeriods) == null ? void 0 : _.map((d) => u.Period.fromPartial(d))) || [], S;
    }
  };
  function D() {
    return {};
  }
  e.MsgCreatePeriodicVestingAccountResponse = {
    encode(h, S = O.Writer.create()) {
      return S;
    },
    decode(h, S) {
      const _ = h instanceof O.Reader ? h : new O.Reader(h);
      let d = S === void 0 ? _.len : _.pos + S;
      const p = D();
      for (; _.pos < d; ) {
        const g = _.uint32();
        switch (g >>> 3) {
          default:
            _.skipType(g & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(h) {
      return {};
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return D();
    }
  };
  class b {
    constructor(S) {
      this.rpc = S, this.CreateVestingAccount = this.CreateVestingAccount.bind(this), this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this), this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
    }
    CreateVestingAccount(S) {
      const _ = e.MsgCreateVestingAccount.encode(S).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", _).then((p) => e.MsgCreateVestingAccountResponse.decode(new O.Reader(p)));
    }
    CreatePermanentLockedAccount(S) {
      const _ = e.MsgCreatePermanentLockedAccount.encode(S).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", _).then((p) => e.MsgCreatePermanentLockedAccountResponse.decode(new O.Reader(p)));
    }
    CreatePeriodicVestingAccount(S) {
      const _ = e.MsgCreatePeriodicVestingAccount.encode(S).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", _).then((p) => e.MsgCreatePeriodicVestingAccountResponse.decode(new O.Reader(p)));
    }
  }
  e.MsgClientImpl = b;
})(Wu);
Object.defineProperty(yi, "__esModule", { value: !0 });
yi.vestingTypes = void 0;
const Vm = Wu;
yi.vestingTypes = [
  ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", Vm.MsgCreateVestingAccount]
];
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createStakingAminoConverters = e.setupSlashingExtension = e.isAminoMsgUnjail = e.createSlashingAminoConverters = e.setupMintExtension = e.setupIbcExtension = e.isMsgTransferEncodeObject = e.ibcTypes = e.isAminoMsgTransfer = e.createIbcAminoConverters = e.groupTypes = e.createGroupAminoConverters = e.setupGovExtension = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgDepositEncodeObject = e.govTypes = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgSubmitProposal = e.isAminoMsgDeposit = e.createGovAminoConverters = e.setupFeegrantExtension = e.feegrantTypes = e.createFeegrantAminoConverters = e.isAminoMsgSubmitEvidence = e.createEvidenceAminoConverters = e.setupDistributionExtension = e.isMsgWithdrawDelegatorRewardEncodeObject = e.distributionTypes = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgFundCommunityPool = e.createDistributionAminoConverters = e.isAminoMsgVerifyInvariant = e.createCrysisAminoConverters = e.setupBankExtension = e.isMsgSendEncodeObject = e.bankTypes = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.createBankAminoConverters = e.setupAuthzExtension = e.authzTypes = e.createAuthzAminoConverters = e.setupAuthExtension = void 0, e.vestingTypes = e.isAminoMsgCreateVestingAccount = e.createVestingAminoConverters = e.setupTxExtension = e.setupStakingExtension = e.stakingTypes = e.isMsgUndelegateEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgUndelegate = e.isAminoMsgEditValidator = e.isAminoMsgDelegate = void 0;
  var n = qr;
  Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return n.setupAuthExtension;
  } });
  var c = Xr;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return c.createAuthzAminoConverters;
  } });
  var i = xr;
  Object.defineProperty(e, "authzTypes", { enumerable: !0, get: function() {
    return i.authzTypes;
  } });
  var r = jr;
  Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return r.setupAuthzExtension;
  } });
  var u = Vn;
  Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return u.createBankAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return u.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return u.isAminoMsgSend;
  } });
  var f = Nt;
  Object.defineProperty(e, "bankTypes", { enumerable: !0, get: function() {
    return f.bankTypes;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return f.isMsgSendEncodeObject;
  } });
  var O = ei;
  Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return O.setupBankExtension;
  } });
  var A = Tt;
  Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return A.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return A.isAminoMsgVerifyInvariant;
  } });
  var T = rn;
  Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return T.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return T.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return T.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawValidatorCommission;
  } });
  var L = Et;
  Object.defineProperty(e, "distributionTypes", { enumerable: !0, get: function() {
    return L.distributionTypes;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return L.isMsgWithdrawDelegatorRewardEncodeObject;
  } });
  var M = ni;
  Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return M.setupDistributionExtension;
  } });
  var V = Ct;
  Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return V.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return V.isAminoMsgSubmitEvidence;
  } });
  var D = ti;
  Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return D.createFeegrantAminoConverters;
  } });
  var b = ri;
  Object.defineProperty(e, "feegrantTypes", { enumerable: !0, get: function() {
    return b.feegrantTypes;
  } });
  var h = ii;
  Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return h.setupFeegrantExtension;
  } });
  var S = on;
  Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return S.createGovAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return S.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return S.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return S.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return S.isAminoMsgVoteWeighted;
  } });
  var _ = an;
  Object.defineProperty(e, "govTypes", { enumerable: !0, get: function() {
    return _.govTypes;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return _.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return _.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return _.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return _.isMsgVoteWeightedEncodeObject;
  } });
  var d = ai;
  Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return d.setupGovExtension;
  } });
  var p = si;
  Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return p.createGroupAminoConverters;
  } });
  var g = di;
  Object.defineProperty(e, "groupTypes", { enumerable: !0, get: function() {
    return g.groupTypes;
  } });
  var J = It;
  Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return J.createIbcAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return J.isAminoMsgTransfer;
  } });
  var B = wt;
  Object.defineProperty(e, "ibcTypes", { enumerable: !0, get: function() {
    return B.ibcTypes;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return B.isMsgTransferEncodeObject;
  } });
  var I = li;
  Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return I.setupIbcExtension;
  } });
  var Z = pi;
  Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return Z.setupMintExtension;
  } });
  var t = bt;
  Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return t.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return t.isAminoMsgUnjail;
  } });
  var y = hi;
  Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return y.setupSlashingExtension;
  } });
  var E = Be;
  Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return E.createStakingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return E.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return E.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return E.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return E.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return E.isAminoMsgUndelegate;
  } });
  var H = Ge;
  Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return H.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return H.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return H.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return H.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return H.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "stakingTypes", { enumerable: !0, get: function() {
    return H.stakingTypes;
  } });
  var a = mi;
  Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return a.setupStakingExtension;
  } });
  var l = gi;
  Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return l.setupTxExtension;
  } });
  var C = Jt;
  Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return C.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return C.isAminoMsgCreateVestingAccount;
  } });
  var v = yi;
  Object.defineProperty(e, "vestingTypes", { enumerable: !0, get: function() {
    return v.vestingTypes;
  } });
})(Xt);
var Zn = {}, Lm = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.makeMultisignedTxBytes = Zn.makeMultisignedTx = Zn.makeCompactBitArray = void 0;
const Hm = Fo, qm = Ve, Wm = tt, Jo = Gc, Zm = Zo, Xs = er, Zu = er, xs = Lm(An);
function Qu(e) {
  const n = Math.ceil(e.length / 8), c = e.length - Math.floor(e.length / 8) * 8, i = new Uint8Array(n);
  return e.forEach((r, u) => {
    const f = Math.floor(u / 8), O = u % 8;
    r && (i[f] |= 1 << 8 - 1 - O);
  }), Jo.CompactBitArray.fromPartial({ elems: i, extraBitsStored: c });
}
Zn.makeCompactBitArray = Qu;
function Fu(e, n, c, i, r) {
  const u = Array.from(r.keys()), f = (0, qm.fromBech32)(u[0]).prefix, O = Array(e.value.pubkeys.length).fill(!1), A = new Array();
  for (let D = 0; D < e.value.pubkeys.length; D++) {
    const b = (0, Hm.pubkeyToAddress)(e.value.pubkeys[D], f), h = r.get(b);
    h && (O[D] = !0, A.push(h));
  }
  const T = {
    publicKey: (0, Wm.encodePubkey)(e),
    modeInfo: {
      multi: {
        bitarray: Qu(O),
        modeInfos: A.map((D) => ({ single: { mode: Zm.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
      }
    },
    sequence: xs.default.fromNumber(n)
  }, L = Xs.AuthInfo.fromPartial({
    signerInfos: [T],
    fee: {
      amount: [...c.amount],
      gasLimit: xs.default.fromString(c.gas)
    }
  }), M = Xs.AuthInfo.encode(L).finish();
  return Zu.TxRaw.fromPartial({
    bodyBytes: i,
    authInfoBytes: M,
    signatures: [Jo.MultiSignature.encode(Jo.MultiSignature.fromPartial({ signatures: A })).finish()]
  });
}
Zn.makeMultisignedTx = Fu;
function Qm(e, n, c, i, r) {
  const u = Fu(e, n, c, i, r);
  return Uint8Array.from(Zu.TxRaw.encode(u).finish());
}
Zn.makeMultisignedTxBytes = Qm;
var Gu = {}, ua = {}, kn = {};
Object.defineProperty(kn, "__esModule", { value: !0 });
kn.pubkeyToAddress = kn.pubkeyToRawAddress = kn.rawSecp256k1PubkeyToRawAddress = kn.rawEd25519PubkeyToRawAddress = void 0;
const Do = Qo, Fm = Ve;
function $u(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, Do.sha256)(e).slice(0, 20);
}
kn.rawEd25519PubkeyToRawAddress = $u;
function Ku(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, Do.ripemd160)((0, Do.sha256)(e));
}
kn.rawSecp256k1PubkeyToRawAddress = Ku;
function zu(e, n) {
  switch (e) {
    case "ed25519":
      return $u(n);
    case "secp256k1":
      return Ku(n);
    default:
      throw new Error(`Pubkey type ${e} not supported`);
  }
}
kn.pubkeyToRawAddress = zu;
function Gm(e, n) {
  return (0, Fm.toHex)(zu(e, n)).toUpperCase();
}
kn.pubkeyToAddress = Gm;
var $e = {};
Object.defineProperty($e, "__esModule", { value: !0 });
$e.DateTime = $e.toSeconds = $e.fromSeconds = $e.toRfc3339WithNanoseconds = $e.fromRfc3339WithNanoseconds = void 0;
const $m = Ve, Km = _n;
function Yu(e) {
  const n = (0, $m.fromRfc3339)(e), c = e.match(/\.(\d+)Z$/), i = c ? c[1].slice(3) : "";
  return n.nanoseconds = parseInt(i.padEnd(6, "0"), 10), n;
}
$e.fromRfc3339WithNanoseconds = Yu;
function Xu(e) {
  var i;
  const n = e.toISOString(), c = ((i = e.nanoseconds) == null ? void 0 : i.toString()) ?? "";
  return `${n.slice(0, -1)}${c.padStart(6, "0")}Z`;
}
$e.toRfc3339WithNanoseconds = Xu;
function zm(e, n = 0) {
  const c = new Km.Uint32(n).toNumber();
  if (c > 999999999)
    throw new Error("Nano seconds must not exceed 999999999");
  const i = new Date(e * 1e3 + Math.floor(c / 1e6));
  return i.nanoseconds = c % 1e6, i;
}
$e.fromSeconds = zm;
function Ym(e) {
  return {
    seconds: Math.floor(e.getTime() / 1e3),
    nanos: e.getTime() % 1e3 * 1e6 + (e.nanoseconds ?? 0)
  };
}
$e.toSeconds = Ym;
class Xm {
  /** @deprecated Use fromRfc3339WithNanoseconds instead */
  static decode(n) {
    return Yu(n);
  }
  /** @deprecated Use toRfc3339WithNanoseconds instead */
  static encode(n) {
    return Xu(n);
  }
}
$e.DateTime = Xm;
var Si = {}, Oi = {}, Ri = {}, Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
Pi.makeJsonRpcId = void 0;
let xm = 1e4;
function jm() {
  return xm += 1;
}
Pi.makeJsonRpcId = jm;
var vi = {}, En = {};
Object.defineProperty(En, "__esModule", { value: !0 });
En.jsonRpcCode = En.isJsonRpcSuccessResponse = En.isJsonRpcErrorResponse = void 0;
function xu(e) {
  return typeof e.error == "object";
}
En.isJsonRpcErrorResponse = xu;
function eg(e) {
  return !xu(e);
}
En.isJsonRpcSuccessResponse = eg;
En.jsonRpcCode = {
  parseError: -32700,
  invalidRequest: -32600,
  methodNotFound: -32601,
  invalidParams: -32602,
  internalError: -32603,
  // server error (Reserved for implementation-defined server-errors.):
  // -32000 to -32099
  serverError: {
    default: -32e3
  }
};
Object.defineProperty(vi, "__esModule", { value: !0 });
vi.JsonRpcClient = void 0;
const ng = ir, tg = En;
class rg {
  constructor(n) {
    this.connection = n;
  }
  async run(n) {
    const c = this.connection.responseStream.filter((u) => u.id === n.id), i = (0, ng.firstEvent)(c);
    this.connection.sendRequest(n);
    const r = await i;
    if ((0, tg.isJsonRpcErrorResponse)(r)) {
      const u = r.error;
      throw new Error(`JSON RPC error: code=${u.code}; message='${u.message}'`);
    }
    return r;
  }
}
vi.JsonRpcClient = rg;
var sn = {}, Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.isJsonCompatibleDictionary = Qn.isJsonCompatibleArray = Qn.isJsonCompatibleValue = void 0;
function ca(e) {
  return !!(typeof e == "string" || typeof e == "number" || typeof e == "boolean" || e === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  ju(e) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  ec(e));
}
Qn.isJsonCompatibleValue = ca;
function ju(e) {
  if (!Array.isArray(e))
    return !1;
  for (const n of e)
    if (!ca(n))
      return !1;
  return !0;
}
Qn.isJsonCompatibleArray = ju;
function ec(e) {
  return typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]" ? !1 : Object.values(e).every(ca);
}
Qn.isJsonCompatibleDictionary = ec;
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.parseJsonRpcResponse = sn.parseJsonRpcSuccessResponse = sn.parseJsonRpcErrorResponse = sn.parseJsonRpcRequest = sn.parseJsonRpcId = void 0;
const Fn = Qn;
function nc(e) {
  if (!(0, Fn.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  const n = e.id;
  return typeof n != "number" && typeof n != "string" ? null : n;
}
sn.parseJsonRpcId = nc;
function ig(e) {
  if (!(0, Fn.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${e.jsonrpc}`);
  const n = nc(e);
  if (n === null)
    throw new Error("Invalid id field");
  const c = e.method;
  if (typeof c != "string")
    throw new Error("Invalid method field");
  if (!(0, Fn.isJsonCompatibleArray)(e.params) && !(0, Fn.isJsonCompatibleDictionary)(e.params))
    throw new Error("Invalid params field");
  return {
    jsonrpc: "2.0",
    id: n,
    method: c,
    params: e.params
  };
}
sn.parseJsonRpcRequest = ig;
function og(e) {
  if (typeof e.code != "number")
    throw new Error("Error property 'code' is not a number");
  if (typeof e.message != "string")
    throw new Error("Error property 'message' is not a string");
  let n;
  if (e.data === void 0)
    n = void 0;
  else if ((0, Fn.isJsonCompatibleValue)(e.data))
    n = e.data;
  else
    throw new Error("Error property 'data' is defined but not a JSON compatible value.");
  return {
    code: e.code,
    message: e.message,
    ...n !== void 0 ? { data: n } : {}
  };
}
function tc(e) {
  if (!(0, Fn.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const n = e.id;
  if (typeof n != "number" && typeof n != "string" && n !== null)
    throw new Error("Invalid id field");
  if (typeof e.error > "u" || !(0, Fn.isJsonCompatibleDictionary)(e.error))
    throw new Error("Invalid error field");
  return {
    jsonrpc: "2.0",
    id: n,
    error: og(e.error)
  };
}
sn.parseJsonRpcErrorResponse = tc;
function rc(e) {
  if (!(0, Fn.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const n = e.id;
  if (typeof n != "number" && typeof n != "string")
    throw new Error("Invalid id field");
  if (typeof e.result > "u")
    throw new Error("Invalid result field");
  const c = e.result;
  return {
    jsonrpc: "2.0",
    id: n,
    result: c
  };
}
sn.parseJsonRpcSuccessResponse = rc;
function ag(e) {
  let n;
  try {
    n = tc(e);
  } catch {
    n = rc(e);
  }
  return n;
}
sn.parseJsonRpcResponse = ag;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.jsonRpcCode = e.isJsonRpcSuccessResponse = e.isJsonRpcErrorResponse = e.parseJsonRpcSuccessResponse = e.parseJsonRpcResponse = e.parseJsonRpcRequest = e.parseJsonRpcId = e.parseJsonRpcErrorResponse = e.JsonRpcClient = e.makeJsonRpcId = void 0;
  var n = Pi;
  Object.defineProperty(e, "makeJsonRpcId", { enumerable: !0, get: function() {
    return n.makeJsonRpcId;
  } });
  var c = vi;
  Object.defineProperty(e, "JsonRpcClient", { enumerable: !0, get: function() {
    return c.JsonRpcClient;
  } });
  var i = sn;
  Object.defineProperty(e, "parseJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return i.parseJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "parseJsonRpcId", { enumerable: !0, get: function() {
    return i.parseJsonRpcId;
  } }), Object.defineProperty(e, "parseJsonRpcRequest", { enumerable: !0, get: function() {
    return i.parseJsonRpcRequest;
  } }), Object.defineProperty(e, "parseJsonRpcResponse", { enumerable: !0, get: function() {
    return i.parseJsonRpcResponse;
  } }), Object.defineProperty(e, "parseJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return i.parseJsonRpcSuccessResponse;
  } });
  var r = En;
  Object.defineProperty(e, "isJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return r.isJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "isJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return r.isJsonRpcSuccessResponse;
  } }), Object.defineProperty(e, "jsonRpcCode", { enumerable: !0, get: function() {
    return r.jsonRpcCode;
  } });
})(Ri);
var ar = {}, la = { exports: {} }, ic = function(n, c) {
  return function() {
    for (var r = new Array(arguments.length), u = 0; u < r.length; u++)
      r[u] = arguments[u];
    return n.apply(c, r);
  };
}, sg = ic, it = Object.prototype.toString;
function fa(e) {
  return it.call(e) === "[object Array]";
}
function Uo(e) {
  return typeof e > "u";
}
function dg(e) {
  return e !== null && !Uo(e) && e.constructor !== null && !Uo(e.constructor) && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}
function ug(e) {
  return it.call(e) === "[object ArrayBuffer]";
}
function cg(e) {
  return typeof FormData < "u" && e instanceof FormData;
}
function lg(e) {
  var n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(e) : n = e && e.buffer && e.buffer instanceof ArrayBuffer, n;
}
function fg(e) {
  return typeof e == "string";
}
function pg(e) {
  return typeof e == "number";
}
function oc(e) {
  return e !== null && typeof e == "object";
}
function Cr(e) {
  if (it.call(e) !== "[object Object]")
    return !1;
  var n = Object.getPrototypeOf(e);
  return n === null || n === Object.prototype;
}
function hg(e) {
  return it.call(e) === "[object Date]";
}
function mg(e) {
  return it.call(e) === "[object File]";
}
function gg(e) {
  return it.call(e) === "[object Blob]";
}
function ac(e) {
  return it.call(e) === "[object Function]";
}
function yg(e) {
  return oc(e) && ac(e.pipe);
}
function Sg(e) {
  return typeof URLSearchParams < "u" && e instanceof URLSearchParams;
}
function Og(e) {
  return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
}
function Rg() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function pa(e, n) {
  if (!(e === null || typeof e > "u"))
    if (typeof e != "object" && (e = [e]), fa(e))
      for (var c = 0, i = e.length; c < i; c++)
        n.call(null, e[c], c, e);
    else
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && n.call(null, e[r], r, e);
}
function Mo() {
  var e = {};
  function n(r, u) {
    Cr(e[u]) && Cr(r) ? e[u] = Mo(e[u], r) : Cr(r) ? e[u] = Mo({}, r) : fa(r) ? e[u] = r.slice() : e[u] = r;
  }
  for (var c = 0, i = arguments.length; c < i; c++)
    pa(arguments[c], n);
  return e;
}
function Pg(e, n, c) {
  return pa(n, function(r, u) {
    c && typeof r == "function" ? e[u] = sg(r, c) : e[u] = r;
  }), e;
}
function vg(e) {
  return e.charCodeAt(0) === 65279 && (e = e.slice(1)), e;
}
var nn = {
  isArray: fa,
  isArrayBuffer: ug,
  isBuffer: dg,
  isFormData: cg,
  isArrayBufferView: lg,
  isString: fg,
  isNumber: pg,
  isObject: oc,
  isPlainObject: Cr,
  isUndefined: Uo,
  isDate: hg,
  isFile: mg,
  isBlob: gg,
  isFunction: ac,
  isStream: yg,
  isURLSearchParams: Sg,
  isStandardBrowserEnv: Rg,
  forEach: pa,
  merge: Mo,
  extend: Pg,
  trim: Og,
  stripBOM: vg
}, lt = nn;
function js(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var sc = function(n, c, i) {
  if (!c)
    return n;
  var r;
  if (i)
    r = i(c);
  else if (lt.isURLSearchParams(c))
    r = c.toString();
  else {
    var u = [];
    lt.forEach(c, function(A, T) {
      A === null || typeof A > "u" || (lt.isArray(A) ? T = T + "[]" : A = [A], lt.forEach(A, function(M) {
        lt.isDate(M) ? M = M.toISOString() : lt.isObject(M) && (M = JSON.stringify(M)), u.push(js(T) + "=" + js(M));
      }));
    }), r = u.join("&");
  }
  if (r) {
    var f = n.indexOf("#");
    f !== -1 && (n = n.slice(0, f)), n += (n.indexOf("?") === -1 ? "?" : "&") + r;
  }
  return n;
}, kg = nn;
function ki() {
  this.handlers = [];
}
ki.prototype.use = function(n, c, i) {
  return this.handlers.push({
    fulfilled: n,
    rejected: c,
    synchronous: i ? i.synchronous : !1,
    runWhen: i ? i.runWhen : null
  }), this.handlers.length - 1;
};
ki.prototype.eject = function(n) {
  this.handlers[n] && (this.handlers[n] = null);
};
ki.prototype.forEach = function(n) {
  kg.forEach(this.handlers, function(i) {
    i !== null && n(i);
  });
};
var Ag = ki, _g = nn, Ng = function(n, c) {
  _g.forEach(n, function(r, u) {
    u !== c && u.toUpperCase() === c.toUpperCase() && (n[c] = r, delete n[u]);
  });
}, dc = function(n, c, i, r, u) {
  return n.config = c, i && (n.code = i), n.request = r, n.response = u, n.isAxiosError = !0, n.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, n;
}, so, ed;
function uc() {
  if (ed)
    return so;
  ed = 1;
  var e = dc;
  return so = function(c, i, r, u, f) {
    var O = new Error(c);
    return e(O, i, r, u, f);
  }, so;
}
var uo, nd;
function Tg() {
  if (nd)
    return uo;
  nd = 1;
  var e = uc();
  return uo = function(c, i, r) {
    var u = r.config.validateStatus;
    !r.status || !u || u(r.status) ? c(r) : i(e(
      "Request failed with status code " + r.status,
      r.config,
      null,
      r.request,
      r
    ));
  }, uo;
}
var co, td;
function Eg() {
  if (td)
    return co;
  td = 1;
  var e = nn;
  return co = e.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function() {
      return {
        write: function(i, r, u, f, O, A) {
          var T = [];
          T.push(i + "=" + encodeURIComponent(r)), e.isNumber(u) && T.push("expires=" + new Date(u).toGMTString()), e.isString(f) && T.push("path=" + f), e.isString(O) && T.push("domain=" + O), A === !0 && T.push("secure"), document.cookie = T.join("; ");
        },
        read: function(i) {
          var r = document.cookie.match(new RegExp("(^|;\\s*)(" + i + ")=([^;]*)"));
          return r ? decodeURIComponent(r[3]) : null;
        },
        remove: function(i) {
          this.write(i, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), co;
}
var lo, rd;
function Cg() {
  return rd || (rd = 1, lo = function(n) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(n);
  }), lo;
}
var fo, id;
function Ig() {
  return id || (id = 1, fo = function(n, c) {
    return c ? n.replace(/\/+$/, "") + "/" + c.replace(/^\/+/, "") : n;
  }), fo;
}
var po, od;
function wg() {
  if (od)
    return po;
  od = 1;
  var e = Cg(), n = Ig();
  return po = function(i, r) {
    return i && !e(r) ? n(i, r) : r;
  }, po;
}
var ho, ad;
function bg() {
  if (ad)
    return ho;
  ad = 1;
  var e = nn, n = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return ho = function(i) {
    var r = {}, u, f, O;
    return i && e.forEach(i.split(`
`), function(T) {
      if (O = T.indexOf(":"), u = e.trim(T.substr(0, O)).toLowerCase(), f = e.trim(T.substr(O + 1)), u) {
        if (r[u] && n.indexOf(u) >= 0)
          return;
        u === "set-cookie" ? r[u] = (r[u] ? r[u] : []).concat([f]) : r[u] = r[u] ? r[u] + ", " + f : f;
      }
    }), r;
  }, ho;
}
var mo, sd;
function Bg() {
  if (sd)
    return mo;
  sd = 1;
  var e = nn;
  return mo = e.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var c = /(msie|trident)/i.test(navigator.userAgent), i = document.createElement("a"), r;
      function u(f) {
        var O = f;
        return c && (i.setAttribute("href", O), O = i.href), i.setAttribute("href", O), {
          href: i.href,
          protocol: i.protocol ? i.protocol.replace(/:$/, "") : "",
          host: i.host,
          search: i.search ? i.search.replace(/^\?/, "") : "",
          hash: i.hash ? i.hash.replace(/^#/, "") : "",
          hostname: i.hostname,
          port: i.port,
          pathname: i.pathname.charAt(0) === "/" ? i.pathname : "/" + i.pathname
        };
      }
      return r = u(window.location.href), function(O) {
        var A = e.isString(O) ? u(O) : O;
        return A.protocol === r.protocol && A.host === r.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function() {
      return function() {
        return !0;
      };
    }()
  ), mo;
}
var go, dd;
function ud() {
  if (dd)
    return go;
  dd = 1;
  var e = nn, n = Tg(), c = Eg(), i = sc, r = wg(), u = bg(), f = Bg(), O = uc();
  return go = function(T) {
    return new Promise(function(M, V) {
      var D = T.data, b = T.headers, h = T.responseType;
      e.isFormData(D) && delete b["Content-Type"];
      var S = new XMLHttpRequest();
      if (T.auth) {
        var _ = T.auth.username || "", d = T.auth.password ? unescape(encodeURIComponent(T.auth.password)) : "";
        b.Authorization = "Basic " + btoa(_ + ":" + d);
      }
      var p = r(T.baseURL, T.url);
      S.open(T.method.toUpperCase(), i(p, T.params, T.paramsSerializer), !0), S.timeout = T.timeout;
      function g() {
        if (S) {
          var B = "getAllResponseHeaders" in S ? u(S.getAllResponseHeaders()) : null, I = !h || h === "text" || h === "json" ? S.responseText : S.response, Z = {
            data: I,
            status: S.status,
            statusText: S.statusText,
            headers: B,
            config: T,
            request: S
          };
          n(M, V, Z), S = null;
        }
      }
      if ("onloadend" in S ? S.onloadend = g : S.onreadystatechange = function() {
        !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(g);
      }, S.onabort = function() {
        S && (V(O("Request aborted", T, "ECONNABORTED", S)), S = null);
      }, S.onerror = function() {
        V(O("Network Error", T, null, S)), S = null;
      }, S.ontimeout = function() {
        var I = "timeout of " + T.timeout + "ms exceeded";
        T.timeoutErrorMessage && (I = T.timeoutErrorMessage), V(O(
          I,
          T,
          T.transitional && T.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          S
        )), S = null;
      }, e.isStandardBrowserEnv()) {
        var J = (T.withCredentials || f(p)) && T.xsrfCookieName ? c.read(T.xsrfCookieName) : void 0;
        J && (b[T.xsrfHeaderName] = J);
      }
      "setRequestHeader" in S && e.forEach(b, function(I, Z) {
        typeof D > "u" && Z.toLowerCase() === "content-type" ? delete b[Z] : S.setRequestHeader(Z, I);
      }), e.isUndefined(T.withCredentials) || (S.withCredentials = !!T.withCredentials), h && h !== "json" && (S.responseType = T.responseType), typeof T.onDownloadProgress == "function" && S.addEventListener("progress", T.onDownloadProgress), typeof T.onUploadProgress == "function" && S.upload && S.upload.addEventListener("progress", T.onUploadProgress), T.cancelToken && T.cancelToken.promise.then(function(I) {
        S && (S.abort(), V(I), S = null);
      }), D || (D = null), S.send(D);
    });
  }, go;
}
var Ne = nn, cd = Ng, Jg = dc, Dg = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function ld(e, n) {
  !Ne.isUndefined(e) && Ne.isUndefined(e["Content-Type"]) && (e["Content-Type"] = n);
}
function Ug() {
  var e;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (e = ud()), e;
}
function Mg(e, n, c) {
  if (Ne.isString(e))
    try {
      return (n || JSON.parse)(e), Ne.trim(e);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (c || JSON.stringify)(e);
}
var Ai = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: Ug(),
  transformRequest: [function(n, c) {
    return cd(c, "Accept"), cd(c, "Content-Type"), Ne.isFormData(n) || Ne.isArrayBuffer(n) || Ne.isBuffer(n) || Ne.isStream(n) || Ne.isFile(n) || Ne.isBlob(n) ? n : Ne.isArrayBufferView(n) ? n.buffer : Ne.isURLSearchParams(n) ? (ld(c, "application/x-www-form-urlencoded;charset=utf-8"), n.toString()) : Ne.isObject(n) || c && c["Content-Type"] === "application/json" ? (ld(c, "application/json"), Mg(n)) : n;
  }],
  transformResponse: [function(n) {
    var c = this.transitional, i = c && c.silentJSONParsing, r = c && c.forcedJSONParsing, u = !i && this.responseType === "json";
    if (u || r && Ne.isString(n) && n.length)
      try {
        return JSON.parse(n);
      } catch (f) {
        if (u)
          throw f.name === "SyntaxError" ? Jg(f, this, "E_JSON_PARSE") : f;
      }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function(n) {
    return n >= 200 && n < 300;
  }
};
Ai.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
Ne.forEach(["delete", "get", "head"], function(n) {
  Ai.headers[n] = {};
});
Ne.forEach(["post", "put", "patch"], function(n) {
  Ai.headers[n] = Ne.merge(Dg);
});
var ha = Ai, Vg = nn, Lg = ha, Hg = function(n, c, i) {
  var r = this || Lg;
  return Vg.forEach(i, function(f) {
    n = f.call(r, n, c);
  }), n;
}, yo, fd;
function cc() {
  return fd || (fd = 1, yo = function(n) {
    return !!(n && n.__CANCEL__);
  }), yo;
}
var pd = nn, So = Hg, qg = cc(), Wg = ha;
function Oo(e) {
  e.cancelToken && e.cancelToken.throwIfRequested();
}
var Zg = function(n) {
  Oo(n), n.headers = n.headers || {}, n.data = So.call(
    n,
    n.data,
    n.headers,
    n.transformRequest
  ), n.headers = pd.merge(
    n.headers.common || {},
    n.headers[n.method] || {},
    n.headers
  ), pd.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(r) {
      delete n.headers[r];
    }
  );
  var c = n.adapter || Wg.adapter;
  return c(n).then(function(r) {
    return Oo(n), r.data = So.call(
      n,
      r.data,
      r.headers,
      n.transformResponse
    ), r;
  }, function(r) {
    return qg(r) || (Oo(n), r && r.response && (r.response.data = So.call(
      n,
      r.response.data,
      r.response.headers,
      n.transformResponse
    ))), Promise.reject(r);
  });
}, Ce = nn, lc = function(n, c) {
  c = c || {};
  var i = {}, r = ["url", "method", "data"], u = ["headers", "auth", "proxy", "params"], f = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], O = ["validateStatus"];
  function A(V, D) {
    return Ce.isPlainObject(V) && Ce.isPlainObject(D) ? Ce.merge(V, D) : Ce.isPlainObject(D) ? Ce.merge({}, D) : Ce.isArray(D) ? D.slice() : D;
  }
  function T(V) {
    Ce.isUndefined(c[V]) ? Ce.isUndefined(n[V]) || (i[V] = A(void 0, n[V])) : i[V] = A(n[V], c[V]);
  }
  Ce.forEach(r, function(D) {
    Ce.isUndefined(c[D]) || (i[D] = A(void 0, c[D]));
  }), Ce.forEach(u, T), Ce.forEach(f, function(D) {
    Ce.isUndefined(c[D]) ? Ce.isUndefined(n[D]) || (i[D] = A(void 0, n[D])) : i[D] = A(void 0, c[D]);
  }), Ce.forEach(O, function(D) {
    D in c ? i[D] = A(n[D], c[D]) : D in n && (i[D] = A(void 0, n[D]));
  });
  var L = r.concat(u).concat(f).concat(O), M = Object.keys(n).concat(Object.keys(c)).filter(function(D) {
    return L.indexOf(D) === -1;
  });
  return Ce.forEach(M, T), i;
};
const Qg = "axios", Fg = "0.21.4", Gg = "Promise based HTTP client for the browser and node.js", $g = "index.js", Kg = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, zg = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, Yg = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], Xg = "Matt Zabriskie", xg = "MIT", jg = {
  url: "https://github.com/axios/axios/issues"
}, ey = "https://axios-http.com", ny = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, ty = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, ry = "dist/axios.min.js", iy = "dist/axios.min.js", oy = "./index.d.ts", ay = {
  "follow-redirects": "^1.14.0"
}, sy = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], dy = {
  name: Qg,
  version: Fg,
  description: Gg,
  main: $g,
  scripts: Kg,
  repository: zg,
  keywords: Yg,
  author: Xg,
  license: xg,
  bugs: jg,
  homepage: ey,
  devDependencies: ny,
  browser: ty,
  jsdelivr: ry,
  unpkg: iy,
  typings: oy,
  dependencies: ay,
  bundlesize: sy
};
var fc = dy, ma = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(e, n) {
  ma[e] = function(i) {
    return typeof i === e || "a" + (n < 1 ? "n " : " ") + e;
  };
});
var hd = {}, uy = fc.version.split(".");
function pc(e, n) {
  for (var c = n ? n.split(".") : uy, i = e.split("."), r = 0; r < 3; r++) {
    if (c[r] > i[r])
      return !0;
    if (c[r] < i[r])
      return !1;
  }
  return !1;
}
ma.transitional = function(n, c, i) {
  var r = c && pc(c);
  function u(f, O) {
    return "[Axios v" + fc.version + "] Transitional option '" + f + "'" + O + (i ? ". " + i : "");
  }
  return function(f, O, A) {
    if (n === !1)
      throw new Error(u(O, " has been removed in " + c));
    return r && !hd[O] && (hd[O] = !0, console.warn(
      u(
        O,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), n ? n(f, O, A) : !0;
  };
};
function cy(e, n, c) {
  if (typeof e != "object")
    throw new TypeError("options must be an object");
  for (var i = Object.keys(e), r = i.length; r-- > 0; ) {
    var u = i[r], f = n[u];
    if (f) {
      var O = e[u], A = O === void 0 || f(O, u, e);
      if (A !== !0)
        throw new TypeError("option " + u + " must be " + A);
      continue;
    }
    if (c !== !0)
      throw Error("Unknown option " + u);
  }
}
var ly = {
  isOlderVersion: pc,
  assertOptions: cy,
  validators: ma
}, hc = nn, fy = sc, md = Ag, gd = Zg, _i = lc, mc = ly, ft = mc.validators;
function sr(e) {
  this.defaults = e, this.interceptors = {
    request: new md(),
    response: new md()
  };
}
sr.prototype.request = function(n) {
  typeof n == "string" ? (n = arguments[1] || {}, n.url = arguments[0]) : n = n || {}, n = _i(this.defaults, n), n.method ? n.method = n.method.toLowerCase() : this.defaults.method ? n.method = this.defaults.method.toLowerCase() : n.method = "get";
  var c = n.transitional;
  c !== void 0 && mc.assertOptions(c, {
    silentJSONParsing: ft.transitional(ft.boolean, "1.0.0"),
    forcedJSONParsing: ft.transitional(ft.boolean, "1.0.0"),
    clarifyTimeoutError: ft.transitional(ft.boolean, "1.0.0")
  }, !1);
  var i = [], r = !0;
  this.interceptors.request.forEach(function(V) {
    typeof V.runWhen == "function" && V.runWhen(n) === !1 || (r = r && V.synchronous, i.unshift(V.fulfilled, V.rejected));
  });
  var u = [];
  this.interceptors.response.forEach(function(V) {
    u.push(V.fulfilled, V.rejected);
  });
  var f;
  if (!r) {
    var O = [gd, void 0];
    for (Array.prototype.unshift.apply(O, i), O = O.concat(u), f = Promise.resolve(n); O.length; )
      f = f.then(O.shift(), O.shift());
    return f;
  }
  for (var A = n; i.length; ) {
    var T = i.shift(), L = i.shift();
    try {
      A = T(A);
    } catch (M) {
      L(M);
      break;
    }
  }
  try {
    f = gd(A);
  } catch (M) {
    return Promise.reject(M);
  }
  for (; u.length; )
    f = f.then(u.shift(), u.shift());
  return f;
};
sr.prototype.getUri = function(n) {
  return n = _i(this.defaults, n), fy(n.url, n.params, n.paramsSerializer).replace(/^\?/, "");
};
hc.forEach(["delete", "get", "head", "options"], function(n) {
  sr.prototype[n] = function(c, i) {
    return this.request(_i(i || {}, {
      method: n,
      url: c,
      data: (i || {}).data
    }));
  };
});
hc.forEach(["post", "put", "patch"], function(n) {
  sr.prototype[n] = function(c, i, r) {
    return this.request(_i(r || {}, {
      method: n,
      url: c,
      data: i
    }));
  };
});
var py = sr, Ro, yd;
function gc() {
  if (yd)
    return Ro;
  yd = 1;
  function e(n) {
    this.message = n;
  }
  return e.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, e.prototype.__CANCEL__ = !0, Ro = e, Ro;
}
var Po, Sd;
function hy() {
  if (Sd)
    return Po;
  Sd = 1;
  var e = gc();
  function n(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var i;
    this.promise = new Promise(function(f) {
      i = f;
    });
    var r = this;
    c(function(f) {
      r.reason || (r.reason = new e(f), i(r.reason));
    });
  }
  return n.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, n.source = function() {
    var i, r = new n(function(f) {
      i = f;
    });
    return {
      token: r,
      cancel: i
    };
  }, Po = n, Po;
}
var vo, Od;
function my() {
  return Od || (Od = 1, vo = function(n) {
    return function(i) {
      return n.apply(null, i);
    };
  }), vo;
}
var ko, Rd;
function gy() {
  return Rd || (Rd = 1, ko = function(n) {
    return typeof n == "object" && n.isAxiosError === !0;
  }), ko;
}
var Pd = nn, yy = ic, Ir = py, Sy = lc, Oy = ha;
function yc(e) {
  var n = new Ir(e), c = yy(Ir.prototype.request, n);
  return Pd.extend(c, Ir.prototype, n), Pd.extend(c, n), c;
}
var gn = yc(Oy);
gn.Axios = Ir;
gn.create = function(n) {
  return yc(Sy(gn.defaults, n));
};
gn.Cancel = gc();
gn.CancelToken = hy();
gn.isCancel = cc();
gn.all = function(n) {
  return Promise.all(n);
};
gn.spread = my();
gn.isAxiosError = gy();
la.exports = gn;
la.exports.default = gn;
var Ry = la.exports, Py = Ry, vy = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.http = void 0;
const ky = vy(Py);
function Ay(e) {
  if (e.status >= 400)
    throw new Error(`Bad status on response: ${e.status}`);
  return e;
}
function _y(e) {
  return e.toString().includes("emitExperimentalWarning");
}
async function Ny(e, n, c, i) {
  if (typeof fetch == "function" && !_y(fetch)) {
    const r = {
      method: e,
      body: i ? JSON.stringify(i) : void 0,
      headers: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "Content-Type": "application/json",
        ...c
      }
    };
    return fetch(n, r).then(Ay).then((u) => u.json());
  } else
    return ky.default.request({ url: n, method: e, data: i, headers: c }).then((r) => r.data);
}
ar.http = Ny;
var Cn = {};
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.hasProtocol = Cn.instanceOfRpcStreamingClient = void 0;
function Ty(e) {
  return typeof e.listen == "function";
}
Cn.instanceOfRpcStreamingClient = Ty;
function Ey(e) {
  return e.search("://") !== -1;
}
Cn.hasProtocol = Ey;
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.HttpBatchClient = void 0;
const vd = Ri, Cy = ar, Iy = Cn, kd = {
  dispatchInterval: 20,
  batchSizeLimit: 20
};
class wy {
  constructor(n, c = {}) {
    this.queue = [], this.options = {
      batchSizeLimit: c.batchSizeLimit ?? kd.batchSizeLimit,
      dispatchInterval: c.dispatchInterval ?? kd.dispatchInterval
    }, typeof n == "string" ? this.url = (0, Iy.hasProtocol)(n) ? n : "http://" + n : (this.url = n.url, this.headers = n.headers), this.timer = setInterval(() => this.tick(), c.dispatchInterval), this.validate();
  }
  disconnect() {
    this.timer && clearInterval(this.timer), this.timer = void 0;
  }
  async execute(n) {
    return new Promise((c, i) => {
      this.queue.push({ request: n, resolve: c, reject: i }), this.queue.length >= this.options.batchSizeLimit && this.tick();
    });
  }
  validate() {
    if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1)
      throw new Error("batchSizeLimit must be a safe integer >= 1");
  }
  /**
   * This is called in an interval where promise rejections cannot be handled.
   * So this is not async and HTTP errors need to be handled by the queued promises.
   */
  tick() {
    const n = this.queue.splice(0, this.options.batchSizeLimit);
    if (!n.length)
      return;
    const c = n.map((r) => r.request), i = c.map((r) => r.id);
    (0, Cy.http)("POST", this.url, this.headers, c).then((r) => {
      (Array.isArray(r) ? r : [r]).forEach((f) => {
        const O = n.find((M) => M.request.id === f.id);
        if (!O)
          return;
        const { reject: A, resolve: T } = O, L = (0, vd.parseJsonRpcResponse)(f);
        (0, vd.isJsonRpcErrorResponse)(L) ? A(new Error(JSON.stringify(L.error))) : T(L);
      });
    }, (r) => {
      for (const u of i) {
        const f = n.find((O) => O.request.id === u);
        if (!f)
          return;
        f.reject(r);
      }
    });
  }
}
Oi.HttpBatchClient = wy;
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.HttpClient = void 0;
const Ad = Ri, by = ar, By = Cn;
class Jy {
  constructor(n) {
    typeof n == "string" ? this.url = (0, By.hasProtocol)(n) ? n : "http://" + n : (this.url = n.url, this.headers = n.headers);
  }
  disconnect() {
  }
  async execute(n) {
    const c = (0, Ad.parseJsonRpcResponse)(await (0, by.http)("POST", this.url, this.headers, n));
    if ((0, Ad.isJsonRpcErrorResponse)(c))
      throw new Error(JSON.stringify(c.error));
    return c;
  }
}
Ni.HttpClient = Jy;
var Ti = {}, Sc = {}, ga = {}, dr = {}, ur = {}, mt = null;
typeof WebSocket < "u" ? mt = WebSocket : typeof MozWebSocket < "u" ? mt = MozWebSocket : typeof G < "u" ? mt = G.WebSocket || G.MozWebSocket : typeof window < "u" ? mt = window.WebSocket || window.MozWebSocket : typeof self < "u" && (mt = self.WebSocket || self.MozWebSocket);
var Dy = mt, Uy = G && G.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.SocketWrapper = void 0;
const pt = Uy(Dy);
function My() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
class Vy {
  constructor(n, c, i, r, u, f = 1e4) {
    this.closed = !1, this.connected = new Promise((O, A) => {
      this.connectedResolver = O, this.connectedRejecter = A;
    }), this.url = n, this.messageHandler = c, this.errorHandler = i, this.openHandler = r, this.closeHandler = u, this.timeout = f;
  }
  /**
   * returns a promise that resolves when connection is open
   */
  connect() {
    const n = new pt.default(this.url);
    n.onerror = (i) => {
      this.clearTimeout(), this.errorHandler && this.errorHandler(i);
    }, n.onmessage = (i) => {
      this.messageHandler({
        type: i.type,
        data: i.data
      });
    }, n.onopen = (i) => {
      this.clearTimeout(), this.connectedResolver(), this.openHandler && this.openHandler();
    }, n.onclose = (i) => {
      this.closed = !0, this.closeHandler && this.closeHandler(i);
    };
    const c = Date.now();
    this.timeoutId = setTimeout(() => {
      n.onmessage = () => 0, n.onerror = () => 0, n.onopen = () => 0, n.onclose = () => 0, n.close(), this.socket = void 0;
      const i = Math.floor(Date.now() - c);
      this.connectedRejecter(`Connection attempt timed out after ${i} ms`);
    }, this.timeout), this.socket = n;
  }
  /**
   * Closes an established connection and aborts other connection states
   */
  disconnect() {
    if (!this.socket)
      throw new Error("Socket undefined. This must be called after connecting.");
    switch (this.clearTimeout(), this.socket.readyState) {
      case pt.default.OPEN:
        this.socket.close(
          1e3
          /* Normal Closure */
        );
        break;
      case pt.default.CLOSED:
        break;
      case pt.default.CONNECTING:
        this.socket.onopen = () => 0, this.socket.onclose = () => 0, this.socket.onerror = () => 0, this.socket.onmessage = () => 0, this.socket = void 0, this.closeHandler && this.closeHandler({ wasClean: !1, code: 4001 });
        break;
      case pt.default.CLOSING:
        break;
      default:
        throw new Error(`Unknown readyState: ${this.socket.readyState}`);
    }
  }
  async send(n) {
    return new Promise((c, i) => {
      if (!this.socket)
        throw new Error("Socket undefined. This must be called after connecting.");
      if (this.closed)
        throw new Error("Socket was closed, so no data can be sent anymore.");
      if (this.socket.readyState !== pt.default.OPEN)
        throw new Error("Websocket is not open");
      My() ? this.socket.send(n, (r) => r ? i(r) : c()) : (this.socket.send(n), c());
    });
  }
  /**
   * Clears the timeout function, such that no timeout error will be raised anymore. This should be
   * called when the connection is established, a connection error occurred or the socket is disconnected.
   *
   * This method must not be called before `connect()`.
   * This method is idempotent.
   */
  clearTimeout() {
    if (!this.timeoutId)
      throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
    clearTimeout(this.timeoutId);
  }
}
ur.SocketWrapper = Vy;
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.StreamingSocket = void 0;
const Ly = Ee, Hy = ur;
class qy {
  constructor(n, c = 1e4) {
    this.socket = new Hy.SocketWrapper(n, (r) => {
      this.eventProducerListener && this.eventProducerListener.next(r);
    }, (r) => {
      this.eventProducerListener && this.eventProducerListener.error(r);
    }, () => {
    }, (r) => {
      this.eventProducerListener && (r.wasClean ? this.eventProducerListener.complete() : this.eventProducerListener.error("Socket was closed unclean"));
    }, c), this.connected = this.socket.connected;
    const i = {
      start: (r) => this.eventProducerListener = r,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = Ly.Stream.create(i);
  }
  connect() {
    this.socket.connect();
  }
  disconnect() {
    this.socket.disconnect();
  }
  async send(n) {
    return this.socket.send(n);
  }
}
dr.StreamingSocket = qy;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  const n = ir, c = Ee, i = dr;
  var r;
  (function(f) {
    f[f.Unconnected = 0] = "Unconnected", f[f.Connecting = 1] = "Connecting", f[f.Connected = 2] = "Connected", f[f.Disconnected = 3] = "Disconnected";
  })(r = e.ConnectionStatus || (e.ConnectionStatus = {}));
  class u {
    constructor(O, A = 1e4, T) {
      this.queue = [], this.isProcessingQueue = !1, this.url = O, this.timeout = A, this.reconnectedHandler = T;
      const L = {
        start: (M) => this.eventProducerListener = M,
        stop: () => this.eventProducerListener = void 0
      };
      this.events = c.Stream.create(L), this.connectionStatusProducer = new n.DefaultValueProducer(r.Unconnected), this.connectionStatus = new n.ValueAndUpdates(this.connectionStatusProducer), this.socket = new i.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (M) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(M);
        },
        error: () => this.connectionStatusProducer.update(r.Disconnected)
      });
    }
    connect() {
      this.connectionStatusProducer.update(r.Connecting), this.socket.connected.then(async () => (this.connectionStatusProducer.update(r.Connected), this.processQueue()), () => this.connectionStatusProducer.update(r.Disconnected)), this.socket.connect();
    }
    disconnect() {
      this.connectionStatusProducer.update(r.Disconnected), this.socket.disconnect();
    }
    reconnect() {
      this.socket = new i.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (O) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(O);
        },
        error: () => this.connectionStatusProducer.update(r.Disconnected)
      }), this.socket.connected.then(() => {
        this.reconnectedHandler && this.reconnectedHandler();
      }), this.connect();
    }
    getQueueLength() {
      return this.queue.length;
    }
    queueRequest(O) {
      this.queue.push(O), this.processQueue();
    }
    async processQueue() {
      if (this.isProcessingQueue || this.connectionStatus.value !== r.Connected)
        return;
      this.isProcessingQueue = !0;
      let O;
      for (; O = this.queue.shift(); )
        try {
          await this.socket.send(O), this.isProcessingQueue = !1;
        } catch {
          this.queue.unshift(O), this.isProcessingQueue = !1;
          return;
        }
    }
  }
  e.QueueingStreamingSocket = u;
})(ga);
var Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.ReconnectingSocket = void 0;
const Wy = Ee, Ao = ga;
class ya {
  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
  static calculateTimeout(n) {
    return Math.min(2 ** n * 100, 5e3);
  }
  constructor(n, c = 1e4, i) {
    this.unconnected = !0, this.disconnected = !1, this.timeoutIndex = 0, this.reconnectTimeout = null;
    const r = {
      start: (u) => this.eventProducerListener = u,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = Wy.Stream.create(r), this.socket = new Ao.QueueingStreamingSocket(n, c, i), this.socket.events.subscribe({
      next: (u) => {
        this.eventProducerListener && this.eventProducerListener.next(u);
      },
      error: (u) => {
        this.eventProducerListener && this.eventProducerListener.error(u);
      }
    }), this.connectionStatus = this.socket.connectionStatus, this.connectionStatus.updates.subscribe({
      next: (u) => {
        u === Ao.ConnectionStatus.Connected && (this.timeoutIndex = 0), u === Ao.ConnectionStatus.Disconnected && (this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null), this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ya.calculateTimeout(this.timeoutIndex++)));
      }
    });
  }
  connect() {
    if (!this.unconnected)
      throw new Error("Cannot connect: socket has already connected");
    this.socket.connect(), this.unconnected = !1;
  }
  disconnect() {
    if (this.unconnected)
      throw new Error("Cannot disconnect: socket has not yet connected");
    this.socket.disconnect(), this.eventProducerListener && this.eventProducerListener.complete(), this.disconnected = !0;
  }
  queueRequest(n) {
    if (this.disconnected)
      throw new Error("Cannot queue request: socket has disconnected");
    this.socket.queueRequest(n);
  }
}
Ei.ReconnectingSocket = ya;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.StreamingSocket = e.SocketWrapper = e.ReconnectingSocket = e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  var n = ga;
  Object.defineProperty(e, "ConnectionStatus", { enumerable: !0, get: function() {
    return n.ConnectionStatus;
  } }), Object.defineProperty(e, "QueueingStreamingSocket", { enumerable: !0, get: function() {
    return n.QueueingStreamingSocket;
  } });
  var c = Ei;
  Object.defineProperty(e, "ReconnectingSocket", { enumerable: !0, get: function() {
    return c.ReconnectingSocket;
  } });
  var i = ur;
  Object.defineProperty(e, "SocketWrapper", { enumerable: !0, get: function() {
    return i.SocketWrapper;
  } });
  var r = dr;
  Object.defineProperty(e, "StreamingSocket", { enumerable: !0, get: function() {
    return r.StreamingSocket;
  } });
})(Sc);
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.WebsocketClient = void 0;
const Jr = Ri, _d = Sc, Zy = ir, Qy = Ee, Fy = Cn;
function Gy(e) {
  throw e;
}
function Oc(e) {
  if (e.type !== "message")
    throw new Error(`Unexcepted message type on websocket: ${e.type}`);
  return (0, Jr.parseJsonRpcResponse)(JSON.parse(e.data));
}
class $y {
  constructor(n, c) {
    this.running = !1, this.subscriptions = [], this.request = n, this.socket = c;
  }
  /**
   * Implementation of Producer.start
   */
  start(n) {
    if (this.running)
      throw Error("Already started. Please stop first before restarting.");
    this.running = !0, this.connectToClient(n), this.socket.queueRequest(JSON.stringify(this.request));
  }
  /**
   * Implementation of Producer.stop
   *
   * Called by the stream when the stream's last listener stopped listening
   * or when the producer completed.
   */
  stop() {
    this.running = !1;
    const n = { ...this.request, method: "unsubscribe" };
    try {
      this.socket.queueRequest(JSON.stringify(n));
    } catch (c) {
      if (!(c instanceof Error && c.message.match(/socket has disconnected/i)))
        throw c;
    }
  }
  connectToClient(n) {
    const c = this.socket.events.map(Oc), i = c.filter((f) => f.id === this.request.id).subscribe({
      next: (f) => {
        (0, Jr.isJsonRpcErrorResponse)(f) && (this.closeSubscriptions(), n.error(JSON.stringify(f.error))), i.unsubscribe();
      }
    }), r = c.filter((f) => f.id === this.request.id).subscribe({
      next: (f) => {
        (0, Jr.isJsonRpcErrorResponse)(f) ? (this.closeSubscriptions(), n.error(JSON.stringify(f.error))) : n.next(f.result);
      }
    }), u = c.subscribe({
      error: (f) => {
        this.closeSubscriptions(), n.error(f);
      },
      complete: () => {
        this.closeSubscriptions(), n.complete();
      }
    });
    this.subscriptions.push(i, r, u);
  }
  closeSubscriptions() {
    for (const n of this.subscriptions)
      n.unsubscribe();
    this.subscriptions = [];
  }
}
class Ky {
  constructor(n, c = Gy) {
    this.subscriptionStreams = /* @__PURE__ */ new Map();
    const i = n.endsWith("/") ? "websocket" : "/websocket", r = (0, Fy.hasProtocol)(n) ? n : "ws://" + n;
    this.url = r + i, this.socket = new _d.ReconnectingSocket(this.url);
    const u = this.socket.events.subscribe({
      error: (f) => {
        c(f), u.unsubscribe();
      }
    });
    this.jsonRpcResponseStream = this.socket.events.map(Oc), this.socket.connect();
  }
  async execute(n) {
    const c = this.responseForRequestId(n.id);
    this.socket.queueRequest(JSON.stringify(n));
    const i = await c;
    if ((0, Jr.isJsonRpcErrorResponse)(i))
      throw new Error(JSON.stringify(i.error));
    return i;
  }
  listen(n) {
    if (n.method !== "subscribe")
      throw new Error('Request method must be "subscribe" to start event listening');
    const c = n.params.query;
    if (typeof c != "string")
      throw new Error("request.params.query must be a string");
    if (!this.subscriptionStreams.has(c)) {
      const i = new $y(n, this.socket), r = Qy.Stream.create(i);
      this.subscriptionStreams.set(c, r);
    }
    return this.subscriptionStreams.get(c).filter((i) => i.query !== void 0);
  }
  /**
   * Resolves as soon as websocket is connected. execute() queues requests automatically,
   * so this should be required for testing purposes only.
   */
  async connected() {
    await this.socket.connectionStatus.waitFor(_d.ConnectionStatus.Connected);
  }
  disconnect() {
    this.socket.disconnect();
  }
  async responseForRequestId(n) {
    return (0, Zy.firstEvent)(this.jsonRpcResponseStream.filter((c) => c.id === n));
  }
}
Ti.WebsocketClient = Ky;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.WebsocketClient = e.instanceOfRpcStreamingClient = e.HttpClient = e.HttpBatchClient = void 0;
  var n = Oi;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return n.HttpBatchClient;
  } });
  var c = Ni;
  Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return c.HttpClient;
  } });
  var i = Cn;
  Object.defineProperty(e, "instanceOfRpcStreamingClient", { enumerable: !0, get: function() {
    return i.instanceOfRpcStreamingClient;
  } });
  var r = Ti;
  Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return r.WebsocketClient;
  } });
})(Si);
var Yt = {}, Ci = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(c) {
    c.AbciInfo = "abci_info", c.AbciQuery = "abci_query", c.Block = "block", c.Blockchain = "blockchain", c.BlockResults = "block_results", c.BlockSearch = "block_search", c.BroadcastTxAsync = "broadcast_tx_async", c.BroadcastTxSync = "broadcast_tx_sync", c.BroadcastTxCommit = "broadcast_tx_commit", c.Commit = "commit", c.Genesis = "genesis", c.Health = "health", c.NumUnconfirmedTxs = "num_unconfirmed_txs", c.Status = "status", c.Subscribe = "subscribe", c.Tx = "tx", c.TxSearch = "tx_search", c.Validators = "validators", c.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(c) {
    c.NewBlock = "NewBlock", c.NewBlockHeader = "NewBlockHeader", c.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(c) {
    const r = (c.tags ? c.tags : []).map((f) => `${f.key}='${f.value}'`), u = c.raw ? [c.raw] : [];
    return [...r, ...u].join(" AND ");
  }
  e.buildQuery = n;
})(Ci);
var Rc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(i) {
    return i.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function c(i) {
    return i.checkTx.code === 0 && !!i.deliverTx && i.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = c, function(i) {
    i[i.PreVote = 1] = "PreVote", i[i.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Rc);
var Ii = {}, ot = {};
Object.defineProperty(ot, "__esModule", { value: !0 });
ot.createJsonRpcRequest = void 0;
const Nd = "123456789";
function zy() {
  return Nd[Math.floor(Math.random() * Nd.length)];
}
function Yy() {
  return parseInt(Array.from({ length: 12 }).map(() => zy()).join(""), 10);
}
function Xy(e, n) {
  const c = n ? { ...n } : {};
  return {
    jsonrpc: "2.0",
    id: Yy(),
    method: e,
    params: c
  };
}
ot.createJsonRpcRequest = Xy;
var wi = {}, et = {}, pe = {};
Object.defineProperty(pe, "__esModule", { value: !0 });
pe.encodeBlockId = pe.encodeVersion = pe.encodeBytes = pe.encodeTime = pe.encodeUvarint = pe.encodeString = pe.dictionaryToStringMap = pe.may = pe.assertNotEmpty = pe.assertObject = pe.assertArray = pe.assertNumber = pe.assertString = pe.assertBoolean = pe.assertSet = void 0;
const xy = Ve;
function at(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
pe.assertSet = at;
function jy(e) {
  if (at(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
pe.assertBoolean = jy;
function eS(e) {
  if (at(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
pe.assertString = eS;
function nS(e) {
  if (at(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
pe.assertNumber = nS;
function tS(e) {
  if (at(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
pe.assertArray = tS;
function rS(e) {
  if (at(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
pe.assertObject = rS;
function iS(e) {
  if (at(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
pe.assertNotEmpty = iS;
function oS(e, n) {
  return n == null ? void 0 : e(n);
}
pe.may = oS;
function aS(e) {
  const n = /* @__PURE__ */ new Map();
  for (const c of Object.keys(e)) {
    const i = e[c];
    if (typeof i != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(c, i);
  }
  return n;
}
pe.dictionaryToStringMap = aS;
function sS(e) {
  const n = (0, xy.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
pe.encodeString = sS;
function Dt(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Dt(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
pe.encodeUvarint = Dt;
function dS(e) {
  const n = e.getTime(), c = Math.floor(n / 1e3), i = c ? [8, ...Dt(c)] : new Uint8Array(), r = (e.nanoseconds || 0) + n % 1e3 * 1e6, u = r ? [16, ...Dt(r)] : new Uint8Array();
  return Uint8Array.from([...i, ...u]);
}
pe.encodeTime = dS;
function uS(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
pe.encodeBytes = uS;
function cS(e) {
  const n = e.block ? Uint8Array.from([8, ...Dt(e.block)]) : new Uint8Array(), c = e.app ? Uint8Array.from([16, ...Dt(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...c]);
}
pe.encodeVersion = cS;
function lS(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
pe.encodeBlockId = lS;
Object.defineProperty(et, "__esModule", { value: !0 });
et.hashBlock = et.hashTx = void 0;
const Sa = Qo, qe = pe;
function fS(e) {
  return (0, Sa.sha256)(e);
}
et.hashTx = fS;
function pS(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function hS(e) {
  const n = new Sa.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function mS(e, n) {
  const c = new Sa.Sha256(Uint8Array.from([1]));
  return c.update(e), c.update(n), c.digest();
}
function Vo(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return hS(e[0]);
    default: {
      const n = pS(e.length), c = Vo(e.slice(0, n)), i = Vo(e.slice(n));
      return mS(c, i);
    }
  }
}
function gS(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, qe.encodeVersion)(e.version),
    (0, qe.encodeString)(e.chainId),
    (0, qe.encodeUvarint)(e.height),
    (0, qe.encodeTime)(e.time),
    (0, qe.encodeBlockId)(e.lastBlockId),
    (0, qe.encodeBytes)(e.lastCommitHash),
    (0, qe.encodeBytes)(e.dataHash),
    (0, qe.encodeBytes)(e.validatorsHash),
    (0, qe.encodeBytes)(e.nextValidatorsHash),
    (0, qe.encodeBytes)(e.consensusHash),
    (0, qe.encodeBytes)(e.appHash),
    (0, qe.encodeBytes)(e.lastResultsHash),
    (0, qe.encodeBytes)(e.evidenceHash),
    (0, qe.encodeBytes)(e.proposerAddress)
  ];
  return Vo(n);
}
et.hashBlock = gS;
var bi = {}, pn = {};
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.smallIntToApi = pn.apiToBigInt = pn.apiToSmallInt = void 0;
const Lo = _n, yS = pe;
function SS(e) {
  return (typeof e == "number" ? new Lo.Int53(e) : Lo.Int53.fromString(e)).toNumber();
}
pn.apiToSmallInt = SS;
function OS(e) {
  if ((0, yS.assertString)(e), !e.match(/^-?[0-9]+$/))
    throw new Error("Invalid string format");
  return BigInt(e);
}
pn.apiToBigInt = OS;
function RS(e) {
  return new Lo.Int53(e).toString();
}
pn.smallIntToApi = RS;
var PS = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), vS = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), kS = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && PS(n, e, c);
  return vS(n, e), n;
};
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.Params = void 0;
const Oa = Ve, hn = pn, Ie = ot, Ke = pe, AS = kS(Ci);
function _o(e) {
  return {
    height: (0, Ke.may)(hn.smallIntToApi, e.height)
  };
}
function _S(e) {
  return {
    minHeight: (0, Ke.may)(hn.smallIntToApi, e.minHeight),
    maxHeight: (0, Ke.may)(hn.smallIntToApi, e.maxHeight)
  };
}
function NS(e) {
  return {
    query: e.query,
    page: (0, Ke.may)(hn.smallIntToApi, e.page),
    per_page: (0, Ke.may)(hn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function TS(e) {
  return {
    path: (0, Ke.assertNotEmpty)(e.path),
    data: (0, Oa.toHex)(e.data),
    height: (0, Ke.may)(hn.smallIntToApi, e.height),
    prove: e.prove
  };
}
function ES(e) {
  return {
    tx: (0, Oa.toBase64)((0, Ke.assertNotEmpty)(e.tx))
  };
}
function CS(e) {
  return {
    hash: (0, Oa.toBase64)((0, Ke.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function IS(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, Ke.may)(hn.smallIntToApi, e.page),
    per_page: (0, Ke.may)(hn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function wS(e) {
  return {
    height: (0, Ke.may)(hn.smallIntToApi, e.height),
    page: (0, Ke.may)(hn.smallIntToApi, e.page),
    per_page: (0, Ke.may)(hn.smallIntToApi, e.per_page)
  };
}
let bS = class {
  static encodeAbciInfo(n) {
    return (0, Ie.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, TS(n.params));
  }
  static encodeBlock(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, _o(n.params));
  }
  static encodeBlockchain(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, _S(n.params));
  }
  static encodeBlockResults(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, _o(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, NS(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, ES(n.params));
  }
  static encodeCommit(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, _o(n.params));
  }
  static encodeGenesis(n) {
    return (0, Ie.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, Ie.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, Ie.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, Ie.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const c = { key: "tm.event", value: n.query.type }, i = AS.buildQuery({ tags: [c], raw: n.query.raw });
    return (0, Ie.createJsonRpcRequest)("subscribe", { query: i });
  }
  static encodeTx(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, CS(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, IS(n.params));
  }
  static encodeValidators(n) {
    return (0, Ie.createJsonRpcRequest)(n.method, wS(n.params));
  }
};
bi.Params = bS;
var dn = {}, Bi = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = void 0, function(n) {
    n[n.Unknown = 0] = "Unknown", n[n.Absent = 1] = "Absent", n[n.Commit = 2] = "Commit", n[n.Nil = 3] = "Nil", n[n.Unrecognized = -1] = "Unrecognized";
  }(e.BlockIdFlag || (e.BlockIdFlag = {}));
})(Bi);
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.Responses = dn.decodeValidatorInfo = dn.decodeValidatorGenesis = dn.decodeValidatorUpdate = dn.decodeEvent = void 0;
const de = Ve, Pc = yn, xt = $e, ue = pn, BS = Bi, j = pe, JS = et;
function DS(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, j.may)(ue.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, j.may)(de.fromBase64, e.last_block_app_hash)
  };
}
function US(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, de.fromBase64)(n.key),
      data: (0, de.fromBase64)(n.data)
    }))
  };
}
function MS(e) {
  return {
    key: (0, de.fromBase64)((0, j.assertString)(e.key ?? "")),
    value: (0, de.fromBase64)((0, j.assertString)(e.value ?? "")),
    proof: (0, j.may)(US, e.proofOps),
    height: (0, j.may)(ue.apiToSmallInt, e.height),
    code: (0, j.may)(ue.apiToSmallInt, e.code),
    codespace: (0, j.assertString)(e.codespace ?? ""),
    index: (0, j.may)(ue.apiToSmallInt, e.index),
    log: e.log,
    info: (0, j.assertString)(e.info ?? "")
  };
}
function VS(e) {
  return {
    key: (0, de.fromBase64)((0, j.assertNotEmpty)(e.key)),
    value: (0, de.fromBase64)((0, j.assertString)(e.value ?? ""))
  };
}
function LS(e) {
  return (0, j.assertArray)(e).map(VS);
}
function vc(e) {
  return {
    type: e.type,
    attributes: e.attributes ? LS(e.attributes) : []
  };
}
dn.decodeEvent = vc;
function Ho(e) {
  return (0, j.assertArray)(e).map(vc);
}
function Ut(e) {
  return {
    code: (0, ue.apiToSmallInt)((0, j.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, j.may)(de.fromBase64, e.data),
    events: e.events ? Ho(e.events) : [],
    gasWanted: (0, ue.apiToSmallInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, ue.apiToSmallInt)(e.gas_used ?? "0")
  };
}
function Ra(e) {
  if ("Sum" in e) {
    const [[n, c]] = Object.entries(e.Sum.value);
    return (0, Pc.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, de.fromBase64)((0, j.assertNotEmpty)(c))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, de.fromBase64)((0, j.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, de.fromBase64)((0, j.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function HS(e) {
  return {
    maxBytes: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.max_gas))
  };
}
function qS(e) {
  return {
    maxAgeNumBlocks: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.max_age_duration))
  };
}
function kc(e) {
  return {
    block: HS((0, j.assertObject)(e.block)),
    evidence: qS((0, j.assertObject)(e.evidence))
  };
}
function Ac(e) {
  return {
    pubkey: Ra((0, j.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)(e.power ?? "0")
  };
}
dn.decodeValidatorUpdate = Ac;
function WS(e) {
  return {
    height: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Ut),
    validatorUpdates: (e.validator_updates || []).map(Ac),
    consensusUpdates: (0, j.may)(kc, e.consensus_param_updates),
    beginBlockEvents: Ho(e.begin_block_events || []),
    endBlockEvents: Ho(e.end_block_events || [])
  };
}
function Ji(e) {
  return {
    hash: (0, de.fromHex)((0, j.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, j.assertNotEmpty)(e.parts.total),
      hash: (0, de.fromHex)((0, j.assertNotEmpty)(e.parts.hash))
    }
  };
}
function ZS(e) {
  return {
    block: (0, ue.apiToSmallInt)(e.block),
    app: (0, ue.apiToSmallInt)(e.app ?? 0)
  };
}
function Di(e) {
  return {
    version: ZS(e.version),
    chainId: (0, j.assertNotEmpty)(e.chain_id),
    height: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    time: (0, xt.fromRfc3339WithNanoseconds)((0, j.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? Ji(e.last_block_id) : null,
    lastCommitHash: (0, de.fromHex)((0, j.assertSet)(e.last_commit_hash)),
    dataHash: (0, de.fromHex)((0, j.assertSet)(e.data_hash)),
    validatorsHash: (0, de.fromHex)((0, j.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, de.fromHex)((0, j.assertSet)(e.next_validators_hash)),
    consensusHash: (0, de.fromHex)((0, j.assertSet)(e.consensus_hash)),
    appHash: (0, de.fromHex)((0, j.assertSet)(e.app_hash)),
    lastResultsHash: (0, de.fromHex)((0, j.assertSet)(e.last_results_hash)),
    evidenceHash: (0, de.fromHex)((0, j.assertSet)(e.evidence_hash)),
    proposerAddress: (0, de.fromHex)((0, j.assertNotEmpty)(e.proposer_address))
  };
}
function QS(e) {
  return {
    blockId: Ji(e.block_id),
    blockSize: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.block_size)),
    header: Di(e.header),
    numTxs: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.num_txs))
  };
}
function FS(e) {
  return {
    lastHeight: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.last_height)),
    blockMetas: (0, j.assertArray)(e.block_metas).map(QS)
  };
}
function GS(e) {
  return {
    ...Ut(e),
    hash: (0, de.fromHex)((0, j.assertNotEmpty)(e.hash))
  };
}
function $S(e) {
  return {
    height: (0, ue.apiToSmallInt)(e.height),
    hash: (0, de.fromHex)((0, j.assertNotEmpty)(e.hash)),
    checkTx: Ut((0, j.assertObject)(e.check_tx)),
    deliverTx: (0, j.may)(Ut, e.deliver_tx)
  };
}
function KS(e) {
  return (0, Pc.assert)(e in BS.BlockIdFlag), e;
}
function zS(e) {
  return e && !e.startsWith("0001-01-01") ? (0, xt.fromRfc3339WithNanoseconds)(e) : void 0;
}
function YS(e) {
  return {
    blockIdFlag: KS(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, de.fromHex)(e.validator_address) : void 0,
    timestamp: zS(e.timestamp),
    signature: e.signature ? (0, de.fromBase64)(e.signature) : void 0
  };
}
function _c(e) {
  return {
    blockId: Ji((0, j.assertObject)(e.block_id)),
    height: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    round: (0, ue.apiToSmallInt)(e.round),
    signatures: (0, j.assertArray)(e.signatures).map(YS)
  };
}
function XS(e) {
  return {
    canonical: (0, j.assertBoolean)(e.canonical),
    header: Di(e.signed_header.header),
    commit: _c(e.signed_header.commit)
  };
}
function Nc(e) {
  return {
    address: (0, de.fromHex)((0, j.assertNotEmpty)(e.address)),
    pubkey: Ra((0, j.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, j.assertNotEmpty)(e.power))
  };
}
dn.decodeValidatorGenesis = Nc;
function xS(e) {
  return {
    genesisTime: (0, xt.fromRfc3339WithNanoseconds)((0, j.assertNotEmpty)(e.genesis_time)),
    chainId: (0, j.assertNotEmpty)(e.chain_id),
    consensusParams: kc(e.consensus_params),
    validators: e.validators ? (0, j.assertArray)(e.validators).map(Nc) : [],
    appHash: (0, de.fromHex)((0, j.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function Pa(e) {
  return {
    pubkey: Ra((0, j.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, j.assertNotEmpty)(e.voting_power)),
    address: (0, de.fromHex)((0, j.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, ue.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
dn.decodeValidatorInfo = Pa;
function jS(e) {
  return {
    id: (0, de.fromHex)((0, j.assertNotEmpty)(e.id)),
    listenAddr: (0, j.assertNotEmpty)(e.listen_addr),
    network: (0, j.assertNotEmpty)(e.network),
    version: (0, j.assertString)(e.version),
    channels: (0, j.assertNotEmpty)(e.channels),
    moniker: (0, j.assertNotEmpty)(e.moniker),
    other: (0, j.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.protocol_version.app)),
      block: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function eO(e) {
  const n = e.earliest_block_height ? (0, ue.apiToSmallInt)(e.earliest_block_height) : void 0, c = e.earliest_block_time ? (0, xt.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, de.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, de.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: c != null && c.getTime() ? c : void 0,
    latestBlockHash: (0, de.fromHex)((0, j.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, de.fromHex)((0, j.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, xt.fromRfc3339WithNanoseconds)((0, j.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, j.assertBoolean)(e.catching_up)
  };
}
function nO(e) {
  return {
    nodeInfo: jS(e.node_info),
    syncInfo: eO(e.sync_info),
    validatorInfo: Pa(e.validator_info)
  };
}
function tO(e) {
  return {
    data: (0, de.fromBase64)((0, j.assertNotEmpty)(e.data)),
    rootHash: (0, de.fromHex)((0, j.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.proof.total)),
      index: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.proof.index)),
      leafHash: (0, de.fromBase64)((0, j.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, j.assertArray)(e.proof.aunts).map(de.fromBase64)
    }
  };
}
function Tc(e) {
  return {
    tx: (0, de.fromBase64)((0, j.assertNotEmpty)(e.tx)),
    result: Ut((0, j.assertObject)(e.tx_result)),
    height: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    index: (0, ue.apiToSmallInt)((0, j.assertNumber)(e.index)),
    hash: (0, de.fromHex)((0, j.assertNotEmpty)(e.hash)),
    proof: (0, j.may)(tO, e.proof)
  };
}
function rO(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.total_count)),
    txs: (0, j.assertArray)(e.txs).map(Tc)
  };
}
function iO(e) {
  const n = (0, de.fromBase64)((0, j.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, JS.hashTx)(n),
    result: Ut(e.result),
    height: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.height))
  };
}
function oO(e) {
  return {
    blockHeight: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.block_height)),
    validators: (0, j.assertArray)(e.validators).map(Pa),
    count: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.count)),
    total: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.total))
  };
}
function Ec(e) {
  var n;
  return {
    header: Di((0, j.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? _c((0, j.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, j.assertArray)(e.data.txs).map(de.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function Cc(e) {
  return {
    blockId: Ji(e.block_id),
    block: Ec(e.block)
  };
}
function aO(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.total_count)),
    blocks: (0, j.assertArray)(e.blocks).map(Cc)
  };
}
function sO(e) {
  return {
    total: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.total)),
    totalBytes: (0, ue.apiToSmallInt)((0, j.assertNotEmpty)(e.total_bytes))
  };
}
let dO = class Ic {
  static decodeAbciInfo(n) {
    return DS((0, j.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return MS((0, j.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return Cc(n.result);
  }
  static decodeBlockResults(n) {
    return WS(n.result);
  }
  static decodeBlockSearch(n) {
    return aO(n.result);
  }
  static decodeBlockchain(n) {
    return FS(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return GS(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return Ic.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return $S(n.result);
  }
  static decodeCommit(n) {
    return XS(n.result);
  }
  static decodeGenesis(n) {
    return xS((0, j.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return sO(n.result);
  }
  static decodeStatus(n) {
    return nO(n.result);
  }
  static decodeNewBlockEvent(n) {
    return Ec(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return Di(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return iO(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return Tc(n.result);
  }
  static decodeTxSearch(n) {
    return rO(n.result);
  }
  static decodeValidators(n) {
    return oO(n.result);
  }
};
dn.Responses = dO;
Object.defineProperty(wi, "__esModule", { value: !0 });
wi.adaptor34 = void 0;
const Td = et, uO = bi, cO = dn;
wi.adaptor34 = {
  params: uO.Params,
  responses: cO.Responses,
  hashTx: Td.hashTx,
  hashBlock: Td.hashBlock
};
var lO = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), fO = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), pO = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && lO(n, e, c);
  return fO(n, e), n;
};
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.Tendermint34Client = void 0;
const hO = ot, Pr = Si, Ed = wi, ge = pO(Ci);
class Dr {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let c;
    return typeof n == "object" ? c = new Pr.HttpClient(n) : c = n.startsWith("http://") || n.startsWith("https://") ? new Pr.HttpClient(n) : new Pr.WebsocketClient(n), await this.detectVersion(c), Dr.create(c);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new Dr(n);
  }
  static async detectVersion(n) {
    const c = (0, hO.createJsonRpcRequest)(ge.Method.Status), r = (await n.execute(c)).result;
    if (!r || !r.node_info)
      throw new Error("Unrecognized format for status response");
    const u = r.node_info.version;
    if (typeof u != "string")
      throw new Error("Unrecognized version format: must be string");
    return u;
  }
  /**
   * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n, this.p = Ed.adaptor34.params, this.r = Ed.adaptor34.responses;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: ge.Method.AbciInfo };
    return this.doCall(n, this.p.encodeAbciInfo, this.r.decodeAbciInfo);
  }
  async abciQuery(n) {
    const c = { params: n, method: ge.Method.AbciQuery };
    return this.doCall(c, this.p.encodeAbciQuery, this.r.decodeAbciQuery);
  }
  async block(n) {
    const c = { method: ge.Method.Block, params: { height: n } };
    return this.doCall(c, this.p.encodeBlock, this.r.decodeBlock);
  }
  async blockResults(n) {
    const c = {
      method: ge.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(c, this.p.encodeBlockResults, this.r.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const c = { params: n, method: ge.Method.BlockSearch }, i = await this.doCall(c, this.p.encodeBlockSearch, this.r.decodeBlockSearch);
    return {
      ...i,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...i.blocks].sort((r, u) => r.block.header.height - u.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let c = n.page || 1;
    const i = [];
    let r = !1;
    for (; !r; ) {
      const u = await this.blockSearch({ ...n, page: c });
      i.push(...u.blocks), i.length < u.totalCount ? c++ : r = !0;
    }
    return i.sort((u, f) => u.block.header.height - f.block.header.height), {
      totalCount: i.length,
      blocks: i
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, c) {
    const i = {
      method: ge.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: c
      }
    };
    return this.doCall(i, this.p.encodeBlockchain, this.r.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const c = { params: n, method: ge.Method.BroadcastTxSync };
    return this.doCall(c, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const c = { params: n, method: ge.Method.BroadcastTxAsync };
    return this.doCall(c, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const c = { params: n, method: ge.Method.BroadcastTxCommit };
    return this.doCall(c, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const c = { method: ge.Method.Commit, params: { height: n } };
    return this.doCall(c, this.p.encodeCommit, this.r.decodeCommit);
  }
  async genesis() {
    const n = { method: ge.Method.Genesis };
    return this.doCall(n, this.p.encodeGenesis, this.r.decodeGenesis);
  }
  async health() {
    const n = { method: ge.Method.Health };
    return this.doCall(n, this.p.encodeHealth, this.r.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: ge.Method.NumUnconfirmedTxs };
    return this.doCall(n, this.p.encodeNumUnconfirmedTxs, this.r.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: ge.Method.Status };
    return this.doCall(n, this.p.encodeStatus, this.r.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: ge.Method.Subscribe,
      query: { type: ge.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, this.r.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: ge.Method.Subscribe,
      query: { type: ge.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, this.r.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const c = {
      method: ge.Method.Subscribe,
      query: {
        type: ge.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(c, this.r.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const c = { params: n, method: ge.Method.Tx };
    return this.doCall(c, this.p.encodeTx, this.r.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const c = { params: n, method: ge.Method.TxSearch };
    return this.doCall(c, this.p.encodeTxSearch, this.r.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let c = n.page || 1;
    const i = [];
    let r = !1;
    for (; !r; ) {
      const u = await this.txSearch({ ...n, page: c });
      i.push(...u.txs), i.length < u.totalCount ? c++ : r = !0;
    }
    return {
      totalCount: i.length,
      txs: i
    };
  }
  async validators(n) {
    const c = {
      method: ge.Method.Validators,
      params: n
    };
    return this.doCall(c, this.p.encodeValidators, this.r.decodeValidators);
  }
  async validatorsAll(n) {
    const c = [];
    let i = 1, r = !1, u = n;
    for (; !r; ) {
      const f = await this.validators({
        per_page: 50,
        height: u,
        page: i
      });
      c.push(...f.validators), u = u || f.blockHeight, c.length < f.total ? i++ : r = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: u ?? 0,
      count: c.length,
      total: c.length,
      validators: c
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, c, i) {
    const r = c(n), u = await this.client.execute(r);
    return i(u);
  }
  subscribe(n, c) {
    if (!(0, Pr.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const i = this.p.encodeSubscribe(n);
    return this.client.listen(i).map((u) => c(u));
  }
}
Ii.Tendermint34Client = Dr;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint34Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var n = Ci;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return n.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return n.SubscriptionEventType;
  } });
  var c = Rc;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return c.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return c.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return c.VoteType;
  } });
  var i = Ii;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return i.Tendermint34Client;
  } });
})(Yt);
var Ur = {}, Ui = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(c) {
    c.AbciInfo = "abci_info", c.AbciQuery = "abci_query", c.Block = "block", c.Blockchain = "blockchain", c.BlockResults = "block_results", c.BlockSearch = "block_search", c.BroadcastTxAsync = "broadcast_tx_async", c.BroadcastTxSync = "broadcast_tx_sync", c.BroadcastTxCommit = "broadcast_tx_commit", c.Commit = "commit", c.Genesis = "genesis", c.Health = "health", c.NumUnconfirmedTxs = "num_unconfirmed_txs", c.Status = "status", c.Subscribe = "subscribe", c.Tx = "tx", c.TxSearch = "tx_search", c.Validators = "validators", c.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(c) {
    c.NewBlock = "NewBlock", c.NewBlockHeader = "NewBlockHeader", c.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(c) {
    const r = (c.tags ? c.tags : []).map((f) => `${f.key}='${f.value}'`), u = c.raw ? [c.raw] : [];
    return [...r, ...u].join(" AND ");
  }
  e.buildQuery = n;
})(Ui);
var wc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(i) {
    return i.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function c(i) {
    return i.checkTx.code === 0 && !!i.deliverTx && i.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = c, function(i) {
    i[i.PreVote = 1] = "PreVote", i[i.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(wc);
var Mi = {}, Vi = {}, nt = {}, he = {};
Object.defineProperty(he, "__esModule", { value: !0 });
he.encodeBlockId = he.encodeVersion = he.encodeBytes = he.encodeTime = he.encodeUvarint = he.encodeString = he.dictionaryToStringMap = he.may = he.assertNotEmpty = he.assertObject = he.assertArray = he.assertNumber = he.assertString = he.assertBoolean = he.assertSet = void 0;
const mO = Ve;
function st(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
he.assertSet = st;
function gO(e) {
  if (st(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
he.assertBoolean = gO;
function yO(e) {
  if (st(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
he.assertString = yO;
function SO(e) {
  if (st(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
he.assertNumber = SO;
function OO(e) {
  if (st(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
he.assertArray = OO;
function RO(e) {
  if (st(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
he.assertObject = RO;
function PO(e) {
  if (st(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
he.assertNotEmpty = PO;
function vO(e, n) {
  return n == null ? void 0 : e(n);
}
he.may = vO;
function kO(e) {
  const n = /* @__PURE__ */ new Map();
  for (const c of Object.keys(e)) {
    const i = e[c];
    if (typeof i != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(c, i);
  }
  return n;
}
he.dictionaryToStringMap = kO;
function AO(e) {
  const n = (0, mO.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
he.encodeString = AO;
function Mt(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Mt(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
he.encodeUvarint = Mt;
function _O(e) {
  const n = e.getTime(), c = Math.floor(n / 1e3), i = c ? [8, ...Mt(c)] : new Uint8Array(), r = (e.nanoseconds || 0) + n % 1e3 * 1e6, u = r ? [16, ...Mt(r)] : new Uint8Array();
  return Uint8Array.from([...i, ...u]);
}
he.encodeTime = _O;
function NO(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
he.encodeBytes = NO;
function TO(e) {
  const n = e.block ? Uint8Array.from([8, ...Mt(e.block)]) : new Uint8Array(), c = e.app ? Uint8Array.from([16, ...Mt(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...c]);
}
he.encodeVersion = TO;
function EO(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
he.encodeBlockId = EO;
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.hashBlock = nt.hashTx = void 0;
const va = Qo, We = he;
function CO(e) {
  return (0, va.sha256)(e);
}
nt.hashTx = CO;
function IO(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function wO(e) {
  const n = new va.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function bO(e, n) {
  const c = new va.Sha256(Uint8Array.from([1]));
  return c.update(e), c.update(n), c.digest();
}
function qo(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return wO(e[0]);
    default: {
      const n = IO(e.length), c = qo(e.slice(0, n)), i = qo(e.slice(n));
      return bO(c, i);
    }
  }
}
function BO(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, We.encodeVersion)(e.version),
    (0, We.encodeString)(e.chainId),
    (0, We.encodeUvarint)(e.height),
    (0, We.encodeTime)(e.time),
    (0, We.encodeBlockId)(e.lastBlockId),
    (0, We.encodeBytes)(e.lastCommitHash),
    (0, We.encodeBytes)(e.dataHash),
    (0, We.encodeBytes)(e.validatorsHash),
    (0, We.encodeBytes)(e.nextValidatorsHash),
    (0, We.encodeBytes)(e.consensusHash),
    (0, We.encodeBytes)(e.appHash),
    (0, We.encodeBytes)(e.lastResultsHash),
    (0, We.encodeBytes)(e.evidenceHash),
    (0, We.encodeBytes)(e.proposerAddress)
  ];
  return qo(n);
}
nt.hashBlock = BO;
var Li = {}, JO = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), DO = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), UO = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && JO(n, e, c);
  return DO(n, e), n;
};
Object.defineProperty(Li, "__esModule", { value: !0 });
Li.Params = void 0;
const ka = Ve, mn = pn, we = ot, ze = he, MO = UO(Ui);
function No(e) {
  return {
    height: (0, ze.may)(mn.smallIntToApi, e.height)
  };
}
function VO(e) {
  return {
    minHeight: (0, ze.may)(mn.smallIntToApi, e.minHeight),
    maxHeight: (0, ze.may)(mn.smallIntToApi, e.maxHeight)
  };
}
function LO(e) {
  return {
    query: e.query,
    page: (0, ze.may)(mn.smallIntToApi, e.page),
    per_page: (0, ze.may)(mn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function HO(e) {
  return {
    path: (0, ze.assertNotEmpty)(e.path),
    data: (0, ka.toHex)(e.data),
    height: (0, ze.may)(mn.smallIntToApi, e.height),
    prove: e.prove
  };
}
function qO(e) {
  return {
    tx: (0, ka.toBase64)((0, ze.assertNotEmpty)(e.tx))
  };
}
function WO(e) {
  return {
    hash: (0, ka.toBase64)((0, ze.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function ZO(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, ze.may)(mn.smallIntToApi, e.page),
    per_page: (0, ze.may)(mn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function QO(e) {
  return {
    height: (0, ze.may)(mn.smallIntToApi, e.height),
    page: (0, ze.may)(mn.smallIntToApi, e.page),
    per_page: (0, ze.may)(mn.smallIntToApi, e.per_page)
  };
}
class FO {
  static encodeAbciInfo(n) {
    return (0, we.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, we.createJsonRpcRequest)(n.method, HO(n.params));
  }
  static encodeBlock(n) {
    return (0, we.createJsonRpcRequest)(n.method, No(n.params));
  }
  static encodeBlockchain(n) {
    return (0, we.createJsonRpcRequest)(n.method, VO(n.params));
  }
  static encodeBlockResults(n) {
    return (0, we.createJsonRpcRequest)(n.method, No(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, we.createJsonRpcRequest)(n.method, LO(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, we.createJsonRpcRequest)(n.method, qO(n.params));
  }
  static encodeCommit(n) {
    return (0, we.createJsonRpcRequest)(n.method, No(n.params));
  }
  static encodeGenesis(n) {
    return (0, we.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, we.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, we.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, we.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const c = { key: "tm.event", value: n.query.type }, i = MO.buildQuery({ tags: [c], raw: n.query.raw });
    return (0, we.createJsonRpcRequest)("subscribe", { query: i });
  }
  static encodeTx(n) {
    return (0, we.createJsonRpcRequest)(n.method, WO(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, we.createJsonRpcRequest)(n.method, ZO(n.params));
  }
  static encodeValidators(n) {
    return (0, we.createJsonRpcRequest)(n.method, QO(n.params));
  }
}
Li.Params = FO;
var un = {};
Object.defineProperty(un, "__esModule", { value: !0 });
un.Responses = un.decodeValidatorInfo = un.decodeValidatorGenesis = un.decodeValidatorUpdate = un.decodeEvent = void 0;
const le = Ve, bc = yn, jt = $e, ce = pn, GO = Bi, ee = he, $O = nt;
function KO(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, ee.may)(ce.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, ee.may)(le.fromBase64, e.last_block_app_hash)
  };
}
function zO(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, le.fromBase64)(n.key),
      data: (0, le.fromBase64)(n.data)
    }))
  };
}
function YO(e) {
  return {
    key: (0, le.fromBase64)((0, ee.assertString)(e.key ?? "")),
    value: (0, le.fromBase64)((0, ee.assertString)(e.value ?? "")),
    proof: (0, ee.may)(zO, e.proofOps),
    height: (0, ee.may)(ce.apiToSmallInt, e.height),
    code: (0, ee.may)(ce.apiToSmallInt, e.code),
    codespace: (0, ee.assertString)(e.codespace ?? ""),
    index: (0, ee.may)(ce.apiToSmallInt, e.index),
    log: e.log,
    info: (0, ee.assertString)(e.info ?? "")
  };
}
function XO(e) {
  return {
    key: (0, ee.assertNotEmpty)(e.key),
    value: e.value ?? ""
  };
}
function xO(e) {
  return (0, ee.assertArray)(e).map(XO);
}
function Bc(e) {
  return {
    type: e.type,
    attributes: e.attributes ? xO(e.attributes) : []
  };
}
un.decodeEvent = Bc;
function Wo(e) {
  return (0, ee.assertArray)(e).map(Bc);
}
function Vt(e) {
  return {
    code: (0, ce.apiToSmallInt)((0, ee.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, ee.may)(le.fromBase64, e.data),
    events: e.events ? Wo(e.events) : [],
    gasWanted: (0, ce.apiToSmallInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, ce.apiToSmallInt)(e.gas_used ?? "0")
  };
}
function Aa(e) {
  if ("Sum" in e) {
    const [[n, c]] = Object.entries(e.Sum.value);
    return (0, bc.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, le.fromBase64)((0, ee.assertNotEmpty)(c))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function jO(e) {
  return {
    maxBytes: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_gas))
  };
}
function eR(e) {
  return {
    maxAgeNumBlocks: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_age_duration))
  };
}
function Jc(e) {
  return {
    block: jO((0, ee.assertObject)(e.block)),
    evidence: eR((0, ee.assertObject)(e.evidence))
  };
}
function Dc(e) {
  return {
    pubkey: Aa((0, ee.assertObject)(e.pub_key)),
    votingPower: (0, ce.apiToBigInt)(e.power ?? "0")
  };
}
un.decodeValidatorUpdate = Dc;
function nR(e) {
  return {
    height: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Vt),
    validatorUpdates: (e.validator_updates || []).map(Dc),
    consensusUpdates: (0, ee.may)(Jc, e.consensus_param_updates),
    beginBlockEvents: Wo(e.begin_block_events || []),
    endBlockEvents: Wo(e.end_block_events || [])
  };
}
function Hi(e) {
  return {
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, ee.assertNotEmpty)(e.parts.total),
      hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.parts.hash))
    }
  };
}
function tR(e) {
  return {
    block: (0, ce.apiToSmallInt)(e.block),
    app: (0, ce.apiToSmallInt)(e.app ?? 0)
  };
}
function qi(e) {
  return {
    version: tR(e.version),
    chainId: (0, ee.assertNotEmpty)(e.chain_id),
    height: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    time: (0, jt.fromRfc3339WithNanoseconds)((0, ee.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? Hi(e.last_block_id) : null,
    lastCommitHash: (0, le.fromHex)((0, ee.assertSet)(e.last_commit_hash)),
    dataHash: (0, le.fromHex)((0, ee.assertSet)(e.data_hash)),
    validatorsHash: (0, le.fromHex)((0, ee.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, le.fromHex)((0, ee.assertSet)(e.next_validators_hash)),
    consensusHash: (0, le.fromHex)((0, ee.assertSet)(e.consensus_hash)),
    appHash: (0, le.fromHex)((0, ee.assertSet)(e.app_hash)),
    lastResultsHash: (0, le.fromHex)((0, ee.assertSet)(e.last_results_hash)),
    evidenceHash: (0, le.fromHex)((0, ee.assertSet)(e.evidence_hash)),
    proposerAddress: (0, le.fromHex)((0, ee.assertNotEmpty)(e.proposer_address))
  };
}
function rR(e) {
  return {
    blockId: Hi(e.block_id),
    blockSize: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.block_size)),
    header: qi(e.header),
    numTxs: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.num_txs))
  };
}
function iR(e) {
  return {
    lastHeight: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.last_height)),
    blockMetas: (0, ee.assertArray)(e.block_metas).map(rR)
  };
}
function oR(e) {
  return {
    ...Vt(e),
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash))
  };
}
function aR(e) {
  return {
    height: (0, ce.apiToSmallInt)(e.height),
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash)),
    checkTx: Vt((0, ee.assertObject)(e.check_tx)),
    deliverTx: (0, ee.may)(Vt, e.deliver_tx)
  };
}
function sR(e) {
  return (0, bc.assert)(e in GO.BlockIdFlag), e;
}
function dR(e) {
  return e && !e.startsWith("0001-01-01") ? (0, jt.fromRfc3339WithNanoseconds)(e) : void 0;
}
function uR(e) {
  return {
    blockIdFlag: sR(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, le.fromHex)(e.validator_address) : void 0,
    timestamp: dR(e.timestamp),
    signature: e.signature ? (0, le.fromBase64)(e.signature) : void 0
  };
}
function Uc(e) {
  return {
    blockId: Hi((0, ee.assertObject)(e.block_id)),
    height: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    round: (0, ce.apiToSmallInt)(e.round),
    signatures: (0, ee.assertArray)(e.signatures).map(uR)
  };
}
function cR(e) {
  return {
    canonical: (0, ee.assertBoolean)(e.canonical),
    header: qi(e.signed_header.header),
    commit: Uc(e.signed_header.commit)
  };
}
function Mc(e) {
  return {
    address: (0, le.fromHex)((0, ee.assertNotEmpty)(e.address)),
    pubkey: Aa((0, ee.assertObject)(e.pub_key)),
    votingPower: (0, ce.apiToBigInt)((0, ee.assertNotEmpty)(e.power))
  };
}
un.decodeValidatorGenesis = Mc;
function lR(e) {
  return {
    genesisTime: (0, jt.fromRfc3339WithNanoseconds)((0, ee.assertNotEmpty)(e.genesis_time)),
    chainId: (0, ee.assertNotEmpty)(e.chain_id),
    consensusParams: Jc(e.consensus_params),
    validators: e.validators ? (0, ee.assertArray)(e.validators).map(Mc) : [],
    appHash: (0, le.fromHex)((0, ee.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function _a(e) {
  return {
    pubkey: Aa((0, ee.assertObject)(e.pub_key)),
    votingPower: (0, ce.apiToBigInt)((0, ee.assertNotEmpty)(e.voting_power)),
    address: (0, le.fromHex)((0, ee.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, ce.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
un.decodeValidatorInfo = _a;
function fR(e) {
  return {
    id: (0, le.fromHex)((0, ee.assertNotEmpty)(e.id)),
    listenAddr: (0, ee.assertNotEmpty)(e.listen_addr),
    network: (0, ee.assertNotEmpty)(e.network),
    version: (0, ee.assertString)(e.version),
    channels: (0, ee.assertNotEmpty)(e.channels),
    moniker: (0, ee.assertNotEmpty)(e.moniker),
    other: (0, ee.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.protocol_version.app)),
      block: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function pR(e) {
  const n = e.earliest_block_height ? (0, ce.apiToSmallInt)(e.earliest_block_height) : void 0, c = e.earliest_block_time ? (0, jt.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, le.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, le.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: c != null && c.getTime() ? c : void 0,
    latestBlockHash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, jt.fromRfc3339WithNanoseconds)((0, ee.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, ee.assertBoolean)(e.catching_up)
  };
}
function hR(e) {
  return {
    nodeInfo: fR(e.node_info),
    syncInfo: pR(e.sync_info),
    validatorInfo: _a(e.validator_info)
  };
}
function mR(e) {
  return {
    data: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.data)),
    rootHash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.proof.total)),
      index: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.proof.index)),
      leafHash: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, ee.assertArray)(e.proof.aunts).map(le.fromBase64)
    }
  };
}
function Vc(e) {
  return {
    tx: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.tx)),
    result: Vt((0, ee.assertObject)(e.tx_result)),
    height: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    index: (0, ce.apiToSmallInt)((0, ee.assertNumber)(e.index)),
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash)),
    proof: (0, ee.may)(mR, e.proof)
  };
}
function gR(e) {
  return {
    totalCount: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.total_count)),
    txs: (0, ee.assertArray)(e.txs).map(Vc)
  };
}
function yR(e) {
  const n = (0, le.fromBase64)((0, ee.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, $O.hashTx)(n),
    result: Vt(e.result),
    height: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.height))
  };
}
function SR(e) {
  return {
    blockHeight: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.block_height)),
    validators: (0, ee.assertArray)(e.validators).map(_a),
    count: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.count)),
    total: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.total))
  };
}
function Lc(e) {
  var n;
  return {
    header: qi((0, ee.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? Uc((0, ee.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, ee.assertArray)(e.data.txs).map(le.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function Hc(e) {
  return {
    blockId: Hi(e.block_id),
    block: Lc(e.block)
  };
}
function OR(e) {
  return {
    totalCount: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.total_count)),
    blocks: (0, ee.assertArray)(e.blocks).map(Hc)
  };
}
function RR(e) {
  return {
    total: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.total)),
    totalBytes: (0, ce.apiToSmallInt)((0, ee.assertNotEmpty)(e.total_bytes))
  };
}
class Na {
  static decodeAbciInfo(n) {
    return KO((0, ee.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return YO((0, ee.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return Hc(n.result);
  }
  static decodeBlockResults(n) {
    return nR(n.result);
  }
  static decodeBlockSearch(n) {
    return OR(n.result);
  }
  static decodeBlockchain(n) {
    return iR(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return oR(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return Na.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return aR(n.result);
  }
  static decodeCommit(n) {
    return cR(n.result);
  }
  static decodeGenesis(n) {
    return lR((0, ee.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return RR(n.result);
  }
  static decodeStatus(n) {
    return hR(n.result);
  }
  static decodeNewBlockEvent(n) {
    return Lc(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return qi(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return yR(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return Vc(n.result);
  }
  static decodeTxSearch(n) {
    return gR(n.result);
  }
  static decodeValidators(n) {
    return SR(n.result);
  }
}
un.Responses = Na;
Object.defineProperty(Vi, "__esModule", { value: !0 });
Vi.adaptor37 = void 0;
const Cd = nt, PR = Li, vR = un;
Vi.adaptor37 = {
  params: PR.Params,
  responses: vR.Responses,
  hashTx: Cd.hashTx,
  hashBlock: Cd.hashBlock
};
var kR = G && G.__createBinding || (Object.create ? function(e, n, c, i) {
  i === void 0 && (i = c);
  var r = Object.getOwnPropertyDescriptor(n, c);
  (!r || ("get" in r ? !n.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(e, i, r);
} : function(e, n, c, i) {
  i === void 0 && (i = c), e[i] = n[c];
}), AR = G && G.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), _R = G && G.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var c in e)
      c !== "default" && Object.prototype.hasOwnProperty.call(e, c) && kR(n, e, c);
  return AR(n, e), n;
};
Object.defineProperty(Mi, "__esModule", { value: !0 });
Mi.Tendermint37Client = void 0;
const NR = ot, vr = Si, Id = Vi, ye = _R(Ui);
class Mr {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let c;
    return typeof n == "object" ? c = new vr.HttpClient(n) : c = n.startsWith("http://") || n.startsWith("https://") ? new vr.HttpClient(n) : new vr.WebsocketClient(n), await this.detectVersion(c), Mr.create(c);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new Mr(n);
  }
  static async detectVersion(n) {
    const c = (0, NR.createJsonRpcRequest)(ye.Method.Status), r = (await n.execute(c)).result;
    if (!r || !r.node_info)
      throw new Error("Unrecognized format for status response");
    const u = r.node_info.version;
    if (typeof u != "string")
      throw new Error("Unrecognized version format: must be string");
    return u;
  }
  /**
   * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n, this.p = Id.adaptor37.params, this.r = Id.adaptor37.responses;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: ye.Method.AbciInfo };
    return this.doCall(n, this.p.encodeAbciInfo, this.r.decodeAbciInfo);
  }
  async abciQuery(n) {
    const c = { params: n, method: ye.Method.AbciQuery };
    return this.doCall(c, this.p.encodeAbciQuery, this.r.decodeAbciQuery);
  }
  async block(n) {
    const c = { method: ye.Method.Block, params: { height: n } };
    return this.doCall(c, this.p.encodeBlock, this.r.decodeBlock);
  }
  async blockResults(n) {
    const c = {
      method: ye.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(c, this.p.encodeBlockResults, this.r.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const c = { params: n, method: ye.Method.BlockSearch }, i = await this.doCall(c, this.p.encodeBlockSearch, this.r.decodeBlockSearch);
    return {
      ...i,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...i.blocks].sort((r, u) => r.block.header.height - u.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let c = n.page || 1;
    const i = [];
    let r = !1;
    for (; !r; ) {
      const u = await this.blockSearch({ ...n, page: c });
      i.push(...u.blocks), i.length < u.totalCount ? c++ : r = !0;
    }
    return i.sort((u, f) => u.block.header.height - f.block.header.height), {
      totalCount: i.length,
      blocks: i
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, c) {
    const i = {
      method: ye.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: c
      }
    };
    return this.doCall(i, this.p.encodeBlockchain, this.r.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const c = { params: n, method: ye.Method.BroadcastTxSync };
    return this.doCall(c, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const c = { params: n, method: ye.Method.BroadcastTxAsync };
    return this.doCall(c, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const c = { params: n, method: ye.Method.BroadcastTxCommit };
    return this.doCall(c, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const c = { method: ye.Method.Commit, params: { height: n } };
    return this.doCall(c, this.p.encodeCommit, this.r.decodeCommit);
  }
  async genesis() {
    const n = { method: ye.Method.Genesis };
    return this.doCall(n, this.p.encodeGenesis, this.r.decodeGenesis);
  }
  async health() {
    const n = { method: ye.Method.Health };
    return this.doCall(n, this.p.encodeHealth, this.r.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: ye.Method.NumUnconfirmedTxs };
    return this.doCall(n, this.p.encodeNumUnconfirmedTxs, this.r.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: ye.Method.Status };
    return this.doCall(n, this.p.encodeStatus, this.r.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: ye.Method.Subscribe,
      query: { type: ye.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, this.r.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: ye.Method.Subscribe,
      query: { type: ye.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, this.r.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const c = {
      method: ye.Method.Subscribe,
      query: {
        type: ye.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(c, this.r.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const c = { params: n, method: ye.Method.Tx };
    return this.doCall(c, this.p.encodeTx, this.r.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const c = { params: n, method: ye.Method.TxSearch };
    return this.doCall(c, this.p.encodeTxSearch, this.r.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let c = n.page || 1;
    const i = [];
    let r = !1;
    for (; !r; ) {
      const u = await this.txSearch({ ...n, page: c });
      i.push(...u.txs), i.length < u.totalCount ? c++ : r = !0;
    }
    return {
      totalCount: i.length,
      txs: i
    };
  }
  async validators(n) {
    const c = {
      method: ye.Method.Validators,
      params: n
    };
    return this.doCall(c, this.p.encodeValidators, this.r.decodeValidators);
  }
  async validatorsAll(n) {
    const c = [];
    let i = 1, r = !1, u = n;
    for (; !r; ) {
      const f = await this.validators({
        per_page: 50,
        height: u,
        page: i
      });
      c.push(...f.validators), u = u || f.blockHeight, c.length < f.total ? i++ : r = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: u ?? 0,
      count: c.length,
      total: c.length,
      validators: c
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, c, i) {
    const r = c(n), u = await this.client.execute(r);
    return i(u);
  }
  subscribe(n, c) {
    if (!(0, vr.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const i = this.p.encodeSubscribe(n);
    return this.client.listen(i).map((u) => c(u));
  }
}
Mi.Tendermint37Client = Mr;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint37Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var n = Ui;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return n.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return n.SubscriptionEventType;
  } });
  var c = wc;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return c.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return c.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return c.VoteType;
  } });
  var i = Mi;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return i.Tendermint37Client;
  } });
})(Ur);
var Lt = {};
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.isTendermint37Client = Lt.isTendermint34Client = void 0;
const TR = Yt, ER = Ur;
function CR(e) {
  return e instanceof TR.Tendermint34Client;
}
Lt.isTendermint34Client = CR;
function IR(e) {
  return e instanceof ER.Tendermint37Client;
}
Lt.isTendermint37Client = IR;
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(V, D, b, h) {
    h === void 0 && (h = b);
    var S = Object.getOwnPropertyDescriptor(D, b);
    (!S || ("get" in S ? !D.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return D[b];
    } }), Object.defineProperty(V, h, S);
  } : function(V, D, b, h) {
    h === void 0 && (h = b), V[h] = D[b];
  }), c = G && G.__setModuleDefault || (Object.create ? function(V, D) {
    Object.defineProperty(V, "default", { enumerable: !0, value: D });
  } : function(V, D) {
    V.default = D;
  }), i = G && G.__importStar || function(V) {
    if (V && V.__esModule)
      return V;
    var D = {};
    if (V != null)
      for (var b in V)
        b !== "default" && Object.prototype.hasOwnProperty.call(V, b) && n(D, V, b);
    return c(D, V), D;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = e.isTendermint37Client = e.isTendermint34Client = e.Tendermint37Client = e.tendermint37 = e.Tendermint34Client = e.tendermint34 = e.VoteType = e.SubscriptionEventType = e.Method = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.WebsocketClient = e.HttpClient = e.HttpBatchClient = e.toSeconds = e.toRfc3339WithNanoseconds = e.fromSeconds = e.fromRfc3339WithNanoseconds = e.DateTime = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var r = kn;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return r.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return r.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return r.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return r.rawSecp256k1PubkeyToRawAddress;
  } });
  var u = $e;
  Object.defineProperty(e, "DateTime", { enumerable: !0, get: function() {
    return u.DateTime;
  } }), Object.defineProperty(e, "fromRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return u.fromRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "fromSeconds", { enumerable: !0, get: function() {
    return u.fromSeconds;
  } }), Object.defineProperty(e, "toRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return u.toRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "toSeconds", { enumerable: !0, get: function() {
    return u.toSeconds;
  } });
  var f = Si;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return f.HttpBatchClient;
  } }), Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return f.HttpClient;
  } }), Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return f.WebsocketClient;
  } });
  var O = Yt;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return O.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return O.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return O.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return O.SubscriptionEventType;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return O.VoteType;
  } }), e.tendermint34 = i(Yt);
  var A = Yt;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return A.Tendermint34Client;
  } }), e.tendermint37 = i(Ur);
  var T = Ur;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return T.Tendermint37Client;
  } });
  var L = Lt;
  Object.defineProperty(e, "isTendermint34Client", { enumerable: !0, get: function() {
    return L.isTendermint34Client;
  } }), Object.defineProperty(e, "isTendermint37Client", { enumerable: !0, get: function() {
    return L.isTendermint37Client;
  } });
  var M = Bi;
  Object.defineProperty(e, "BlockIdFlag", { enumerable: !0, get: function() {
    return M.BlockIdFlag;
  } });
})(ua);
var Te = {};
Object.defineProperty(Te, "__esModule", { value: !0 });
Te.StargateClient = Te.BroadcastTxError = Te.assertIsDeliverTxFailure = Te.assertIsDeliverTxSuccess = Te.isDeliverTxSuccess = Te.isDeliverTxFailure = Te.TimeoutError = void 0;
const wR = Fo, To = Ve, wd = _n, Eo = ua, bd = yn, bR = da, BR = nr, JR = rr, kr = Xt, DR = Le;
class qc extends Error {
  constructor(n, c) {
    super(n), this.txId = c;
  }
}
Te.TimeoutError = qc;
function Ta(e) {
  return !!e.code;
}
Te.isDeliverTxFailure = Ta;
function Wc(e) {
  return !Ta(e);
}
Te.isDeliverTxSuccess = Wc;
function UR(e) {
  if (Ta(e))
    throw new Error(`Error when broadcasting tx ${e.transactionHash} at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
Te.assertIsDeliverTxSuccess = UR;
function MR(e) {
  if (Wc(e))
    throw new Error(`Transaction ${e.transactionHash} did not fail at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
Te.assertIsDeliverTxFailure = MR;
class Zc extends Error {
  constructor(n, c, i) {
    super(`Broadcasting transaction failed with code ${n} (codespace: ${c}). Log: ${i}`), this.code = n, this.codespace = c, this.log = i;
  }
}
Te.BroadcastTxError = Zc;
class Vr {
  /**
   * Creates an instance by connecting to the given Tendermint RPC endpoint.
   *
   * This uses auto-detection to decide between a Tendermint 0.37 and 0.34 client.
   * To set the Tendermint client explicitly, use `create`.
   */
  static async connect(n, c = {}) {
    let i;
    const r = await Eo.Tendermint37Client.connect(n);
    return (await r.status()).nodeInfo.version.startsWith("0.37.") ? i = r : (r.disconnect(), i = await Eo.Tendermint34Client.connect(n)), Vr.create(i, c);
  }
  /**
   * Creates an instance from a manually created Tendermint client.
   * Use this to use `Tendermint37Client` instead of `Tendermint34Client`.
   */
  static async create(n, c = {}) {
    return new Vr(n, c);
  }
  constructor(n, c) {
    n && (this.tmClient = n, this.queryClient = DR.QueryClient.withExtensions(n, kr.setupAuthExtension, kr.setupBankExtension, kr.setupStakingExtension, kr.setupTxExtension));
    const { accountParser: i = BR.accountFromAny } = c;
    this.accountParser = i;
  }
  getTmClient() {
    return this.tmClient;
  }
  forceGetTmClient() {
    if (!this.tmClient)
      throw new Error("Tendermint client not available. You cannot use online functionality in offline mode.");
    return this.tmClient;
  }
  getQueryClient() {
    return this.queryClient;
  }
  forceGetQueryClient() {
    if (!this.queryClient)
      throw new Error("Query client not available. You cannot use online functionality in offline mode.");
    return this.queryClient;
  }
  async getChainId() {
    if (!this.chainId) {
      const c = (await this.forceGetTmClient().status()).nodeInfo.network;
      if (!c)
        throw new Error("Chain ID must not be empty");
      this.chainId = c;
    }
    return this.chainId;
  }
  async getHeight() {
    return (await this.forceGetTmClient().status()).syncInfo.latestBlockHeight;
  }
  async getAccount(n) {
    try {
      const c = await this.forceGetQueryClient().auth.account(n);
      return c ? this.accountParser(c) : null;
    } catch (c) {
      if (/rpc error: code = NotFound/i.test(c.toString()))
        return null;
      throw c;
    }
  }
  async getSequence(n) {
    const c = await this.getAccount(n);
    if (!c)
      throw new Error(`Account '${n}' does not exist on chain. Send some tokens there before trying to query sequence.`);
    return {
      accountNumber: c.accountNumber,
      sequence: c.sequence
    };
  }
  async getBlock(n) {
    const c = await this.forceGetTmClient().block(n);
    return {
      id: (0, To.toHex)(c.blockId.hash).toUpperCase(),
      header: {
        version: {
          block: new wd.Uint53(c.block.header.version.block).toString(),
          app: new wd.Uint53(c.block.header.version.app).toString()
        },
        height: c.block.header.height,
        chainId: c.block.header.chainId,
        time: (0, Eo.toRfc3339WithNanoseconds)(c.block.header.time)
      },
      txs: c.block.txs
    };
  }
  async getBalance(n, c) {
    return this.forceGetQueryClient().bank.balance(n, c);
  }
  /**
   * Queries all balances for all denoms that belong to this address.
   *
   * Uses the grpc queries (which iterates over the store internally), and we cannot get
   * proofs from such a method.
   */
  async getAllBalances(n) {
    return this.forceGetQueryClient().bank.allBalances(n);
  }
  async getBalanceStaked(n) {
    const c = [];
    let i;
    do {
      const { delegationResponses: u, pagination: f } = await this.forceGetQueryClient().staking.delegatorDelegations(n, i), O = u || [];
      c.push(...O), i = f == null ? void 0 : f.nextKey;
    } while (i !== void 0 && i.length !== 0);
    return c.reduce((u, f) => ((0, bd.assert)(f.balance), u !== null ? (0, wR.addCoins)(u, f.balance) : f.balance), null);
  }
  async getDelegation(n, c) {
    var r;
    let i;
    try {
      i = (r = (await this.forceGetQueryClient().staking.delegation(n, c)).delegationResponse) == null ? void 0 : r.balance;
    } catch (u) {
      if (!u.toString().includes("key not found"))
        throw u;
    }
    return i || null;
  }
  async getTx(n) {
    return (await this.txsQuery(`tx.hash='${n}'`))[0] ?? null;
  }
  async searchTx(n) {
    let c;
    if (typeof n == "string")
      c = n;
    else if (Array.isArray(n))
      c = n.map((i) => `${i.key}='${i.value}'`).join(" AND ");
    else
      throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
    return this.txsQuery(c);
  }
  disconnect() {
    this.tmClient && this.tmClient.disconnect();
  }
  /**
   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
   *
   * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
   * usually needs to check for execution success or failure.
   */
  async broadcastTx(n, c = 6e4, i = 3e3) {
    let r = !1;
    const u = setTimeout(() => {
      r = !0;
    }, c), f = async (A) => {
      if (r)
        throw new qc(`Transaction with ID ${A} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${c / 1e3} seconds.`, A);
      await (0, bd.sleep)(i);
      const T = await this.getTx(A);
      return T ? {
        code: T.code,
        height: T.height,
        txIndex: T.txIndex,
        events: T.events,
        rawLog: T.rawLog,
        transactionHash: A,
        msgResponses: T.msgResponses,
        gasUsed: T.gasUsed,
        gasWanted: T.gasWanted
      } : f(A);
    }, O = await this.broadcastTxSync(n);
    return new Promise((A, T) => f(O).then((L) => {
      clearTimeout(u), A(L);
    }, (L) => {
      clearTimeout(u), T(L);
    }));
  }
  /**
   * Broadcasts a signed transaction to the network without monitoring it.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
   * usually needs to check if the transaction was included in a block and was successful.
   *
   * @returns Returns the hash of the transaction
   */
  async broadcastTxSync(n) {
    const c = await this.forceGetTmClient().broadcastTxSync({ tx: n });
    return c.code ? Promise.reject(new Zc(c.code, c.codespace ?? "", c.log)) : (0, To.toHex)(c.hash).toUpperCase();
  }
  async txsQuery(n) {
    return (await this.forceGetTmClient().txSearchAll({ query: n })).txs.map((i) => {
      const r = bR.TxMsgData.decode(i.result.data ?? new Uint8Array());
      return {
        height: i.height,
        txIndex: i.index,
        hash: (0, To.toHex)(i.hash).toUpperCase(),
        code: i.result.code,
        events: i.result.events.map(JR.fromTendermintEvent),
        rawLog: i.result.log || "",
        tx: i.tx,
        msgResponses: r.msgResponses,
        gasUsed: i.result.gasUsed,
        gasWanted: i.result.gasWanted
      };
    });
  }
}
Te.StargateClient = Vr;
(function(e) {
  var n = G && G.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SigningStargateClient = e.createDefaultAminoConverters = e.defaultRegistryTypes = void 0;
  const c = Fo, i = Ve, r = _n, u = tt, f = ua, O = yn, A = Me, T = ea, L = oa, M = Zo, V = er, D = ui, b = n(An), h = tr, S = xn, _ = Xt, d = Xt, p = Te;
  e.defaultRegistryTypes = [
    ["/cosmos.base.v1beta1.Coin", A.Coin],
    ..._.authzTypes,
    ..._.bankTypes,
    ..._.distributionTypes,
    ..._.feegrantTypes,
    ..._.govTypes,
    ..._.groupTypes,
    ..._.stakingTypes,
    ..._.ibcTypes,
    ..._.vestingTypes
  ];
  function g() {
    return {
      ...(0, d.createAuthzAminoConverters)(),
      ...(0, d.createBankAminoConverters)(),
      ...(0, d.createDistributionAminoConverters)(),
      ...(0, d.createGovAminoConverters)(),
      ...(0, d.createStakingAminoConverters)(),
      ...(0, d.createIbcAminoConverters)(),
      ...(0, d.createFeegrantAminoConverters)(),
      ...(0, d.createVestingAminoConverters)()
    };
  }
  e.createDefaultAminoConverters = g;
  class J extends p.StargateClient {
    /**
     * Creates an instance by connecting to the given Tendermint RPC endpoint.
     *
     * This uses auto-detection to decide between a Tendermint 0.37 and 0.34 client.
     * To set the Tendermint client explicitly, use `createWithSigner`.
     */
    static async connectWithSigner(I, Z, t = {}) {
      let y;
      const E = await f.Tendermint37Client.connect(I);
      return (await E.status()).nodeInfo.version.startsWith("0.37.") ? y = E : (E.disconnect(), y = await f.Tendermint34Client.connect(I)), J.createWithSigner(y, Z, t);
    }
    /**
     * Creates an instance from a manually created Tendermint client.
     * Use this to use `Tendermint37Client` instead of `Tendermint34Client`.
     */
    static async createWithSigner(I, Z, t = {}) {
      return new J(I, Z, t);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */
    static async offline(I, Z = {}) {
      return new J(void 0, I, Z);
    }
    constructor(I, Z, t) {
      super(I, t);
      const { registry: y = new u.Registry(e.defaultRegistryTypes), aminoTypes: E = new h.AminoTypes(g()) } = t;
      this.registry = y, this.aminoTypes = E, this.signer = Z, this.broadcastTimeoutMs = t.broadcastTimeoutMs, this.broadcastPollIntervalMs = t.broadcastPollIntervalMs, this.gasPrice = t.gasPrice;
    }
    async simulate(I, Z, t) {
      const y = Z.map((C) => this.registry.encodeAsAny(C)), E = (await this.signer.getAccounts()).find((C) => C.address === I);
      if (!E)
        throw new Error("Failed to retrieve account from signer");
      const H = (0, c.encodeSecp256k1Pubkey)(E.pubkey), { sequence: a } = await this.getSequence(I), { gasInfo: l } = await this.forceGetQueryClient().tx.simulate(y, t, H, a);
      return (0, O.assertDefined)(l), r.Uint53.fromString(l.gasUsed.toString()).toNumber();
    }
    async sendTokens(I, Z, t, y, E = "") {
      const H = {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: {
          fromAddress: I,
          toAddress: Z,
          amount: [...t]
        }
      };
      return this.signAndBroadcast(I, [H], y, E);
    }
    async delegateTokens(I, Z, t, y, E = "") {
      const H = {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: L.MsgDelegate.fromPartial({
          delegatorAddress: I,
          validatorAddress: Z,
          amount: t
        })
      };
      return this.signAndBroadcast(I, [H], y, E);
    }
    async undelegateTokens(I, Z, t, y, E = "") {
      const H = {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: L.MsgUndelegate.fromPartial({
          delegatorAddress: I,
          validatorAddress: Z,
          amount: t
        })
      };
      return this.signAndBroadcast(I, [H], y, E);
    }
    async withdrawRewards(I, Z, t, y = "") {
      const E = {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: T.MsgWithdrawDelegatorReward.fromPartial({
          delegatorAddress: I,
          validatorAddress: Z
        })
      };
      return this.signAndBroadcast(I, [E], t, y);
    }
    async sendIbcTokens(I, Z, t, y, E, H, a, l, C = "") {
      const v = a ? b.default.fromNumber(a).multiply(1e9) : void 0, k = {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: D.MsgTransfer.fromPartial({
          sourcePort: y,
          sourceChannel: E,
          sender: I,
          receiver: Z,
          token: t,
          timeoutHeight: H,
          timeoutTimestamp: v
        })
      };
      return this.signAndBroadcast(I, [k], l, C);
    }
    async signAndBroadcast(I, Z, t, y = "") {
      let E;
      if (t == "auto" || typeof t == "number") {
        (0, O.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const l = await this.simulate(I, Z, y), C = typeof t == "number" ? t : 1.4;
        E = (0, S.calculateFee)(Math.round(l * C), this.gasPrice);
      } else
        E = t;
      const H = await this.sign(I, Z, E, y), a = V.TxRaw.encode(H).finish();
      return this.broadcastTx(a, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    /**
     * This method is useful if you want to send a transaction in broadcast,
     * without waiting for it to be placed inside a block, because for example
     * I would like to receive the hash to later track the transaction with another tool.
     * @returns Returns the hash of the transaction
     */
    async signAndBroadcastSync(I, Z, t, y = "") {
      let E;
      if (t == "auto" || typeof t == "number") {
        (0, O.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const l = await this.simulate(I, Z, y), C = typeof t == "number" ? t : 1.3;
        E = (0, S.calculateFee)(Math.round(l * C), this.gasPrice);
      } else
        E = t;
      const H = await this.sign(I, Z, E, y), a = V.TxRaw.encode(H).finish();
      return this.broadcastTxSync(a);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */
    async sign(I, Z, t, y, E) {
      let H;
      if (E)
        H = E;
      else {
        const { accountNumber: a, sequence: l } = await this.getSequence(I), C = await this.getChainId();
        H = {
          accountNumber: a,
          sequence: l,
          chainId: C
        };
      }
      return (0, u.isOfflineDirectSigner)(this.signer) ? this.signDirect(I, Z, t, y, H) : this.signAmino(I, Z, t, y, H);
    }
    async signAmino(I, Z, t, y, { accountNumber: E, sequence: H, chainId: a }) {
      (0, O.assert)(!(0, u.isOfflineDirectSigner)(this.signer));
      const l = (await this.signer.getAccounts()).find((K) => K.address === I);
      if (!l)
        throw new Error("Failed to retrieve account from signer");
      const C = (0, u.encodePubkey)((0, c.encodeSecp256k1Pubkey)(l.pubkey)), v = M.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, k = Z.map((K) => this.aminoTypes.toAmino(K)), U = (0, c.makeSignDoc)(k, t, a, y, E, H), { signature: F, signed: q } = await this.signer.signAmino(I, U), P = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: q.msgs.map((K) => this.aminoTypes.fromAmino(K)),
          memo: q.memo
        }
      }, m = this.registry.encode(P), R = r.Int53.fromString(q.fee.gas).toNumber(), N = r.Int53.fromString(q.sequence).toNumber(), Q = (0, u.makeAuthInfoBytes)([{ pubkey: C, sequence: N }], q.fee.amount, R, q.fee.granter, q.fee.payer, v);
      return V.TxRaw.fromPartial({
        bodyBytes: m,
        authInfoBytes: Q,
        signatures: [(0, i.fromBase64)(F.signature)]
      });
    }
    async signDirect(I, Z, t, y, { accountNumber: E, sequence: H, chainId: a }) {
      (0, O.assert)((0, u.isOfflineDirectSigner)(this.signer));
      const l = (await this.signer.getAccounts()).find((m) => m.address === I);
      if (!l)
        throw new Error("Failed to retrieve account from signer");
      const C = (0, u.encodePubkey)((0, c.encodeSecp256k1Pubkey)(l.pubkey)), v = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: Z,
          memo: y
        }
      }, k = this.registry.encode(v), U = r.Int53.fromString(t.gas).toNumber(), F = (0, u.makeAuthInfoBytes)([{ pubkey: C, sequence: H }], t.amount, U, t.granter, t.payer), q = (0, u.makeSignDoc)(k, F, a, E), { signature: o, signed: P } = await this.signer.signDirect(I, q);
      return V.TxRaw.fromPartial({
        bodyBytes: P.bodyBytes,
        authInfoBytes: P.authInfoBytes,
        signatures: [(0, i.fromBase64)(o.signature)]
      });
    }
  }
  e.SigningStargateClient = J;
})(Gu);
(function(e) {
  var n = G && G.__createBinding || (Object.create ? function(b, h, S, _) {
    _ === void 0 && (_ = S);
    var d = Object.getOwnPropertyDescriptor(h, S);
    (!d || ("get" in d ? !h.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return h[S];
    } }), Object.defineProperty(b, _, d);
  } : function(b, h, S, _) {
    _ === void 0 && (_ = S), b[_] = h[S];
  }), c = G && G.__setModuleDefault || (Object.create ? function(b, h) {
    Object.defineProperty(b, "default", { enumerable: !0, value: h });
  } : function(b, h) {
    b.default = h;
  }), i = G && G.__importStar || function(b) {
    if (b && b.__esModule)
      return b;
    var h = {};
    if (b != null)
      for (var S in b)
        S !== "default" && Object.prototype.hasOwnProperty.call(b, S) && n(h, b, S);
    return c(h, b), h;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMsgWithdrawDelegatorRewardEncodeObject = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgUndelegateEncodeObject = e.isMsgTransferEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgSendEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDepositEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgVerifyInvariant = e.isAminoMsgUnjail = e.isAminoMsgUndelegate = e.isAminoMsgTransfer = e.isAminoMsgSubmitProposal = e.isAminoMsgSubmitEvidence = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.isAminoMsgFundCommunityPool = e.isAminoMsgEditValidator = e.isAminoMsgDeposit = e.isAminoMsgDelegate = e.isAminoMsgCreateVestingAccount = e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createVestingAminoConverters = e.createStakingAminoConverters = e.createSlashingAminoConverters = e.createIbcAminoConverters = e.createGroupAminoConverters = e.createGovAminoConverters = e.createFeegrantAminoConverters = e.createEvidenceAminoConverters = e.createDistributionAminoConverters = e.createCrysisAminoConverters = e.createBankAminoConverters = e.createAuthzAminoConverters = e.logs = e.GasPrice = e.calculateFee = e.fromTendermintEvent = e.AminoTypes = e.accountFromAny = void 0, e.parseCoins = e.makeCosmoshubPath = e.coins = e.coin = e.TimeoutError = e.StargateClient = e.isDeliverTxSuccess = e.isDeliverTxFailure = e.BroadcastTxError = e.assertIsDeliverTxSuccess = e.assertIsDeliverTxFailure = e.SigningStargateClient = e.defaultRegistryTypes = e.createDefaultAminoConverters = e.QueryClient = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.makeMultisignedTxBytes = e.makeMultisignedTx = e.setupTxExtension = e.setupStakingExtension = e.setupSlashingExtension = e.setupMintExtension = e.setupIbcExtension = e.setupGovExtension = e.setupFeegrantExtension = e.setupDistributionExtension = e.setupBankExtension = e.setupAuthzExtension = e.setupAuthExtension = void 0;
  var r = nr;
  Object.defineProperty(e, "accountFromAny", { enumerable: !0, get: function() {
    return r.accountFromAny;
  } });
  var u = tr;
  Object.defineProperty(e, "AminoTypes", { enumerable: !0, get: function() {
    return u.AminoTypes;
  } });
  var f = rr;
  Object.defineProperty(e, "fromTendermintEvent", { enumerable: !0, get: function() {
    return f.fromTendermintEvent;
  } });
  var O = xn;
  Object.defineProperty(e, "calculateFee", { enumerable: !0, get: function() {
    return O.calculateFee;
  } }), Object.defineProperty(e, "GasPrice", { enumerable: !0, get: function() {
    return O.GasPrice;
  } }), e.logs = i(Fe);
  var A = Xt;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return A.createAuthzAminoConverters;
  } }), Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return A.createBankAminoConverters;
  } }), Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return A.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return A.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return A.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return A.createFeegrantAminoConverters;
  } }), Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return A.createGovAminoConverters;
  } }), Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return A.createGroupAminoConverters;
  } }), Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return A.createIbcAminoConverters;
  } }), Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return A.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return A.createStakingAminoConverters;
  } }), Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return A.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return A.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return A.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return A.isAminoMsgCreateVestingAccount;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return A.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return A.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return A.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return A.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return A.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return A.isAminoMsgSend;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return A.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return A.isAminoMsgSubmitEvidence;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return A.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return A.isAminoMsgTransfer;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return A.isAminoMsgUndelegate;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return A.isAminoMsgUnjail;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return A.isAminoMsgVerifyInvariant;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return A.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return A.isAminoMsgVoteWeighted;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return A.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return A.isAminoMsgWithdrawValidatorCommission;
  } }), Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgSendEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgTransferEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgVoteWeightedEncodeObject;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgWithdrawDelegatorRewardEncodeObject;
  } }), Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return A.setupAuthExtension;
  } }), Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return A.setupAuthzExtension;
  } }), Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return A.setupBankExtension;
  } }), Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return A.setupDistributionExtension;
  } }), Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return A.setupFeegrantExtension;
  } }), Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return A.setupGovExtension;
  } }), Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return A.setupIbcExtension;
  } }), Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return A.setupMintExtension;
  } }), Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return A.setupSlashingExtension;
  } }), Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return A.setupStakingExtension;
  } }), Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return A.setupTxExtension;
  } });
  var T = Zn;
  Object.defineProperty(e, "makeMultisignedTx", { enumerable: !0, get: function() {
    return T.makeMultisignedTx;
  } }), Object.defineProperty(e, "makeMultisignedTxBytes", { enumerable: !0, get: function() {
    return T.makeMultisignedTxBytes;
  } });
  var L = Le;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return L.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return L.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return L.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return L.QueryClient;
  } });
  var M = Gu;
  Object.defineProperty(e, "createDefaultAminoConverters", { enumerable: !0, get: function() {
    return M.createDefaultAminoConverters;
  } }), Object.defineProperty(e, "defaultRegistryTypes", { enumerable: !0, get: function() {
    return M.defaultRegistryTypes;
  } }), Object.defineProperty(e, "SigningStargateClient", { enumerable: !0, get: function() {
    return M.SigningStargateClient;
  } });
  var V = Te;
  Object.defineProperty(e, "assertIsDeliverTxFailure", { enumerable: !0, get: function() {
    return V.assertIsDeliverTxFailure;
  } }), Object.defineProperty(e, "assertIsDeliverTxSuccess", { enumerable: !0, get: function() {
    return V.assertIsDeliverTxSuccess;
  } }), Object.defineProperty(e, "BroadcastTxError", { enumerable: !0, get: function() {
    return V.BroadcastTxError;
  } }), Object.defineProperty(e, "isDeliverTxFailure", { enumerable: !0, get: function() {
    return V.isDeliverTxFailure;
  } }), Object.defineProperty(e, "isDeliverTxSuccess", { enumerable: !0, get: function() {
    return V.isDeliverTxSuccess;
  } }), Object.defineProperty(e, "StargateClient", { enumerable: !0, get: function() {
    return V.StargateClient;
  } }), Object.defineProperty(e, "TimeoutError", { enumerable: !0, get: function() {
    return V.TimeoutError;
  } });
  var D = tt;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return D.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return D.coins;
  } }), Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return D.makeCosmoshubPath;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return D.parseCoins;
  } });
})(Bd);
const ZR = /* @__PURE__ */ xc({
  __proto__: null
}, [Bd]);
export {
  ZR as i
};
