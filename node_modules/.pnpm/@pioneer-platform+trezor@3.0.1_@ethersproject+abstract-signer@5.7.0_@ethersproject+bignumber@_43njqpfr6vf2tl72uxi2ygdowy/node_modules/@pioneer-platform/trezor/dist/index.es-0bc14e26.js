var ou = Object.defineProperty, au = (e, t, r) => t in e ? ou(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ne = (e, t, r) => (au(e, typeof t != "symbol" ? t + "" : t, r), r), xo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ci(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Co = { exports: {} };
(function(e) {
  (function(t, r) {
    function n(a, u) {
      if (!a)
        throw new Error(u || "Assertion failed");
    }
    function i(a, u) {
      a.super_ = u;
      var l = function() {
      };
      l.prototype = u.prototype, a.prototype = new l(), a.prototype.constructor = a;
    }
    function s(a, u, l) {
      if (s.isBN(a))
        return a;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, a !== null && ((u === "le" || u === "be") && (l = u, u = 10), this._init(a || 0, u || 10, l || "be"));
    }
    typeof t == "object" ? t.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = require("buffer").Buffer;
    } catch {
    }
    s.isBN = function(a) {
      return a instanceof s ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words);
    }, s.max = function(a, u) {
      return a.cmp(u) > 0 ? a : u;
    }, s.min = function(a, u) {
      return a.cmp(u) < 0 ? a : u;
    }, s.prototype._init = function(a, u, l) {
      if (typeof a == "number")
        return this._initNumber(a, u, l);
      if (typeof a == "object")
        return this._initArray(a, u, l);
      u === "hex" && (u = 16), n(u === (u | 0) && u >= 2 && u <= 36), a = a.toString().replace(/\s+/g, "");
      var d = 0;
      a[0] === "-" && (d++, this.negative = 1), d < a.length && (u === 16 ? this._parseHex(a, d, l) : (this._parseBase(a, u, d), l === "le" && this._initArray(this.toArray(), u, l)));
    }, s.prototype._initNumber = function(a, u, l) {
      a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
        a & 67108863,
        a / 67108864 & 67108863
      ], this.length = 2) : (n(a < 9007199254740992), this.words = [
        a & 67108863,
        a / 67108864 & 67108863,
        1
      ], this.length = 3), l === "le" && this._initArray(this.toArray(), u, l);
    }, s.prototype._initArray = function(a, u, l) {
      if (n(typeof a.length == "number"), a.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        this.words[d] = 0;
      var g, y, b = 0;
      if (l === "be")
        for (d = a.length - 1, g = 0; d >= 0; d -= 3)
          y = a[d] | a[d - 1] << 8 | a[d - 2] << 16, this.words[g] |= y << b & 67108863, this.words[g + 1] = y >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, g++);
      else if (l === "le")
        for (d = 0, g = 0; d < a.length; d += 3)
          y = a[d] | a[d + 1] << 8 | a[d + 2] << 16, this.words[g] |= y << b & 67108863, this.words[g + 1] = y >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, g++);
      return this._strip();
    };
    function c(a, u) {
      var l = a.charCodeAt(u);
      if (l >= 48 && l <= 57)
        return l - 48;
      if (l >= 65 && l <= 70)
        return l - 55;
      if (l >= 97 && l <= 102)
        return l - 87;
      n(!1, "Invalid character in " + a);
    }
    function f(a, u, l) {
      var d = c(a, l);
      return l - 1 >= u && (d |= c(a, l - 1) << 4), d;
    }
    s.prototype._parseHex = function(a, u, l) {
      this.length = Math.ceil((a.length - u) / 6), this.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        this.words[d] = 0;
      var g = 0, y = 0, b;
      if (l === "be")
        for (d = a.length - 1; d >= u; d -= 2)
          b = f(a, u, d) << g, this.words[y] |= b & 67108863, g >= 18 ? (g -= 18, y += 1, this.words[y] |= b >>> 26) : g += 8;
      else {
        var w = a.length - u;
        for (d = w % 2 === 0 ? u + 1 : u; d < a.length; d += 2)
          b = f(a, u, d) << g, this.words[y] |= b & 67108863, g >= 18 ? (g -= 18, y += 1, this.words[y] |= b >>> 26) : g += 8;
      }
      this._strip();
    };
    function m(a, u, l, d) {
      for (var g = 0, y = 0, b = Math.min(a.length, l), w = u; w < b; w++) {
        var h = a.charCodeAt(w) - 48;
        g *= d, h >= 49 ? y = h - 49 + 10 : h >= 17 ? y = h - 17 + 10 : y = h, n(h >= 0 && y < d, "Invalid character"), g += y;
      }
      return g;
    }
    s.prototype._parseBase = function(a, u, l) {
      this.words = [0], this.length = 1;
      for (var d = 0, g = 1; g <= 67108863; g *= u)
        d++;
      d--, g = g / u | 0;
      for (var y = a.length - l, b = y % d, w = Math.min(y, y - b) + l, h = 0, A = l; A < w; A += d)
        h = m(a, A, A + d, u), this.imuln(g), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      if (b !== 0) {
        var j = 1;
        for (h = m(a, A, a.length, u), A = 0; A < b; A++)
          j *= u;
        this.imuln(j), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      }
      this._strip();
    }, s.prototype.copy = function(a) {
      a.words = new Array(this.length);
      for (var u = 0; u < this.length; u++)
        a.words[u] = this.words[u];
      a.length = this.length, a.negative = this.negative, a.red = this.red;
    };
    function E(a, u) {
      a.words = u.words, a.length = u.length, a.negative = u.negative, a.red = u.red;
    }
    if (s.prototype._move = function(a) {
      E(a, this);
    }, s.prototype.clone = function() {
      var a = new s(null);
      return this.copy(a), a;
    }, s.prototype._expand = function(a) {
      for (; this.length < a; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = _;
      } catch {
        s.prototype.inspect = _;
      }
    else
      s.prototype.inspect = _;
    function _() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var S = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], O = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], C = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(a, u) {
      a = a || 10, u = u | 0 || 1;
      var l;
      if (a === 16 || a === "hex") {
        l = "";
        for (var d = 0, g = 0, y = 0; y < this.length; y++) {
          var b = this.words[y], w = ((b << d | g) & 16777215).toString(16);
          g = b >>> 24 - d & 16777215, d += 2, d >= 26 && (d -= 26, y--), g !== 0 || y !== this.length - 1 ? l = S[6 - w.length] + w + l : l = w + l;
        }
        for (g !== 0 && (l = g.toString(16) + l); l.length % u !== 0; )
          l = "0" + l;
        return this.negative !== 0 && (l = "-" + l), l;
      }
      if (a === (a | 0) && a >= 2 && a <= 36) {
        var h = O[a], A = C[a];
        l = "";
        var j = this.clone();
        for (j.negative = 0; !j.isZero(); ) {
          var z = j.modrn(A).toString(a);
          j = j.idivn(A), j.isZero() ? l = z + l : l = S[h - z.length] + z + l;
        }
        for (this.isZero() && (l = "0" + l); l.length % u !== 0; )
          l = "0" + l;
        return this.negative !== 0 && (l = "-" + l), l;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var a = this.words[0];
      return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(a, u) {
      return this.toArrayLike(o, a, u);
    }), s.prototype.toArray = function(a, u) {
      return this.toArrayLike(Array, a, u);
    };
    var F = function(a, u) {
      return a.allocUnsafe ? a.allocUnsafe(u) : new a(u);
    };
    s.prototype.toArrayLike = function(a, u, l) {
      this._strip();
      var d = this.byteLength(), g = l || Math.max(1, d);
      n(d <= g, "byte array longer than desired length"), n(g > 0, "Requested array length <= 0");
      var y = F(a, g), b = u === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b](y, d), y;
    }, s.prototype._toArrayLikeLE = function(a, u) {
      for (var l = 0, d = 0, g = 0, y = 0; g < this.length; g++) {
        var b = this.words[g] << y | d;
        a[l++] = b & 255, l < a.length && (a[l++] = b >> 8 & 255), l < a.length && (a[l++] = b >> 16 & 255), y === 6 ? (l < a.length && (a[l++] = b >> 24 & 255), d = 0, y = 0) : (d = b >>> 24, y += 2);
      }
      if (l < a.length)
        for (a[l++] = d; l < a.length; )
          a[l++] = 0;
    }, s.prototype._toArrayLikeBE = function(a, u) {
      for (var l = a.length - 1, d = 0, g = 0, y = 0; g < this.length; g++) {
        var b = this.words[g] << y | d;
        a[l--] = b & 255, l >= 0 && (a[l--] = b >> 8 & 255), l >= 0 && (a[l--] = b >> 16 & 255), y === 6 ? (l >= 0 && (a[l--] = b >> 24 & 255), d = 0, y = 0) : (d = b >>> 24, y += 2);
      }
      if (l >= 0)
        for (a[l--] = d; l >= 0; )
          a[l--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(a) {
      return 32 - Math.clz32(a);
    } : s.prototype._countBits = function(a) {
      var u = a, l = 0;
      return u >= 4096 && (l += 13, u >>>= 13), u >= 64 && (l += 7, u >>>= 7), u >= 8 && (l += 4, u >>>= 4), u >= 2 && (l += 2, u >>>= 2), l + u;
    }, s.prototype._zeroBits = function(a) {
      if (a === 0)
        return 26;
      var u = a, l = 0;
      return u & 8191 || (l += 13, u >>>= 13), u & 127 || (l += 7, u >>>= 7), u & 15 || (l += 4, u >>>= 4), u & 3 || (l += 2, u >>>= 2), u & 1 || l++, l;
    }, s.prototype.bitLength = function() {
      var a = this.words[this.length - 1], u = this._countBits(a);
      return (this.length - 1) * 26 + u;
    };
    function L(a) {
      for (var u = new Array(a.bitLength()), l = 0; l < u.length; l++) {
        var d = l / 26 | 0, g = l % 26;
        u[l] = a.words[d] >>> g & 1;
      }
      return u;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var a = 0, u = 0; u < this.length; u++) {
        var l = this._zeroBits(this.words[u]);
        if (a += l, l !== 26)
          break;
      }
      return a;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(a) {
      return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(a) {
      return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(a) {
      for (; this.length < a.length; )
        this.words[this.length++] = 0;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] | a.words[u];
      return this._strip();
    }, s.prototype.ior = function(a) {
      return n((this.negative | a.negative) === 0), this.iuor(a);
    }, s.prototype.or = function(a) {
      return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
    }, s.prototype.uor = function(a) {
      return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
    }, s.prototype.iuand = function(a) {
      var u;
      this.length > a.length ? u = a : u = this;
      for (var l = 0; l < u.length; l++)
        this.words[l] = this.words[l] & a.words[l];
      return this.length = u.length, this._strip();
    }, s.prototype.iand = function(a) {
      return n((this.negative | a.negative) === 0), this.iuand(a);
    }, s.prototype.and = function(a) {
      return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
    }, s.prototype.uand = function(a) {
      return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
    }, s.prototype.iuxor = function(a) {
      var u, l;
      this.length > a.length ? (u = this, l = a) : (u = a, l = this);
      for (var d = 0; d < l.length; d++)
        this.words[d] = u.words[d] ^ l.words[d];
      if (this !== u)
        for (; d < u.length; d++)
          this.words[d] = u.words[d];
      return this.length = u.length, this._strip();
    }, s.prototype.ixor = function(a) {
      return n((this.negative | a.negative) === 0), this.iuxor(a);
    }, s.prototype.xor = function(a) {
      return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
    }, s.prototype.uxor = function(a) {
      return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
    }, s.prototype.inotn = function(a) {
      n(typeof a == "number" && a >= 0);
      var u = Math.ceil(a / 26) | 0, l = a % 26;
      this._expand(u), l > 0 && u--;
      for (var d = 0; d < u; d++)
        this.words[d] = ~this.words[d] & 67108863;
      return l > 0 && (this.words[d] = ~this.words[d] & 67108863 >> 26 - l), this._strip();
    }, s.prototype.notn = function(a) {
      return this.clone().inotn(a);
    }, s.prototype.setn = function(a, u) {
      n(typeof a == "number" && a >= 0);
      var l = a / 26 | 0, d = a % 26;
      return this._expand(l + 1), u ? this.words[l] = this.words[l] | 1 << d : this.words[l] = this.words[l] & ~(1 << d), this._strip();
    }, s.prototype.iadd = function(a) {
      var u;
      if (this.negative !== 0 && a.negative === 0)
        return this.negative = 0, u = this.isub(a), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && a.negative !== 0)
        return a.negative = 0, u = this.isub(a), a.negative = 1, u._normSign();
      var l, d;
      this.length > a.length ? (l = this, d = a) : (l = a, d = this);
      for (var g = 0, y = 0; y < d.length; y++)
        u = (l.words[y] | 0) + (d.words[y] | 0) + g, this.words[y] = u & 67108863, g = u >>> 26;
      for (; g !== 0 && y < l.length; y++)
        u = (l.words[y] | 0) + g, this.words[y] = u & 67108863, g = u >>> 26;
      if (this.length = l.length, g !== 0)
        this.words[this.length] = g, this.length++;
      else if (l !== this)
        for (; y < l.length; y++)
          this.words[y] = l.words[y];
      return this;
    }, s.prototype.add = function(a) {
      var u;
      return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, u = this.sub(a), a.negative ^= 1, u) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = a.sub(this), this.negative = 1, u) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
    }, s.prototype.isub = function(a) {
      if (a.negative !== 0) {
        a.negative = 0;
        var u = this.iadd(a);
        return a.negative = 1, u._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
      var l = this.cmp(a);
      if (l === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var d, g;
      l > 0 ? (d = this, g = a) : (d = a, g = this);
      for (var y = 0, b = 0; b < g.length; b++)
        u = (d.words[b] | 0) - (g.words[b] | 0) + y, y = u >> 26, this.words[b] = u & 67108863;
      for (; y !== 0 && b < d.length; b++)
        u = (d.words[b] | 0) + y, y = u >> 26, this.words[b] = u & 67108863;
      if (y === 0 && b < d.length && d !== this)
        for (; b < d.length; b++)
          this.words[b] = d.words[b];
      return this.length = Math.max(this.length, b), d !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(a) {
      return this.clone().isub(a);
    };
    function D(a, u, l) {
      l.negative = u.negative ^ a.negative;
      var d = a.length + u.length | 0;
      l.length = d, d = d - 1 | 0;
      var g = a.words[0] | 0, y = u.words[0] | 0, b = g * y, w = b & 67108863, h = b / 67108864 | 0;
      l.words[0] = w;
      for (var A = 1; A < d; A++) {
        for (var j = h >>> 26, z = h & 67108863, p = Math.min(A, u.length - 1), k = Math.max(0, A - a.length + 1); k <= p; k++) {
          var x = A - k | 0;
          g = a.words[x] | 0, y = u.words[k] | 0, b = g * y + z, j += b / 67108864 | 0, z = b & 67108863;
        }
        l.words[A] = z | 0, h = j | 0;
      }
      return h !== 0 ? l.words[A] = h | 0 : l.length--, l._strip();
    }
    var P = function(a, u, l) {
      var d = a.words, g = u.words, y = l.words, b = 0, w, h, A, j = d[0] | 0, z = j & 8191, p = j >>> 13, k = d[1] | 0, x = k & 8191, B = k >>> 13, Q = d[2] | 0, q = Q & 8191, H = Q >>> 13, J = d[3] | 0, Z = J & 8191, G = J >>> 13, st = d[4] | 0, gt = st & 8191, yt = st >>> 13, Or = d[5] | 0, vt = Or & 8191, wt = Or >>> 13, Mr = d[6] | 0, At = Mr & 8191, Et = Mr >>> 13, Pr = d[7] | 0, bt = Pr & 8191, Nt = Pr >>> 13, kr = d[8] | 0, _t = kr & 8191, It = kr >>> 13, xr = d[9] | 0, St = xr & 8191, Rt = xr >>> 13, Cr = g[0] | 0, Tt = Cr & 8191, Ot = Cr >>> 13, Br = g[1] | 0, Mt = Br & 8191, Pt = Br >>> 13, Dr = g[2] | 0, kt = Dr & 8191, xt = Dr >>> 13, Ur = g[3] | 0, Ct = Ur & 8191, Bt = Ur >>> 13, Lr = g[4] | 0, Dt = Lr & 8191, Ut = Lr >>> 13, Fr = g[5] | 0, Lt = Fr & 8191, Ft = Fr >>> 13, Gr = g[6] | 0, Gt = Gr & 8191, Ht = Gr >>> 13, Hr = g[7] | 0, Vt = Hr & 8191, zt = Hr >>> 13, Vr = g[8] | 0, qt = Vr & 8191, jt = Vr >>> 13, zr = g[9] | 0, Qt = zr & 8191, Yt = zr >>> 13;
      l.negative = a.negative ^ u.negative, l.length = 19, w = Math.imul(z, Tt), h = Math.imul(z, Ot), h = h + Math.imul(p, Tt) | 0, A = Math.imul(p, Ot);
      var mr = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (mr >>> 26) | 0, mr &= 67108863, w = Math.imul(x, Tt), h = Math.imul(x, Ot), h = h + Math.imul(B, Tt) | 0, A = Math.imul(B, Ot), w = w + Math.imul(z, Mt) | 0, h = h + Math.imul(z, Pt) | 0, h = h + Math.imul(p, Mt) | 0, A = A + Math.imul(p, Pt) | 0;
      var gr = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, w = Math.imul(q, Tt), h = Math.imul(q, Ot), h = h + Math.imul(H, Tt) | 0, A = Math.imul(H, Ot), w = w + Math.imul(x, Mt) | 0, h = h + Math.imul(x, Pt) | 0, h = h + Math.imul(B, Mt) | 0, A = A + Math.imul(B, Pt) | 0, w = w + Math.imul(z, kt) | 0, h = h + Math.imul(z, xt) | 0, h = h + Math.imul(p, kt) | 0, A = A + Math.imul(p, xt) | 0;
      var yr = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, w = Math.imul(Z, Tt), h = Math.imul(Z, Ot), h = h + Math.imul(G, Tt) | 0, A = Math.imul(G, Ot), w = w + Math.imul(q, Mt) | 0, h = h + Math.imul(q, Pt) | 0, h = h + Math.imul(H, Mt) | 0, A = A + Math.imul(H, Pt) | 0, w = w + Math.imul(x, kt) | 0, h = h + Math.imul(x, xt) | 0, h = h + Math.imul(B, kt) | 0, A = A + Math.imul(B, xt) | 0, w = w + Math.imul(z, Ct) | 0, h = h + Math.imul(z, Bt) | 0, h = h + Math.imul(p, Ct) | 0, A = A + Math.imul(p, Bt) | 0;
      var vr = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, w = Math.imul(gt, Tt), h = Math.imul(gt, Ot), h = h + Math.imul(yt, Tt) | 0, A = Math.imul(yt, Ot), w = w + Math.imul(Z, Mt) | 0, h = h + Math.imul(Z, Pt) | 0, h = h + Math.imul(G, Mt) | 0, A = A + Math.imul(G, Pt) | 0, w = w + Math.imul(q, kt) | 0, h = h + Math.imul(q, xt) | 0, h = h + Math.imul(H, kt) | 0, A = A + Math.imul(H, xt) | 0, w = w + Math.imul(x, Ct) | 0, h = h + Math.imul(x, Bt) | 0, h = h + Math.imul(B, Ct) | 0, A = A + Math.imul(B, Bt) | 0, w = w + Math.imul(z, Dt) | 0, h = h + Math.imul(z, Ut) | 0, h = h + Math.imul(p, Dt) | 0, A = A + Math.imul(p, Ut) | 0;
      var wr = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, w = Math.imul(vt, Tt), h = Math.imul(vt, Ot), h = h + Math.imul(wt, Tt) | 0, A = Math.imul(wt, Ot), w = w + Math.imul(gt, Mt) | 0, h = h + Math.imul(gt, Pt) | 0, h = h + Math.imul(yt, Mt) | 0, A = A + Math.imul(yt, Pt) | 0, w = w + Math.imul(Z, kt) | 0, h = h + Math.imul(Z, xt) | 0, h = h + Math.imul(G, kt) | 0, A = A + Math.imul(G, xt) | 0, w = w + Math.imul(q, Ct) | 0, h = h + Math.imul(q, Bt) | 0, h = h + Math.imul(H, Ct) | 0, A = A + Math.imul(H, Bt) | 0, w = w + Math.imul(x, Dt) | 0, h = h + Math.imul(x, Ut) | 0, h = h + Math.imul(B, Dt) | 0, A = A + Math.imul(B, Ut) | 0, w = w + Math.imul(z, Lt) | 0, h = h + Math.imul(z, Ft) | 0, h = h + Math.imul(p, Lt) | 0, A = A + Math.imul(p, Ft) | 0;
      var Ar = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Ar >>> 26) | 0, Ar &= 67108863, w = Math.imul(At, Tt), h = Math.imul(At, Ot), h = h + Math.imul(Et, Tt) | 0, A = Math.imul(Et, Ot), w = w + Math.imul(vt, Mt) | 0, h = h + Math.imul(vt, Pt) | 0, h = h + Math.imul(wt, Mt) | 0, A = A + Math.imul(wt, Pt) | 0, w = w + Math.imul(gt, kt) | 0, h = h + Math.imul(gt, xt) | 0, h = h + Math.imul(yt, kt) | 0, A = A + Math.imul(yt, xt) | 0, w = w + Math.imul(Z, Ct) | 0, h = h + Math.imul(Z, Bt) | 0, h = h + Math.imul(G, Ct) | 0, A = A + Math.imul(G, Bt) | 0, w = w + Math.imul(q, Dt) | 0, h = h + Math.imul(q, Ut) | 0, h = h + Math.imul(H, Dt) | 0, A = A + Math.imul(H, Ut) | 0, w = w + Math.imul(x, Lt) | 0, h = h + Math.imul(x, Ft) | 0, h = h + Math.imul(B, Lt) | 0, A = A + Math.imul(B, Ft) | 0, w = w + Math.imul(z, Gt) | 0, h = h + Math.imul(z, Ht) | 0, h = h + Math.imul(p, Gt) | 0, A = A + Math.imul(p, Ht) | 0;
      var Ri = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Ri >>> 26) | 0, Ri &= 67108863, w = Math.imul(bt, Tt), h = Math.imul(bt, Ot), h = h + Math.imul(Nt, Tt) | 0, A = Math.imul(Nt, Ot), w = w + Math.imul(At, Mt) | 0, h = h + Math.imul(At, Pt) | 0, h = h + Math.imul(Et, Mt) | 0, A = A + Math.imul(Et, Pt) | 0, w = w + Math.imul(vt, kt) | 0, h = h + Math.imul(vt, xt) | 0, h = h + Math.imul(wt, kt) | 0, A = A + Math.imul(wt, xt) | 0, w = w + Math.imul(gt, Ct) | 0, h = h + Math.imul(gt, Bt) | 0, h = h + Math.imul(yt, Ct) | 0, A = A + Math.imul(yt, Bt) | 0, w = w + Math.imul(Z, Dt) | 0, h = h + Math.imul(Z, Ut) | 0, h = h + Math.imul(G, Dt) | 0, A = A + Math.imul(G, Ut) | 0, w = w + Math.imul(q, Lt) | 0, h = h + Math.imul(q, Ft) | 0, h = h + Math.imul(H, Lt) | 0, A = A + Math.imul(H, Ft) | 0, w = w + Math.imul(x, Gt) | 0, h = h + Math.imul(x, Ht) | 0, h = h + Math.imul(B, Gt) | 0, A = A + Math.imul(B, Ht) | 0, w = w + Math.imul(z, Vt) | 0, h = h + Math.imul(z, zt) | 0, h = h + Math.imul(p, Vt) | 0, A = A + Math.imul(p, zt) | 0;
      var Ti = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Ti >>> 26) | 0, Ti &= 67108863, w = Math.imul(_t, Tt), h = Math.imul(_t, Ot), h = h + Math.imul(It, Tt) | 0, A = Math.imul(It, Ot), w = w + Math.imul(bt, Mt) | 0, h = h + Math.imul(bt, Pt) | 0, h = h + Math.imul(Nt, Mt) | 0, A = A + Math.imul(Nt, Pt) | 0, w = w + Math.imul(At, kt) | 0, h = h + Math.imul(At, xt) | 0, h = h + Math.imul(Et, kt) | 0, A = A + Math.imul(Et, xt) | 0, w = w + Math.imul(vt, Ct) | 0, h = h + Math.imul(vt, Bt) | 0, h = h + Math.imul(wt, Ct) | 0, A = A + Math.imul(wt, Bt) | 0, w = w + Math.imul(gt, Dt) | 0, h = h + Math.imul(gt, Ut) | 0, h = h + Math.imul(yt, Dt) | 0, A = A + Math.imul(yt, Ut) | 0, w = w + Math.imul(Z, Lt) | 0, h = h + Math.imul(Z, Ft) | 0, h = h + Math.imul(G, Lt) | 0, A = A + Math.imul(G, Ft) | 0, w = w + Math.imul(q, Gt) | 0, h = h + Math.imul(q, Ht) | 0, h = h + Math.imul(H, Gt) | 0, A = A + Math.imul(H, Ht) | 0, w = w + Math.imul(x, Vt) | 0, h = h + Math.imul(x, zt) | 0, h = h + Math.imul(B, Vt) | 0, A = A + Math.imul(B, zt) | 0, w = w + Math.imul(z, qt) | 0, h = h + Math.imul(z, jt) | 0, h = h + Math.imul(p, qt) | 0, A = A + Math.imul(p, jt) | 0;
      var Oi = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Oi >>> 26) | 0, Oi &= 67108863, w = Math.imul(St, Tt), h = Math.imul(St, Ot), h = h + Math.imul(Rt, Tt) | 0, A = Math.imul(Rt, Ot), w = w + Math.imul(_t, Mt) | 0, h = h + Math.imul(_t, Pt) | 0, h = h + Math.imul(It, Mt) | 0, A = A + Math.imul(It, Pt) | 0, w = w + Math.imul(bt, kt) | 0, h = h + Math.imul(bt, xt) | 0, h = h + Math.imul(Nt, kt) | 0, A = A + Math.imul(Nt, xt) | 0, w = w + Math.imul(At, Ct) | 0, h = h + Math.imul(At, Bt) | 0, h = h + Math.imul(Et, Ct) | 0, A = A + Math.imul(Et, Bt) | 0, w = w + Math.imul(vt, Dt) | 0, h = h + Math.imul(vt, Ut) | 0, h = h + Math.imul(wt, Dt) | 0, A = A + Math.imul(wt, Ut) | 0, w = w + Math.imul(gt, Lt) | 0, h = h + Math.imul(gt, Ft) | 0, h = h + Math.imul(yt, Lt) | 0, A = A + Math.imul(yt, Ft) | 0, w = w + Math.imul(Z, Gt) | 0, h = h + Math.imul(Z, Ht) | 0, h = h + Math.imul(G, Gt) | 0, A = A + Math.imul(G, Ht) | 0, w = w + Math.imul(q, Vt) | 0, h = h + Math.imul(q, zt) | 0, h = h + Math.imul(H, Vt) | 0, A = A + Math.imul(H, zt) | 0, w = w + Math.imul(x, qt) | 0, h = h + Math.imul(x, jt) | 0, h = h + Math.imul(B, qt) | 0, A = A + Math.imul(B, jt) | 0, w = w + Math.imul(z, Qt) | 0, h = h + Math.imul(z, Yt) | 0, h = h + Math.imul(p, Qt) | 0, A = A + Math.imul(p, Yt) | 0;
      var Mi = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Mi >>> 26) | 0, Mi &= 67108863, w = Math.imul(St, Mt), h = Math.imul(St, Pt), h = h + Math.imul(Rt, Mt) | 0, A = Math.imul(Rt, Pt), w = w + Math.imul(_t, kt) | 0, h = h + Math.imul(_t, xt) | 0, h = h + Math.imul(It, kt) | 0, A = A + Math.imul(It, xt) | 0, w = w + Math.imul(bt, Ct) | 0, h = h + Math.imul(bt, Bt) | 0, h = h + Math.imul(Nt, Ct) | 0, A = A + Math.imul(Nt, Bt) | 0, w = w + Math.imul(At, Dt) | 0, h = h + Math.imul(At, Ut) | 0, h = h + Math.imul(Et, Dt) | 0, A = A + Math.imul(Et, Ut) | 0, w = w + Math.imul(vt, Lt) | 0, h = h + Math.imul(vt, Ft) | 0, h = h + Math.imul(wt, Lt) | 0, A = A + Math.imul(wt, Ft) | 0, w = w + Math.imul(gt, Gt) | 0, h = h + Math.imul(gt, Ht) | 0, h = h + Math.imul(yt, Gt) | 0, A = A + Math.imul(yt, Ht) | 0, w = w + Math.imul(Z, Vt) | 0, h = h + Math.imul(Z, zt) | 0, h = h + Math.imul(G, Vt) | 0, A = A + Math.imul(G, zt) | 0, w = w + Math.imul(q, qt) | 0, h = h + Math.imul(q, jt) | 0, h = h + Math.imul(H, qt) | 0, A = A + Math.imul(H, jt) | 0, w = w + Math.imul(x, Qt) | 0, h = h + Math.imul(x, Yt) | 0, h = h + Math.imul(B, Qt) | 0, A = A + Math.imul(B, Yt) | 0;
      var Pi = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Pi >>> 26) | 0, Pi &= 67108863, w = Math.imul(St, kt), h = Math.imul(St, xt), h = h + Math.imul(Rt, kt) | 0, A = Math.imul(Rt, xt), w = w + Math.imul(_t, Ct) | 0, h = h + Math.imul(_t, Bt) | 0, h = h + Math.imul(It, Ct) | 0, A = A + Math.imul(It, Bt) | 0, w = w + Math.imul(bt, Dt) | 0, h = h + Math.imul(bt, Ut) | 0, h = h + Math.imul(Nt, Dt) | 0, A = A + Math.imul(Nt, Ut) | 0, w = w + Math.imul(At, Lt) | 0, h = h + Math.imul(At, Ft) | 0, h = h + Math.imul(Et, Lt) | 0, A = A + Math.imul(Et, Ft) | 0, w = w + Math.imul(vt, Gt) | 0, h = h + Math.imul(vt, Ht) | 0, h = h + Math.imul(wt, Gt) | 0, A = A + Math.imul(wt, Ht) | 0, w = w + Math.imul(gt, Vt) | 0, h = h + Math.imul(gt, zt) | 0, h = h + Math.imul(yt, Vt) | 0, A = A + Math.imul(yt, zt) | 0, w = w + Math.imul(Z, qt) | 0, h = h + Math.imul(Z, jt) | 0, h = h + Math.imul(G, qt) | 0, A = A + Math.imul(G, jt) | 0, w = w + Math.imul(q, Qt) | 0, h = h + Math.imul(q, Yt) | 0, h = h + Math.imul(H, Qt) | 0, A = A + Math.imul(H, Yt) | 0;
      var ki = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (ki >>> 26) | 0, ki &= 67108863, w = Math.imul(St, Ct), h = Math.imul(St, Bt), h = h + Math.imul(Rt, Ct) | 0, A = Math.imul(Rt, Bt), w = w + Math.imul(_t, Dt) | 0, h = h + Math.imul(_t, Ut) | 0, h = h + Math.imul(It, Dt) | 0, A = A + Math.imul(It, Ut) | 0, w = w + Math.imul(bt, Lt) | 0, h = h + Math.imul(bt, Ft) | 0, h = h + Math.imul(Nt, Lt) | 0, A = A + Math.imul(Nt, Ft) | 0, w = w + Math.imul(At, Gt) | 0, h = h + Math.imul(At, Ht) | 0, h = h + Math.imul(Et, Gt) | 0, A = A + Math.imul(Et, Ht) | 0, w = w + Math.imul(vt, Vt) | 0, h = h + Math.imul(vt, zt) | 0, h = h + Math.imul(wt, Vt) | 0, A = A + Math.imul(wt, zt) | 0, w = w + Math.imul(gt, qt) | 0, h = h + Math.imul(gt, jt) | 0, h = h + Math.imul(yt, qt) | 0, A = A + Math.imul(yt, jt) | 0, w = w + Math.imul(Z, Qt) | 0, h = h + Math.imul(Z, Yt) | 0, h = h + Math.imul(G, Qt) | 0, A = A + Math.imul(G, Yt) | 0;
      var xi = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (xi >>> 26) | 0, xi &= 67108863, w = Math.imul(St, Dt), h = Math.imul(St, Ut), h = h + Math.imul(Rt, Dt) | 0, A = Math.imul(Rt, Ut), w = w + Math.imul(_t, Lt) | 0, h = h + Math.imul(_t, Ft) | 0, h = h + Math.imul(It, Lt) | 0, A = A + Math.imul(It, Ft) | 0, w = w + Math.imul(bt, Gt) | 0, h = h + Math.imul(bt, Ht) | 0, h = h + Math.imul(Nt, Gt) | 0, A = A + Math.imul(Nt, Ht) | 0, w = w + Math.imul(At, Vt) | 0, h = h + Math.imul(At, zt) | 0, h = h + Math.imul(Et, Vt) | 0, A = A + Math.imul(Et, zt) | 0, w = w + Math.imul(vt, qt) | 0, h = h + Math.imul(vt, jt) | 0, h = h + Math.imul(wt, qt) | 0, A = A + Math.imul(wt, jt) | 0, w = w + Math.imul(gt, Qt) | 0, h = h + Math.imul(gt, Yt) | 0, h = h + Math.imul(yt, Qt) | 0, A = A + Math.imul(yt, Yt) | 0;
      var Ci = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Ci >>> 26) | 0, Ci &= 67108863, w = Math.imul(St, Lt), h = Math.imul(St, Ft), h = h + Math.imul(Rt, Lt) | 0, A = Math.imul(Rt, Ft), w = w + Math.imul(_t, Gt) | 0, h = h + Math.imul(_t, Ht) | 0, h = h + Math.imul(It, Gt) | 0, A = A + Math.imul(It, Ht) | 0, w = w + Math.imul(bt, Vt) | 0, h = h + Math.imul(bt, zt) | 0, h = h + Math.imul(Nt, Vt) | 0, A = A + Math.imul(Nt, zt) | 0, w = w + Math.imul(At, qt) | 0, h = h + Math.imul(At, jt) | 0, h = h + Math.imul(Et, qt) | 0, A = A + Math.imul(Et, jt) | 0, w = w + Math.imul(vt, Qt) | 0, h = h + Math.imul(vt, Yt) | 0, h = h + Math.imul(wt, Qt) | 0, A = A + Math.imul(wt, Yt) | 0;
      var Bi = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Bi >>> 26) | 0, Bi &= 67108863, w = Math.imul(St, Gt), h = Math.imul(St, Ht), h = h + Math.imul(Rt, Gt) | 0, A = Math.imul(Rt, Ht), w = w + Math.imul(_t, Vt) | 0, h = h + Math.imul(_t, zt) | 0, h = h + Math.imul(It, Vt) | 0, A = A + Math.imul(It, zt) | 0, w = w + Math.imul(bt, qt) | 0, h = h + Math.imul(bt, jt) | 0, h = h + Math.imul(Nt, qt) | 0, A = A + Math.imul(Nt, jt) | 0, w = w + Math.imul(At, Qt) | 0, h = h + Math.imul(At, Yt) | 0, h = h + Math.imul(Et, Qt) | 0, A = A + Math.imul(Et, Yt) | 0;
      var Di = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Di >>> 26) | 0, Di &= 67108863, w = Math.imul(St, Vt), h = Math.imul(St, zt), h = h + Math.imul(Rt, Vt) | 0, A = Math.imul(Rt, zt), w = w + Math.imul(_t, qt) | 0, h = h + Math.imul(_t, jt) | 0, h = h + Math.imul(It, qt) | 0, A = A + Math.imul(It, jt) | 0, w = w + Math.imul(bt, Qt) | 0, h = h + Math.imul(bt, Yt) | 0, h = h + Math.imul(Nt, Qt) | 0, A = A + Math.imul(Nt, Yt) | 0;
      var Ui = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Ui >>> 26) | 0, Ui &= 67108863, w = Math.imul(St, qt), h = Math.imul(St, jt), h = h + Math.imul(Rt, qt) | 0, A = Math.imul(Rt, jt), w = w + Math.imul(_t, Qt) | 0, h = h + Math.imul(_t, Yt) | 0, h = h + Math.imul(It, Qt) | 0, A = A + Math.imul(It, Yt) | 0;
      var Li = (b + w | 0) + ((h & 8191) << 13) | 0;
      b = (A + (h >>> 13) | 0) + (Li >>> 26) | 0, Li &= 67108863, w = Math.imul(St, Qt), h = Math.imul(St, Yt), h = h + Math.imul(Rt, Qt) | 0, A = Math.imul(Rt, Yt);
      var Fi = (b + w | 0) + ((h & 8191) << 13) | 0;
      return b = (A + (h >>> 13) | 0) + (Fi >>> 26) | 0, Fi &= 67108863, y[0] = mr, y[1] = gr, y[2] = yr, y[3] = vr, y[4] = wr, y[5] = Ar, y[6] = Ri, y[7] = Ti, y[8] = Oi, y[9] = Mi, y[10] = Pi, y[11] = ki, y[12] = xi, y[13] = Ci, y[14] = Bi, y[15] = Di, y[16] = Ui, y[17] = Li, y[18] = Fi, b !== 0 && (y[19] = b, l.length++), l;
    };
    Math.imul || (P = D);
    function X(a, u, l) {
      l.negative = u.negative ^ a.negative, l.length = a.length + u.length;
      for (var d = 0, g = 0, y = 0; y < l.length - 1; y++) {
        var b = g;
        g = 0;
        for (var w = d & 67108863, h = Math.min(y, u.length - 1), A = Math.max(0, y - a.length + 1); A <= h; A++) {
          var j = y - A, z = a.words[j] | 0, p = u.words[A] | 0, k = z * p, x = k & 67108863;
          b = b + (k / 67108864 | 0) | 0, x = x + w | 0, w = x & 67108863, b = b + (x >>> 26) | 0, g += b >>> 26, b &= 67108863;
        }
        l.words[y] = w, d = b, b = g;
      }
      return d !== 0 ? l.words[y] = d : l.length--, l._strip();
    }
    function rt(a, u, l) {
      return X(a, u, l);
    }
    s.prototype.mulTo = function(a, u) {
      var l, d = this.length + a.length;
      return this.length === 10 && a.length === 10 ? l = P(this, a, u) : d < 63 ? l = D(this, a, u) : d < 1024 ? l = X(this, a, u) : l = rt(this, a, u), l;
    }, s.prototype.mul = function(a) {
      var u = new s(null);
      return u.words = new Array(this.length + a.length), this.mulTo(a, u);
    }, s.prototype.mulf = function(a) {
      var u = new s(null);
      return u.words = new Array(this.length + a.length), rt(this, a, u);
    }, s.prototype.imul = function(a) {
      return this.clone().mulTo(a, this);
    }, s.prototype.imuln = function(a) {
      var u = a < 0;
      u && (a = -a), n(typeof a == "number"), n(a < 67108864);
      for (var l = 0, d = 0; d < this.length; d++) {
        var g = (this.words[d] | 0) * a, y = (g & 67108863) + (l & 67108863);
        l >>= 26, l += g / 67108864 | 0, l += y >>> 26, this.words[d] = y & 67108863;
      }
      return l !== 0 && (this.words[d] = l, this.length++), u ? this.ineg() : this;
    }, s.prototype.muln = function(a) {
      return this.clone().imuln(a);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(a) {
      var u = L(a);
      if (u.length === 0)
        return new s(1);
      for (var l = this, d = 0; d < u.length && u[d] === 0; d++, l = l.sqr())
        ;
      if (++d < u.length)
        for (var g = l.sqr(); d < u.length; d++, g = g.sqr())
          u[d] !== 0 && (l = l.mul(g));
      return l;
    }, s.prototype.iushln = function(a) {
      n(typeof a == "number" && a >= 0);
      var u = a % 26, l = (a - u) / 26, d = 67108863 >>> 26 - u << 26 - u, g;
      if (u !== 0) {
        var y = 0;
        for (g = 0; g < this.length; g++) {
          var b = this.words[g] & d, w = (this.words[g] | 0) - b << u;
          this.words[g] = w | y, y = b >>> 26 - u;
        }
        y && (this.words[g] = y, this.length++);
      }
      if (l !== 0) {
        for (g = this.length - 1; g >= 0; g--)
          this.words[g + l] = this.words[g];
        for (g = 0; g < l; g++)
          this.words[g] = 0;
        this.length += l;
      }
      return this._strip();
    }, s.prototype.ishln = function(a) {
      return n(this.negative === 0), this.iushln(a);
    }, s.prototype.iushrn = function(a, u, l) {
      n(typeof a == "number" && a >= 0);
      var d;
      u ? d = (u - u % 26) / 26 : d = 0;
      var g = a % 26, y = Math.min((a - g) / 26, this.length), b = 67108863 ^ 67108863 >>> g << g, w = l;
      if (d -= y, d = Math.max(0, d), w) {
        for (var h = 0; h < y; h++)
          w.words[h] = this.words[h];
        w.length = y;
      }
      if (y !== 0)
        if (this.length > y)
          for (this.length -= y, h = 0; h < this.length; h++)
            this.words[h] = this.words[h + y];
        else
          this.words[0] = 0, this.length = 1;
      var A = 0;
      for (h = this.length - 1; h >= 0 && (A !== 0 || h >= d); h--) {
        var j = this.words[h] | 0;
        this.words[h] = A << 26 - g | j >>> g, A = j & b;
      }
      return w && A !== 0 && (w.words[w.length++] = A), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(a, u, l) {
      return n(this.negative === 0), this.iushrn(a, u, l);
    }, s.prototype.shln = function(a) {
      return this.clone().ishln(a);
    }, s.prototype.ushln = function(a) {
      return this.clone().iushln(a);
    }, s.prototype.shrn = function(a) {
      return this.clone().ishrn(a);
    }, s.prototype.ushrn = function(a) {
      return this.clone().iushrn(a);
    }, s.prototype.testn = function(a) {
      n(typeof a == "number" && a >= 0);
      var u = a % 26, l = (a - u) / 26, d = 1 << u;
      if (this.length <= l)
        return !1;
      var g = this.words[l];
      return !!(g & d);
    }, s.prototype.imaskn = function(a) {
      n(typeof a == "number" && a >= 0);
      var u = a % 26, l = (a - u) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= l)
        return this;
      if (u !== 0 && l++, this.length = Math.min(l, this.length), u !== 0) {
        var d = 67108863 ^ 67108863 >>> u << u;
        this.words[this.length - 1] &= d;
      }
      return this._strip();
    }, s.prototype.maskn = function(a) {
      return this.clone().imaskn(a);
    }, s.prototype.iaddn = function(a) {
      return n(typeof a == "number"), n(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
    }, s.prototype._iaddn = function(a) {
      this.words[0] += a;
      for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
        this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
      return this.length = Math.max(this.length, u + 1), this;
    }, s.prototype.isubn = function(a) {
      if (n(typeof a == "number"), n(a < 67108864), a < 0)
        return this.iaddn(-a);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(a), this.negative = 1, this;
      if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var u = 0; u < this.length && this.words[u] < 0; u++)
          this.words[u] += 67108864, this.words[u + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(a) {
      return this.clone().iaddn(a);
    }, s.prototype.subn = function(a) {
      return this.clone().isubn(a);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(a, u, l) {
      var d = a.length + l, g;
      this._expand(d);
      var y, b = 0;
      for (g = 0; g < a.length; g++) {
        y = (this.words[g + l] | 0) + b;
        var w = (a.words[g] | 0) * u;
        y -= w & 67108863, b = (y >> 26) - (w / 67108864 | 0), this.words[g + l] = y & 67108863;
      }
      for (; g < this.length - l; g++)
        y = (this.words[g + l] | 0) + b, b = y >> 26, this.words[g + l] = y & 67108863;
      if (b === 0)
        return this._strip();
      for (n(b === -1), b = 0, g = 0; g < this.length; g++)
        y = -(this.words[g] | 0) + b, b = y >> 26, this.words[g] = y & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(a, u) {
      var l = this.length - a.length, d = this.clone(), g = a, y = g.words[g.length - 1] | 0, b = this._countBits(y);
      l = 26 - b, l !== 0 && (g = g.ushln(l), d.iushln(l), y = g.words[g.length - 1] | 0);
      var w = d.length - g.length, h;
      if (u !== "mod") {
        h = new s(null), h.length = w + 1, h.words = new Array(h.length);
        for (var A = 0; A < h.length; A++)
          h.words[A] = 0;
      }
      var j = d.clone()._ishlnsubmul(g, 1, w);
      j.negative === 0 && (d = j, h && (h.words[w] = 1));
      for (var z = w - 1; z >= 0; z--) {
        var p = (d.words[g.length + z] | 0) * 67108864 + (d.words[g.length + z - 1] | 0);
        for (p = Math.min(p / y | 0, 67108863), d._ishlnsubmul(g, p, z); d.negative !== 0; )
          p--, d.negative = 0, d._ishlnsubmul(g, 1, z), d.isZero() || (d.negative ^= 1);
        h && (h.words[z] = p);
      }
      return h && h._strip(), d._strip(), u !== "div" && l !== 0 && d.iushrn(l), {
        div: h || null,
        mod: d
      };
    }, s.prototype.divmod = function(a, u, l) {
      if (n(!a.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var d, g, y;
      return this.negative !== 0 && a.negative === 0 ? (y = this.neg().divmod(a, u), u !== "mod" && (d = y.div.neg()), u !== "div" && (g = y.mod.neg(), l && g.negative !== 0 && g.iadd(a)), {
        div: d,
        mod: g
      }) : this.negative === 0 && a.negative !== 0 ? (y = this.divmod(a.neg(), u), u !== "mod" && (d = y.div.neg()), {
        div: d,
        mod: y.mod
      }) : this.negative & a.negative ? (y = this.neg().divmod(a.neg(), u), u !== "div" && (g = y.mod.neg(), l && g.negative !== 0 && g.isub(a)), {
        div: y.div,
        mod: g
      }) : a.length > this.length || this.cmp(a) < 0 ? {
        div: new s(0),
        mod: this
      } : a.length === 1 ? u === "div" ? {
        div: this.divn(a.words[0]),
        mod: null
      } : u === "mod" ? {
        div: null,
        mod: new s(this.modrn(a.words[0]))
      } : {
        div: this.divn(a.words[0]),
        mod: new s(this.modrn(a.words[0]))
      } : this._wordDiv(a, u);
    }, s.prototype.div = function(a) {
      return this.divmod(a, "div", !1).div;
    }, s.prototype.mod = function(a) {
      return this.divmod(a, "mod", !1).mod;
    }, s.prototype.umod = function(a) {
      return this.divmod(a, "mod", !0).mod;
    }, s.prototype.divRound = function(a) {
      var u = this.divmod(a);
      if (u.mod.isZero())
        return u.div;
      var l = u.div.negative !== 0 ? u.mod.isub(a) : u.mod, d = a.ushrn(1), g = a.andln(1), y = l.cmp(d);
      return y < 0 || g === 1 && y === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
    }, s.prototype.modrn = function(a) {
      var u = a < 0;
      u && (a = -a), n(a <= 67108863);
      for (var l = (1 << 26) % a, d = 0, g = this.length - 1; g >= 0; g--)
        d = (l * d + (this.words[g] | 0)) % a;
      return u ? -d : d;
    }, s.prototype.modn = function(a) {
      return this.modrn(a);
    }, s.prototype.idivn = function(a) {
      var u = a < 0;
      u && (a = -a), n(a <= 67108863);
      for (var l = 0, d = this.length - 1; d >= 0; d--) {
        var g = (this.words[d] | 0) + l * 67108864;
        this.words[d] = g / a | 0, l = g % a;
      }
      return this._strip(), u ? this.ineg() : this;
    }, s.prototype.divn = function(a) {
      return this.clone().idivn(a);
    }, s.prototype.egcd = function(a) {
      n(a.negative === 0), n(!a.isZero());
      var u = this, l = a.clone();
      u.negative !== 0 ? u = u.umod(a) : u = u.clone();
      for (var d = new s(1), g = new s(0), y = new s(0), b = new s(1), w = 0; u.isEven() && l.isEven(); )
        u.iushrn(1), l.iushrn(1), ++w;
      for (var h = l.clone(), A = u.clone(); !u.isZero(); ) {
        for (var j = 0, z = 1; !(u.words[0] & z) && j < 26; ++j, z <<= 1)
          ;
        if (j > 0)
          for (u.iushrn(j); j-- > 0; )
            (d.isOdd() || g.isOdd()) && (d.iadd(h), g.isub(A)), d.iushrn(1), g.iushrn(1);
        for (var p = 0, k = 1; !(l.words[0] & k) && p < 26; ++p, k <<= 1)
          ;
        if (p > 0)
          for (l.iushrn(p); p-- > 0; )
            (y.isOdd() || b.isOdd()) && (y.iadd(h), b.isub(A)), y.iushrn(1), b.iushrn(1);
        u.cmp(l) >= 0 ? (u.isub(l), d.isub(y), g.isub(b)) : (l.isub(u), y.isub(d), b.isub(g));
      }
      return {
        a: y,
        b,
        gcd: l.iushln(w)
      };
    }, s.prototype._invmp = function(a) {
      n(a.negative === 0), n(!a.isZero());
      var u = this, l = a.clone();
      u.negative !== 0 ? u = u.umod(a) : u = u.clone();
      for (var d = new s(1), g = new s(0), y = l.clone(); u.cmpn(1) > 0 && l.cmpn(1) > 0; ) {
        for (var b = 0, w = 1; !(u.words[0] & w) && b < 26; ++b, w <<= 1)
          ;
        if (b > 0)
          for (u.iushrn(b); b-- > 0; )
            d.isOdd() && d.iadd(y), d.iushrn(1);
        for (var h = 0, A = 1; !(l.words[0] & A) && h < 26; ++h, A <<= 1)
          ;
        if (h > 0)
          for (l.iushrn(h); h-- > 0; )
            g.isOdd() && g.iadd(y), g.iushrn(1);
        u.cmp(l) >= 0 ? (u.isub(l), d.isub(g)) : (l.isub(u), g.isub(d));
      }
      var j;
      return u.cmpn(1) === 0 ? j = d : j = g, j.cmpn(0) < 0 && j.iadd(a), j;
    }, s.prototype.gcd = function(a) {
      if (this.isZero())
        return a.abs();
      if (a.isZero())
        return this.abs();
      var u = this.clone(), l = a.clone();
      u.negative = 0, l.negative = 0;
      for (var d = 0; u.isEven() && l.isEven(); d++)
        u.iushrn(1), l.iushrn(1);
      do {
        for (; u.isEven(); )
          u.iushrn(1);
        for (; l.isEven(); )
          l.iushrn(1);
        var g = u.cmp(l);
        if (g < 0) {
          var y = u;
          u = l, l = y;
        } else if (g === 0 || l.cmpn(1) === 0)
          break;
        u.isub(l);
      } while (!0);
      return l.iushln(d);
    }, s.prototype.invm = function(a) {
      return this.egcd(a).a.umod(a);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(a) {
      return this.words[0] & a;
    }, s.prototype.bincn = function(a) {
      n(typeof a == "number");
      var u = a % 26, l = (a - u) / 26, d = 1 << u;
      if (this.length <= l)
        return this._expand(l + 1), this.words[l] |= d, this;
      for (var g = d, y = l; g !== 0 && y < this.length; y++) {
        var b = this.words[y] | 0;
        b += g, g = b >>> 26, b &= 67108863, this.words[y] = b;
      }
      return g !== 0 && (this.words[y] = g, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(a) {
      var u = a < 0;
      if (this.negative !== 0 && !u)
        return -1;
      if (this.negative === 0 && u)
        return 1;
      this._strip();
      var l;
      if (this.length > 1)
        l = 1;
      else {
        u && (a = -a), n(a <= 67108863, "Number is too big");
        var d = this.words[0] | 0;
        l = d === a ? 0 : d < a ? -1 : 1;
      }
      return this.negative !== 0 ? -l | 0 : l;
    }, s.prototype.cmp = function(a) {
      if (this.negative !== 0 && a.negative === 0)
        return -1;
      if (this.negative === 0 && a.negative !== 0)
        return 1;
      var u = this.ucmp(a);
      return this.negative !== 0 ? -u | 0 : u;
    }, s.prototype.ucmp = function(a) {
      if (this.length > a.length)
        return 1;
      if (this.length < a.length)
        return -1;
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d = this.words[l] | 0, g = a.words[l] | 0;
        if (d !== g) {
          d < g ? u = -1 : d > g && (u = 1);
          break;
        }
      }
      return u;
    }, s.prototype.gtn = function(a) {
      return this.cmpn(a) === 1;
    }, s.prototype.gt = function(a) {
      return this.cmp(a) === 1;
    }, s.prototype.gten = function(a) {
      return this.cmpn(a) >= 0;
    }, s.prototype.gte = function(a) {
      return this.cmp(a) >= 0;
    }, s.prototype.ltn = function(a) {
      return this.cmpn(a) === -1;
    }, s.prototype.lt = function(a) {
      return this.cmp(a) === -1;
    }, s.prototype.lten = function(a) {
      return this.cmpn(a) <= 0;
    }, s.prototype.lte = function(a) {
      return this.cmp(a) <= 0;
    }, s.prototype.eqn = function(a) {
      return this.cmpn(a) === 0;
    }, s.prototype.eq = function(a) {
      return this.cmp(a) === 0;
    }, s.red = function(a) {
      return new T(a);
    }, s.prototype.toRed = function(a) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(a) {
      return this.red = a, this;
    }, s.prototype.forceRed = function(a) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(a);
    }, s.prototype.redAdd = function(a) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
    }, s.prototype.redIAdd = function(a) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
    }, s.prototype.redSub = function(a) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
    }, s.prototype.redISub = function(a) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
    }, s.prototype.redShl = function(a) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
    }, s.prototype.redMul = function(a) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
    }, s.prototype.redIMul = function(a) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(a) {
      return n(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
    };
    var $ = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function tt(a, u) {
      this.name = a, this.p = new s(u, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    tt.prototype._tmp = function() {
      var a = new s(null);
      return a.words = new Array(Math.ceil(this.n / 13)), a;
    }, tt.prototype.ireduce = function(a) {
      var u = a, l;
      do
        this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), l = u.bitLength();
      while (l > this.n);
      var d = l < this.n ? -1 : u.ucmp(this.p);
      return d === 0 ? (u.words[0] = 0, u.length = 1) : d > 0 ? u.isub(this.p) : u.strip !== void 0 ? u.strip() : u._strip(), u;
    }, tt.prototype.split = function(a, u) {
      a.iushrn(this.n, 0, u);
    }, tt.prototype.imulK = function(a) {
      return a.imul(this.k);
    };
    function mt() {
      tt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(mt, tt), mt.prototype.split = function(a, u) {
      for (var l = 4194303, d = Math.min(a.length, 9), g = 0; g < d; g++)
        u.words[g] = a.words[g];
      if (u.length = d, a.length <= 9) {
        a.words[0] = 0, a.length = 1;
        return;
      }
      var y = a.words[9];
      for (u.words[u.length++] = y & l, g = 10; g < a.length; g++) {
        var b = a.words[g] | 0;
        a.words[g - 10] = (b & l) << 4 | y >>> 22, y = b;
      }
      y >>>= 22, a.words[g - 10] = y, y === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
    }, mt.prototype.imulK = function(a) {
      a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
      for (var u = 0, l = 0; l < a.length; l++) {
        var d = a.words[l] | 0;
        u += d * 977, a.words[l] = u & 67108863, u = d * 64 + (u / 67108864 | 0);
      }
      return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
    };
    function v() {
      tt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(v, tt);
    function N() {
      tt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(N, tt);
    function I() {
      tt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(I, tt), I.prototype.imulK = function(a) {
      for (var u = 0, l = 0; l < a.length; l++) {
        var d = (a.words[l] | 0) * 19 + u, g = d & 67108863;
        d >>>= 26, a.words[l] = g, u = d;
      }
      return u !== 0 && (a.words[a.length++] = u), a;
    }, s._prime = function(a) {
      if ($[a])
        return $[a];
      var u;
      if (a === "k256")
        u = new mt();
      else if (a === "p224")
        u = new v();
      else if (a === "p192")
        u = new N();
      else if (a === "p25519")
        u = new I();
      else
        throw new Error("Unknown prime " + a);
      return $[a] = u, u;
    };
    function T(a) {
      if (typeof a == "string") {
        var u = s._prime(a);
        this.m = u.p, this.prime = u;
      } else
        n(a.gtn(1), "modulus must be greater than 1"), this.m = a, this.prime = null;
    }
    T.prototype._verify1 = function(a) {
      n(a.negative === 0, "red works only with positives"), n(a.red, "red works only with red numbers");
    }, T.prototype._verify2 = function(a, u) {
      n((a.negative | u.negative) === 0, "red works only with positives"), n(
        a.red && a.red === u.red,
        "red works only with red numbers"
      );
    }, T.prototype.imod = function(a) {
      return this.prime ? this.prime.ireduce(a)._forceRed(this) : (E(a, a.umod(this.m)._forceRed(this)), a);
    }, T.prototype.neg = function(a) {
      return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
    }, T.prototype.add = function(a, u) {
      this._verify2(a, u);
      var l = a.add(u);
      return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this);
    }, T.prototype.iadd = function(a, u) {
      this._verify2(a, u);
      var l = a.iadd(u);
      return l.cmp(this.m) >= 0 && l.isub(this.m), l;
    }, T.prototype.sub = function(a, u) {
      this._verify2(a, u);
      var l = a.sub(u);
      return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this);
    }, T.prototype.isub = function(a, u) {
      this._verify2(a, u);
      var l = a.isub(u);
      return l.cmpn(0) < 0 && l.iadd(this.m), l;
    }, T.prototype.shl = function(a, u) {
      return this._verify1(a), this.imod(a.ushln(u));
    }, T.prototype.imul = function(a, u) {
      return this._verify2(a, u), this.imod(a.imul(u));
    }, T.prototype.mul = function(a, u) {
      return this._verify2(a, u), this.imod(a.mul(u));
    }, T.prototype.isqr = function(a) {
      return this.imul(a, a.clone());
    }, T.prototype.sqr = function(a) {
      return this.mul(a, a);
    }, T.prototype.sqrt = function(a) {
      if (a.isZero())
        return a.clone();
      var u = this.m.andln(3);
      if (n(u % 2 === 1), u === 3) {
        var l = this.m.add(new s(1)).iushrn(2);
        return this.pow(a, l);
      }
      for (var d = this.m.subn(1), g = 0; !d.isZero() && d.andln(1) === 0; )
        g++, d.iushrn(1);
      n(!d.isZero());
      var y = new s(1).toRed(this), b = y.redNeg(), w = this.m.subn(1).iushrn(1), h = this.m.bitLength();
      for (h = new s(2 * h * h).toRed(this); this.pow(h, w).cmp(b) !== 0; )
        h.redIAdd(b);
      for (var A = this.pow(h, d), j = this.pow(a, d.addn(1).iushrn(1)), z = this.pow(a, d), p = g; z.cmp(y) !== 0; ) {
        for (var k = z, x = 0; k.cmp(y) !== 0; x++)
          k = k.redSqr();
        n(x < p);
        var B = this.pow(A, new s(1).iushln(p - x - 1));
        j = j.redMul(B), A = B.redSqr(), z = z.redMul(A), p = x;
      }
      return j;
    }, T.prototype.invm = function(a) {
      var u = a._invmp(this.m);
      return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
    }, T.prototype.pow = function(a, u) {
      if (u.isZero())
        return new s(1).toRed(this);
      if (u.cmpn(1) === 0)
        return a.clone();
      var l = 4, d = new Array(1 << l);
      d[0] = new s(1).toRed(this), d[1] = a;
      for (var g = 2; g < d.length; g++)
        d[g] = this.mul(d[g - 1], a);
      var y = d[0], b = 0, w = 0, h = u.bitLength() % 26;
      for (h === 0 && (h = 26), g = u.length - 1; g >= 0; g--) {
        for (var A = u.words[g], j = h - 1; j >= 0; j--) {
          var z = A >> j & 1;
          if (y !== d[0] && (y = this.sqr(y)), z === 0 && b === 0) {
            w = 0;
            continue;
          }
          b <<= 1, b |= z, w++, !(w !== l && (g !== 0 || j !== 0)) && (y = this.mul(y, d[b]), w = 0, b = 0);
        }
        h = 26;
      }
      return y;
    }, T.prototype.convertTo = function(a) {
      var u = a.umod(this.m);
      return u === a ? u.clone() : u;
    }, T.prototype.convertFrom = function(a) {
      var u = a.clone();
      return u.red = null, u;
    }, s.mont = function(a) {
      return new R(a);
    };
    function R(a) {
      T.call(this, a), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(R, T), R.prototype.convertTo = function(a) {
      return this.imod(a.ushln(this.shift));
    }, R.prototype.convertFrom = function(a) {
      var u = this.imod(a.mul(this.rinv));
      return u.red = null, u;
    }, R.prototype.imul = function(a, u) {
      if (a.isZero() || u.isZero())
        return a.words[0] = 0, a.length = 1, a;
      var l = a.imul(u), d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = l.isub(d).iushrn(this.shift), y = g;
      return g.cmp(this.m) >= 0 ? y = g.isub(this.m) : g.cmpn(0) < 0 && (y = g.iadd(this.m)), y._forceRed(this);
    }, R.prototype.mul = function(a, u) {
      if (a.isZero() || u.isZero())
        return new s(0)._forceRed(this);
      var l = a.mul(u), d = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = l.isub(d).iushrn(this.shift), y = g;
      return g.cmp(this.m) >= 0 ? y = g.isub(this.m) : g.cmpn(0) < 0 && (y = g.iadd(this.m)), y._forceRed(this);
    }, R.prototype.invm = function(a) {
      var u = this.imod(a._invmp(this.m).mul(this.r2));
      return u._forceRed(this);
    };
  })(e, xo);
})(Co);
var uu = Co.exports;
const ut = /* @__PURE__ */ ci(uu), hu = "logger/5.7.0";
let Us = !1, Ls = !1;
const Kn = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Fs = Kn.default, Gi = null;
function lu() {
  try {
    const e = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        e.push(t);
      }
    }), e.length)
      throw new Error("missing " + e.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (e) {
    return e.message;
  }
  return null;
}
const Gs = lu();
var as;
(function(e) {
  e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF";
})(as || (as = {}));
var He;
(function(e) {
  e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED";
})(He || (He = {}));
const Hs = "0123456789abcdef";
class M {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, r) {
    const n = t.toLowerCase();
    Kn[n] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(Fs > Kn[n]) && console.log.apply(console, r);
  }
  debug(...t) {
    this._log(M.levels.DEBUG, t);
  }
  info(...t) {
    this._log(M.levels.INFO, t);
  }
  warn(...t) {
    this._log(M.levels.WARNING, t);
  }
  makeError(t, r, n) {
    if (Ls)
      return this.makeError("censored error", r, {});
    r || (r = M.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((f) => {
      const m = n[f];
      try {
        if (m instanceof Uint8Array) {
          let E = "";
          for (let _ = 0; _ < m.length; _++)
            E += Hs[m[_] >> 4], E += Hs[m[_] & 15];
          i.push(f + "=Uint8Array(0x" + E + ")");
        } else
          i.push(f + "=" + JSON.stringify(m));
      } catch {
        i.push(f + "=" + JSON.stringify(n[f].toString()));
      }
    }), i.push(`code=${r}`), i.push(`version=${this.version}`);
    const s = t;
    let o = "";
    switch (r) {
      case He.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const f = t;
        switch (f) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + f;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case He.CALL_EXCEPTION:
      case He.INSUFFICIENT_FUNDS:
      case He.MISSING_NEW:
      case He.NONCE_EXPIRED:
      case He.REPLACEMENT_UNDERPRICED:
      case He.TRANSACTION_REPLACED:
      case He.UNPREDICTABLE_GAS_LIMIT:
        o = r;
        break;
    }
    o && (t += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (t += " (" + i.join(", ") + ")");
    const c = new Error(t);
    return c.reason = s, c.code = r, Object.keys(n).forEach(function(f) {
      c[f] = n[f];
    }), c;
  }
  throwError(t, r, n) {
    throw this.makeError(t, r, n);
  }
  throwArgumentError(t, r, n) {
    return this.throwError(t, M.errors.INVALID_ARGUMENT, {
      argument: r,
      value: n
    });
  }
  assert(t, r, n, i) {
    t || this.throwError(r, n, i);
  }
  assertArgument(t, r, n, i) {
    t || this.throwArgumentError(r, n, i);
  }
  checkNormalize(t) {
    Gs && this.throwError("platform missing String.prototype.normalize", M.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: Gs
    });
  }
  checkSafeUint53(t, r) {
    typeof t == "number" && (r == null && (r = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(r, M.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(r, M.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, r, n) {
    n ? n = ": " + n : n = "", t < r && this.throwError("missing argument" + n, M.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: r
    }), t > r && this.throwError("too many arguments" + n, M.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: r
    });
  }
  checkNew(t, r) {
    (t === Object || t == null) && this.throwError("missing new", M.errors.MISSING_NEW, { name: r.name });
  }
  checkAbstract(t, r) {
    t === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", M.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", M.errors.MISSING_NEW, { name: r.name });
  }
  static globalLogger() {
    return Gi || (Gi = new M(hu)), Gi;
  }
  static setCensorship(t, r) {
    if (!t && r && this.globalLogger().throwError("cannot permanently disable censorship", M.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Us) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", M.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    Ls = !!t, Us = !!r;
  }
  static setLogLevel(t) {
    const r = Kn[t.toLowerCase()];
    if (r == null) {
      M.globalLogger().warn("invalid log level - " + t);
      return;
    }
    Fs = r;
  }
  static from(t) {
    return new M(t);
  }
}
M.errors = He;
M.levels = as;
const cu = "bytes/5.7.0", Zt = new M(cu);
function Bo(e) {
  return !!e.toHexString;
}
function on(e) {
  return e.slice || (e.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return on(new Uint8Array(Array.prototype.slice.apply(e, t)));
  }), e;
}
function fi(e) {
  return pt(e) && !(e.length % 2) || kn(e);
}
function Vs(e) {
  return typeof e == "number" && e == e && e % 1 === 0;
}
function kn(e) {
  if (e == null)
    return !1;
  if (e.constructor === Uint8Array)
    return !0;
  if (typeof e == "string" || !Vs(e.length) || e.length < 0)
    return !1;
  for (let t = 0; t < e.length; t++) {
    const r = e[t];
    if (!Vs(r) || r < 0 || r >= 256)
      return !1;
  }
  return !0;
}
function et(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Zt.checkSafeUint53(e, "invalid arrayify value");
    const r = [];
    for (; e; )
      r.unshift(e & 255), e = parseInt(String(e / 256));
    return r.length === 0 && r.push(0), on(new Uint8Array(r));
  }
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), Bo(e) && (e = e.toHexString()), pt(e)) {
    let r = e.substring(2);
    r.length % 2 && (t.hexPad === "left" ? r = "0" + r : t.hexPad === "right" ? r += "0" : Zt.throwArgumentError("hex data is odd-length", "value", e));
    const n = [];
    for (let i = 0; i < r.length; i += 2)
      n.push(parseInt(r.substring(i, i + 2), 16));
    return on(new Uint8Array(n));
  }
  return kn(e) ? on(new Uint8Array(e)) : Zt.throwArgumentError("invalid arrayify value", "value", e);
}
function ge(e) {
  const t = e.map((i) => et(i)), r = t.reduce((i, s) => i + s.length, 0), n = new Uint8Array(r);
  return t.reduce((i, s) => (n.set(s, i), i + s.length), 0), on(n);
}
function Yr(e) {
  let t = et(e);
  if (t.length === 0)
    return t;
  let r = 0;
  for (; r < t.length && t[r] === 0; )
    r++;
  return r && (t = t.slice(r)), t;
}
function Do(e, t) {
  e = et(e), e.length > t && Zt.throwArgumentError("value out of range", "value", arguments[0]);
  const r = new Uint8Array(t);
  return r.set(e, t - e.length), on(r);
}
function pt(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
const Hi = "0123456789abcdef";
function K(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Zt.checkSafeUint53(e, "invalid hexlify value");
    let r = "";
    for (; e; )
      r = Hi[e & 15] + r, e = Math.floor(e / 16);
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof e == "bigint")
    return e = e.toString(16), e.length % 2 ? "0x0" + e : "0x" + e;
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), Bo(e))
    return e.toHexString();
  if (pt(e))
    return e.length % 2 && (t.hexPad === "left" ? e = "0x0" + e.substring(2) : t.hexPad === "right" ? e += "0" : Zt.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
  if (kn(e)) {
    let r = "0x";
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      r += Hi[(i & 240) >> 4] + Hi[i & 15];
    }
    return r;
  }
  return Zt.throwArgumentError("invalid hexlify value", "value", e);
}
function Ir(e) {
  if (typeof e != "string")
    e = K(e);
  else if (!pt(e) || e.length % 2)
    return null;
  return (e.length - 2) / 2;
}
function he(e, t, r) {
  return typeof e != "string" ? e = K(e) : (!pt(e) || e.length % 2) && Zt.throwArgumentError("invalid hexData", "value", e), t = 2 + 2 * t, r != null ? "0x" + e.substring(t, 2 + 2 * r) : "0x" + e.substring(t);
}
function de(e) {
  let t = "0x";
  return e.forEach((r) => {
    t += K(r).substring(2);
  }), t;
}
function di(e) {
  const t = Uo(K(e, { hexPad: "left" }));
  return t === "0x" ? "0x0" : t;
}
function Uo(e) {
  typeof e != "string" && (e = K(e)), pt(e) || Zt.throwArgumentError("invalid hex string", "value", e), e = e.substring(2);
  let t = 0;
  for (; t < e.length && e[t] === "0"; )
    t++;
  return "0x" + e.substring(t);
}
function Xt(e, t) {
  for (typeof e != "string" ? e = K(e) : pt(e) || Zt.throwArgumentError("invalid hex string", "value", e), e.length > 2 * t + 2 && Zt.throwArgumentError("value out of range", "value", arguments[1]); e.length < 2 * t + 2; )
    e = "0x0" + e.substring(2);
  return e;
}
function xn(e) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (fi(e)) {
    let r = et(e);
    r.length === 64 ? (t.v = 27 + (r[32] >> 7), r[32] &= 127, t.r = K(r.slice(0, 32)), t.s = K(r.slice(32, 64))) : r.length === 65 ? (t.r = K(r.slice(0, 32)), t.s = K(r.slice(32, 64)), t.v = r[64]) : Zt.throwArgumentError("invalid signature string", "signature", e), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : Zt.throwArgumentError("signature invalid v byte", "signature", e)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (r[32] |= 128), t._vs = K(r.slice(32, 64));
  } else {
    if (t.r = e.r, t.s = e.s, t.v = e.v, t.recoveryParam = e.recoveryParam, t._vs = e._vs, t._vs != null) {
      const i = Do(et(t._vs), 32);
      t._vs = K(i);
      const s = i[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = s : t.recoveryParam !== s && Zt.throwArgumentError("signature recoveryParam mismatch _vs", "signature", e), i[0] &= 127;
      const o = K(i);
      t.s == null ? t.s = o : t.s !== o && Zt.throwArgumentError("signature v mismatch _vs", "signature", e);
    }
    if (t.recoveryParam == null)
      t.v == null ? Zt.throwArgumentError("signature missing v and recoveryParam", "signature", e) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null)
      t.v = 27 + t.recoveryParam;
    else {
      const i = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== i && Zt.throwArgumentError("signature recoveryParam mismatch v", "signature", e);
    }
    t.r == null || !pt(t.r) ? Zt.throwArgumentError("signature missing or invalid r", "signature", e) : t.r = Xt(t.r, 32), t.s == null || !pt(t.s) ? Zt.throwArgumentError("signature missing or invalid s", "signature", e) : t.s = Xt(t.s, 32);
    const r = et(t.s);
    r[0] >= 128 && Zt.throwArgumentError("signature s out of range", "signature", e), t.recoveryParam && (r[0] |= 128);
    const n = K(r);
    t._vs && (pt(t._vs) || Zt.throwArgumentError("signature invalid _vs", "signature", e), t._vs = Xt(t._vs, 32)), t._vs == null ? t._vs = n : t._vs !== n && Zt.throwArgumentError("signature _vs mismatch v and s", "signature", e);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
const fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayify: et,
  concat: ge,
  hexConcat: de,
  hexDataLength: Ir,
  hexDataSlice: he,
  hexStripZeros: Uo,
  hexValue: di,
  hexZeroPad: Xt,
  hexlify: K,
  isBytes: kn,
  isBytesLike: fi,
  isHexString: pt,
  splitSignature: xn,
  stripZeros: Yr,
  zeroPad: Do
}, Symbol.toStringTag, { value: "Module" })), du = "bignumber/5.7.0";
var ri = ut.BN;
const sr = new M(du), Vi = {}, zs = 9007199254740991;
let qs = !1, V = class Ue {
  constructor(t, r) {
    t !== Vi && sr.throwError("cannot call constructor directly; use BigNumber.from", M.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = r, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(t) {
    return pe(lt(this).fromTwos(t));
  }
  toTwos(t) {
    return pe(lt(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? Ue.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return pe(lt(this).add(lt(t)));
  }
  sub(t) {
    return pe(lt(this).sub(lt(t)));
  }
  div(t) {
    return Ue.from(t).isZero() && _e("division-by-zero", "div"), pe(lt(this).div(lt(t)));
  }
  mul(t) {
    return pe(lt(this).mul(lt(t)));
  }
  mod(t) {
    const r = lt(t);
    return r.isNeg() && _e("division-by-zero", "mod"), pe(lt(this).umod(r));
  }
  pow(t) {
    const r = lt(t);
    return r.isNeg() && _e("negative-power", "pow"), pe(lt(this).pow(r));
  }
  and(t) {
    const r = lt(t);
    return (this.isNegative() || r.isNeg()) && _e("unbound-bitwise-result", "and"), pe(lt(this).and(r));
  }
  or(t) {
    const r = lt(t);
    return (this.isNegative() || r.isNeg()) && _e("unbound-bitwise-result", "or"), pe(lt(this).or(r));
  }
  xor(t) {
    const r = lt(t);
    return (this.isNegative() || r.isNeg()) && _e("unbound-bitwise-result", "xor"), pe(lt(this).xor(r));
  }
  mask(t) {
    return (this.isNegative() || t < 0) && _e("negative-width", "mask"), pe(lt(this).maskn(t));
  }
  shl(t) {
    return (this.isNegative() || t < 0) && _e("negative-width", "shl"), pe(lt(this).shln(t));
  }
  shr(t) {
    return (this.isNegative() || t < 0) && _e("negative-width", "shr"), pe(lt(this).shrn(t));
  }
  eq(t) {
    return lt(this).eq(lt(t));
  }
  lt(t) {
    return lt(this).lt(lt(t));
  }
  lte(t) {
    return lt(this).lte(lt(t));
  }
  gt(t) {
    return lt(this).gt(lt(t));
  }
  gte(t) {
    return lt(this).gte(lt(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return lt(this).isZero();
  }
  toNumber() {
    try {
      return lt(this).toNumber();
    } catch {
      _e("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return sr.throwError("this platform does not support BigInt", M.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? qs || (qs = !0, sr.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? sr.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", M.errors.UNEXPECTED_ARGUMENT, {}) : sr.throwError("BigNumber.toString does not accept parameters", M.errors.UNEXPECTED_ARGUMENT, {})), lt(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof Ue)
      return t;
    if (typeof t == "string")
      return t.match(/^-?0x[0-9a-f]+$/i) ? new Ue(Vi, In(t)) : t.match(/^-?[0-9]+$/) ? new Ue(Vi, In(new ri(t))) : sr.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number")
      return t % 1 && _e("underflow", "BigNumber.from", t), (t >= zs || t <= -zs) && _e("overflow", "BigNumber.from", t), Ue.from(String(t));
    const r = t;
    if (typeof r == "bigint")
      return Ue.from(r.toString());
    if (kn(r))
      return Ue.from(K(r));
    if (r)
      if (r.toHexString) {
        const n = r.toHexString();
        if (typeof n == "string")
          return Ue.from(n);
      } else {
        let n = r._hex;
        if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (pt(n) || n[0] === "-" && pt(n.substring(1))))
          return Ue.from(n);
      }
    return sr.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
};
function In(e) {
  if (typeof e != "string")
    return In(e.toString(16));
  if (e[0] === "-")
    return e = e.substring(1), e[0] === "-" && sr.throwArgumentError("invalid hex", "value", e), e = In(e), e === "0x00" ? e : "-" + e;
  if (e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x")
    return "0x00";
  for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00"; )
    e = "0x" + e.substring(4);
  return e;
}
function pe(e) {
  return V.from(In(e));
}
function lt(e) {
  const t = V.from(e).toHexString();
  return t[0] === "-" ? new ri("-" + t.substring(3), 16) : new ri(t.substring(2), 16);
}
function _e(e, t, r) {
  const n = { fault: e, operation: t };
  return r != null && (n.value = r), sr.throwError(e, M.errors.NUMERIC_FAULT, n);
}
function pu(e) {
  return new ri(e, 36).toString(16);
}
const nr = (e) => typeof e == "string" || typeof e == "number" || e instanceof V, hr = (e, t = 8) => {
  const r = V.from(e || 0);
  return {
    amount: () => r,
    plus: (n, i = t) => hr(r.add(nr(n) ? n : n.amount()), i),
    minus: (n, i = t) => hr(r.sub(nr(n) ? n : n.amount()), i),
    times: (n, i = t) => hr(r.mul(nr(n) ? n : n.amount()), i),
    div: (n, i = t) => hr(r.div(nr(n) ? n : n.amount()), i),
    lt: (n) => r.lt(nr(n) ? n : n.amount()),
    lte: (n) => r.lte(nr(n) ? n : n.amount()),
    gt: (n) => r.gt(nr(n) ? n : n.amount()),
    gte: (n) => r.gte(nr(n) ? n : n.amount()),
    eq: (n) => r.eq(nr(n) ? n : n.amount()),
    decimal: t
  };
}, Lo = (e) => {
  var t;
  const [r, ...n] = e.split("."), i = e.includes("/"), s = n.join("."), o = (t = s == null ? void 0 : s.split("-")) == null ? void 0 : t[0];
  return { chain: r, symbol: s, ticker: o, synth: i };
}, pi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var nt = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(nt || {});
nt.INVALID_INPUT_PARAMETERS + "", nt.UNKNOWN_PROVIDERS + "", nt.CANNOT_FIND_INBOUND_ADDRESS + "", nt.NO_INBOUND_ADDRESSES + "", nt.CHAIN_HALTED_OR_UNSUPPORTED + "", nt.MISSING_INPUT_PARAMETER + "", nt.INVALID_TYPE_GENERIC + "", nt.INVALID_NUMBER_STRING + "", nt.INVALID_NUMBER + "", nt.INVALID_BOOLEAN + "", nt.INVALID_OBJECT + "", nt.INVALID_ARRAY + "", nt.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", nt.SELL_BUY_ASSETS_ARE_THE_SAME + "", nt.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", nt.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", nt.AFF_ADDRESS_TOO_LONG + "", nt.AFF_BPS_INTEGER_0_100 + "", nt.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", nt.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", nt.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", nt.DESTINATION_ADDRESS_SMART_CONTRACT + "", nt.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", nt.INVALID_PROVIDER + "", nt.MISSING_CROSS_CHAIN_PROVIDER + "", nt.MISSING_AVAX_PROVIDER + "", nt.MISSING_BSC_PROVIDER + "", nt.MISSING_ETH_PROVIDER + "", nt.MISSING_ARB_PROVIDER + "", nt.INVALID_PROVIDER_FOR_SWAP_OUT + "", nt.INVALID_CHAIN + "", nt.INVALID_ASSET + "", nt.UNSUPPORTED_CHAIN + "", nt.UNSUPPORTED_ASSET + "", nt.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", nt.THORNODE_QUOTE_GENERIC_ERROR + "", nt.NOT_ENOUGH_SYNTH_BALANCE + "", nt.SYNTH_MINTING_CAP_REACHED + "", nt.INVALID_QUOTE_MODE + "", nt.NO_QUOTES + "", nt.SERVICE_UNAVAILABLE_GENERIC + "", nt.MISSING_GAS_DATA_GENERIC + "", nt.MISSING_TOKEN_INFO_GENERIC + "", nt.CANT_FIND_TOKEN_LIST + "", nt.NO_PRICE + "", nt.PRICE_IS_STALE + "", nt.ADDRESS_NOT_WHITELISTED + "", nt.ADDRESS_ALREADY_CLAIMED + "";
var te = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dogecoin = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.Optimism = "OP", e.Polygon = "MATIC", e.THORChain = "THOR", e))(te || {}), jr = /* @__PURE__ */ ((e) => (e.ARB = "0x0000000000000000000000000000000000000000", e.AVAX = "0x0000000000000000000000000000000000000000", e.ETH = "0x0000000000000000000000000000000000000000", e.BSC = "0x0000000000000000000000000000000000000000", e.MATIC = "0x0000000000000000000000000000000000001010", e.OP = "0x4200000000000000000000000000000000000042", e))(jr || {}), cn = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.OP = 18] = "OP", e[e.THOR = 8] = "THOR", e))(cn || {}), Zr = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceHex = "", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinHex = "", e.BitcoinCash = "bitcoincash", e.BitcoinCashHex = "", e.Cosmos = "cosmoshub-4", e.CosmosHex = "", e.Dogecoin = "dogecoin", e.DogecoinHex = "", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.LitecoinHex = "", e.Optimism = "10", e.OptimismHex = "0xa", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainHex = "", e.THORChainStagenet = "thorchain-stagenet-v2", e))(Zr || {}), Fo = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Optimism = "https://mainnet.optimism.io", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(Fo || {});
const mi = Object.values(te), mu = Object.keys(te), As = mi.reduce(
  (e, t) => {
    const r = mu.find((n) => te[n] === t);
    return r && (e[t] = r), e;
  },
  {}
);
mi.reduce(
  (e, t) => (e[t] = Zr[As[t]], e),
  {}
);
const gu = mi.reduce(
  (e, t) => (e[t] = Fo[As[t]], e),
  {}
);
mi.reduce(
  (e, t) => (e[t] = Zr[`${As[t]}Hex`], e),
  {}
);
const zi = {
  42161: "ARB",
  "0xa4b1": "ARB",
  "0xa86a": "AVAX",
  43114: "AVAX",
  "Binance-Chain-Tigris": "BNB",
  56: "BSC",
  "0x38": "BSC",
  bitcoin: "BTC",
  bitcoincash: "BCH",
  "cosmoshub-4": "GAIA",
  dogecoin: "DOGE",
  "0x1": "ETH",
  1: "ETH",
  litecoin: "LTC",
  "thorchain-mainnet-v1": "THOR",
  "": "THOR",
  "thorchain-stagenet-v2": "THOR",
  10: "OP",
  "0xa": "OP",
  137: "MATIC",
  "0x89": "MATIC"
  /* Polygon */
}, Go = {
  ARB: "https://arbiscan.io",
  AVAX: "https://snowtrace.io",
  BSC: "https://bscscan.com",
  BNB: "https://explorer.binance.org",
  BCH: "https://www.blockchain.com/bch",
  BTC: "https://blockstream.info",
  GAIA: "https://cosmos.bigdipper.live",
  DOGE: "https://blockchair.com/dogecoin",
  ETH: "https://etherscan.io",
  LTC: "https://ltc.bitaps.com",
  OP: "https://optimistic.etherscan.io",
  MATIC: "https://polygonscan.com",
  THOR: "https://viewblock.io/thorchain"
};
var Ee = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(Ee || {});
Ee.Average + "", Ee.Fast + "", Ee.Fastest + "";
const Ho = async (e, t) => {
  const r = Object.entries(t || {}).reduce((n, [i, s]) => (s && (n[i] = s), n), {});
  return (await fetch(
    `${e}${t ? `?${new URLSearchParams(r).toString()}` : ""}`,
    { method: "GET", mode: "cors", credentials: "omit" }
  )).json();
};
var yu = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, qi = Math.ceil, Se = Math.floor, me = "[BigNumber Error] ", js = me + "Number primitive has more than 15 significant digits: ", xe = 1e14, at = 14, ji = 9007199254740991, Qi = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], Er = 1e7, oe = 1e9;
function Vo(e) {
  var t, r, n, i = P.prototype = { constructor: P, toString: null, valueOf: null }, s = new P(1), o = 20, c = 4, f = -7, m = 21, E = -1e7, _ = 1e7, S = !1, O = 1, C = 0, F = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, L = "0123456789abcdefghijklmnopqrstuvwxyz", D = !0;
  function P(v, N) {
    var I, T, R, a, u, l, d, g, y = this;
    if (!(y instanceof P))
      return new P(v, N);
    if (N == null) {
      if (v && v._isBigNumber === !0) {
        y.s = v.s, !v.c || v.e > _ ? y.c = y.e = null : v.e < E ? y.c = [y.e = 0] : (y.e = v.e, y.c = v.c.slice());
        return;
      }
      if ((l = typeof v == "number") && v * 0 == 0) {
        if (y.s = 1 / v < 0 ? (v = -v, -1) : 1, v === ~~v) {
          for (a = 0, u = v; u >= 10; u /= 10, a++)
            ;
          a > _ ? y.c = y.e = null : (y.e = a, y.c = [v]);
          return;
        }
        g = String(v);
      } else {
        if (!yu.test(g = String(v)))
          return n(y, g, l);
        y.s = g.charCodeAt(0) == 45 ? (g = g.slice(1), -1) : 1;
      }
      (a = g.indexOf(".")) > -1 && (g = g.replace(".", "")), (u = g.search(/e/i)) > 0 ? (a < 0 && (a = u), a += +g.slice(u + 1), g = g.substring(0, u)) : a < 0 && (a = g.length);
    } else {
      if (Jt(N, 2, L.length, "Base"), N == 10 && D)
        return y = new P(v), tt(y, o + y.e + 1, c);
      if (g = String(v), l = typeof v == "number") {
        if (v * 0 != 0)
          return n(y, g, l, N);
        if (y.s = 1 / v < 0 ? (g = g.slice(1), -1) : 1, P.DEBUG && g.replace(/^0\.0*|\./, "").length > 15)
          throw Error(js + v);
      } else
        y.s = g.charCodeAt(0) === 45 ? (g = g.slice(1), -1) : 1;
      for (I = L.slice(0, N), a = u = 0, d = g.length; u < d; u++)
        if (I.indexOf(T = g.charAt(u)) < 0) {
          if (T == ".") {
            if (u > a) {
              a = d;
              continue;
            }
          } else if (!R && (g == g.toUpperCase() && (g = g.toLowerCase()) || g == g.toLowerCase() && (g = g.toUpperCase()))) {
            R = !0, u = -1, a = 0;
            continue;
          }
          return n(y, String(v), l, N);
        }
      l = !1, g = r(g, N, 10, y.s), (a = g.indexOf(".")) > -1 ? g = g.replace(".", "") : a = g.length;
    }
    for (u = 0; g.charCodeAt(u) === 48; u++)
      ;
    for (d = g.length; g.charCodeAt(--d) === 48; )
      ;
    if (g = g.slice(u, ++d)) {
      if (d -= u, l && P.DEBUG && d > 15 && (v > ji || v !== Se(v)))
        throw Error(js + y.s * v);
      if ((a = a - u - 1) > _)
        y.c = y.e = null;
      else if (a < E)
        y.c = [y.e = 0];
      else {
        if (y.e = a, y.c = [], u = (a + 1) % at, a < 0 && (u += at), u < d) {
          for (u && y.c.push(+g.slice(0, u)), d -= at; u < d; )
            y.c.push(+g.slice(u, u += at));
          u = at - (g = g.slice(u)).length;
        } else
          u -= d;
        for (; u--; g += "0")
          ;
        y.c.push(+g);
      }
    } else
      y.c = [y.e = 0];
  }
  P.clone = Vo, P.ROUND_UP = 0, P.ROUND_DOWN = 1, P.ROUND_CEIL = 2, P.ROUND_FLOOR = 3, P.ROUND_HALF_UP = 4, P.ROUND_HALF_DOWN = 5, P.ROUND_HALF_EVEN = 6, P.ROUND_HALF_CEIL = 7, P.ROUND_HALF_FLOOR = 8, P.EUCLID = 9, P.config = P.set = function(v) {
    var N, I;
    if (v != null)
      if (typeof v == "object") {
        if (v.hasOwnProperty(N = "DECIMAL_PLACES") && (I = v[N], Jt(I, 0, oe, N), o = I), v.hasOwnProperty(N = "ROUNDING_MODE") && (I = v[N], Jt(I, 0, 8, N), c = I), v.hasOwnProperty(N = "EXPONENTIAL_AT") && (I = v[N], I && I.pop ? (Jt(I[0], -oe, 0, N), Jt(I[1], 0, oe, N), f = I[0], m = I[1]) : (Jt(I, -oe, oe, N), f = -(m = I < 0 ? -I : I))), v.hasOwnProperty(N = "RANGE"))
          if (I = v[N], I && I.pop)
            Jt(I[0], -oe, -1, N), Jt(I[1], 1, oe, N), E = I[0], _ = I[1];
          else if (Jt(I, -oe, oe, N), I)
            E = -(_ = I < 0 ? -I : I);
          else
            throw Error(me + N + " cannot be zero: " + I);
        if (v.hasOwnProperty(N = "CRYPTO"))
          if (I = v[N], I === !!I)
            if (I)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                S = I;
              else
                throw S = !I, Error(me + "crypto unavailable");
            else
              S = I;
          else
            throw Error(me + N + " not true or false: " + I);
        if (v.hasOwnProperty(N = "MODULO_MODE") && (I = v[N], Jt(I, 0, 9, N), O = I), v.hasOwnProperty(N = "POW_PRECISION") && (I = v[N], Jt(I, 0, oe, N), C = I), v.hasOwnProperty(N = "FORMAT"))
          if (I = v[N], typeof I == "object")
            F = I;
          else
            throw Error(me + N + " not an object: " + I);
        if (v.hasOwnProperty(N = "ALPHABET"))
          if (I = v[N], typeof I == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(I))
            D = I.slice(0, 10) == "0123456789", L = I;
          else
            throw Error(me + N + " invalid: " + I);
      } else
        throw Error(me + "Object expected: " + v);
    return {
      DECIMAL_PLACES: o,
      ROUNDING_MODE: c,
      EXPONENTIAL_AT: [f, m],
      RANGE: [E, _],
      CRYPTO: S,
      MODULO_MODE: O,
      POW_PRECISION: C,
      FORMAT: F,
      ALPHABET: L
    };
  }, P.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== !0)
      return !1;
    if (!P.DEBUG)
      return !0;
    var N, I, T = v.c, R = v.e, a = v.s;
    t:
      if ({}.toString.call(T) == "[object Array]") {
        if ((a === 1 || a === -1) && R >= -oe && R <= oe && R === Se(R)) {
          if (T[0] === 0) {
            if (R === 0 && T.length === 1)
              return !0;
            break t;
          }
          if (N = (R + 1) % at, N < 1 && (N += at), String(T[0]).length == N) {
            for (N = 0; N < T.length; N++)
              if (I = T[N], I < 0 || I >= xe || I !== Se(I))
                break t;
            if (I !== 0)
              return !0;
          }
        }
      } else if (T === null && R === null && (a === null || a === 1 || a === -1))
        return !0;
    throw Error(me + "Invalid BigNumber: " + v);
  }, P.maximum = P.max = function() {
    return rt(arguments, -1);
  }, P.minimum = P.min = function() {
    return rt(arguments, 1);
  }, P.random = function() {
    var v = 9007199254740992, N = Math.random() * v & 2097151 ? function() {
      return Se(Math.random() * v);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(I) {
      var T, R, a, u, l, d = 0, g = [], y = new P(s);
      if (I == null ? I = o : Jt(I, 0, oe), u = qi(I / at), S)
        if (crypto.getRandomValues) {
          for (T = crypto.getRandomValues(new Uint32Array(u *= 2)); d < u; )
            l = T[d] * 131072 + (T[d + 1] >>> 11), l >= 9e15 ? (R = crypto.getRandomValues(new Uint32Array(2)), T[d] = R[0], T[d + 1] = R[1]) : (g.push(l % 1e14), d += 2);
          d = u / 2;
        } else if (crypto.randomBytes) {
          for (T = crypto.randomBytes(u *= 7); d < u; )
            l = (T[d] & 31) * 281474976710656 + T[d + 1] * 1099511627776 + T[d + 2] * 4294967296 + T[d + 3] * 16777216 + (T[d + 4] << 16) + (T[d + 5] << 8) + T[d + 6], l >= 9e15 ? crypto.randomBytes(7).copy(T, d) : (g.push(l % 1e14), d += 7);
          d = u / 7;
        } else
          throw S = !1, Error(me + "crypto unavailable");
      if (!S)
        for (; d < u; )
          l = N(), l < 9e15 && (g[d++] = l % 1e14);
      for (u = g[--d], I %= at, u && I && (l = Qi[at - I], g[d] = Se(u / l) * l); g[d] === 0; g.pop(), d--)
        ;
      if (d < 0)
        g = [a = 0];
      else {
        for (a = -1; g[0] === 0; g.splice(0, 1), a -= at)
          ;
        for (d = 1, l = g[0]; l >= 10; l /= 10, d++)
          ;
        d < at && (a -= at - d);
      }
      return y.e = a, y.c = g, y;
    };
  }(), P.sum = function() {
    for (var v = 1, N = arguments, I = new P(N[0]); v < N.length; )
      I = I.plus(N[v++]);
    return I;
  }, r = function() {
    var v = "0123456789";
    function N(I, T, R, a) {
      for (var u, l = [0], d, g = 0, y = I.length; g < y; ) {
        for (d = l.length; d--; l[d] *= T)
          ;
        for (l[0] += a.indexOf(I.charAt(g++)), u = 0; u < l.length; u++)
          l[u] > R - 1 && (l[u + 1] == null && (l[u + 1] = 0), l[u + 1] += l[u] / R | 0, l[u] %= R);
      }
      return l.reverse();
    }
    return function(I, T, R, a, u) {
      var l, d, g, y, b, w, h, A, j = I.indexOf("."), z = o, p = c;
      for (j >= 0 && (y = C, C = 0, I = I.replace(".", ""), A = new P(T), w = A.pow(I.length - j), C = y, A.c = N(
        ir(Ie(w.c), w.e, "0"),
        10,
        R,
        v
      ), A.e = A.c.length), h = N(I, T, R, u ? (l = L, v) : (l = v, L)), g = y = h.length; h[--y] == 0; h.pop())
        ;
      if (!h[0])
        return l.charAt(0);
      if (j < 0 ? --g : (w.c = h, w.e = g, w.s = a, w = t(w, A, z, p, R), h = w.c, b = w.r, g = w.e), d = g + z + 1, j = h[d], y = R / 2, b = b || d < 0 || h[d + 1] != null, b = p < 4 ? (j != null || b) && (p == 0 || p == (w.s < 0 ? 3 : 2)) : j > y || j == y && (p == 4 || b || p == 6 && h[d - 1] & 1 || p == (w.s < 0 ? 8 : 7)), d < 1 || !h[0])
        I = b ? ir(l.charAt(1), -z, l.charAt(0)) : l.charAt(0);
      else {
        if (h.length = d, b)
          for (--R; ++h[--d] > R; )
            h[d] = 0, d || (++g, h = [1].concat(h));
        for (y = h.length; !h[--y]; )
          ;
        for (j = 0, I = ""; j <= y; I += l.charAt(h[j++]))
          ;
        I = ir(I, g, l.charAt(0));
      }
      return I;
    };
  }(), t = function() {
    function v(T, R, a) {
      var u, l, d, g, y = 0, b = T.length, w = R % Er, h = R / Er | 0;
      for (T = T.slice(); b--; )
        d = T[b] % Er, g = T[b] / Er | 0, u = h * d + g * w, l = w * d + u % Er * Er + y, y = (l / a | 0) + (u / Er | 0) + h * g, T[b] = l % a;
      return y && (T = [y].concat(T)), T;
    }
    function N(T, R, a, u) {
      var l, d;
      if (a != u)
        d = a > u ? 1 : -1;
      else
        for (l = d = 0; l < a; l++)
          if (T[l] != R[l]) {
            d = T[l] > R[l] ? 1 : -1;
            break;
          }
      return d;
    }
    function I(T, R, a, u) {
      for (var l = 0; a--; )
        T[a] -= l, l = T[a] < R[a] ? 1 : 0, T[a] = l * u + T[a] - R[a];
      for (; !T[0] && T.length > 1; T.splice(0, 1))
        ;
    }
    return function(T, R, a, u, l) {
      var d, g, y, b, w, h, A, j, z, p, k, x, B, Q, q, H, J, Z = T.s == R.s ? 1 : -1, G = T.c, st = R.c;
      if (!G || !G[0] || !st || !st[0])
        return new P(
          // Return NaN if either NaN, or both Infinity or 0.
          !T.s || !R.s || (G ? st && G[0] == st[0] : !st) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            G && G[0] == 0 || !st ? Z * 0 : Z / 0
          )
        );
      for (j = new P(Z), z = j.c = [], g = T.e - R.e, Z = a + g + 1, l || (l = xe, g = Re(T.e / at) - Re(R.e / at), Z = Z / at | 0), y = 0; st[y] == (G[y] || 0); y++)
        ;
      if (st[y] > (G[y] || 0) && g--, Z < 0)
        z.push(1), b = !0;
      else {
        for (Q = G.length, H = st.length, y = 0, Z += 2, w = Se(l / (st[0] + 1)), w > 1 && (st = v(st, w, l), G = v(G, w, l), H = st.length, Q = G.length), B = H, p = G.slice(0, H), k = p.length; k < H; p[k++] = 0)
          ;
        J = st.slice(), J = [0].concat(J), q = st[0], st[1] >= l / 2 && q++;
        do {
          if (w = 0, d = N(st, p, H, k), d < 0) {
            if (x = p[0], H != k && (x = x * l + (p[1] || 0)), w = Se(x / q), w > 1)
              for (w >= l && (w = l - 1), h = v(st, w, l), A = h.length, k = p.length; N(h, p, A, k) == 1; )
                w--, I(h, H < A ? J : st, A, l), A = h.length, d = 1;
            else
              w == 0 && (d = w = 1), h = st.slice(), A = h.length;
            if (A < k && (h = [0].concat(h)), I(p, h, k, l), k = p.length, d == -1)
              for (; N(st, p, H, k) < 1; )
                w++, I(p, H < k ? J : st, k, l), k = p.length;
          } else
            d === 0 && (w++, p = [0]);
          z[y++] = w, p[0] ? p[k++] = G[B] || 0 : (p = [G[B]], k = 1);
        } while ((B++ < Q || p[0] != null) && Z--);
        b = p[0] != null, z[0] || z.splice(0, 1);
      }
      if (l == xe) {
        for (y = 1, Z = z[0]; Z >= 10; Z /= 10, y++)
          ;
        tt(j, a + (j.e = y + g * at - 1) + 1, u, b);
      } else
        j.e = g, j.r = +b;
      return j;
    };
  }();
  function X(v, N, I, T) {
    var R, a, u, l, d;
    if (I == null ? I = c : Jt(I, 0, 8), !v.c)
      return v.toString();
    if (R = v.c[0], u = v.e, N == null)
      d = Ie(v.c), d = T == 1 || T == 2 && (u <= f || u >= m) ? Vn(d, u) : ir(d, u, "0");
    else if (v = tt(new P(v), N, I), a = v.e, d = Ie(v.c), l = d.length, T == 1 || T == 2 && (N <= a || a <= f)) {
      for (; l < N; d += "0", l++)
        ;
      d = Vn(d, a);
    } else if (N -= u, d = ir(d, a, "0"), a + 1 > l) {
      if (--N > 0)
        for (d += "."; N--; d += "0")
          ;
    } else if (N += a - l, N > 0)
      for (a + 1 == l && (d += "."); N--; d += "0")
        ;
    return v.s < 0 && R ? "-" + d : d;
  }
  function rt(v, N) {
    for (var I, T, R = 1, a = new P(v[0]); R < v.length; R++)
      T = new P(v[R]), (!T.s || (I = qr(a, T)) === N || I === 0 && a.s === N) && (a = T);
    return a;
  }
  function $(v, N, I) {
    for (var T = 1, R = N.length; !N[--R]; N.pop())
      ;
    for (R = N[0]; R >= 10; R /= 10, T++)
      ;
    return (I = T + I * at - 1) > _ ? v.c = v.e = null : I < E ? v.c = [v.e = 0] : (v.e = I, v.c = N), v;
  }
  n = function() {
    var v = /^(-?)0([xbo])(?=\w[\w.]*$)/i, N = /^([^.]+)\.$/, I = /^\.([^.]+)$/, T = /^-?(Infinity|NaN)$/, R = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(a, u, l, d) {
      var g, y = l ? u : u.replace(R, "");
      if (T.test(y))
        a.s = isNaN(y) ? null : y < 0 ? -1 : 1;
      else {
        if (!l && (y = y.replace(v, function(b, w, h) {
          return g = (h = h.toLowerCase()) == "x" ? 16 : h == "b" ? 2 : 8, !d || d == g ? w : b;
        }), d && (g = d, y = y.replace(N, "$1").replace(I, "0.$1")), u != y))
          return new P(y, g);
        if (P.DEBUG)
          throw Error(me + "Not a" + (d ? " base " + d : "") + " number: " + u);
        a.s = null;
      }
      a.c = a.e = null;
    };
  }();
  function tt(v, N, I, T) {
    var R, a, u, l, d, g, y, b = v.c, w = Qi;
    if (b) {
      t: {
        for (R = 1, l = b[0]; l >= 10; l /= 10, R++)
          ;
        if (a = N - R, a < 0)
          a += at, u = N, d = b[g = 0], y = Se(d / w[R - u - 1] % 10);
        else if (g = qi((a + 1) / at), g >= b.length)
          if (T) {
            for (; b.length <= g; b.push(0))
              ;
            d = y = 0, R = 1, a %= at, u = a - at + 1;
          } else
            break t;
        else {
          for (d = l = b[g], R = 1; l >= 10; l /= 10, R++)
            ;
          a %= at, u = a - at + R, y = u < 0 ? 0 : Se(d / w[R - u - 1] % 10);
        }
        if (T = T || N < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        b[g + 1] != null || (u < 0 ? d : d % w[R - u - 1]), T = I < 4 ? (y || T) && (I == 0 || I == (v.s < 0 ? 3 : 2)) : y > 5 || y == 5 && (I == 4 || T || I == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (a > 0 ? u > 0 ? d / w[R - u] : 0 : b[g - 1]) % 10 & 1 || I == (v.s < 0 ? 8 : 7)), N < 1 || !b[0])
          return b.length = 0, T ? (N -= v.e + 1, b[0] = w[(at - N % at) % at], v.e = -N || 0) : b[0] = v.e = 0, v;
        if (a == 0 ? (b.length = g, l = 1, g--) : (b.length = g + 1, l = w[at - a], b[g] = u > 0 ? Se(d / w[R - u] % w[u]) * l : 0), T)
          for (; ; )
            if (g == 0) {
              for (a = 1, u = b[0]; u >= 10; u /= 10, a++)
                ;
              for (u = b[0] += l, l = 1; u >= 10; u /= 10, l++)
                ;
              a != l && (v.e++, b[0] == xe && (b[0] = 1));
              break;
            } else {
              if (b[g] += l, b[g] != xe)
                break;
              b[g--] = 0, l = 1;
            }
        for (a = b.length; b[--a] === 0; b.pop())
          ;
      }
      v.e > _ ? v.c = v.e = null : v.e < E && (v.c = [v.e = 0]);
    }
    return v;
  }
  function mt(v) {
    var N, I = v.e;
    return I === null ? v.toString() : (N = Ie(v.c), N = I <= f || I >= m ? Vn(N, I) : ir(N, I, "0"), v.s < 0 ? "-" + N : N);
  }
  return i.absoluteValue = i.abs = function() {
    var v = new P(this);
    return v.s < 0 && (v.s = 1), v;
  }, i.comparedTo = function(v, N) {
    return qr(this, new P(v, N));
  }, i.decimalPlaces = i.dp = function(v, N) {
    var I, T, R, a = this;
    if (v != null)
      return Jt(v, 0, oe), N == null ? N = c : Jt(N, 0, 8), tt(new P(a), v + a.e + 1, N);
    if (!(I = a.c))
      return null;
    if (T = ((R = I.length - 1) - Re(this.e / at)) * at, R = I[R])
      for (; R % 10 == 0; R /= 10, T--)
        ;
    return T < 0 && (T = 0), T;
  }, i.dividedBy = i.div = function(v, N) {
    return t(this, new P(v, N), o, c);
  }, i.dividedToIntegerBy = i.idiv = function(v, N) {
    return t(this, new P(v, N), 0, 1);
  }, i.exponentiatedBy = i.pow = function(v, N) {
    var I, T, R, a, u, l, d, g, y, b = this;
    if (v = new P(v), v.c && !v.isInteger())
      throw Error(me + "Exponent not an integer: " + mt(v));
    if (N != null && (N = new P(N)), l = v.e > 14, !b.c || !b.c[0] || b.c[0] == 1 && !b.e && b.c.length == 1 || !v.c || !v.c[0])
      return y = new P(Math.pow(+mt(b), l ? v.s * (2 - Hn(v)) : +mt(v))), N ? y.mod(N) : y;
    if (d = v.s < 0, N) {
      if (N.c ? !N.c[0] : !N.s)
        return new P(NaN);
      T = !d && b.isInteger() && N.isInteger(), T && (b = b.mod(N));
    } else {
      if (v.e > 9 && (b.e > 0 || b.e < -1 || (b.e == 0 ? b.c[0] > 1 || l && b.c[1] >= 24e7 : b.c[0] < 8e13 || l && b.c[0] <= 9999975e7)))
        return a = b.s < 0 && Hn(v) ? -0 : 0, b.e > -1 && (a = 1 / a), new P(d ? 1 / a : a);
      C && (a = qi(C / at + 2));
    }
    for (l ? (I = new P(0.5), d && (v.s = 1), g = Hn(v)) : (R = Math.abs(+mt(v)), g = R % 2), y = new P(s); ; ) {
      if (g) {
        if (y = y.times(b), !y.c)
          break;
        a ? y.c.length > a && (y.c.length = a) : T && (y = y.mod(N));
      }
      if (R) {
        if (R = Se(R / 2), R === 0)
          break;
        g = R % 2;
      } else if (v = v.times(I), tt(v, v.e + 1, 1), v.e > 14)
        g = Hn(v);
      else {
        if (R = +mt(v), R === 0)
          break;
        g = R % 2;
      }
      b = b.times(b), a ? b.c && b.c.length > a && (b.c.length = a) : T && (b = b.mod(N));
    }
    return T ? y : (d && (y = s.div(y)), N ? y.mod(N) : a ? tt(y, C, c, u) : y);
  }, i.integerValue = function(v) {
    var N = new P(this);
    return v == null ? v = c : Jt(v, 0, 8), tt(N, N.e + 1, v);
  }, i.isEqualTo = i.eq = function(v, N) {
    return qr(this, new P(v, N)) === 0;
  }, i.isFinite = function() {
    return !!this.c;
  }, i.isGreaterThan = i.gt = function(v, N) {
    return qr(this, new P(v, N)) > 0;
  }, i.isGreaterThanOrEqualTo = i.gte = function(v, N) {
    return (N = qr(this, new P(v, N))) === 1 || N === 0;
  }, i.isInteger = function() {
    return !!this.c && Re(this.e / at) > this.c.length - 2;
  }, i.isLessThan = i.lt = function(v, N) {
    return qr(this, new P(v, N)) < 0;
  }, i.isLessThanOrEqualTo = i.lte = function(v, N) {
    return (N = qr(this, new P(v, N))) === -1 || N === 0;
  }, i.isNaN = function() {
    return !this.s;
  }, i.isNegative = function() {
    return this.s < 0;
  }, i.isPositive = function() {
    return this.s > 0;
  }, i.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, i.minus = function(v, N) {
    var I, T, R, a, u = this, l = u.s;
    if (v = new P(v, N), N = v.s, !l || !N)
      return new P(NaN);
    if (l != N)
      return v.s = -N, u.plus(v);
    var d = u.e / at, g = v.e / at, y = u.c, b = v.c;
    if (!d || !g) {
      if (!y || !b)
        return y ? (v.s = -N, v) : new P(b ? u : NaN);
      if (!y[0] || !b[0])
        return b[0] ? (v.s = -N, v) : new P(y[0] ? u : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          c == 3 ? -0 : 0
        ));
    }
    if (d = Re(d), g = Re(g), y = y.slice(), l = d - g) {
      for ((a = l < 0) ? (l = -l, R = y) : (g = d, R = b), R.reverse(), N = l; N--; R.push(0))
        ;
      R.reverse();
    } else
      for (T = (a = (l = y.length) < (N = b.length)) ? l : N, l = N = 0; N < T; N++)
        if (y[N] != b[N]) {
          a = y[N] < b[N];
          break;
        }
    if (a && (R = y, y = b, b = R, v.s = -v.s), N = (T = b.length) - (I = y.length), N > 0)
      for (; N--; y[I++] = 0)
        ;
    for (N = xe - 1; T > l; ) {
      if (y[--T] < b[T]) {
        for (I = T; I && !y[--I]; y[I] = N)
          ;
        --y[I], y[T] += xe;
      }
      y[T] -= b[T];
    }
    for (; y[0] == 0; y.splice(0, 1), --g)
      ;
    return y[0] ? $(v, y, g) : (v.s = c == 3 ? -1 : 1, v.c = [v.e = 0], v);
  }, i.modulo = i.mod = function(v, N) {
    var I, T, R = this;
    return v = new P(v, N), !R.c || !v.s || v.c && !v.c[0] ? new P(NaN) : !v.c || R.c && !R.c[0] ? new P(R) : (O == 9 ? (T = v.s, v.s = 1, I = t(R, v, 0, 3), v.s = T, I.s *= T) : I = t(R, v, 0, O), v = R.minus(I.times(v)), !v.c[0] && O == 1 && (v.s = R.s), v);
  }, i.multipliedBy = i.times = function(v, N) {
    var I, T, R, a, u, l, d, g, y, b, w, h, A, j, z, p = this, k = p.c, x = (v = new P(v, N)).c;
    if (!k || !x || !k[0] || !x[0])
      return !p.s || !v.s || k && !k[0] && !x || x && !x[0] && !k ? v.c = v.e = v.s = null : (v.s *= p.s, !k || !x ? v.c = v.e = null : (v.c = [0], v.e = 0)), v;
    for (T = Re(p.e / at) + Re(v.e / at), v.s *= p.s, d = k.length, b = x.length, d < b && (A = k, k = x, x = A, R = d, d = b, b = R), R = d + b, A = []; R--; A.push(0))
      ;
    for (j = xe, z = Er, R = b; --R >= 0; ) {
      for (I = 0, w = x[R] % z, h = x[R] / z | 0, u = d, a = R + u; a > R; )
        g = k[--u] % z, y = k[u] / z | 0, l = h * g + y * w, g = w * g + l % z * z + A[a] + I, I = (g / j | 0) + (l / z | 0) + h * y, A[a--] = g % j;
      A[a] = I;
    }
    return I ? ++T : A.splice(0, 1), $(v, A, T);
  }, i.negated = function() {
    var v = new P(this);
    return v.s = -v.s || null, v;
  }, i.plus = function(v, N) {
    var I, T = this, R = T.s;
    if (v = new P(v, N), N = v.s, !R || !N)
      return new P(NaN);
    if (R != N)
      return v.s = -N, T.minus(v);
    var a = T.e / at, u = v.e / at, l = T.c, d = v.c;
    if (!a || !u) {
      if (!l || !d)
        return new P(R / 0);
      if (!l[0] || !d[0])
        return d[0] ? v : new P(l[0] ? T : R * 0);
    }
    if (a = Re(a), u = Re(u), l = l.slice(), R = a - u) {
      for (R > 0 ? (u = a, I = d) : (R = -R, I = l), I.reverse(); R--; I.push(0))
        ;
      I.reverse();
    }
    for (R = l.length, N = d.length, R - N < 0 && (I = d, d = l, l = I, N = R), R = 0; N; )
      R = (l[--N] = l[N] + d[N] + R) / xe | 0, l[N] = xe === l[N] ? 0 : l[N] % xe;
    return R && (l = [R].concat(l), ++u), $(v, l, u);
  }, i.precision = i.sd = function(v, N) {
    var I, T, R, a = this;
    if (v != null && v !== !!v)
      return Jt(v, 1, oe), N == null ? N = c : Jt(N, 0, 8), tt(new P(a), v, N);
    if (!(I = a.c))
      return null;
    if (R = I.length - 1, T = R * at + 1, R = I[R]) {
      for (; R % 10 == 0; R /= 10, T--)
        ;
      for (R = I[0]; R >= 10; R /= 10, T++)
        ;
    }
    return v && a.e + 1 > T && (T = a.e + 1), T;
  }, i.shiftedBy = function(v) {
    return Jt(v, -ji, ji), this.times("1e" + v);
  }, i.squareRoot = i.sqrt = function() {
    var v, N, I, T, R, a = this, u = a.c, l = a.s, d = a.e, g = o + 4, y = new P("0.5");
    if (l !== 1 || !u || !u[0])
      return new P(!l || l < 0 && (!u || u[0]) ? NaN : u ? a : 1 / 0);
    if (l = Math.sqrt(+mt(a)), l == 0 || l == 1 / 0 ? (N = Ie(u), (N.length + d) % 2 == 0 && (N += "0"), l = Math.sqrt(+N), d = Re((d + 1) / 2) - (d < 0 || d % 2), l == 1 / 0 ? N = "5e" + d : (N = l.toExponential(), N = N.slice(0, N.indexOf("e") + 1) + d), I = new P(N)) : I = new P(l + ""), I.c[0]) {
      for (d = I.e, l = d + g, l < 3 && (l = 0); ; )
        if (R = I, I = y.times(R.plus(t(a, R, g, 1))), Ie(R.c).slice(0, l) === (N = Ie(I.c)).slice(0, l))
          if (I.e < d && --l, N = N.slice(l - 3, l + 1), N == "9999" || !T && N == "4999") {
            if (!T && (tt(R, R.e + o + 2, 0), R.times(R).eq(a))) {
              I = R;
              break;
            }
            g += 4, l += 4, T = 1;
          } else {
            (!+N || !+N.slice(1) && N.charAt(0) == "5") && (tt(I, I.e + o + 2, 1), v = !I.times(I).eq(a));
            break;
          }
    }
    return tt(I, I.e + o + 1, c, v);
  }, i.toExponential = function(v, N) {
    return v != null && (Jt(v, 0, oe), v++), X(this, v, N, 1);
  }, i.toFixed = function(v, N) {
    return v != null && (Jt(v, 0, oe), v = v + this.e + 1), X(this, v, N);
  }, i.toFormat = function(v, N, I) {
    var T, R = this;
    if (I == null)
      v != null && N && typeof N == "object" ? (I = N, N = null) : v && typeof v == "object" ? (I = v, v = N = null) : I = F;
    else if (typeof I != "object")
      throw Error(me + "Argument not an object: " + I);
    if (T = R.toFixed(v, N), R.c) {
      var a, u = T.split("."), l = +I.groupSize, d = +I.secondaryGroupSize, g = I.groupSeparator || "", y = u[0], b = u[1], w = R.s < 0, h = w ? y.slice(1) : y, A = h.length;
      if (d && (a = l, l = d, d = a, A -= a), l > 0 && A > 0) {
        for (a = A % l || l, y = h.substr(0, a); a < A; a += l)
          y += g + h.substr(a, l);
        d > 0 && (y += g + h.slice(a)), w && (y = "-" + y);
      }
      T = b ? y + (I.decimalSeparator || "") + ((d = +I.fractionGroupSize) ? b.replace(
        new RegExp("\\d{" + d + "}\\B", "g"),
        "$&" + (I.fractionGroupSeparator || "")
      ) : b) : y;
    }
    return (I.prefix || "") + T + (I.suffix || "");
  }, i.toFraction = function(v) {
    var N, I, T, R, a, u, l, d, g, y, b, w, h = this, A = h.c;
    if (v != null && (l = new P(v), !l.isInteger() && (l.c || l.s !== 1) || l.lt(s)))
      throw Error(me + "Argument " + (l.isInteger() ? "out of range: " : "not an integer: ") + mt(l));
    if (!A)
      return new P(h);
    for (N = new P(s), g = I = new P(s), T = d = new P(s), w = Ie(A), a = N.e = w.length - h.e - 1, N.c[0] = Qi[(u = a % at) < 0 ? at + u : u], v = !v || l.comparedTo(N) > 0 ? a > 0 ? N : g : l, u = _, _ = 1 / 0, l = new P(w), d.c[0] = 0; y = t(l, N, 0, 1), R = I.plus(y.times(T)), R.comparedTo(v) != 1; )
      I = T, T = R, g = d.plus(y.times(R = g)), d = R, N = l.minus(y.times(R = N)), l = R;
    return R = t(v.minus(I), T, 0, 1), d = d.plus(R.times(g)), I = I.plus(R.times(T)), d.s = g.s = h.s, a = a * 2, b = t(g, T, a, c).minus(h).abs().comparedTo(
      t(d, I, a, c).minus(h).abs()
    ) < 1 ? [g, T] : [d, I], _ = u, b;
  }, i.toNumber = function() {
    return +mt(this);
  }, i.toPrecision = function(v, N) {
    return v != null && Jt(v, 1, oe), X(this, v, N, 2);
  }, i.toString = function(v) {
    var N, I = this, T = I.s, R = I.e;
    return R === null ? T ? (N = "Infinity", T < 0 && (N = "-" + N)) : N = "NaN" : (v == null ? N = R <= f || R >= m ? Vn(Ie(I.c), R) : ir(Ie(I.c), R, "0") : v === 10 && D ? (I = tt(new P(I), o + R + 1, c), N = ir(Ie(I.c), I.e, "0")) : (Jt(v, 2, L.length, "Base"), N = r(ir(Ie(I.c), R, "0"), 10, v, T, !0)), T < 0 && I.c[0] && (N = "-" + N)), N;
  }, i.valueOf = i.toJSON = function() {
    return mt(this);
  }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, e != null && P.set(e), P;
}
function Re(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function Ie(e) {
  for (var t, r, n = 1, i = e.length, s = e[0] + ""; n < i; ) {
    for (t = e[n++] + "", r = at - t.length; r--; t = "0" + t)
      ;
    s += t;
  }
  for (i = s.length; s.charCodeAt(--i) === 48; )
    ;
  return s.slice(0, i + 1 || 1);
}
function qr(e, t) {
  var r, n, i = e.c, s = t.c, o = e.s, c = t.s, f = e.e, m = t.e;
  if (!o || !c)
    return null;
  if (r = i && !i[0], n = s && !s[0], r || n)
    return r ? n ? 0 : -c : o;
  if (o != c)
    return o;
  if (r = o < 0, n = f == m, !i || !s)
    return n ? 0 : !i ^ r ? 1 : -1;
  if (!n)
    return f > m ^ r ? 1 : -1;
  for (c = (f = i.length) < (m = s.length) ? f : m, o = 0; o < c; o++)
    if (i[o] != s[o])
      return i[o] > s[o] ^ r ? 1 : -1;
  return f == m ? 0 : f > m ^ r ? 1 : -1;
}
function Jt(e, t, r, n) {
  if (e < t || e > r || e !== Se(e))
    throw Error(me + (n || "Argument") + (typeof e == "number" ? e < t || e > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function Hn(e) {
  var t = e.c.length - 1;
  return Re(e.e / at) == t && e.c[t] % 2 != 0;
}
function Vn(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function ir(e, t, r) {
  var n, i;
  if (t < 0) {
    for (i = r + "."; ++t; i += r)
      ;
    e = i + e;
  } else if (n = e.length, ++t > n) {
    for (i = r, t -= n; --t; i += r)
      ;
    e += i;
  } else
    t < n && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var Yi = Vo(), vu = Object.defineProperty, wu = (e, t, r) => t in e ? vu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Le = (e, t, r) => (wu(e, typeof t != "symbol" ? t + "" : t, r), r), Qr = /* @__PURE__ */ ((e) => (e.THOR = "THOR", e.RUNE = "RUNE", e.ATOM = "ATOM", e.MUON = "MUON", e.USDC = "USDC", e))(Qr || {}), it = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(it || {});
it.INVALID_INPUT_PARAMETERS + "", it.UNKNOWN_PROVIDERS + "", it.CANNOT_FIND_INBOUND_ADDRESS + "", it.NO_INBOUND_ADDRESSES + "", it.CHAIN_HALTED_OR_UNSUPPORTED + "", it.MISSING_INPUT_PARAMETER + "", it.INVALID_TYPE_GENERIC + "", it.INVALID_NUMBER_STRING + "", it.INVALID_NUMBER + "", it.INVALID_BOOLEAN + "", it.INVALID_OBJECT + "", it.INVALID_ARRAY + "", it.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", it.SELL_BUY_ASSETS_ARE_THE_SAME + "", it.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", it.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", it.AFF_ADDRESS_TOO_LONG + "", it.AFF_BPS_INTEGER_0_100 + "", it.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", it.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", it.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", it.DESTINATION_ADDRESS_SMART_CONTRACT + "", it.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", it.INVALID_PROVIDER + "", it.MISSING_CROSS_CHAIN_PROVIDER + "", it.MISSING_AVAX_PROVIDER + "", it.MISSING_BSC_PROVIDER + "", it.MISSING_ETH_PROVIDER + "", it.MISSING_ARB_PROVIDER + "", it.INVALID_PROVIDER_FOR_SWAP_OUT + "", it.INVALID_CHAIN + "", it.INVALID_ASSET + "", it.UNSUPPORTED_CHAIN + "", it.UNSUPPORTED_ASSET + "", it.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", it.THORNODE_QUOTE_GENERIC_ERROR + "", it.NOT_ENOUGH_SYNTH_BALANCE + "", it.SYNTH_MINTING_CAP_REACHED + "", it.INVALID_QUOTE_MODE + "", it.NO_QUOTES + "", it.SERVICE_UNAVAILABLE_GENERIC + "", it.MISSING_GAS_DATA_GENERIC + "", it.MISSING_TOKEN_INFO_GENERIC + "", it.CANT_FIND_TOKEN_LIST + "", it.NO_PRICE + "", it.PRICE_IS_STALE + "", it.ADDRESS_NOT_WHITELISTED + "", it.ADDRESS_ALREADY_CLAIMED + "";
var W = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dogecoin = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.Optimism = "OP", e.Polygon = "MATIC", e.THORChain = "THOR", e))(W || {}), bn = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.OP = 18] = "OP", e[e.THOR = 8] = "THOR", e))(bn || {}), Es = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceHex = "", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinHex = "", e.BitcoinCash = "bitcoincash", e.BitcoinCashHex = "", e.Cosmos = "cosmoshub-4", e.CosmosHex = "", e.Dogecoin = "dogecoin", e.DogecoinHex = "", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.LitecoinHex = "", e.Optimism = "10", e.OptimismHex = "0xa", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainHex = "", e.THORChainStagenet = "thorchain-stagenet-v2", e))(Es || {}), zo = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Optimism = "https://mainnet.optimism.io", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(zo || {});
const gi = Object.values(W), Au = Object.keys(W), bs = gi.reduce(
  (e, t) => {
    const r = Au.find((n) => W[n] === t);
    return r && (e[t] = r), e;
  },
  {}
);
gi.reduce(
  (e, t) => (e[t] = Es[bs[t]], e),
  {}
);
gi.reduce(
  (e, t) => (e[t] = zo[bs[t]], e),
  {}
);
gi.reduce(
  (e, t) => (e[t] = Es[`${bs[t]}Hex`], e),
  {}
);
const Eu = (e, t, r = !1) => {
  if (r)
    return "Synth";
  switch (e) {
    case W.Bitcoin:
    case W.BitcoinCash:
    case W.Dogecoin:
    case W.Litecoin:
    case W.THORChain:
      return "Native";
    case W.Cosmos:
      return t === "ATOM" ? "Native" : "GAIA";
    case W.Binance:
      return t === W.Binance ? "Native" : "BEP2";
    case W.BinanceSmartChain:
      return t === W.Binance ? "Native" : "BEP20";
    case W.Ethereum:
      return t === W.Ethereum ? "Native" : "ERC20";
    case W.Avalanche:
      return t === W.Avalanche ? "Native" : "AVAX";
    case W.Polygon:
      return t === W.Polygon ? "Native" : "POLYGON";
    case W.Arbitrum:
      return [W.Ethereum, W.Arbitrum].includes(t) ? "Native" : "ARBITRUM";
    case W.Optimism:
      return [W.Ethereum, W.Optimism].includes(t) ? "Native" : "OPTIMISM";
    default:
      return e;
  }
};
Yi.ROUND_DOWN, Yi.ROUND_HALF_UP, Yi.ROUND_UP;
const bu = (e, t) => e === W.Bitcoin ? "Bitcoin" : e === W.Dogecoin ? "Dogecoin" : e === W.Litecoin ? "Litecoin" : e === W.BitcoinCash ? "Bitcoin Cash" : e === W.Ethereum && t === "ETH" ? "Ethereum" : t, us = class hs {
  constructor(t, r, n = !1, i) {
    Le(this, "chain"), Le(this, "symbol"), Le(this, "ticker"), Le(this, "type"), Le(this, "network"), Le(this, "name"), Le(this, "decimal"), Le(this, "isSynth", !1), Le(this, "L1Chain"), Le(this, "setDecimal", (s) => {
      this.decimal = s || bn[this.chain] || bn.THOR;
    }), this.chain = t, this.symbol = r.toUpperCase(), this.ticker = i || r.toUpperCase().split("-")[0], this.type = Eu(t, this.ticker, n), this.name = n ? `Synth ${this.ticker}` : this.ticker, this.network = bu(t, this.ticker), this.decimal = n ? bn.THOR : bn[t], this.isSynth = n, this.L1Chain = n ? W.THORChain : t;
  }
  static fromAssetString(t) {
    var r;
    if (!t)
      return null;
    const n = t.includes("/"), [i, ...s] = t.split(n ? "/" : "."), o = s.join("."), c = (r = o == null ? void 0 : o.split("-")) == null ? void 0 : r[0];
    return i && o && c ? new hs(i, o, n) : null;
  }
  getAssetObj() {
    if (this.isSynth) {
      const t = `${this.chain.toLowerCase()}/${this.symbol.toLowerCase()}`;
      return {
        chain: W.THORChain,
        symbol: t,
        ticker: t
      };
    }
    return { chain: this.chain, symbol: this.symbol, ticker: this.ticker };
  }
  /**
   * convert asset entity to string
   * @returns L1 asset -> btc.btc, Synth asset -> btc/btc
   */
  toString() {
    return `${this.chain}${this.isSynth ? "/" : "."}${this.symbol}`;
  }
  toURLEncoded() {
    return `${this.isSynth ? "THOR." : ""}${this.chain}.${this.symbol}`;
  }
  // full compare chain, symbol, synth
  eq(t) {
    return this.chain === t.chain && this.symbol.toUpperCase() === t.symbol.toUpperCase() && this.ticker.toUpperCase() === t.ticker.toUpperCase() && this.isSynth === t.isSynth;
  }
  // compare chain, symbol but not synth
  shallowEq(t) {
    return this.chain === t.chain && this.symbol.toUpperCase() === t.symbol.toUpperCase() && this.ticker.toUpperCase() === t.ticker.toUpperCase();
  }
  isRUNE() {
    return this.eq(Sr(W.THORChain));
  }
  identifier() {
    return `${this.chain}.${this.symbol}`;
  }
  toSynth() {
    return this.isSynth ? this : new hs(W.THORChain, `${this.chain}/${this.symbol}`, !0);
  }
};
Le(us, "decodeFromURL", (e) => {
  var t, r, n;
  let i = e.toUpperCase();
  return i.startsWith("THOR.") && ((t = i.split("THOR.")) == null ? void 0 : t[1]) !== "RUNE" && (i = (n = (r = i.split("THOR.")) == null ? void 0 : r[1]) == null ? void 0 : n.replace(".", "/")), us.fromAssetString(i);
});
let Fe = us;
const Nu = "THOR-0xa5f2211B9b8170F694421f2046281775E8468044", _u = "VTHOR-0x815C23eCA83261b6Ec689b60Cc4a58b54BC24D8D", Ce = {}, Sr = (e, t = !1) => {
  if (Ce[e])
    return Ce[e];
  switch (e) {
    case W.Avalanche:
    case W.Binance:
    case W.Bitcoin:
    case W.BitcoinCash:
    case W.Dogecoin:
    case W.Ethereum:
    case W.Litecoin: {
      const r = new Fe(e, e, t);
      return Ce[e] = r, r;
    }
    case W.Optimism:
    case W.Arbitrum: {
      const r = new Fe(e, W.Ethereum, t);
      return r.setDecimal(18), Ce[e] = r, r;
    }
    case W.BinanceSmartChain: {
      const r = new Fe(e, W.Binance, t);
      return r.setDecimal(18), Ce[e] = r, r;
    }
    case W.Polygon: {
      const r = new Fe(e, e, t);
      return r.setDecimal(18), Ce[e] = r, r;
    }
    case W.Cosmos: {
      const r = new Fe(e, Qr.ATOM, t, Qr.ATOM);
      return Ce[e] = r, r;
    }
    case W.THORChain: {
      const r = new Fe(W.THORChain, Qr.RUNE, t, Qr.RUNE);
      return Ce[e] = r, r;
    }
    case "USD": {
      const r = new Fe(W.THORChain, "USD-USD", t, "USD-USD");
      return Ce[e] = r, r;
    }
    case "ETH_THOR": {
      const r = new Fe(W.Ethereum, Nu, t);
      return r.setDecimal(18), Ce[e] = r, r;
    }
    case "ETH_VTHOR": {
      const r = new Fe(W.Ethereum, _u, t);
      return r.setDecimal(18), Ce[e] = r, r;
    }
    default:
      return new Fe(W.THORChain, Qr.RUNE, t, Qr.RUNE);
  }
}, qo = (e) => e.eq(Sr(e.chain)), jo = ({ apiKey: e, chainId: t }) => ({
  getBalance: async (r) => {
    const { data: n } = await Ho(
      `https://api.covalenthq.com/v1/${t}/address/${r}/balances_v2/`,
      { key: e }
    );
    return Iu(n || { items: [] }, t);
  }
}), Iu = async (e, t) => e.items.map(({ balance: r, contract_decimals: n, contract_ticker_symbol: i, contract_address: s }) => ({
  amount: hr(V.from(r.toString()), n),
  asset: s !== "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" && Lo(
    `${zi[t]}.${i}-${s}`
  ) || Sr(zi[t])
})).filter(({ asset: { symbol: r, ticker: n } }) => {
  const i = Sr(zi[t]);
  return !(r === i.symbol && n === i.ticker);
});
var Qo = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(e) {
  (function() {
    var t = "input is invalid type", r = "finalize already called", n = typeof window == "object", i = n ? window : {};
    i.JS_SHA3_NO_WINDOW && (n = !1);
    var s = !n && typeof self == "object", o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    o ? i = xo : s && (i = self);
    var c = !i.JS_SHA3_NO_COMMON_JS && !0 && e.exports, f = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", m = "0123456789abcdef".split(""), E = [31, 7936, 2031616, 520093696], _ = [4, 1024, 262144, 67108864], S = [1, 256, 65536, 16777216], O = [6, 1536, 393216, 100663296], C = [0, 8, 16, 24], F = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], L = [224, 256, 384, 512], D = [128, 256], P = ["hex", "buffer", "arrayBuffer", "array", "digest"], X = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(p) {
      return Object.prototype.toString.call(p) === "[object Array]";
    }), f && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(p) {
      return typeof p == "object" && p.buffer && p.buffer.constructor === ArrayBuffer;
    });
    for (var rt = function(p, k, x) {
      return function(B) {
        return new A(p, k, p).update(B)[x]();
      };
    }, $ = function(p, k, x) {
      return function(B, Q) {
        return new A(p, k, Q).update(B)[x]();
      };
    }, tt = function(p, k, x) {
      return function(B, Q, q, H) {
        return u["cshake" + p].update(B, Q, q, H)[x]();
      };
    }, mt = function(p, k, x) {
      return function(B, Q, q, H) {
        return u["kmac" + p].update(B, Q, q, H)[x]();
      };
    }, v = function(p, k, x, B) {
      for (var Q = 0; Q < P.length; ++Q) {
        var q = P[Q];
        p[q] = k(x, B, q);
      }
      return p;
    }, N = function(p, k) {
      var x = rt(p, k, "hex");
      return x.create = function() {
        return new A(p, k, p);
      }, x.update = function(B) {
        return x.create().update(B);
      }, v(x, rt, p, k);
    }, I = function(p, k) {
      var x = $(p, k, "hex");
      return x.create = function(B) {
        return new A(p, k, B);
      }, x.update = function(B, Q) {
        return x.create(Q).update(B);
      }, v(x, $, p, k);
    }, T = function(p, k) {
      var x = X[p], B = tt(p, k, "hex");
      return B.create = function(Q, q, H) {
        return !q && !H ? u["shake" + p].create(Q) : new A(p, k, Q).bytepad([q, H], x);
      }, B.update = function(Q, q, H, J) {
        return B.create(q, H, J).update(Q);
      }, v(B, tt, p, k);
    }, R = function(p, k) {
      var x = X[p], B = mt(p, k, "hex");
      return B.create = function(Q, q, H) {
        return new j(p, k, q).bytepad(["KMAC", H], x).bytepad([Q], x);
      }, B.update = function(Q, q, H, J) {
        return B.create(Q, H, J).update(q);
      }, v(B, mt, p, k);
    }, a = [
      { name: "keccak", padding: S, bits: L, createMethod: N },
      { name: "sha3", padding: O, bits: L, createMethod: N },
      { name: "shake", padding: E, bits: D, createMethod: I },
      { name: "cshake", padding: _, bits: D, createMethod: T },
      { name: "kmac", padding: _, bits: D, createMethod: R }
    ], u = {}, l = [], d = 0; d < a.length; ++d)
      for (var g = a[d], y = g.bits, b = 0; b < y.length; ++b) {
        var w = g.name + "_" + y[b];
        if (l.push(w), u[w] = g.createMethod(y[b], g.padding), g.name !== "sha3") {
          var h = g.name + y[b];
          l.push(h), u[h] = u[w];
        }
      }
    function A(p, k, x) {
      this.blocks = [], this.s = [], this.padding = k, this.outputBits = x, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (p << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = x >> 5, this.extraBytes = (x & 31) >> 3;
      for (var B = 0; B < 50; ++B)
        this.s[B] = 0;
    }
    A.prototype.update = function(p) {
      if (this.finalized)
        throw new Error(r);
      var k, x = typeof p;
      if (x !== "string") {
        if (x === "object") {
          if (p === null)
            throw new Error(t);
          if (f && p.constructor === ArrayBuffer)
            p = new Uint8Array(p);
          else if (!Array.isArray(p) && (!f || !ArrayBuffer.isView(p)))
            throw new Error(t);
        } else
          throw new Error(t);
        k = !0;
      }
      for (var B = this.blocks, Q = this.byteCount, q = p.length, H = this.blockCount, J = 0, Z = this.s, G, st; J < q; ) {
        if (this.reset)
          for (this.reset = !1, B[0] = this.block, G = 1; G < H + 1; ++G)
            B[G] = 0;
        if (k)
          for (G = this.start; J < q && G < Q; ++J)
            B[G >> 2] |= p[J] << C[G++ & 3];
        else
          for (G = this.start; J < q && G < Q; ++J)
            st = p.charCodeAt(J), st < 128 ? B[G >> 2] |= st << C[G++ & 3] : st < 2048 ? (B[G >> 2] |= (192 | st >> 6) << C[G++ & 3], B[G >> 2] |= (128 | st & 63) << C[G++ & 3]) : st < 55296 || st >= 57344 ? (B[G >> 2] |= (224 | st >> 12) << C[G++ & 3], B[G >> 2] |= (128 | st >> 6 & 63) << C[G++ & 3], B[G >> 2] |= (128 | st & 63) << C[G++ & 3]) : (st = 65536 + ((st & 1023) << 10 | p.charCodeAt(++J) & 1023), B[G >> 2] |= (240 | st >> 18) << C[G++ & 3], B[G >> 2] |= (128 | st >> 12 & 63) << C[G++ & 3], B[G >> 2] |= (128 | st >> 6 & 63) << C[G++ & 3], B[G >> 2] |= (128 | st & 63) << C[G++ & 3]);
        if (this.lastByteIndex = G, G >= Q) {
          for (this.start = G - Q, this.block = B[H], G = 0; G < H; ++G)
            Z[G] ^= B[G];
          z(Z), this.reset = !0;
        } else
          this.start = G;
      }
      return this;
    }, A.prototype.encode = function(p, k) {
      var x = p & 255, B = 1, Q = [x];
      for (p = p >> 8, x = p & 255; x > 0; )
        Q.unshift(x), p = p >> 8, x = p & 255, ++B;
      return k ? Q.push(B) : Q.unshift(B), this.update(Q), Q.length;
    }, A.prototype.encodeString = function(p) {
      var k, x = typeof p;
      if (x !== "string") {
        if (x === "object") {
          if (p === null)
            throw new Error(t);
          if (f && p.constructor === ArrayBuffer)
            p = new Uint8Array(p);
          else if (!Array.isArray(p) && (!f || !ArrayBuffer.isView(p)))
            throw new Error(t);
        } else
          throw new Error(t);
        k = !0;
      }
      var B = 0, Q = p.length;
      if (k)
        B = Q;
      else
        for (var q = 0; q < p.length; ++q) {
          var H = p.charCodeAt(q);
          H < 128 ? B += 1 : H < 2048 ? B += 2 : H < 55296 || H >= 57344 ? B += 3 : (H = 65536 + ((H & 1023) << 10 | p.charCodeAt(++q) & 1023), B += 4);
        }
      return B += this.encode(B * 8), this.update(p), B;
    }, A.prototype.bytepad = function(p, k) {
      for (var x = this.encode(k), B = 0; B < p.length; ++B)
        x += this.encodeString(p[B]);
      var Q = k - x % k, q = [];
      return q.length = Q, this.update(q), this;
    }, A.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var p = this.blocks, k = this.lastByteIndex, x = this.blockCount, B = this.s;
        if (p[k >> 2] |= this.padding[k & 3], this.lastByteIndex === this.byteCount)
          for (p[0] = p[x], k = 1; k < x + 1; ++k)
            p[k] = 0;
        for (p[x - 1] |= 2147483648, k = 0; k < x; ++k)
          B[k] ^= p[k];
        z(B);
      }
    }, A.prototype.toString = A.prototype.hex = function() {
      this.finalize();
      for (var p = this.blockCount, k = this.s, x = this.outputBlocks, B = this.extraBytes, Q = 0, q = 0, H = "", J; q < x; ) {
        for (Q = 0; Q < p && q < x; ++Q, ++q)
          J = k[Q], H += m[J >> 4 & 15] + m[J & 15] + m[J >> 12 & 15] + m[J >> 8 & 15] + m[J >> 20 & 15] + m[J >> 16 & 15] + m[J >> 28 & 15] + m[J >> 24 & 15];
        q % p === 0 && (z(k), Q = 0);
      }
      return B && (J = k[Q], H += m[J >> 4 & 15] + m[J & 15], B > 1 && (H += m[J >> 12 & 15] + m[J >> 8 & 15]), B > 2 && (H += m[J >> 20 & 15] + m[J >> 16 & 15])), H;
    }, A.prototype.arrayBuffer = function() {
      this.finalize();
      var p = this.blockCount, k = this.s, x = this.outputBlocks, B = this.extraBytes, Q = 0, q = 0, H = this.outputBits >> 3, J;
      B ? J = new ArrayBuffer(x + 1 << 2) : J = new ArrayBuffer(H);
      for (var Z = new Uint32Array(J); q < x; ) {
        for (Q = 0; Q < p && q < x; ++Q, ++q)
          Z[q] = k[Q];
        q % p === 0 && z(k);
      }
      return B && (Z[Q] = k[Q], J = J.slice(0, H)), J;
    }, A.prototype.buffer = A.prototype.arrayBuffer, A.prototype.digest = A.prototype.array = function() {
      this.finalize();
      for (var p = this.blockCount, k = this.s, x = this.outputBlocks, B = this.extraBytes, Q = 0, q = 0, H = [], J, Z; q < x; ) {
        for (Q = 0; Q < p && q < x; ++Q, ++q)
          J = q << 2, Z = k[Q], H[J] = Z & 255, H[J + 1] = Z >> 8 & 255, H[J + 2] = Z >> 16 & 255, H[J + 3] = Z >> 24 & 255;
        q % p === 0 && z(k);
      }
      return B && (J = q << 2, Z = k[Q], H[J] = Z & 255, B > 1 && (H[J + 1] = Z >> 8 & 255), B > 2 && (H[J + 2] = Z >> 16 & 255)), H;
    };
    function j(p, k, x) {
      A.call(this, p, k, x);
    }
    j.prototype = new A(), j.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), A.prototype.finalize.call(this);
    };
    var z = function(p) {
      var k, x, B, Q, q, H, J, Z, G, st, gt, yt, Or, vt, wt, Mr, At, Et, Pr, bt, Nt, kr, _t, It, xr, St, Rt, Cr, Tt, Ot, Br, Mt, Pt, Dr, kt, xt, Ur, Ct, Bt, Lr, Dt, Ut, Fr, Lt, Ft, Gr, Gt, Ht, Hr, Vt, zt, Vr, qt, jt, zr, Qt, Yt, mr, gr, yr, vr, wr, Ar;
      for (B = 0; B < 48; B += 2)
        Q = p[0] ^ p[10] ^ p[20] ^ p[30] ^ p[40], q = p[1] ^ p[11] ^ p[21] ^ p[31] ^ p[41], H = p[2] ^ p[12] ^ p[22] ^ p[32] ^ p[42], J = p[3] ^ p[13] ^ p[23] ^ p[33] ^ p[43], Z = p[4] ^ p[14] ^ p[24] ^ p[34] ^ p[44], G = p[5] ^ p[15] ^ p[25] ^ p[35] ^ p[45], st = p[6] ^ p[16] ^ p[26] ^ p[36] ^ p[46], gt = p[7] ^ p[17] ^ p[27] ^ p[37] ^ p[47], yt = p[8] ^ p[18] ^ p[28] ^ p[38] ^ p[48], Or = p[9] ^ p[19] ^ p[29] ^ p[39] ^ p[49], k = yt ^ (H << 1 | J >>> 31), x = Or ^ (J << 1 | H >>> 31), p[0] ^= k, p[1] ^= x, p[10] ^= k, p[11] ^= x, p[20] ^= k, p[21] ^= x, p[30] ^= k, p[31] ^= x, p[40] ^= k, p[41] ^= x, k = Q ^ (Z << 1 | G >>> 31), x = q ^ (G << 1 | Z >>> 31), p[2] ^= k, p[3] ^= x, p[12] ^= k, p[13] ^= x, p[22] ^= k, p[23] ^= x, p[32] ^= k, p[33] ^= x, p[42] ^= k, p[43] ^= x, k = H ^ (st << 1 | gt >>> 31), x = J ^ (gt << 1 | st >>> 31), p[4] ^= k, p[5] ^= x, p[14] ^= k, p[15] ^= x, p[24] ^= k, p[25] ^= x, p[34] ^= k, p[35] ^= x, p[44] ^= k, p[45] ^= x, k = Z ^ (yt << 1 | Or >>> 31), x = G ^ (Or << 1 | yt >>> 31), p[6] ^= k, p[7] ^= x, p[16] ^= k, p[17] ^= x, p[26] ^= k, p[27] ^= x, p[36] ^= k, p[37] ^= x, p[46] ^= k, p[47] ^= x, k = st ^ (Q << 1 | q >>> 31), x = gt ^ (q << 1 | Q >>> 31), p[8] ^= k, p[9] ^= x, p[18] ^= k, p[19] ^= x, p[28] ^= k, p[29] ^= x, p[38] ^= k, p[39] ^= x, p[48] ^= k, p[49] ^= x, vt = p[0], wt = p[1], Gr = p[11] << 4 | p[10] >>> 28, Gt = p[10] << 4 | p[11] >>> 28, Cr = p[20] << 3 | p[21] >>> 29, Tt = p[21] << 3 | p[20] >>> 29, yr = p[31] << 9 | p[30] >>> 23, vr = p[30] << 9 | p[31] >>> 23, Ut = p[40] << 18 | p[41] >>> 14, Fr = p[41] << 18 | p[40] >>> 14, Dr = p[2] << 1 | p[3] >>> 31, kt = p[3] << 1 | p[2] >>> 31, Mr = p[13] << 12 | p[12] >>> 20, At = p[12] << 12 | p[13] >>> 20, Ht = p[22] << 10 | p[23] >>> 22, Hr = p[23] << 10 | p[22] >>> 22, Ot = p[33] << 13 | p[32] >>> 19, Br = p[32] << 13 | p[33] >>> 19, wr = p[42] << 2 | p[43] >>> 30, Ar = p[43] << 2 | p[42] >>> 30, jt = p[5] << 30 | p[4] >>> 2, zr = p[4] << 30 | p[5] >>> 2, xt = p[14] << 6 | p[15] >>> 26, Ur = p[15] << 6 | p[14] >>> 26, Et = p[25] << 11 | p[24] >>> 21, Pr = p[24] << 11 | p[25] >>> 21, Vt = p[34] << 15 | p[35] >>> 17, zt = p[35] << 15 | p[34] >>> 17, Mt = p[45] << 29 | p[44] >>> 3, Pt = p[44] << 29 | p[45] >>> 3, It = p[6] << 28 | p[7] >>> 4, xr = p[7] << 28 | p[6] >>> 4, Qt = p[17] << 23 | p[16] >>> 9, Yt = p[16] << 23 | p[17] >>> 9, Ct = p[26] << 25 | p[27] >>> 7, Bt = p[27] << 25 | p[26] >>> 7, bt = p[36] << 21 | p[37] >>> 11, Nt = p[37] << 21 | p[36] >>> 11, Vr = p[47] << 24 | p[46] >>> 8, qt = p[46] << 24 | p[47] >>> 8, Lt = p[8] << 27 | p[9] >>> 5, Ft = p[9] << 27 | p[8] >>> 5, St = p[18] << 20 | p[19] >>> 12, Rt = p[19] << 20 | p[18] >>> 12, mr = p[29] << 7 | p[28] >>> 25, gr = p[28] << 7 | p[29] >>> 25, Lr = p[38] << 8 | p[39] >>> 24, Dt = p[39] << 8 | p[38] >>> 24, kr = p[48] << 14 | p[49] >>> 18, _t = p[49] << 14 | p[48] >>> 18, p[0] = vt ^ ~Mr & Et, p[1] = wt ^ ~At & Pr, p[10] = It ^ ~St & Cr, p[11] = xr ^ ~Rt & Tt, p[20] = Dr ^ ~xt & Ct, p[21] = kt ^ ~Ur & Bt, p[30] = Lt ^ ~Gr & Ht, p[31] = Ft ^ ~Gt & Hr, p[40] = jt ^ ~Qt & mr, p[41] = zr ^ ~Yt & gr, p[2] = Mr ^ ~Et & bt, p[3] = At ^ ~Pr & Nt, p[12] = St ^ ~Cr & Ot, p[13] = Rt ^ ~Tt & Br, p[22] = xt ^ ~Ct & Lr, p[23] = Ur ^ ~Bt & Dt, p[32] = Gr ^ ~Ht & Vt, p[33] = Gt ^ ~Hr & zt, p[42] = Qt ^ ~mr & yr, p[43] = Yt ^ ~gr & vr, p[4] = Et ^ ~bt & kr, p[5] = Pr ^ ~Nt & _t, p[14] = Cr ^ ~Ot & Mt, p[15] = Tt ^ ~Br & Pt, p[24] = Ct ^ ~Lr & Ut, p[25] = Bt ^ ~Dt & Fr, p[34] = Ht ^ ~Vt & Vr, p[35] = Hr ^ ~zt & qt, p[44] = mr ^ ~yr & wr, p[45] = gr ^ ~vr & Ar, p[6] = bt ^ ~kr & vt, p[7] = Nt ^ ~_t & wt, p[16] = Ot ^ ~Mt & It, p[17] = Br ^ ~Pt & xr, p[26] = Lr ^ ~Ut & Dr, p[27] = Dt ^ ~Fr & kt, p[36] = Vt ^ ~Vr & Lt, p[37] = zt ^ ~qt & Ft, p[46] = yr ^ ~wr & jt, p[47] = vr ^ ~Ar & zr, p[8] = kr ^ ~vt & Mr, p[9] = _t ^ ~wt & At, p[18] = Mt ^ ~It & St, p[19] = Pt ^ ~xr & Rt, p[28] = Ut ^ ~Dr & xt, p[29] = Fr ^ ~kt & Ur, p[38] = Vr ^ ~Lt & Gr, p[39] = qt ^ ~Ft & Gt, p[48] = wr ^ ~jt & Qt, p[49] = Ar ^ ~zr & Yt, p[0] ^= F[B], p[1] ^= F[B + 1];
    };
    if (c)
      e.exports = u;
    else
      for (d = 0; d < l.length; ++d)
        i[l[d]] = u[l[d]];
  })();
})(Qo);
var Su = Qo.exports;
const Ru = /* @__PURE__ */ ci(Su);
function ie(e) {
  return "0x" + Ru.keccak_256(et(e));
}
const Tu = "rlp/5.7.0", je = new M(Tu);
function Qs(e) {
  const t = [];
  for (; e; )
    t.unshift(e & 255), e >>= 8;
  return t;
}
function Ys(e, t, r) {
  let n = 0;
  for (let i = 0; i < r; i++)
    n = n * 256 + e[t + i];
  return n;
}
function Yo(e) {
  if (Array.isArray(e)) {
    let n = [];
    if (e.forEach(function(s) {
      n = n.concat(Yo(s));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const i = Qs(n.length);
    return i.unshift(247 + i.length), i.concat(n);
  }
  fi(e) || je.throwArgumentError("RLP object must be BytesLike", "object", e);
  const t = Array.prototype.slice.call(et(e));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const r = Qs(t.length);
  return r.unshift(183 + r.length), r.concat(t);
}
function yi(e) {
  return K(Yo(e));
}
function Js(e, t, r, n) {
  const i = [];
  for (; r < t + 1 + n; ) {
    const s = Jo(e, r);
    i.push(s.result), r += s.consumed, r > t + 1 + n && je.throwError("child data too short", M.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + n, result: i };
}
function Jo(e, t) {
  if (e.length === 0 && je.throwError("data too short", M.errors.BUFFER_OVERRUN, {}), e[t] >= 248) {
    const r = e[t] - 247;
    t + 1 + r > e.length && je.throwError("data short segment too short", M.errors.BUFFER_OVERRUN, {});
    const n = Ys(e, t + 1, r);
    return t + 1 + r + n > e.length && je.throwError("data long segment too short", M.errors.BUFFER_OVERRUN, {}), Js(e, t, t + 1 + r, r + n);
  } else if (e[t] >= 192) {
    const r = e[t] - 192;
    return t + 1 + r > e.length && je.throwError("data array too short", M.errors.BUFFER_OVERRUN, {}), Js(e, t, t + 1, r);
  } else if (e[t] >= 184) {
    const r = e[t] - 183;
    t + 1 + r > e.length && je.throwError("data array too short", M.errors.BUFFER_OVERRUN, {});
    const n = Ys(e, t + 1, r);
    t + 1 + r + n > e.length && je.throwError("data array too short", M.errors.BUFFER_OVERRUN, {});
    const i = K(e.slice(t + 1 + r, t + 1 + r + n));
    return { consumed: 1 + r + n, result: i };
  } else if (e[t] >= 128) {
    const r = e[t] - 128;
    t + 1 + r > e.length && je.throwError("data too short", M.errors.BUFFER_OVERRUN, {});
    const n = K(e.slice(t + 1, t + 1 + r));
    return { consumed: 1 + r, result: n };
  }
  return { consumed: 1, result: K(e[t]) };
}
function Ns(e) {
  const t = et(e), r = Jo(t, 0);
  return r.consumed !== t.length && je.throwArgumentError("invalid rlp data", "data", e), r.result;
}
const Ou = "address/5.7.0", rn = new M(Ou);
function Ks(e) {
  pt(e, 20) || rn.throwArgumentError("invalid address", "address", e), e = e.toLowerCase();
  const t = e.substring(2).split(""), r = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    r[i] = t[i].charCodeAt(0);
  const n = et(ie(r));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (t[i + 1] = t[i + 1].toUpperCase());
  return "0x" + t.join("");
}
const Mu = 9007199254740991;
function Pu(e) {
  return Math.log10 ? Math.log10(e) : Math.log(e) / Math.LN10;
}
const _s = {};
for (let e = 0; e < 10; e++)
  _s[String(e)] = String(e);
for (let e = 0; e < 26; e++)
  _s[String.fromCharCode(65 + e)] = String(10 + e);
const Ws = Math.floor(Pu(Mu));
function ku(e) {
  e = e.toUpperCase(), e = e.substring(4) + e.substring(0, 2) + "00";
  let t = e.split("").map((n) => _s[n]).join("");
  for (; t.length >= Ws; ) {
    let n = t.substring(0, Ws);
    t = parseInt(n, 10) % 97 + t.substring(n.length);
  }
  let r = String(98 - parseInt(t, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
function ne(e) {
  let t = null;
  if (typeof e != "string" && rn.throwArgumentError("invalid address", "address", e), e.match(/^(0x)?[0-9a-fA-F]{40}$/))
    e.substring(0, 2) !== "0x" && (e = "0x" + e), t = Ks(e), e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e && rn.throwArgumentError("bad address checksum", "address", e);
  else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (e.substring(2, 4) !== ku(e) && rn.throwArgumentError("bad icap checksum", "address", e), t = pu(e.substring(4)); t.length < 40; )
      t = "0" + t;
    t = Ks("0x" + t);
  } else
    rn.throwArgumentError("invalid address", "address", e);
  return t;
}
function Ko(e) {
  let t = null;
  try {
    t = ne(e.from);
  } catch {
    rn.throwArgumentError("missing from address", "transaction", e);
  }
  const r = Yr(et(V.from(e.nonce).toHexString()));
  return ne(he(ie(yi([t, r])), 12));
}
const xu = "https://api.ethplorer.io", Cu = (e = "freekey") => ({
  getBalance: async (t) => {
    const { tokens: r } = await Ho(`${xu}/getAddressInfo/${t}`, {
      apiKey: e
    });
    return r ? r.reduce((n, i) => {
      const { symbol: s, decimals: o, address: c } = i.tokenInfo, f = Lo(`${te.Ethereum}.${s}-${ne(c)}`);
      return f ? [
        ...n,
        { asset: f, amount: hr(i.rawBalance, parseInt(o)) }
      ] : n;
    }, []) : [];
  }
}), Bu = "properties/5.7.0";
var Du = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const ni = new M(Bu);
function U(e, t, r) {
  Object.defineProperty(e, t, {
    enumerable: !0,
    value: r,
    writable: !1
  });
}
function Ke(e, t) {
  for (let r = 0; r < 32; r++) {
    if (e[t])
      return e[t];
    if (!e.prototype || typeof e.prototype != "object")
      break;
    e = Object.getPrototypeOf(e.prototype).constructor;
  }
  return null;
}
function ee(e) {
  return Du(this, void 0, void 0, function* () {
    const t = Object.keys(e).map((r) => {
      const n = e[r];
      return Promise.resolve(n).then((i) => ({ key: r, value: i }));
    });
    return (yield Promise.all(t)).reduce((r, n) => (r[n.key] = n.value, r), {});
  });
}
function Uu(e, t) {
  (!e || typeof e != "object") && ni.throwArgumentError("invalid object", "object", e), Object.keys(e).forEach((r) => {
    t[r] || ni.throwArgumentError("invalid object key - " + r, "transaction:" + r, e);
  });
}
function se(e) {
  const t = {};
  for (const r in e)
    t[r] = e[r];
  return t;
}
const Lu = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function Wo(e) {
  if (e == null || Lu[typeof e])
    return !0;
  if (Array.isArray(e) || typeof e == "object") {
    if (!Object.isFrozen(e))
      return !1;
    const t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let n = null;
      try {
        n = e[t[r]];
      } catch {
        continue;
      }
      if (!Wo(n))
        return !1;
    }
    return !0;
  }
  return ni.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e);
}
function Fu(e) {
  if (Wo(e))
    return e;
  if (Array.isArray(e))
    return Object.freeze(e.map((t) => Jr(t)));
  if (typeof e == "object") {
    const t = {};
    for (const r in e) {
      const n = e[r];
      n !== void 0 && U(t, r, Jr(n));
    }
    return t;
  }
  return ni.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e);
}
function Jr(e) {
  return Fu(e);
}
class Cn {
  constructor(t) {
    for (const r in t)
      this[r] = Jr(t[r]);
  }
}
const Gu = "abstract-provider/5.7.0";
var Hu = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const Vu = new M(Gu);
class zu extends Cn {
  static isForkEvent(t) {
    return !!(t && t._isForkEvent);
  }
}
class vi {
  constructor() {
    Vu.checkAbstract(new.target, vi), U(this, "_isProvider", !0);
  }
  getFeeData() {
    return Hu(this, void 0, void 0, function* () {
      const { block: t, gasPrice: r } = yield ee({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((o) => null)
      });
      let n = null, i = null, s = null;
      return t && t.baseFeePerGas && (n = t.baseFeePerGas, s = V.from("1500000000"), i = t.baseFeePerGas.mul(2).add(s)), { lastBaseFeePerGas: n, maxFeePerGas: i, maxPriorityFeePerGas: s, gasPrice: r };
    });
  }
  // Alias for "on"
  addListener(t, r) {
    return this.on(t, r);
  }
  // Alias for "off"
  removeListener(t, r) {
    return this.off(t, r);
  }
  static isProvider(t) {
    return !!(t && t._isProvider);
  }
}
const qu = "networks/5.7.1", Xs = new M(qu);
function ju(e) {
  return e && typeof e.renetwork == "function";
}
function ar(e) {
  const t = function(r, n) {
    n == null && (n = {});
    const i = [];
    if (r.InfuraProvider && n.infura !== "-")
      try {
        i.push(new r.InfuraProvider(e, n.infura));
      } catch {
      }
    if (r.EtherscanProvider && n.etherscan !== "-")
      try {
        i.push(new r.EtherscanProvider(e, n.etherscan));
      } catch {
      }
    if (r.AlchemyProvider && n.alchemy !== "-")
      try {
        i.push(new r.AlchemyProvider(e, n.alchemy));
      } catch {
      }
    if (r.PocketProvider && n.pocket !== "-") {
      const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const o = new r.PocketProvider(e, n.pocket);
        o.network && s.indexOf(o.network.name) === -1 && i.push(o);
      } catch {
      }
    }
    if (r.CloudflareProvider && n.cloudflare !== "-")
      try {
        i.push(new r.CloudflareProvider(e));
      } catch {
      }
    if (r.AnkrProvider && n.ankr !== "-")
      try {
        const s = ["ropsten"], o = new r.AnkrProvider(e, n.ankr);
        o.network && s.indexOf(o.network.name) === -1 && i.push(o);
      } catch {
      }
    if (i.length === 0)
      return null;
    if (r.FallbackProvider) {
      let s = 1;
      return n.quorum != null ? s = n.quorum : e === "homestead" && (s = 2), new r.FallbackProvider(i, s);
    }
    return i[0];
  };
  return t.renetwork = function(r) {
    return ar(r);
  }, t;
}
function ii(e, t) {
  const r = function(n, i) {
    return n.JsonRpcProvider ? new n.JsonRpcProvider(e, t) : null;
  };
  return r.renetwork = function(n) {
    return ii(e, n);
  }, r;
}
const Zs = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ar("homestead")
}, $s = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ar("ropsten")
}, to = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: ii("https://www.ethercluster.com/mordor", "classicMordor")
}, zn = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead: Zs,
  mainnet: Zs,
  morden: { chainId: 2, name: "morden" },
  ropsten: $s,
  testnet: $s,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ar("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ar("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ar("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ar("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: ii("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor: to,
  classicTestnet: to,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: ii("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ar("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ar("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function Qu(e) {
  if (e == null)
    return null;
  if (typeof e == "number") {
    for (const n in zn) {
      const i = zn[n];
      if (i.chainId === e)
        return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null
        };
    }
    return {
      chainId: e,
      name: "unknown"
    };
  }
  if (typeof e == "string") {
    const n = zn[e];
    return n == null ? null : {
      name: n.name,
      chainId: n.chainId,
      ensAddress: n.ensAddress,
      _defaultProvider: n._defaultProvider || null
    };
  }
  const t = zn[e.name];
  if (!t)
    return typeof e.chainId != "number" && Xs.throwArgumentError("invalid network chainId", "network", e), e;
  e.chainId !== 0 && e.chainId !== t.chainId && Xs.throwArgumentError("network chainId mismatch", "network", e);
  let r = e._defaultProvider || null;
  return r == null && t._defaultProvider && (ju(t._defaultProvider) ? r = t._defaultProvider.renetwork(e) : r = t._defaultProvider), {
    name: e.name,
    chainId: t.chainId,
    ensAddress: e.ensAddress || t.ensAddress || null,
    _defaultProvider: r
  };
}
function Xo(e) {
  e = atob(e);
  const t = [];
  for (let r = 0; r < e.length; r++)
    t.push(e.charCodeAt(r));
  return et(t);
}
function Zo(e) {
  e = et(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += String.fromCharCode(e[r]);
  return btoa(t);
}
class $o {
  constructor(t) {
    U(this, "alphabet", t), U(this, "base", t.length), U(this, "_alphabetMap", {}), U(this, "_leader", t.charAt(0));
    for (let r = 0; r < t.length; r++)
      this._alphabetMap[t.charAt(r)] = r;
  }
  encode(t) {
    let r = et(t);
    if (r.length === 0)
      return "";
    let n = [0];
    for (let s = 0; s < r.length; ++s) {
      let o = r[s];
      for (let c = 0; c < n.length; ++c)
        o += n[c] << 8, n[c] = o % this.base, o = o / this.base | 0;
      for (; o > 0; )
        n.push(o % this.base), o = o / this.base | 0;
    }
    let i = "";
    for (let s = 0; r[s] === 0 && s < r.length - 1; ++s)
      i += this._leader;
    for (let s = n.length - 1; s >= 0; --s)
      i += this.alphabet[n[s]];
    return i;
  }
  decode(t) {
    if (typeof t != "string")
      throw new TypeError("Expected String");
    let r = [];
    if (t.length === 0)
      return new Uint8Array(r);
    r.push(0);
    for (let n = 0; n < t.length; n++) {
      let i = this._alphabetMap[t[n]];
      if (i === void 0)
        throw new Error("Non-base" + this.base + " character");
      let s = i;
      for (let o = 0; o < r.length; ++o)
        s += r[o] * this.base, r[o] = s & 255, s >>= 8;
      for (; s > 0; )
        r.push(s & 255), s >>= 8;
    }
    for (let n = 0; t[n] === this._leader && n < t.length - 1; ++n)
      r.push(0);
    return et(new Uint8Array(r.reverse()));
  }
}
new $o("abcdefghijklmnopqrstuvwxyz234567");
const ls = new $o("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Yu = "0x0000000000000000000000000000000000000000", Ju = /* @__PURE__ */ V.from(-1), ta = /* @__PURE__ */ V.from(0), Ku = /* @__PURE__ */ V.from(1), Wu = /* @__PURE__ */ V.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), Xu = /* @__PURE__ */ V.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), Zu = "0x0000000000000000000000000000000000000000000000000000000000000000", $u = "strings/5.7.0", ea = new M($u);
var Sn;
(function(e) {
  e.current = "", e.NFC = "NFC", e.NFD = "NFD", e.NFKC = "NFKC", e.NFKD = "NFKD";
})(Sn || (Sn = {}));
var we;
(function(e) {
  e.UNEXPECTED_CONTINUE = "unexpected continuation byte", e.BAD_PREFIX = "bad codepoint prefix", e.OVERRUN = "string overrun", e.MISSING_CONTINUE = "missing continuation byte", e.OUT_OF_RANGE = "out of UTF-8 range", e.UTF16_SURROGATE = "UTF-16 surrogate", e.OVERLONG = "overlong representation";
})(we || (we = {}));
function th(e, t, r, n, i) {
  return ea.throwArgumentError(`invalid codepoint at offset ${t}; ${e}`, "bytes", r);
}
function ra(e, t, r, n, i) {
  if (e === we.BAD_PREFIX || e === we.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let o = t + 1; o < r.length && r[o] >> 6 === 2; o++)
      s++;
    return s;
  }
  return e === we.OVERRUN ? r.length - t - 1 : 0;
}
function eh(e, t, r, n, i) {
  return e === we.OVERLONG ? (n.push(i), 0) : (n.push(65533), ra(e, t, r));
}
const rh = Object.freeze({
  error: th,
  ignore: ra,
  replace: eh
});
function na(e, t) {
  t == null && (t = rh.error), e = et(e);
  const r = [];
  let n = 0;
  for (; n < e.length; ) {
    const i = e[n++];
    if (!(i >> 7)) {
      r.push(i);
      continue;
    }
    let s = null, o = null;
    if ((i & 224) === 192)
      s = 1, o = 127;
    else if ((i & 240) === 224)
      s = 2, o = 2047;
    else if ((i & 248) === 240)
      s = 3, o = 65535;
    else {
      (i & 192) === 128 ? n += t(we.UNEXPECTED_CONTINUE, n - 1, e, r) : n += t(we.BAD_PREFIX, n - 1, e, r);
      continue;
    }
    if (n - 1 + s >= e.length) {
      n += t(we.OVERRUN, n - 1, e, r);
      continue;
    }
    let c = i & (1 << 8 - s - 1) - 1;
    for (let f = 0; f < s; f++) {
      let m = e[n];
      if ((m & 192) != 128) {
        n += t(we.MISSING_CONTINUE, n, e, r), c = null;
        break;
      }
      c = c << 6 | m & 63, n++;
    }
    if (c !== null) {
      if (c > 1114111) {
        n += t(we.OUT_OF_RANGE, n - 1 - s, e, r, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        n += t(we.UTF16_SURROGATE, n - 1 - s, e, r, c);
        continue;
      }
      if (c <= o) {
        n += t(we.OVERLONG, n - 1 - s, e, r, c);
        continue;
      }
      r.push(c);
    }
  }
  return r;
}
function Oe(e, t = Sn.current) {
  t != Sn.current && (ea.checkNormalize(), e = e.normalize(t));
  let r = [];
  for (let n = 0; n < e.length; n++) {
    const i = e.charCodeAt(n);
    if (i < 128)
      r.push(i);
    else if (i < 2048)
      r.push(i >> 6 | 192), r.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = e.charCodeAt(n);
      if (n >= e.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128);
    } else
      r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128);
  }
  return et(r);
}
function nh(e) {
  return e.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("");
}
function Bn(e, t) {
  return nh(na(e, t));
}
function ih(e, t = Sn.current) {
  return na(Oe(e, t));
}
function nn(e) {
  return ie(Oe(e));
}
const ia = "hash/5.7.0";
function sa(e, t) {
  t == null && (t = 1);
  const r = [], n = r.forEach, i = function(s, o) {
    n.call(s, function(c) {
      o > 0 && Array.isArray(c) ? i(c, o - 1) : r.push(c);
    });
  };
  return i(e, t), r;
}
function sh(e) {
  const t = {};
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    t[n[0]] = n[1];
  }
  return t;
}
function oh(e) {
  let t = 0;
  function r() {
    return e[t++] << 8 | e[t++];
  }
  let n = r(), i = 1, s = [0, 1];
  for (let $ = 1; $ < n; $++)
    s.push(i += r());
  let o = r(), c = t;
  t += o;
  let f = 0, m = 0;
  function E() {
    return f == 0 && (m = m << 8 | e[t++], f = 8), m >> --f & 1;
  }
  const _ = 31, S = Math.pow(2, _), O = S >>> 1, C = O >> 1, F = S - 1;
  let L = 0;
  for (let $ = 0; $ < _; $++)
    L = L << 1 | E();
  let D = [], P = 0, X = S;
  for (; ; ) {
    let $ = Math.floor(((L - P + 1) * i - 1) / X), tt = 0, mt = n;
    for (; mt - tt > 1; ) {
      let I = tt + mt >>> 1;
      $ < s[I] ? mt = I : tt = I;
    }
    if (tt == 0)
      break;
    D.push(tt);
    let v = P + Math.floor(X * s[tt] / i), N = P + Math.floor(X * s[tt + 1] / i) - 1;
    for (; !((v ^ N) & O); )
      L = L << 1 & F | E(), v = v << 1 & F, N = N << 1 & F | 1;
    for (; v & ~N & C; )
      L = L & O | L << 1 & F >>> 1 | E(), v = v << 1 ^ O, N = (N ^ O) << 1 | O | 1;
    P = v, X = 1 + N - v;
  }
  let rt = n - 4;
  return D.map(($) => {
    switch ($ - rt) {
      case 3:
        return rt + 65792 + (e[c++] << 16 | e[c++] << 8 | e[c++]);
      case 2:
        return rt + 256 + (e[c++] << 8 | e[c++]);
      case 1:
        return rt + e[c++];
      default:
        return $ - 1;
    }
  });
}
function ah(e) {
  let t = 0;
  return () => e[t++];
}
function uh(e) {
  return ah(oh(e));
}
function hh(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function lh(e, t) {
  let r = Array(e);
  for (let n = 0; n < e; n++)
    r[n] = 1 + t();
  return r;
}
function eo(e, t) {
  let r = Array(e);
  for (let n = 0, i = -1; n < e; n++)
    r[n] = i += 1 + t();
  return r;
}
function ch(e, t) {
  let r = Array(e);
  for (let n = 0, i = 0; n < e; n++)
    r[n] = i += hh(t());
  return r;
}
function si(e, t) {
  let r = eo(e(), e), n = e(), i = eo(n, e), s = lh(n, e);
  for (let o = 0; o < n; o++)
    for (let c = 0; c < s[o]; c++)
      r.push(i[o] + c);
  return t ? r.map((o) => t[o]) : r;
}
function fh(e) {
  let t = [];
  for (; ; ) {
    let r = e();
    if (r == 0)
      break;
    t.push(ph(r, e));
  }
  for (; ; ) {
    let r = e() - 1;
    if (r < 0)
      break;
    t.push(mh(r, e));
  }
  return sh(sa(t));
}
function dh(e) {
  let t = [];
  for (; ; ) {
    let r = e();
    if (r == 0)
      break;
    t.push(r);
  }
  return t;
}
function oa(e, t, r) {
  let n = Array(e).fill(void 0).map(() => []);
  for (let i = 0; i < t; i++)
    ch(e, r).forEach((s, o) => n[o].push(s));
  return n;
}
function ph(e, t) {
  let r = 1 + t(), n = t(), i = dh(t), s = oa(i.length, 1 + e, t);
  return sa(s.map((o, c) => {
    const f = o[0], m = o.slice(1);
    return Array(i[c]).fill(void 0).map((E, _) => {
      let S = _ * n;
      return [f + _ * r, m.map((O) => O + S)];
    });
  }));
}
function mh(e, t) {
  let r = 1 + t();
  return oa(r, 1 + e, t).map((n) => [n[0], n.slice(1)]);
}
function gh(e) {
  let t = si(e).sort((n, i) => n - i);
  return r();
  function r() {
    let n = [];
    for (; ; ) {
      let m = si(e, t);
      if (m.length == 0)
        break;
      n.push({ set: new Set(m), node: r() });
    }
    n.sort((m, E) => E.set.size - m.set.size);
    let i = e(), s = i % 3;
    i = i / 3 | 0;
    let o = !!(i & 1);
    i >>= 1;
    let c = i == 1, f = i == 2;
    return { branches: n, valid: s, fe0f: o, save: c, check: f };
  }
}
function yh() {
  return uh(Xo("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const wi = yh(), vh = new Set(si(wi)), wh = new Set(si(wi)), Ah = fh(wi), Eh = gh(wi), ro = 45, no = 95;
function aa(e) {
  return ih(e);
}
function bh(e) {
  return e.filter((t) => t != 65039);
}
function ua(e) {
  for (let t of e.split(".")) {
    let r = aa(t);
    try {
      for (let n = r.lastIndexOf(no) - 1; n >= 0; n--)
        if (r[n] !== no)
          throw new Error("underscore only allowed at start");
      if (r.length >= 4 && r.every((n) => n < 128) && r[2] === ro && r[3] === ro)
        throw new Error("invalid label extension");
    } catch (n) {
      throw new Error(`Invalid label "${t}": ${n.message}`);
    }
  }
  return e;
}
function Nh(e) {
  return ua(_h(e, bh));
}
function _h(e, t) {
  let r = aa(e).reverse(), n = [];
  for (; r.length; ) {
    let i = Sh(r);
    if (i) {
      n.push(...t(i));
      continue;
    }
    let s = r.pop();
    if (vh.has(s)) {
      n.push(s);
      continue;
    }
    if (wh.has(s))
      continue;
    let o = Ah[s];
    if (o) {
      n.push(...o);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return ua(Ih(String.fromCodePoint(...n)));
}
function Ih(e) {
  return e.normalize("NFC");
}
function Sh(e, t) {
  var r;
  let n = Eh, i, s, o = [], c = e.length;
  for (t && (t.length = 0); c; ) {
    let f = e[--c];
    if (n = (r = n.branches.find((m) => m.set.has(f))) === null || r === void 0 ? void 0 : r.node, !n)
      break;
    if (n.save)
      s = f;
    else if (n.check && f === s)
      break;
    o.push(f), n.fe0f && (o.push(65039), c > 0 && e[c - 1] == 65039 && c--), n.valid && (i = o.slice(), n.valid == 2 && i.splice(1, 1), t && t.push(...e.slice(c).reverse()), e.length = c);
  }
  return i;
}
const Rh = new M(ia), ha = new Uint8Array(32);
ha.fill(0);
function io(e) {
  if (e.length === 0)
    throw new Error("invalid ENS name; empty component");
  return e;
}
function la(e) {
  const t = Oe(Nh(e)), r = [];
  if (e.length === 0)
    return r;
  let n = 0;
  for (let i = 0; i < t.length; i++)
    t[i] === 46 && (r.push(io(t.slice(n, i))), n = i + 1);
  if (n >= t.length)
    throw new Error("invalid ENS name; empty component");
  return r.push(io(t.slice(n))), r;
}
function Wn(e) {
  typeof e != "string" && Rh.throwArgumentError("invalid ENS name; not a string", "name", e);
  let t = ha;
  const r = la(e);
  for (; r.length; )
    t = ie(ge([t, ie(r.pop())]));
  return K(t);
}
function Th(e) {
  return K(ge(la(e).map((t) => {
    if (t.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const r = new Uint8Array(t.length + 1);
    return r.set(t, 1), r[0] = r.length - 1, r;
  }))) + "00";
}
var Oh = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const Wt = new M(ia), ca = new Uint8Array(32);
ca.fill(0);
const Mh = V.from(-1), fa = V.from(0), da = V.from(1), Ph = V.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function kh(e) {
  const t = et(e), r = t.length % 32;
  return r ? de([t, ca.slice(r)]) : K(t);
}
const xh = Xt(da.toHexString(), 32), Ch = Xt(fa.toHexString(), 32), so = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, Ji = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function oo(e) {
  return function(t) {
    return typeof t != "string" && Wt.throwArgumentError(`invalid domain value for ${JSON.stringify(e)}`, `domain.${e}`, t), t;
  };
}
const Bh = {
  name: oo("name"),
  version: oo("version"),
  chainId: function(e) {
    try {
      return V.from(e).toString();
    } catch {
    }
    return Wt.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", e);
  },
  verifyingContract: function(e) {
    try {
      return ne(e).toLowerCase();
    } catch {
    }
    return Wt.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", e);
  },
  salt: function(e) {
    try {
      const t = et(e);
      if (t.length !== 32)
        throw new Error("bad length");
      return K(t);
    } catch {
    }
    return Wt.throwArgumentError('invalid domain value "salt"', "domain.salt", e);
  }
};
function Ki(e) {
  {
    const t = e.match(/^(u?)int(\d*)$/);
    if (t) {
      const r = t[1] === "", n = parseInt(t[2] || "256");
      (n % 8 !== 0 || n > 256 || t[2] && t[2] !== String(n)) && Wt.throwArgumentError("invalid numeric width", "type", e);
      const i = Ph.mask(r ? n - 1 : n), s = r ? i.add(da).mul(Mh) : fa;
      return function(o) {
        const c = V.from(o);
        return (c.lt(s) || c.gt(i)) && Wt.throwArgumentError(`value out-of-bounds for ${e}`, "value", o), Xt(c.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const t = e.match(/^bytes(\d+)$/);
    if (t) {
      const r = parseInt(t[1]);
      return (r === 0 || r > 32 || t[1] !== String(r)) && Wt.throwArgumentError("invalid bytes width", "type", e), function(n) {
        return et(n).length !== r && Wt.throwArgumentError(`invalid length for ${e}`, "value", n), kh(n);
      };
    }
  }
  switch (e) {
    case "address":
      return function(t) {
        return Xt(ne(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? xh : Ch;
      };
    case "bytes":
      return function(t) {
        return ie(t);
      };
    case "string":
      return function(t) {
        return nn(t);
      };
  }
  return null;
}
function ao(e, t) {
  return `${e}(${t.map(({ name: r, type: n }) => n + " " + r).join(",")})`;
}
class ve {
  constructor(t) {
    U(this, "types", Object.freeze(Jr(t))), U(this, "_encoderCache", {}), U(this, "_types", {});
    const r = {}, n = {}, i = {};
    Object.keys(t).forEach((c) => {
      r[c] = {}, n[c] = [], i[c] = {};
    });
    for (const c in t) {
      const f = {};
      t[c].forEach((m) => {
        f[m.name] && Wt.throwArgumentError(`duplicate variable name ${JSON.stringify(m.name)} in ${JSON.stringify(c)}`, "types", t), f[m.name] = !0;
        const E = m.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        E === c && Wt.throwArgumentError(`circular type reference to ${JSON.stringify(E)}`, "types", t), !Ki(E) && (n[E] || Wt.throwArgumentError(`unknown type ${JSON.stringify(E)}`, "types", t), n[E].push(c), r[c][E] = !0);
      });
    }
    const s = Object.keys(n).filter((c) => n[c].length === 0);
    s.length === 0 ? Wt.throwArgumentError("missing primary type", "types", t) : s.length > 1 && Wt.throwArgumentError(`ambiguous primary types or unused types: ${s.map((c) => JSON.stringify(c)).join(", ")}`, "types", t), U(this, "primaryType", s[0]);
    function o(c, f) {
      f[c] && Wt.throwArgumentError(`circular type reference to ${JSON.stringify(c)}`, "types", t), f[c] = !0, Object.keys(r[c]).forEach((m) => {
        n[m] && (o(m, f), Object.keys(f).forEach((E) => {
          i[E][m] = !0;
        }));
      }), delete f[c];
    }
    o(this.primaryType, {});
    for (const c in i) {
      const f = Object.keys(i[c]);
      f.sort(), this._types[c] = ao(c, t[c]) + f.map((m) => ao(m, t[m])).join("");
    }
  }
  getEncoder(t) {
    let r = this._encoderCache[t];
    return r || (r = this._encoderCache[t] = this._getEncoder(t)), r;
  }
  _getEncoder(t) {
    {
      const i = Ki(t);
      if (i)
        return i;
    }
    const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (r) {
      const i = r[1], s = this.getEncoder(i), o = parseInt(r[3]);
      return (c) => {
        o >= 0 && c.length !== o && Wt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", c);
        let f = c.map(s);
        return this._types[i] && (f = f.map(ie)), ie(de(f));
      };
    }
    const n = this.types[t];
    if (n) {
      const i = nn(this._types[t]);
      return (s) => {
        const o = n.map(({ name: c, type: f }) => {
          const m = this.getEncoder(f)(s[c]);
          return this._types[f] ? ie(m) : m;
        });
        return o.unshift(i), de(o);
      };
    }
    return Wt.throwArgumentError(`unknown type: ${t}`, "type", t);
  }
  encodeType(t) {
    const r = this._types[t];
    return r || Wt.throwArgumentError(`unknown type: ${JSON.stringify(t)}`, "name", t), r;
  }
  encodeData(t, r) {
    return this.getEncoder(t)(r);
  }
  hashStruct(t, r) {
    return ie(this.encodeData(t, r));
  }
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  _visit(t, r, n) {
    if (Ki(t))
      return n(t, r);
    const i = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const o = i[1], c = parseInt(i[3]);
      return c >= 0 && r.length !== c && Wt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", r), r.map((f) => this._visit(o, f, n));
    }
    const s = this.types[t];
    return s ? s.reduce((o, { name: c, type: f }) => (o[c] = this._visit(f, r[c], n), o), {}) : Wt.throwArgumentError(`unknown type: ${t}`, "type", t);
  }
  visit(t, r) {
    return this._visit(this.primaryType, t, r);
  }
  static from(t) {
    return new ve(t);
  }
  static getPrimaryType(t) {
    return ve.from(t).primaryType;
  }
  static hashStruct(t, r, n) {
    return ve.from(r).hashStruct(t, n);
  }
  static hashDomain(t) {
    const r = [];
    for (const n in t) {
      const i = so[n];
      i || Wt.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", t), r.push({ name: n, type: i });
    }
    return r.sort((n, i) => Ji.indexOf(n.name) - Ji.indexOf(i.name)), ve.hashStruct("EIP712Domain", { EIP712Domain: r }, t);
  }
  static encode(t, r, n) {
    return de([
      "0x1901",
      ve.hashDomain(t),
      ve.from(r).hash(n)
    ]);
  }
  static hash(t, r, n) {
    return ie(ve.encode(t, r, n));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(t, r, n, i) {
    return Oh(this, void 0, void 0, function* () {
      t = se(t);
      const s = {};
      t.verifyingContract && !pt(t.verifyingContract, 20) && (s[t.verifyingContract] = "0x");
      const o = ve.from(r);
      o.visit(n, (c, f) => (c === "address" && !pt(f, 20) && (s[f] = "0x"), f));
      for (const c in s)
        s[c] = yield i(c);
      return t.verifyingContract && s[t.verifyingContract] && (t.verifyingContract = s[t.verifyingContract]), n = o.visit(n, (c, f) => c === "address" && s[f] ? s[f] : f), { domain: t, value: n };
    });
  }
  static getPayload(t, r, n) {
    ve.hashDomain(t);
    const i = {}, s = [];
    Ji.forEach((f) => {
      const m = t[f];
      m != null && (i[f] = Bh[f](m), s.push({ name: f, type: so[f] }));
    });
    const o = ve.from(r), c = se(r);
    return c.EIP712Domain ? Wt.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", r) : c.EIP712Domain = s, o.encode(n), {
      types: c,
      domain: i,
      primaryType: o.primaryType,
      message: o.visit(n, (f, m) => {
        if (f.match(/^bytes(\d*)/))
          return K(et(m));
        if (f.match(/^u?int/))
          return V.from(m).toString();
        switch (f) {
          case "address":
            return m.toLowerCase();
          case "bool":
            return !!m;
          case "string":
            return typeof m != "string" && Wt.throwArgumentError("invalid string", "value", m), m;
        }
        return Wt.throwArgumentError("unsupported type", "type", f);
      })
    };
  }
}
var pa = {}, ct = {}, Dn = ma;
function ma(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
ma.equal = function(e, t, r) {
  if (e != t)
    throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var cs = { exports: {} };
typeof Object.create == "function" ? cs.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : cs.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var r = function() {
    };
    r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
  }
};
var Dh = cs.exports, Uh = Dn, Lh = Dh;
ct.inherits = Lh;
function Fh(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function Gh(e, t) {
  if (Array.isArray(e))
    return e.slice();
  if (!e)
    return [];
  var r = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), i = 0; i < e.length; i += 2)
          r.push(parseInt(e[i] + e[i + 1], 16));
    } else
      for (var n = 0, i = 0; i < e.length; i++) {
        var s = e.charCodeAt(i);
        s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : Fh(e, i) ? (s = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128);
      }
  else
    for (i = 0; i < e.length; i++)
      r[i] = e[i] | 0;
  return r;
}
ct.toArray = Gh;
function Hh(e) {
  for (var t = "", r = 0; r < e.length; r++)
    t += ya(e[r].toString(16));
  return t;
}
ct.toHex = Hh;
function ga(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
ct.htonl = ga;
function Vh(e, t) {
  for (var r = "", n = 0; n < e.length; n++) {
    var i = e[n];
    t === "little" && (i = ga(i)), r += va(i.toString(16));
  }
  return r;
}
ct.toHex32 = Vh;
function ya(e) {
  return e.length === 1 ? "0" + e : e;
}
ct.zero2 = ya;
function va(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
ct.zero8 = va;
function zh(e, t, r, n) {
  var i = r - t;
  Uh(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, c = t; o < s.length; o++, c += 4) {
    var f;
    n === "big" ? f = e[c] << 24 | e[c + 1] << 16 | e[c + 2] << 8 | e[c + 3] : f = e[c + 3] << 24 | e[c + 2] << 16 | e[c + 1] << 8 | e[c], s[o] = f >>> 0;
  }
  return s;
}
ct.join32 = zh;
function qh(e, t) {
  for (var r = new Array(e.length * 4), n = 0, i = 0; n < e.length; n++, i += 4) {
    var s = e[n];
    t === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255);
  }
  return r;
}
ct.split32 = qh;
function jh(e, t) {
  return e >>> t | e << 32 - t;
}
ct.rotr32 = jh;
function Qh(e, t) {
  return e << t | e >>> 32 - t;
}
ct.rotl32 = Qh;
function Yh(e, t) {
  return e + t >>> 0;
}
ct.sum32 = Yh;
function Jh(e, t, r) {
  return e + t + r >>> 0;
}
ct.sum32_3 = Jh;
function Kh(e, t, r, n) {
  return e + t + r + n >>> 0;
}
ct.sum32_4 = Kh;
function Wh(e, t, r, n, i) {
  return e + t + r + n + i >>> 0;
}
ct.sum32_5 = Wh;
function Xh(e, t, r, n) {
  var i = e[t], s = e[t + 1], o = n + s >>> 0, c = (o < n ? 1 : 0) + r + i;
  e[t] = c >>> 0, e[t + 1] = o;
}
ct.sum64 = Xh;
function Zh(e, t, r, n) {
  var i = t + n >>> 0, s = (i < t ? 1 : 0) + e + r;
  return s >>> 0;
}
ct.sum64_hi = Zh;
function $h(e, t, r, n) {
  var i = t + n;
  return i >>> 0;
}
ct.sum64_lo = $h;
function tl(e, t, r, n, i, s, o, c) {
  var f = 0, m = t;
  m = m + n >>> 0, f += m < t ? 1 : 0, m = m + s >>> 0, f += m < s ? 1 : 0, m = m + c >>> 0, f += m < c ? 1 : 0;
  var E = e + r + i + o + f;
  return E >>> 0;
}
ct.sum64_4_hi = tl;
function el(e, t, r, n, i, s, o, c) {
  var f = t + n + s + c;
  return f >>> 0;
}
ct.sum64_4_lo = el;
function rl(e, t, r, n, i, s, o, c, f, m) {
  var E = 0, _ = t;
  _ = _ + n >>> 0, E += _ < t ? 1 : 0, _ = _ + s >>> 0, E += _ < s ? 1 : 0, _ = _ + c >>> 0, E += _ < c ? 1 : 0, _ = _ + m >>> 0, E += _ < m ? 1 : 0;
  var S = e + r + i + o + f + E;
  return S >>> 0;
}
ct.sum64_5_hi = rl;
function nl(e, t, r, n, i, s, o, c, f, m) {
  var E = t + n + s + c + m;
  return E >>> 0;
}
ct.sum64_5_lo = nl;
function il(e, t, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
ct.rotr64_hi = il;
function sl(e, t, r) {
  var n = e << 32 - r | t >>> r;
  return n >>> 0;
}
ct.rotr64_lo = sl;
function ol(e, t, r) {
  return e >>> r;
}
ct.shr64_hi = ol;
function al(e, t, r) {
  var n = e << 32 - r | t >>> r;
  return n >>> 0;
}
ct.shr64_lo = al;
var fn = {}, uo = ct, ul = Dn;
function Ai() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
fn.BlockHash = Ai;
Ai.prototype.update = function(e, t) {
  if (e = uo.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var r = e.length % this._delta8;
    this.pending = e.slice(e.length - r, e.length), this.pending.length === 0 && (this.pending = null), e = uo.join32(e, 0, e.length - r, this.endian);
    for (var n = 0; n < e.length; n += this._delta32)
      this._update(e, n, n + this._delta32);
  }
  return this;
};
Ai.prototype.digest = function(e) {
  return this.update(this._pad()), ul(this.pending === null), this._digest(e);
};
Ai.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, r = t - (e + this.padLength) % t, n = new Array(r + this.padLength);
  n[0] = 128;
  for (var i = 1; i < r; i++)
    n[i] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var s = 8; s < this.padLength; s++)
      n[i++] = 0;
    n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = e >>> 24 & 255, n[i++] = e >>> 16 & 255, n[i++] = e >>> 8 & 255, n[i++] = e & 255;
  } else
    for (n[i++] = e & 255, n[i++] = e >>> 8 & 255, n[i++] = e >>> 16 & 255, n[i++] = e >>> 24 & 255, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, s = 8; s < this.padLength; s++)
      n[i++] = 0;
  return n;
};
var dn = {}, rr = {}, hl = ct, We = hl.rotr32;
function ll(e, t, r, n) {
  if (e === 0)
    return wa(t, r, n);
  if (e === 1 || e === 3)
    return Ea(t, r, n);
  if (e === 2)
    return Aa(t, r, n);
}
rr.ft_1 = ll;
function wa(e, t, r) {
  return e & t ^ ~e & r;
}
rr.ch32 = wa;
function Aa(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
rr.maj32 = Aa;
function Ea(e, t, r) {
  return e ^ t ^ r;
}
rr.p32 = Ea;
function cl(e) {
  return We(e, 2) ^ We(e, 13) ^ We(e, 22);
}
rr.s0_256 = cl;
function fl(e) {
  return We(e, 6) ^ We(e, 11) ^ We(e, 25);
}
rr.s1_256 = fl;
function dl(e) {
  return We(e, 7) ^ We(e, 18) ^ e >>> 3;
}
rr.g0_256 = dl;
function pl(e) {
  return We(e, 17) ^ We(e, 19) ^ e >>> 10;
}
rr.g1_256 = pl;
var un = ct, ml = fn, gl = rr, Wi = un.rotl32, yn = un.sum32, yl = un.sum32_5, vl = gl.ft_1, ba = ml.BlockHash, wl = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function $e() {
  if (!(this instanceof $e))
    return new $e();
  ba.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
un.inherits($e, ba);
var Al = $e;
$e.blockSize = 512;
$e.outSize = 160;
$e.hmacStrength = 80;
$e.padLength = 64;
$e.prototype._update = function(e, t) {
  for (var r = this.W, n = 0; n < 16; n++)
    r[n] = e[t + n];
  for (; n < r.length; n++)
    r[n] = Wi(r[n - 3] ^ r[n - 8] ^ r[n - 14] ^ r[n - 16], 1);
  var i = this.h[0], s = this.h[1], o = this.h[2], c = this.h[3], f = this.h[4];
  for (n = 0; n < r.length; n++) {
    var m = ~~(n / 20), E = yl(Wi(i, 5), vl(m, s, o, c), f, r[n], wl[m]);
    f = c, c = o, o = Wi(s, 30), s = i, i = E;
  }
  this.h[0] = yn(this.h[0], i), this.h[1] = yn(this.h[1], s), this.h[2] = yn(this.h[2], o), this.h[3] = yn(this.h[3], c), this.h[4] = yn(this.h[4], f);
};
$e.prototype._digest = function(e) {
  return e === "hex" ? un.toHex32(this.h, "big") : un.split32(this.h, "big");
};
var hn = ct, El = fn, pn = rr, bl = Dn, Be = hn.sum32, Nl = hn.sum32_4, _l = hn.sum32_5, Il = pn.ch32, Sl = pn.maj32, Rl = pn.s0_256, Tl = pn.s1_256, Ol = pn.g0_256, Ml = pn.g1_256, Na = El.BlockHash, Pl = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function tr() {
  if (!(this instanceof tr))
    return new tr();
  Na.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = Pl, this.W = new Array(64);
}
hn.inherits(tr, Na);
var _a = tr;
tr.blockSize = 512;
tr.outSize = 256;
tr.hmacStrength = 192;
tr.padLength = 64;
tr.prototype._update = function(e, t) {
  for (var r = this.W, n = 0; n < 16; n++)
    r[n] = e[t + n];
  for (; n < r.length; n++)
    r[n] = Nl(Ml(r[n - 2]), r[n - 7], Ol(r[n - 15]), r[n - 16]);
  var i = this.h[0], s = this.h[1], o = this.h[2], c = this.h[3], f = this.h[4], m = this.h[5], E = this.h[6], _ = this.h[7];
  for (bl(this.k.length === r.length), n = 0; n < r.length; n++) {
    var S = _l(_, Tl(f), Il(f, m, E), this.k[n], r[n]), O = Be(Rl(i), Sl(i, s, o));
    _ = E, E = m, m = f, f = Be(c, S), c = o, o = s, s = i, i = Be(S, O);
  }
  this.h[0] = Be(this.h[0], i), this.h[1] = Be(this.h[1], s), this.h[2] = Be(this.h[2], o), this.h[3] = Be(this.h[3], c), this.h[4] = Be(this.h[4], f), this.h[5] = Be(this.h[5], m), this.h[6] = Be(this.h[6], E), this.h[7] = Be(this.h[7], _);
};
tr.prototype._digest = function(e) {
  return e === "hex" ? hn.toHex32(this.h, "big") : hn.split32(this.h, "big");
};
var fs = ct, Ia = _a;
function cr() {
  if (!(this instanceof cr))
    return new cr();
  Ia.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
fs.inherits(cr, Ia);
var kl = cr;
cr.blockSize = 512;
cr.outSize = 224;
cr.hmacStrength = 192;
cr.padLength = 64;
cr.prototype._digest = function(e) {
  return e === "hex" ? fs.toHex32(this.h.slice(0, 7), "big") : fs.split32(this.h.slice(0, 7), "big");
};
var ye = ct, xl = fn, Cl = Dn, Xe = ye.rotr64_hi, Ze = ye.rotr64_lo, Sa = ye.shr64_hi, Ra = ye.shr64_lo, br = ye.sum64, Xi = ye.sum64_hi, Zi = ye.sum64_lo, Bl = ye.sum64_4_hi, Dl = ye.sum64_4_lo, Ul = ye.sum64_5_hi, Ll = ye.sum64_5_lo, Ta = xl.BlockHash, Fl = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function ze() {
  if (!(this instanceof ze))
    return new ze();
  Ta.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = Fl, this.W = new Array(160);
}
ye.inherits(ze, Ta);
var Oa = ze;
ze.blockSize = 1024;
ze.outSize = 512;
ze.hmacStrength = 192;
ze.padLength = 128;
ze.prototype._prepareBlock = function(e, t) {
  for (var r = this.W, n = 0; n < 32; n++)
    r[n] = e[t + n];
  for (; n < r.length; n += 2) {
    var i = Wl(r[n - 4], r[n - 3]), s = Xl(r[n - 4], r[n - 3]), o = r[n - 14], c = r[n - 13], f = Jl(r[n - 30], r[n - 29]), m = Kl(r[n - 30], r[n - 29]), E = r[n - 32], _ = r[n - 31];
    r[n] = Bl(
      i,
      s,
      o,
      c,
      f,
      m,
      E,
      _
    ), r[n + 1] = Dl(
      i,
      s,
      o,
      c,
      f,
      m,
      E,
      _
    );
  }
};
ze.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var r = this.W, n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], c = this.h[4], f = this.h[5], m = this.h[6], E = this.h[7], _ = this.h[8], S = this.h[9], O = this.h[10], C = this.h[11], F = this.h[12], L = this.h[13], D = this.h[14], P = this.h[15];
  Cl(this.k.length === r.length);
  for (var X = 0; X < r.length; X += 2) {
    var rt = D, $ = P, tt = Ql(_, S), mt = Yl(_, S), v = Gl(_, S, O, C, F), N = Hl(_, S, O, C, F, L), I = this.k[X], T = this.k[X + 1], R = r[X], a = r[X + 1], u = Ul(
      rt,
      $,
      tt,
      mt,
      v,
      N,
      I,
      T,
      R,
      a
    ), l = Ll(
      rt,
      $,
      tt,
      mt,
      v,
      N,
      I,
      T,
      R,
      a
    );
    rt = ql(n, i), $ = jl(n, i), tt = Vl(n, i, s, o, c), mt = zl(n, i, s, o, c, f);
    var d = Xi(rt, $, tt, mt), g = Zi(rt, $, tt, mt);
    D = F, P = L, F = O, L = C, O = _, C = S, _ = Xi(m, E, u, l), S = Zi(E, E, u, l), m = c, E = f, c = s, f = o, s = n, o = i, n = Xi(u, l, d, g), i = Zi(u, l, d, g);
  }
  br(this.h, 0, n, i), br(this.h, 2, s, o), br(this.h, 4, c, f), br(this.h, 6, m, E), br(this.h, 8, _, S), br(this.h, 10, O, C), br(this.h, 12, F, L), br(this.h, 14, D, P);
};
ze.prototype._digest = function(e) {
  return e === "hex" ? ye.toHex32(this.h, "big") : ye.split32(this.h, "big");
};
function Gl(e, t, r, n, i) {
  var s = e & r ^ ~e & i;
  return s < 0 && (s += 4294967296), s;
}
function Hl(e, t, r, n, i, s) {
  var o = t & n ^ ~t & s;
  return o < 0 && (o += 4294967296), o;
}
function Vl(e, t, r, n, i) {
  var s = e & r ^ e & i ^ r & i;
  return s < 0 && (s += 4294967296), s;
}
function zl(e, t, r, n, i, s) {
  var o = t & n ^ t & s ^ n & s;
  return o < 0 && (o += 4294967296), o;
}
function ql(e, t) {
  var r = Xe(e, t, 28), n = Xe(t, e, 2), i = Xe(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function jl(e, t) {
  var r = Ze(e, t, 28), n = Ze(t, e, 2), i = Ze(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Ql(e, t) {
  var r = Xe(e, t, 14), n = Xe(e, t, 18), i = Xe(t, e, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Yl(e, t) {
  var r = Ze(e, t, 14), n = Ze(e, t, 18), i = Ze(t, e, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Jl(e, t) {
  var r = Xe(e, t, 1), n = Xe(e, t, 8), i = Sa(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Kl(e, t) {
  var r = Ze(e, t, 1), n = Ze(e, t, 8), i = Ra(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Wl(e, t) {
  var r = Xe(e, t, 19), n = Xe(t, e, 29), i = Sa(e, t, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Xl(e, t) {
  var r = Ze(e, t, 19), n = Ze(t, e, 29), i = Ra(e, t, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
var ds = ct, Ma = Oa;
function fr() {
  if (!(this instanceof fr))
    return new fr();
  Ma.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
ds.inherits(fr, Ma);
var Zl = fr;
fr.blockSize = 1024;
fr.outSize = 384;
fr.hmacStrength = 192;
fr.padLength = 128;
fr.prototype._digest = function(e) {
  return e === "hex" ? ds.toHex32(this.h.slice(0, 12), "big") : ds.split32(this.h.slice(0, 12), "big");
};
dn.sha1 = Al;
dn.sha224 = kl;
dn.sha256 = _a;
dn.sha384 = Zl;
dn.sha512 = Oa;
var Pa = {}, Kr = ct, $l = fn, qn = Kr.rotl32, ho = Kr.sum32, vn = Kr.sum32_3, lo = Kr.sum32_4, ka = $l.BlockHash;
function er() {
  if (!(this instanceof er))
    return new er();
  ka.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Kr.inherits(er, ka);
Pa.ripemd160 = er;
er.blockSize = 512;
er.outSize = 160;
er.hmacStrength = 192;
er.padLength = 64;
er.prototype._update = function(e, t) {
  for (var r = this.h[0], n = this.h[1], i = this.h[2], s = this.h[3], o = this.h[4], c = r, f = n, m = i, E = s, _ = o, S = 0; S < 80; S++) {
    var O = ho(
      qn(
        lo(r, co(S, n, i, s), e[rc[S] + t], tc(S)),
        ic[S]
      ),
      o
    );
    r = o, o = s, s = qn(i, 10), i = n, n = O, O = ho(
      qn(
        lo(c, co(79 - S, f, m, E), e[nc[S] + t], ec(S)),
        sc[S]
      ),
      _
    ), c = _, _ = E, E = qn(m, 10), m = f, f = O;
  }
  O = vn(this.h[1], i, E), this.h[1] = vn(this.h[2], s, _), this.h[2] = vn(this.h[3], o, c), this.h[3] = vn(this.h[4], r, f), this.h[4] = vn(this.h[0], n, m), this.h[0] = O;
};
er.prototype._digest = function(e) {
  return e === "hex" ? Kr.toHex32(this.h, "little") : Kr.split32(this.h, "little");
};
function co(e, t, r, n) {
  return e <= 15 ? t ^ r ^ n : e <= 31 ? t & r | ~t & n : e <= 47 ? (t | ~r) ^ n : e <= 63 ? t & n | r & ~n : t ^ (r | ~n);
}
function tc(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function ec(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var rc = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], nc = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], ic = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sc = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], oc = ct, ac = Dn;
function ln(e, t, r) {
  if (!(this instanceof ln))
    return new ln(e, t, r);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(oc.toArray(t, r));
}
var uc = ln;
ln.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), ac(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
ln.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
ln.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(e) {
  var t = e;
  t.utils = ct, t.common = fn, t.sha = dn, t.ripemd = Pa, t.hmac = uc, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(pa);
const qe = /* @__PURE__ */ ci(pa);
function fo(e) {
  return "0x" + qe.sha256().update(et(e)).digest("hex");
}
const hc = "web/5.7.1";
var lc = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
function cc(e, t) {
  return lc(this, void 0, void 0, function* () {
    t == null && (t = {});
    const r = {
      method: t.method || "GET",
      headers: t.headers || {},
      body: t.body || void 0
    };
    if (t.skipFetchSetup !== !0 && (r.mode = "cors", r.cache = "no-cache", r.credentials = "same-origin", r.redirect = "follow", r.referrer = "client"), t.fetchOptions != null) {
      const o = t.fetchOptions;
      o.mode && (r.mode = o.mode), o.cache && (r.cache = o.cache), o.credentials && (r.credentials = o.credentials), o.redirect && (r.redirect = o.redirect), o.referrer && (r.referrer = o.referrer);
    }
    const n = yield fetch(e, r), i = yield n.arrayBuffer(), s = {};
    return n.headers.forEach ? n.headers.forEach((o, c) => {
      s[c.toLowerCase()] = o;
    }) : n.headers.keys().forEach((o) => {
      s[o.toLowerCase()] = n.headers.get(o);
    }), {
      headers: s,
      statusCode: n.status,
      statusMessage: n.statusText,
      body: et(new Uint8Array(i))
    };
  });
}
var fc = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const Ge = new M(hc);
function po(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function Nr(e, t) {
  if (e == null)
    return null;
  if (typeof e == "string")
    return e;
  if (fi(e)) {
    if (t && (t.split("/")[0] === "text" || t.split(";")[0].trim() === "application/json"))
      try {
        return Bn(e);
      } catch {
      }
    return K(e);
  }
  return e;
}
function dc(e) {
  return Oe(e.replace(/%([0-9a-f][0-9a-f])/gi, (t, r) => String.fromCharCode(parseInt(r, 16))));
}
function pc(e, t, r) {
  const n = typeof e == "object" && e.throttleLimit != null ? e.throttleLimit : 12;
  Ge.assertArgument(n > 0 && n % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", n);
  const i = typeof e == "object" ? e.throttleCallback : null, s = typeof e == "object" && typeof e.throttleSlotInterval == "number" ? e.throttleSlotInterval : 100;
  Ge.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
  const o = typeof e == "object" ? !!e.errorPassThrough : !1, c = {};
  let f = null;
  const m = {
    method: "GET"
  };
  let E = !1, _ = 2 * 60 * 1e3;
  if (typeof e == "string")
    f = e;
  else if (typeof e == "object") {
    if ((e == null || e.url == null) && Ge.throwArgumentError("missing URL", "connection.url", e), f = e.url, typeof e.timeout == "number" && e.timeout > 0 && (_ = e.timeout), e.headers)
      for (const D in e.headers)
        c[D.toLowerCase()] = { key: D, value: String(e.headers[D]) }, ["if-none-match", "if-modified-since"].indexOf(D.toLowerCase()) >= 0 && (E = !0);
    if (m.allowGzip = !!e.allowGzip, e.user != null && e.password != null) {
      f.substring(0, 6) !== "https:" && e.allowInsecureAuthentication !== !0 && Ge.throwError("basic authentication requires a secure https url", M.errors.INVALID_ARGUMENT, { argument: "url", url: f, user: e.user, password: "[REDACTED]" });
      const D = e.user + ":" + e.password;
      c.authorization = {
        key: "Authorization",
        value: "Basic " + Zo(Oe(D))
      };
    }
    e.skipFetchSetup != null && (m.skipFetchSetup = !!e.skipFetchSetup), e.fetchOptions != null && (m.fetchOptions = se(e.fetchOptions));
  }
  const S = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), O = f ? f.match(S) : null;
  if (O)
    try {
      const D = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": O[1] || "text/plain" },
        body: O[2] ? Xo(O[3]) : dc(O[3])
      };
      let P = D.body;
      return r && (P = r(D.body, D)), Promise.resolve(P);
    } catch (D) {
      Ge.throwError("processing response error", M.errors.SERVER_ERROR, {
        body: Nr(O[1], O[2]),
        error: D,
        requestBody: null,
        requestMethod: "GET",
        url: f
      });
    }
  t && (m.method = "POST", m.body = t, c["content-type"] == null && (c["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), c["content-length"] == null && (c["content-length"] = { key: "Content-Length", value: String(t.length) }));
  const C = {};
  Object.keys(c).forEach((D) => {
    const P = c[D];
    C[P.key] = P.value;
  }), m.headers = C;
  const F = function() {
    let D = null;
    return { promise: new Promise(function(P, X) {
      _ && (D = setTimeout(() => {
        D != null && (D = null, X(Ge.makeError("timeout", M.errors.TIMEOUT, {
          requestBody: Nr(m.body, C["content-type"]),
          requestMethod: m.method,
          timeout: _,
          url: f
        })));
      }, _));
    }), cancel: function() {
      D != null && (clearTimeout(D), D = null);
    } };
  }(), L = function() {
    return fc(this, void 0, void 0, function* () {
      for (let D = 0; D < n; D++) {
        let P = null;
        try {
          if (P = yield cc(f, m), D < n) {
            if (P.statusCode === 301 || P.statusCode === 302) {
              const rt = P.headers.location || "";
              if (m.method === "GET" && rt.match(/^https:/)) {
                f = P.headers.location;
                continue;
              }
            } else if (P.statusCode === 429) {
              let rt = !0;
              if (i && (rt = yield i(D, f)), rt) {
                let $ = 0;
                const tt = P.headers["retry-after"];
                typeof tt == "string" && tt.match(/^[1-9][0-9]*$/) ? $ = parseInt(tt) * 1e3 : $ = s * parseInt(String(Math.random() * Math.pow(2, D))), yield po($);
                continue;
              }
            }
          }
        } catch (rt) {
          P = rt.response, P == null && (F.cancel(), Ge.throwError("missing response", M.errors.SERVER_ERROR, {
            requestBody: Nr(m.body, C["content-type"]),
            requestMethod: m.method,
            serverError: rt,
            url: f
          }));
        }
        let X = P.body;
        if (E && P.statusCode === 304 ? X = null : !o && (P.statusCode < 200 || P.statusCode >= 300) && (F.cancel(), Ge.throwError("bad response", M.errors.SERVER_ERROR, {
          status: P.statusCode,
          headers: P.headers,
          body: Nr(X, P.headers ? P.headers["content-type"] : null),
          requestBody: Nr(m.body, C["content-type"]),
          requestMethod: m.method,
          url: f
        })), r)
          try {
            const rt = yield r(X, P);
            return F.cancel(), rt;
          } catch (rt) {
            if (rt.throttleRetry && D < n) {
              let $ = !0;
              if (i && ($ = yield i(D, f)), $) {
                const tt = s * parseInt(String(Math.random() * Math.pow(2, D)));
                yield po(tt);
                continue;
              }
            }
            F.cancel(), Ge.throwError("processing response error", M.errors.SERVER_ERROR, {
              body: Nr(X, P.headers ? P.headers["content-type"] : null),
              error: rt,
              requestBody: Nr(m.body, C["content-type"]),
              requestMethod: m.method,
              url: f
            });
          }
        return F.cancel(), X;
      }
      return Ge.throwError("failed response", M.errors.SERVER_ERROR, {
        requestBody: Nr(m.body, C["content-type"]),
        requestMethod: m.method,
        url: f
      });
    });
  }();
  return Promise.race([F.promise, L]);
}
function Is(e, t, r) {
  let n = (s, o) => {
    let c = null;
    if (s != null)
      try {
        c = JSON.parse(Bn(s));
      } catch (f) {
        Ge.throwError("invalid JSON", M.errors.SERVER_ERROR, {
          body: s,
          error: f
        });
      }
    return r && (c = r(c, o)), c;
  }, i = null;
  if (t != null) {
    i = Oe(t);
    const s = typeof e == "string" ? { url: e } : se(e);
    s.headers ? Object.keys(s.headers).filter((o) => o.toLowerCase() === "content-type").length !== 0 || (s.headers = se(s.headers), s.headers["content-type"] = "application/json") : s.headers = { "content-type": "application/json" }, e = s;
  }
  return pc(e, i, n);
}
function Nn(e, t) {
  return t || (t = {}), t = se(t), t.floor == null && (t.floor = 0), t.ceiling == null && (t.ceiling = 1e4), t.interval == null && (t.interval = 250), new Promise(function(r, n) {
    let i = null, s = !1;
    const o = () => s ? !1 : (s = !0, i && clearTimeout(i), !0);
    t.timeout && (i = setTimeout(() => {
      o() && n(new Error("timeout"));
    }, t.timeout));
    const c = t.retryLimit;
    let f = 0;
    function m() {
      return e().then(function(E) {
        if (E !== void 0)
          o() && r(E);
        else if (t.oncePoll)
          t.oncePoll.once("poll", m);
        else if (t.onceBlock)
          t.onceBlock.once("block", m);
        else if (!s) {
          if (f++, f > c) {
            o() && n(new Error("retry limit reached"));
            return;
          }
          let _ = t.interval * parseInt(String(Math.random() * Math.pow(2, f)));
          _ < t.floor && (_ = t.floor), _ > t.ceiling && (_ = t.ceiling), setTimeout(m, _);
        }
        return null;
      }, function(E) {
        o() && n(E);
      });
    }
    m();
  });
}
var oi = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ps = {};
for (var jn = 0; jn < oi.length; jn++) {
  var $i = oi.charAt(jn);
  if (ps[$i] !== void 0)
    throw new TypeError($i + " is ambiguous");
  ps[$i] = jn;
}
function an(e) {
  var t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function xa(e) {
  for (var t = 1, r = 0; r < e.length; ++r) {
    var n = e.charCodeAt(r);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    t = an(t) ^ n >> 5;
  }
  for (t = an(t), r = 0; r < e.length; ++r) {
    var i = e.charCodeAt(r);
    t = an(t) ^ i & 31;
  }
  return t;
}
function mc(e, t, r) {
  if (r = r || 90, e.length + 7 + t.length > r)
    throw new TypeError("Exceeds length limit");
  e = e.toLowerCase();
  var n = xa(e);
  if (typeof n == "string")
    throw new Error(n);
  for (var i = e + "1", s = 0; s < t.length; ++s) {
    var o = t[s];
    if (o >> 5)
      throw new Error("Non 5-bit word");
    n = an(n) ^ o, i += oi.charAt(o);
  }
  for (s = 0; s < 6; ++s)
    n = an(n);
  for (n ^= 1, s = 0; s < 6; ++s) {
    var c = n >> (5 - s) * 5 & 31;
    i += oi.charAt(c);
  }
  return i;
}
function Ca(e, t) {
  if (t = t || 90, e.length < 8)
    return e + " too short";
  if (e.length > t)
    return "Exceeds length limit";
  var r = e.toLowerCase(), n = e.toUpperCase();
  if (e !== r && e !== n)
    return "Mixed-case string " + e;
  e = r;
  var i = e.lastIndexOf("1");
  if (i === -1)
    return "No separator character for " + e;
  if (i === 0)
    return "Missing prefix for " + e;
  var s = e.slice(0, i), o = e.slice(i + 1);
  if (o.length < 6)
    return "Data too short";
  var c = xa(s);
  if (typeof c == "string")
    return c;
  for (var f = [], m = 0; m < o.length; ++m) {
    var E = o.charAt(m), _ = ps[E];
    if (_ === void 0)
      return "Unknown character " + E;
    c = an(c) ^ _, !(m + 6 >= o.length) && f.push(_);
  }
  return c !== 1 ? "Invalid checksum for " + e : { prefix: s, words: f };
}
function gc() {
  var e = Ca.apply(null, arguments);
  if (typeof e == "object")
    return e;
}
function yc(e) {
  var t = Ca.apply(null, arguments);
  if (typeof t == "object")
    return t;
  throw new Error(t);
}
function Ei(e, t, r, n) {
  for (var i = 0, s = 0, o = (1 << r) - 1, c = [], f = 0; f < e.length; ++f)
    for (i = i << t | e[f], s += t; s >= r; )
      s -= r, c.push(i >> s & o);
  if (n)
    s > 0 && c.push(i << r - s & o);
  else {
    if (s >= t)
      return "Excess padding";
    if (i << r - s & o)
      return "Non-zero padding";
  }
  return c;
}
function vc(e) {
  var t = Ei(e, 8, 5, !0);
  if (Array.isArray(t))
    return t;
}
function wc(e) {
  var t = Ei(e, 8, 5, !0);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function Ac(e) {
  var t = Ei(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function Ec(e) {
  var t = Ei(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
var bc = {
  decodeUnsafe: gc,
  decode: yc,
  encode: mc,
  toWordsUnsafe: vc,
  toWords: wc,
  fromWordsUnsafe: Ac,
  fromWords: Ec
};
const mo = /* @__PURE__ */ ci(bc), Ss = "providers/5.7.2";
function mn(e, t, r) {
  return r = {
    path: t,
    exports: {},
    require: function(n, i) {
      return Nc(n, i ?? r.path);
    }
  }, e(r, r.exports), r.exports;
}
function Nc() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var Rs = Ba;
function Ba(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
Ba.equal = function(e, t, r) {
  if (e != t)
    throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var Ve = mn(function(e, t) {
  var r = t;
  function n(o, c) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var f = [];
    if (typeof o != "string") {
      for (var m = 0; m < o.length; m++)
        f[m] = o[m] | 0;
      return f;
    }
    if (c === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var m = 0; m < o.length; m += 2)
        f.push(parseInt(o[m] + o[m + 1], 16));
    } else
      for (var m = 0; m < o.length; m++) {
        var E = o.charCodeAt(m), _ = E >> 8, S = E & 255;
        _ ? f.push(_, S) : f.push(S);
      }
    return f;
  }
  r.toArray = n;
  function i(o) {
    return o.length === 1 ? "0" + o : o;
  }
  r.zero2 = i;
  function s(o) {
    for (var c = "", f = 0; f < o.length; f++)
      c += i(o[f].toString(16));
    return c;
  }
  r.toHex = s, r.encode = function(o, c) {
    return c === "hex" ? s(o) : o;
  };
}), be = mn(function(e, t) {
  var r = t;
  r.assert = Rs, r.toArray = Ve.toArray, r.zero2 = Ve.zero2, r.toHex = Ve.toHex, r.encode = Ve.encode;
  function n(f, m, E) {
    var _ = new Array(Math.max(f.bitLength(), E) + 1);
    _.fill(0);
    for (var S = 1 << m + 1, O = f.clone(), C = 0; C < _.length; C++) {
      var F, L = O.andln(S - 1);
      O.isOdd() ? (L > (S >> 1) - 1 ? F = (S >> 1) - L : F = L, O.isubn(F)) : F = 0, _[C] = F, O.iushrn(1);
    }
    return _;
  }
  r.getNAF = n;
  function i(f, m) {
    var E = [
      [],
      []
    ];
    f = f.clone(), m = m.clone();
    for (var _ = 0, S = 0, O; f.cmpn(-_) > 0 || m.cmpn(-S) > 0; ) {
      var C = f.andln(3) + _ & 3, F = m.andln(3) + S & 3;
      C === 3 && (C = -1), F === 3 && (F = -1);
      var L;
      C & 1 ? (O = f.andln(7) + _ & 7, (O === 3 || O === 5) && F === 2 ? L = -C : L = C) : L = 0, E[0].push(L);
      var D;
      F & 1 ? (O = m.andln(7) + S & 7, (O === 3 || O === 5) && C === 2 ? D = -F : D = F) : D = 0, E[1].push(D), 2 * _ === L + 1 && (_ = 1 - _), 2 * S === D + 1 && (S = 1 - S), f.iushrn(1), m.iushrn(1);
    }
    return E;
  }
  r.getJSF = i;
  function s(f, m, E) {
    var _ = "_" + m;
    f.prototype[m] = function() {
      return this[_] !== void 0 ? this[_] : this[_] = E.call(this);
    };
  }
  r.cachedProperty = s;
  function o(f) {
    return typeof f == "string" ? r.toArray(f, "hex") : f;
  }
  r.parseBytes = o;
  function c(f) {
    return new ut(f, "hex", "le");
  }
  r.intFromLE = c;
}), ai = be.getNAF, _c = be.getJSF, ui = be.assert;
function Tr(e, t) {
  this.type = e, this.p = new ut(t.p, 16), this.red = t.prime ? ut.red(t.prime) : ut.mont(this.p), this.zero = new ut(0).toRed(this.red), this.one = new ut(1).toRed(this.red), this.two = new ut(2).toRed(this.red), this.n = t.n && new ut(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var $r = Tr;
Tr.prototype.point = function() {
  throw new Error("Not implemented");
};
Tr.prototype.validate = function() {
  throw new Error("Not implemented");
};
Tr.prototype._fixedNafMul = function(e, t) {
  ui(e.precomputed);
  var r = e._getDoubles(), n = ai(t, 1, this._bitLength), i = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
  i /= 3;
  var s = [], o, c;
  for (o = 0; o < n.length; o += r.step) {
    c = 0;
    for (var f = o + r.step - 1; f >= o; f--)
      c = (c << 1) + n[f];
    s.push(c);
  }
  for (var m = this.jpoint(null, null, null), E = this.jpoint(null, null, null), _ = i; _ > 0; _--) {
    for (o = 0; o < s.length; o++)
      c = s[o], c === _ ? E = E.mixedAdd(r.points[o]) : c === -_ && (E = E.mixedAdd(r.points[o].neg()));
    m = m.add(E);
  }
  return m.toP();
};
Tr.prototype._wnafMul = function(e, t) {
  var r = 4, n = e._getNAFPoints(r);
  r = n.wnd;
  for (var i = n.points, s = ai(t, r, this._bitLength), o = this.jpoint(null, null, null), c = s.length - 1; c >= 0; c--) {
    for (var f = 0; c >= 0 && s[c] === 0; c--)
      f++;
    if (c >= 0 && f++, o = o.dblp(f), c < 0)
      break;
    var m = s[c];
    ui(m !== 0), e.type === "affine" ? m > 0 ? o = o.mixedAdd(i[m - 1 >> 1]) : o = o.mixedAdd(i[-m - 1 >> 1].neg()) : m > 0 ? o = o.add(i[m - 1 >> 1]) : o = o.add(i[-m - 1 >> 1].neg());
  }
  return e.type === "affine" ? o.toP() : o;
};
Tr.prototype._wnafMulAdd = function(e, t, r, n, i) {
  var s = this._wnafT1, o = this._wnafT2, c = this._wnafT3, f = 0, m, E, _;
  for (m = 0; m < n; m++) {
    _ = t[m];
    var S = _._getNAFPoints(e);
    s[m] = S.wnd, o[m] = S.points;
  }
  for (m = n - 1; m >= 1; m -= 2) {
    var O = m - 1, C = m;
    if (s[O] !== 1 || s[C] !== 1) {
      c[O] = ai(r[O], s[O], this._bitLength), c[C] = ai(r[C], s[C], this._bitLength), f = Math.max(c[O].length, f), f = Math.max(c[C].length, f);
      continue;
    }
    var F = [
      t[O],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[C]
      /* 7 */
    ];
    t[O].y.cmp(t[C].y) === 0 ? (F[1] = t[O].add(t[C]), F[2] = t[O].toJ().mixedAdd(t[C].neg())) : t[O].y.cmp(t[C].y.redNeg()) === 0 ? (F[1] = t[O].toJ().mixedAdd(t[C]), F[2] = t[O].add(t[C].neg())) : (F[1] = t[O].toJ().mixedAdd(t[C]), F[2] = t[O].toJ().mixedAdd(t[C].neg()));
    var L = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], D = _c(r[O], r[C]);
    for (f = Math.max(D[0].length, f), c[O] = new Array(f), c[C] = new Array(f), E = 0; E < f; E++) {
      var P = D[0][E] | 0, X = D[1][E] | 0;
      c[O][E] = L[(P + 1) * 3 + (X + 1)], c[C][E] = 0, o[O] = F;
    }
  }
  var rt = this.jpoint(null, null, null), $ = this._wnafT4;
  for (m = f; m >= 0; m--) {
    for (var tt = 0; m >= 0; ) {
      var mt = !0;
      for (E = 0; E < n; E++)
        $[E] = c[E][m] | 0, $[E] !== 0 && (mt = !1);
      if (!mt)
        break;
      tt++, m--;
    }
    if (m >= 0 && tt++, rt = rt.dblp(tt), m < 0)
      break;
    for (E = 0; E < n; E++) {
      var v = $[E];
      v !== 0 && (v > 0 ? _ = o[E][v - 1 >> 1] : v < 0 && (_ = o[E][-v - 1 >> 1].neg()), _.type === "affine" ? rt = rt.mixedAdd(_) : rt = rt.add(_));
    }
  }
  for (m = 0; m < n; m++)
    o[m] = null;
  return i ? rt : rt.toP();
};
function Pe(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
Tr.BasePoint = Pe;
Pe.prototype.eq = function() {
  throw new Error("Not implemented");
};
Pe.prototype.validate = function() {
  return this.curve.validate(this);
};
Tr.prototype.decodePoint = function(e, t) {
  e = be.toArray(e, t);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6 ? ui(e[e.length - 1] % 2 === 0) : e[0] === 7 && ui(e[e.length - 1] % 2 === 1);
    var n = this.point(
      e.slice(1, 1 + r),
      e.slice(1 + r, 1 + 2 * r)
    );
    return n;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r)
    return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error("Unknown point format");
};
Pe.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
Pe.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), r = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", t));
};
Pe.prototype.encode = function(e, t) {
  return be.encode(this._encode(t), e);
};
Pe.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
Pe.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
Pe.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var r = [this], n = this, i = 0; i < t; i += e) {
    for (var s = 0; s < e; s++)
      n = n.dbl();
    r.push(n);
  }
  return {
    step: e,
    points: r
  };
};
Pe.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], r = (1 << e) - 1, n = r === 1 ? null : this.dbl(), i = 1; i < r; i++)
    t[i] = t[i - 1].add(n);
  return {
    wnd: e,
    points: t
  };
};
Pe.prototype._getBeta = function() {
  return null;
};
Pe.prototype.dblp = function(e) {
  for (var t = this, r = 0; r < e; r++)
    t = t.dbl();
  return t;
};
var Ts = mn(function(e) {
  typeof Object.create == "function" ? e.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : e.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
    }
  };
}), Ic = be.assert;
function ke(e) {
  $r.call(this, "short", e), this.a = new ut(e.a, 16).toRed(this.red), this.b = new ut(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Ts(ke, $r);
var Sc = ke;
ke.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, r;
    if (e.beta)
      t = new ut(e.beta, 16).toRed(this.red);
    else {
      var n = this._getEndoRoots(this.p);
      t = n[0].cmp(n[1]) < 0 ? n[0] : n[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      r = new ut(e.lambda, 16);
    else {
      var i = this._getEndoRoots(this.n);
      this.g.mul(i[0]).x.cmp(this.g.x.redMul(t)) === 0 ? r = i[0] : (r = i[1], Ic(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var s;
    return e.basis ? s = e.basis.map(function(o) {
      return {
        a: new ut(o.a, 16),
        b: new ut(o.b, 16)
      };
    }) : s = this._getEndoBasis(r), {
      beta: t,
      lambda: r,
      basis: s
    };
  }
};
ke.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : ut.mont(e), r = new ut(2).toRed(t).redInvm(), n = r.redNeg(), i = new ut(3).toRed(t).redNeg().redSqrt().redMul(r), s = n.redAdd(i).fromRed(), o = n.redSub(i).fromRed();
  return [s, o];
};
ke.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, n = this.n.clone(), i = new ut(1), s = new ut(0), o = new ut(0), c = new ut(1), f, m, E, _, S, O, C, F = 0, L, D; r.cmpn(0) !== 0; ) {
    var P = n.div(r);
    L = n.sub(P.mul(r)), D = o.sub(P.mul(i));
    var X = c.sub(P.mul(s));
    if (!E && L.cmp(t) < 0)
      f = C.neg(), m = i, E = L.neg(), _ = D;
    else if (E && ++F === 2)
      break;
    C = L, n = r, r = L, o = i, i = D, c = s, s = X;
  }
  S = L.neg(), O = D;
  var rt = E.sqr().add(_.sqr()), $ = S.sqr().add(O.sqr());
  return $.cmp(rt) >= 0 && (S = f, O = m), E.negative && (E = E.neg(), _ = _.neg()), S.negative && (S = S.neg(), O = O.neg()), [
    { a: E, b: _ },
    { a: S, b: O }
  ];
};
ke.prototype._endoSplit = function(e) {
  var t = this.endo.basis, r = t[0], n = t[1], i = n.b.mul(e).divRound(this.n), s = r.b.neg().mul(e).divRound(this.n), o = i.mul(r.a), c = s.mul(n.a), f = i.mul(r.b), m = s.mul(n.b), E = e.sub(o).sub(c), _ = f.add(m).neg();
  return { k1: E, k2: _ };
};
ke.prototype.pointFromX = function(e, t) {
  e = new ut(e, 16), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), n = r.redSqrt();
  if (n.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var i = n.fromRed().isOdd();
  return (t && !i || !t && i) && (n = n.redNeg()), this.point(e, n);
};
ke.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, r = e.y, n = this.a.redMul(t), i = t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);
  return r.redSqr().redISub(i).cmpn(0) === 0;
};
ke.prototype._endoWnafMulAdd = function(e, t, r) {
  for (var n = this._endoWnafT1, i = this._endoWnafT2, s = 0; s < e.length; s++) {
    var o = this._endoSplit(t[s]), c = e[s], f = c._getBeta();
    o.k1.negative && (o.k1.ineg(), c = c.neg(!0)), o.k2.negative && (o.k2.ineg(), f = f.neg(!0)), n[s * 2] = c, n[s * 2 + 1] = f, i[s * 2] = o.k1, i[s * 2 + 1] = o.k2;
  }
  for (var m = this._wnafMulAdd(1, n, i, s * 2, r), E = 0; E < s * 2; E++)
    n[E] = null, i[E] = null;
  return m;
};
function ue(e, t, r, n) {
  $r.BasePoint.call(this, e, "affine"), t === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new ut(t, 16), this.y = new ut(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Ts(ue, $r.BasePoint);
ke.prototype.point = function(e, t, r) {
  return new ue(this, e, t, r);
};
ke.prototype.pointFromJSON = function(e, t) {
  return ue.fromJSON(this, e, t);
};
ue.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve, n = function(i) {
        return r.point(i.x.redMul(r.endo.beta), i.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(n)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(n)
        }
      };
    }
    return t;
  }
};
ue.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
ue.fromJSON = function(e, t, r) {
  typeof t == "string" && (t = JSON.parse(t));
  var n = e.point(t[0], t[1], r);
  if (!t[2])
    return n;
  function i(o) {
    return e.point(o[0], o[1], r);
  }
  var s = t[2];
  return n.precomputed = {
    beta: null,
    doubles: s.doubles && {
      step: s.doubles.step,
      points: [n].concat(s.doubles.points.map(i))
    },
    naf: s.naf && {
      wnd: s.naf.wnd,
      points: [n].concat(s.naf.points.map(i))
    }
  }, n;
};
ue.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
ue.prototype.isInfinity = function() {
  return this.inf;
};
ue.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var r = t.redSqr().redISub(this.x).redISub(e.x), n = t.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, n);
};
ue.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, r = this.x.redSqr(), n = e.redInvm(), i = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(n), s = i.redSqr().redISub(this.x.redAdd(this.x)), o = i.redMul(this.x.redSub(s)).redISub(this.y);
  return this.curve.point(s, o);
};
ue.prototype.getX = function() {
  return this.x.fromRed();
};
ue.prototype.getY = function() {
  return this.y.fromRed();
};
ue.prototype.mul = function(e) {
  return e = new ut(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
ue.prototype.mulAdd = function(e, t, r) {
  var n = [this, t], i = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n, i) : this.curve._wnafMulAdd(1, n, i, 2);
};
ue.prototype.jmulAdd = function(e, t, r) {
  var n = [this, t], i = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n, i, !0) : this.curve._wnafMulAdd(1, n, i, 2, !0);
};
ue.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
ue.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed, n = function(i) {
      return i.neg();
    };
    t.precomputed = {
      naf: r.naf && {
        wnd: r.naf.wnd,
        points: r.naf.points.map(n)
      },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(n)
      }
    };
  }
  return t;
};
ue.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function le(e, t, r, n) {
  $r.BasePoint.call(this, e, "jacobian"), t === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ut(0)) : (this.x = new ut(t, 16), this.y = new ut(r, 16), this.z = new ut(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Ts(le, $r.BasePoint);
ke.prototype.jpoint = function(e, t, r) {
  return new le(this, e, t, r);
};
le.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), r = this.x.redMul(t), n = this.y.redMul(t).redMul(e);
  return this.curve.point(r, n);
};
le.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
le.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), r = this.z.redSqr(), n = this.x.redMul(t), i = e.x.redMul(r), s = this.y.redMul(t.redMul(e.z)), o = e.y.redMul(r.redMul(this.z)), c = n.redSub(i), f = s.redSub(o);
  if (c.cmpn(0) === 0)
    return f.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var m = c.redSqr(), E = m.redMul(c), _ = n.redMul(m), S = f.redSqr().redIAdd(E).redISub(_).redISub(_), O = f.redMul(_.redISub(S)).redISub(s.redMul(E)), C = this.z.redMul(e.z).redMul(c);
  return this.curve.jpoint(S, O, C);
};
le.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), r = this.x, n = e.x.redMul(t), i = this.y, s = e.y.redMul(t).redMul(this.z), o = r.redSub(n), c = i.redSub(s);
  if (o.cmpn(0) === 0)
    return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var f = o.redSqr(), m = f.redMul(o), E = r.redMul(f), _ = c.redSqr().redIAdd(m).redISub(E).redISub(E), S = c.redMul(E.redISub(_)).redISub(i.redMul(m)), O = this.z.redMul(o);
  return this.curve.jpoint(_, S, O);
};
le.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (t = 0; t < e; t++)
      r = r.dbl();
    return r;
  }
  var n = this.curve.a, i = this.curve.tinv, s = this.x, o = this.y, c = this.z, f = c.redSqr().redSqr(), m = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var E = s.redSqr(), _ = m.redSqr(), S = _.redSqr(), O = E.redAdd(E).redIAdd(E).redIAdd(n.redMul(f)), C = s.redMul(_), F = O.redSqr().redISub(C.redAdd(C)), L = C.redISub(F), D = O.redMul(L);
    D = D.redIAdd(D).redISub(S);
    var P = m.redMul(c);
    t + 1 < e && (f = f.redMul(S)), s = F, c = P, m = D;
  }
  return this.curve.jpoint(s, m.redMul(i), c);
};
le.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
le.prototype._zeroDbl = function() {
  var e, t, r;
  if (this.zOne) {
    var n = this.x.redSqr(), i = this.y.redSqr(), s = i.redSqr(), o = this.x.redAdd(i).redSqr().redISub(n).redISub(s);
    o = o.redIAdd(o);
    var c = n.redAdd(n).redIAdd(n), f = c.redSqr().redISub(o).redISub(o), m = s.redIAdd(s);
    m = m.redIAdd(m), m = m.redIAdd(m), e = f, t = c.redMul(o.redISub(f)).redISub(m), r = this.y.redAdd(this.y);
  } else {
    var E = this.x.redSqr(), _ = this.y.redSqr(), S = _.redSqr(), O = this.x.redAdd(_).redSqr().redISub(E).redISub(S);
    O = O.redIAdd(O);
    var C = E.redAdd(E).redIAdd(E), F = C.redSqr(), L = S.redIAdd(S);
    L = L.redIAdd(L), L = L.redIAdd(L), e = F.redISub(O).redISub(O), t = C.redMul(O.redISub(e)).redISub(L), r = this.y.redMul(this.z), r = r.redIAdd(r);
  }
  return this.curve.jpoint(e, t, r);
};
le.prototype._threeDbl = function() {
  var e, t, r;
  if (this.zOne) {
    var n = this.x.redSqr(), i = this.y.redSqr(), s = i.redSqr(), o = this.x.redAdd(i).redSqr().redISub(n).redISub(s);
    o = o.redIAdd(o);
    var c = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), f = c.redSqr().redISub(o).redISub(o);
    e = f;
    var m = s.redIAdd(s);
    m = m.redIAdd(m), m = m.redIAdd(m), t = c.redMul(o.redISub(f)).redISub(m), r = this.y.redAdd(this.y);
  } else {
    var E = this.z.redSqr(), _ = this.y.redSqr(), S = this.x.redMul(_), O = this.x.redSub(E).redMul(this.x.redAdd(E));
    O = O.redAdd(O).redIAdd(O);
    var C = S.redIAdd(S);
    C = C.redIAdd(C);
    var F = C.redAdd(C);
    e = O.redSqr().redISub(F), r = this.y.redAdd(this.z).redSqr().redISub(_).redISub(E);
    var L = _.redSqr();
    L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L), t = O.redMul(C.redISub(e)).redISub(L);
  }
  return this.curve.jpoint(e, t, r);
};
le.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, r = this.y, n = this.z, i = n.redSqr().redSqr(), s = t.redSqr(), o = r.redSqr(), c = s.redAdd(s).redIAdd(s).redIAdd(e.redMul(i)), f = t.redAdd(t);
  f = f.redIAdd(f);
  var m = f.redMul(o), E = c.redSqr().redISub(m.redAdd(m)), _ = m.redISub(E), S = o.redSqr();
  S = S.redIAdd(S), S = S.redIAdd(S), S = S.redIAdd(S);
  var O = c.redMul(_).redISub(S), C = r.redAdd(r).redMul(n);
  return this.curve.jpoint(E, O, C);
};
le.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), r = this.z.redSqr(), n = t.redSqr(), i = e.redAdd(e).redIAdd(e), s = i.redSqr(), o = this.x.redAdd(t).redSqr().redISub(e).redISub(n);
  o = o.redIAdd(o), o = o.redAdd(o).redIAdd(o), o = o.redISub(s);
  var c = o.redSqr(), f = n.redIAdd(n);
  f = f.redIAdd(f), f = f.redIAdd(f), f = f.redIAdd(f);
  var m = i.redIAdd(o).redSqr().redISub(s).redISub(c).redISub(f), E = t.redMul(m);
  E = E.redIAdd(E), E = E.redIAdd(E);
  var _ = this.x.redMul(c).redISub(E);
  _ = _.redIAdd(_), _ = _.redIAdd(_);
  var S = this.y.redMul(m.redMul(f.redISub(m)).redISub(o.redMul(c)));
  S = S.redIAdd(S), S = S.redIAdd(S), S = S.redIAdd(S);
  var O = this.z.redAdd(o).redSqr().redISub(r).redISub(c);
  return this.curve.jpoint(_, S, O);
};
le.prototype.mul = function(e, t) {
  return e = new ut(e, t), this.curve._wnafMul(this, e);
};
le.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var n = t.redMul(this.z), i = r.redMul(e.z);
  return this.y.redMul(i).redISub(e.y.redMul(n)).cmpn(0) === 0;
};
le.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var n = e.clone(), i = this.curve.redN.redMul(t); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(i), this.x.cmp(r) === 0)
      return !0;
  }
};
le.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
le.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Xn = mn(function(e, t) {
  var r = t;
  r.base = $r, r.short = Sc, r.mont = /*RicMoo:ethers:require(./mont)*/
  null, r.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Zn = mn(function(e, t) {
  var r = t, n = be.assert;
  function i(c) {
    c.type === "short" ? this.curve = new Xn.short(c) : c.type === "edwards" ? this.curve = new Xn.edwards(c) : this.curve = new Xn.mont(c), this.g = this.curve.g, this.n = this.curve.n, this.hash = c.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r.PresetCurve = i;
  function s(c, f) {
    Object.defineProperty(r, c, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var m = new i(f);
        return Object.defineProperty(r, c, {
          configurable: !0,
          enumerable: !0,
          value: m
        }), m;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: qe.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: qe.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: qe.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: qe.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: qe.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: qe.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: qe.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var o;
  try {
    o = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    o = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: qe.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      o
    ]
  });
});
function Rr(e) {
  if (!(this instanceof Rr))
    return new Rr(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = Ve.toArray(e.entropy, e.entropyEnc || "hex"), r = Ve.toArray(e.nonce, e.nonceEnc || "hex"), n = Ve.toArray(e.pers, e.persEnc || "hex");
  Rs(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, r, n);
}
var Da = Rr;
Rr.prototype._init = function(e, t, r) {
  var n = e.concat(t).concat(r);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++)
    this.K[i] = 0, this.V[i] = 1;
  this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Rr.prototype._hmac = function() {
  return new qe.hmac(this.hash, this.K);
};
Rr.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Rr.prototype.reseed = function(e, t, r, n) {
  typeof t != "string" && (n = r, r = t, t = null), e = Ve.toArray(e, t), r = Ve.toArray(r, n), Rs(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(r || [])), this._reseed = 1;
};
Rr.prototype.generate = function(e, t, r, n) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (n = r, r = t, t = null), r && (r = Ve.toArray(r, n || "hex"), this._update(r));
  for (var i = []; i.length < e; )
    this.V = this._hmac().update(this.V).digest(), i = i.concat(this.V);
  var s = i.slice(0, e);
  return this._update(r), this._reseed++, Ve.encode(s, t);
};
var ms = be.assert;
function fe(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var Os = fe;
fe.fromPublic = function(e, t, r) {
  return t instanceof fe ? t : new fe(e, {
    pub: t,
    pubEnc: r
  });
};
fe.fromPrivate = function(e, t, r) {
  return t instanceof fe ? t : new fe(e, {
    priv: t,
    privEnc: r
  });
};
fe.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
fe.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
fe.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
fe.prototype._importPrivate = function(e, t) {
  this.priv = new ut(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
fe.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? ms(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ms(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
fe.prototype.derive = function(e) {
  return e.validate() || ms(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
fe.prototype.sign = function(e, t, r) {
  return this.ec.sign(e, this, t, r);
};
fe.prototype.verify = function(e, t) {
  return this.ec.verify(e, t, this);
};
fe.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var Rc = be.assert;
function bi(e, t) {
  if (e instanceof bi)
    return e;
  this._importDER(e, t) || (Rc(e.r && e.s, "Signature without r or s"), this.r = new ut(e.r, 16), this.s = new ut(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var Ni = bi;
function Tc() {
  this.place = 0;
}
function ts(e, t) {
  var r = e[t.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4)
    return !1;
  for (var i = 0, s = 0, o = t.place; s < n; s++, o++)
    i <<= 8, i |= e[o], i >>>= 0;
  return i <= 127 ? !1 : (t.place = o, i);
}
function go(e) {
  for (var t = 0, r = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < r; )
    t++;
  return t === 0 ? e : e.slice(t);
}
bi.prototype._importDER = function(e, t) {
  e = be.toArray(e, t);
  var r = new Tc();
  if (e[r.place++] !== 48)
    return !1;
  var n = ts(e, r);
  if (n === !1 || n + r.place !== e.length || e[r.place++] !== 2)
    return !1;
  var i = ts(e, r);
  if (i === !1)
    return !1;
  var s = e.slice(r.place, i + r.place);
  if (r.place += i, e[r.place++] !== 2)
    return !1;
  var o = ts(e, r);
  if (o === !1 || e.length !== o + r.place)
    return !1;
  var c = e.slice(r.place, o + r.place);
  if (s[0] === 0)
    if (s[1] & 128)
      s = s.slice(1);
    else
      return !1;
  if (c[0] === 0)
    if (c[1] & 128)
      c = c.slice(1);
    else
      return !1;
  return this.r = new ut(s), this.s = new ut(c), this.recoveryParam = null, !0;
};
function es(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var r = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(r | 128); --r; )
    e.push(t >>> (r << 3) & 255);
  e.push(t);
}
bi.prototype.toDER = function(e) {
  var t = this.r.toArray(), r = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), r[0] & 128 && (r = [0].concat(r)), t = go(t), r = go(r); !r[0] && !(r[1] & 128); )
    r = r.slice(1);
  var n = [2];
  es(n, t.length), n = n.concat(t), n.push(2), es(n, r.length);
  var i = n.concat(r), s = [48];
  return es(s, i.length), s = s.concat(i), be.encode(s, e);
};
var Oc = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), Ua = be.assert;
function Me(e) {
  if (!(this instanceof Me))
    return new Me(e);
  typeof e == "string" && (Ua(
    Object.prototype.hasOwnProperty.call(Zn, e),
    "Unknown curve " + e
  ), e = Zn[e]), e instanceof Zn.PresetCurve && (e = { curve: e }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash;
}
var Mc = Me;
Me.prototype.keyPair = function(e) {
  return new Os(this, e);
};
Me.prototype.keyFromPrivate = function(e, t) {
  return Os.fromPrivate(this, e, t);
};
Me.prototype.keyFromPublic = function(e, t) {
  return Os.fromPublic(this, e, t);
};
Me.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var t = new Da({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || Oc(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), r = this.n.byteLength(), n = this.n.sub(new ut(2)); ; ) {
    var i = new ut(t.generate(r));
    if (!(i.cmp(n) > 0))
      return i.iaddn(1), this.keyFromPrivate(i);
  }
};
Me.prototype._truncateToN = function(e, t) {
  var r = e.byteLength() * 8 - this.n.bitLength();
  return r > 0 && (e = e.ushrn(r)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
Me.prototype.sign = function(e, t, r, n) {
  typeof r == "object" && (n = r, r = null), n || (n = {}), t = this.keyFromPrivate(t, r), e = this._truncateToN(new ut(e, 16));
  for (var i = this.n.byteLength(), s = t.getPrivate().toArray("be", i), o = e.toArray("be", i), c = new Da({
    hash: this.hash,
    entropy: s,
    nonce: o,
    pers: n.pers,
    persEnc: n.persEnc || "utf8"
  }), f = this.n.sub(new ut(1)), m = 0; ; m++) {
    var E = n.k ? n.k(m) : new ut(c.generate(this.n.byteLength()));
    if (E = this._truncateToN(E, !0), !(E.cmpn(1) <= 0 || E.cmp(f) >= 0)) {
      var _ = this.g.mul(E);
      if (!_.isInfinity()) {
        var S = _.getX(), O = S.umod(this.n);
        if (O.cmpn(0) !== 0) {
          var C = E.invm(this.n).mul(O.mul(t.getPrivate()).iadd(e));
          if (C = C.umod(this.n), C.cmpn(0) !== 0) {
            var F = (_.getY().isOdd() ? 1 : 0) | (S.cmp(O) !== 0 ? 2 : 0);
            return n.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), F ^= 1), new Ni({ r: O, s: C, recoveryParam: F });
          }
        }
      }
    }
  }
};
Me.prototype.verify = function(e, t, r, n) {
  e = this._truncateToN(new ut(e, 16)), r = this.keyFromPublic(r, n), t = new Ni(t, "hex");
  var i = t.r, s = t.s;
  if (i.cmpn(1) < 0 || i.cmp(this.n) >= 0 || s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return !1;
  var o = s.invm(this.n), c = o.mul(e).umod(this.n), f = o.mul(i).umod(this.n), m;
  return this.curve._maxwellTrick ? (m = this.g.jmulAdd(c, r.getPublic(), f), m.isInfinity() ? !1 : m.eqXToP(i)) : (m = this.g.mulAdd(c, r.getPublic(), f), m.isInfinity() ? !1 : m.getX().umod(this.n).cmp(i) === 0);
};
Me.prototype.recoverPubKey = function(e, t, r, n) {
  Ua((3 & r) === r, "The recovery param is more than two bits"), t = new Ni(t, n);
  var i = this.n, s = new ut(e), o = t.r, c = t.s, f = r & 1, m = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && m)
    throw new Error("Unable to find sencond key candinate");
  m ? o = this.curve.pointFromX(o.add(this.curve.n), f) : o = this.curve.pointFromX(o, f);
  var E = t.r.invm(i), _ = i.sub(s).mul(E).umod(i), S = c.mul(E).umod(i);
  return this.g.mulAdd(_, o, S);
};
Me.prototype.getKeyRecoveryParam = function(e, t, r, n) {
  if (t = new Ni(t, n), t.recoveryParam !== null)
    return t.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(e, t, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Pc = mn(function(e, t) {
  var r = t;
  r.version = "6.5.4", r.utils = be, r.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, r.curve = Xn, r.curves = Zn, r.ec = Mc, r.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), kc = Pc.ec;
const xc = "signing-key/5.7.0", gs = new M(xc);
let rs = null;
function Qe() {
  return rs || (rs = new kc("secp256k1")), rs;
}
class Cc {
  constructor(t) {
    U(this, "curve", "secp256k1"), U(this, "privateKey", K(t)), Ir(this.privateKey) !== 32 && gs.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const r = Qe().keyFromPrivate(et(this.privateKey));
    U(this, "publicKey", "0x" + r.getPublic(!1, "hex")), U(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), U(this, "_isSigningKey", !0);
  }
  _addPoint(t) {
    const r = Qe().keyFromPublic(et(this.publicKey)), n = Qe().keyFromPublic(et(t));
    return "0x" + r.pub.add(n.pub).encodeCompressed("hex");
  }
  signDigest(t) {
    const r = Qe().keyFromPrivate(et(this.privateKey)), n = et(t);
    n.length !== 32 && gs.throwArgumentError("bad digest length", "digest", t);
    const i = r.sign(n, { canonical: !0 });
    return xn({
      recoveryParam: i.recoveryParam,
      r: Xt("0x" + i.r.toString(16), 32),
      s: Xt("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(t) {
    const r = Qe().keyFromPrivate(et(this.privateKey)), n = Qe().keyFromPublic(et(La(t)));
    return Xt("0x" + r.derive(n.getPublic()).toString(16), 32);
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey);
  }
}
function Bc(e, t) {
  const r = xn(t), n = { r: et(r.r), s: et(r.s) };
  return "0x" + Qe().recoverPubKey(et(e), n, r.recoveryParam).encode("hex", !1);
}
function La(e, t) {
  const r = et(e);
  if (r.length === 32) {
    const n = new Cc(r);
    return t ? "0x" + Qe().keyFromPrivate(r).getPublic(!0, "hex") : n.publicKey;
  } else {
    if (r.length === 33)
      return t ? K(r) : "0x" + Qe().keyFromPublic(r).getPublic(!1, "hex");
    if (r.length === 65)
      return t ? "0x" + Qe().keyFromPublic(r).getPublic(!0, "hex") : K(r);
  }
  return gs.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const Dc = "transactions/5.7.0", dr = new M(Dc);
var yo;
(function(e) {
  e[e.legacy = 0] = "legacy", e[e.eip2930 = 1] = "eip2930", e[e.eip1559 = 2] = "eip1559";
})(yo || (yo = {}));
function Ms(e) {
  return e === "0x" ? null : ne(e);
}
function ce(e) {
  return e === "0x" ? ta : V.from(e);
}
function Uc(e) {
  const t = La(e);
  return ne(he(ie(he(t, 1)), 12));
}
function Fa(e, t) {
  return Uc(Bc(et(e), t));
}
function Ae(e, t) {
  const r = Yr(V.from(e).toHexString());
  return r.length > 32 && dr.throwArgumentError("invalid length for " + t, "transaction:" + t, e), r;
}
function ns(e, t) {
  return {
    address: ne(e),
    storageKeys: (t || []).map((r, n) => (Ir(r) !== 32 && dr.throwArgumentError("invalid access list storageKey", `accessList[${e}:${n}]`, r), r.toLowerCase()))
  };
}
function gn(e) {
  if (Array.isArray(e))
    return e.map((r, n) => Array.isArray(r) ? (r.length > 2 && dr.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${n}]`, r), ns(r[0], r[1])) : ns(r.address, r.storageKeys));
  const t = Object.keys(e).map((r) => {
    const n = e[r].reduce((i, s) => (i[s] = !0, i), {});
    return ns(r, Object.keys(n).sort());
  });
  return t.sort((r, n) => r.address.localeCompare(n.address)), t;
}
function Ga(e) {
  return gn(e).map((t) => [t.address, t.storageKeys]);
}
function Lc(e, t) {
  if (e.gasPrice != null) {
    const n = V.from(e.gasPrice), i = V.from(e.maxFeePerGas || 0);
    n.eq(i) || dr.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: n,
      maxFeePerGas: i
    });
  }
  const r = [
    Ae(e.chainId || 0, "chainId"),
    Ae(e.nonce || 0, "nonce"),
    Ae(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Ae(e.maxFeePerGas || 0, "maxFeePerGas"),
    Ae(e.gasLimit || 0, "gasLimit"),
    e.to != null ? ne(e.to) : "0x",
    Ae(e.value || 0, "value"),
    e.data || "0x",
    Ga(e.accessList || [])
  ];
  if (t) {
    const n = xn(t);
    r.push(Ae(n.recoveryParam, "recoveryParam")), r.push(Yr(n.r)), r.push(Yr(n.s));
  }
  return de(["0x02", yi(r)]);
}
function Fc(e, t) {
  const r = [
    Ae(e.chainId || 0, "chainId"),
    Ae(e.nonce || 0, "nonce"),
    Ae(e.gasPrice || 0, "gasPrice"),
    Ae(e.gasLimit || 0, "gasLimit"),
    e.to != null ? ne(e.to) : "0x",
    Ae(e.value || 0, "value"),
    e.data || "0x",
    Ga(e.accessList || [])
  ];
  if (t) {
    const n = xn(t);
    r.push(Ae(n.recoveryParam, "recoveryParam")), r.push(Yr(n.r)), r.push(Yr(n.s));
  }
  return de(["0x01", yi(r)]);
}
function Ha(e, t, r) {
  try {
    const n = ce(t[0]).toNumber();
    if (n !== 0 && n !== 1)
      throw new Error("bad recid");
    e.v = n;
  } catch {
    dr.throwArgumentError("invalid v for transaction type: 1", "v", t[0]);
  }
  e.r = Xt(t[1], 32), e.s = Xt(t[2], 32);
  try {
    const n = ie(r(e));
    e.from = Fa(n, { r: e.r, s: e.s, recoveryParam: e.v });
  } catch {
  }
}
function Gc(e) {
  const t = Ns(e.slice(1));
  t.length !== 9 && t.length !== 12 && dr.throwArgumentError("invalid component count for transaction type: 2", "payload", K(e));
  const r = ce(t[2]), n = ce(t[3]), i = {
    type: 2,
    chainId: ce(t[0]).toNumber(),
    nonce: ce(t[1]).toNumber(),
    maxPriorityFeePerGas: r,
    maxFeePerGas: n,
    gasPrice: null,
    gasLimit: ce(t[4]),
    to: Ms(t[5]),
    value: ce(t[6]),
    data: t[7],
    accessList: gn(t[8])
  };
  return t.length === 9 || (i.hash = ie(e), Ha(i, t.slice(9), Lc)), i;
}
function Hc(e) {
  const t = Ns(e.slice(1));
  t.length !== 8 && t.length !== 11 && dr.throwArgumentError("invalid component count for transaction type: 1", "payload", K(e));
  const r = {
    type: 1,
    chainId: ce(t[0]).toNumber(),
    nonce: ce(t[1]).toNumber(),
    gasPrice: ce(t[2]),
    gasLimit: ce(t[3]),
    to: Ms(t[4]),
    value: ce(t[5]),
    data: t[6],
    accessList: gn(t[7])
  };
  return t.length === 8 || (r.hash = ie(e), Ha(r, t.slice(8), Fc)), r;
}
function Vc(e) {
  const t = Ns(e);
  t.length !== 9 && t.length !== 6 && dr.throwArgumentError("invalid raw transaction", "rawTransaction", e);
  const r = {
    nonce: ce(t[0]).toNumber(),
    gasPrice: ce(t[1]),
    gasLimit: ce(t[2]),
    to: Ms(t[3]),
    value: ce(t[4]),
    data: t[5],
    chainId: 0
  };
  if (t.length === 6)
    return r;
  try {
    r.v = V.from(t[6]).toNumber();
  } catch {
    return r;
  }
  if (r.r = Xt(t[7], 32), r.s = Xt(t[8], 32), V.from(r.r).isZero() && V.from(r.s).isZero())
    r.chainId = r.v, r.v = 0;
  else {
    r.chainId = Math.floor((r.v - 35) / 2), r.chainId < 0 && (r.chainId = 0);
    let n = r.v - 27;
    const i = t.slice(0, 6);
    r.chainId !== 0 && (i.push(K(r.chainId)), i.push("0x"), i.push("0x"), n -= r.chainId * 2 + 8);
    const s = ie(yi(i));
    try {
      r.from = Fa(s, { r: K(r.r), s: K(r.s), recoveryParam: n });
    } catch {
    }
    r.hash = ie(e);
  }
  return r.type = null, r;
}
function zc(e) {
  const t = et(e);
  if (t[0] > 127)
    return Vc(t);
  switch (t[0]) {
    case 1:
      return Hc(t);
    case 2:
      return Gc(t);
  }
  return dr.throwError(`unsupported transaction type: ${t[0]}`, M.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: t[0]
  });
}
const wn = new M(Ss);
class Y {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const t = {}, r = this.address.bind(this), n = this.bigNumber.bind(this), i = this.blockTag.bind(this), s = this.data.bind(this), o = this.hash.bind(this), c = this.hex.bind(this), f = this.number.bind(this), m = this.type.bind(this), E = (_) => this.data(_, !0);
    return t.transaction = {
      hash: o,
      type: m,
      accessList: Y.allowNull(this.accessList.bind(this), null),
      blockHash: Y.allowNull(o, null),
      blockNumber: Y.allowNull(f, null),
      transactionIndex: Y.allowNull(f, null),
      confirmations: Y.allowNull(f, null),
      from: r,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Y.allowNull(n),
      maxPriorityFeePerGas: Y.allowNull(n),
      maxFeePerGas: Y.allowNull(n),
      gasLimit: n,
      to: Y.allowNull(r, null),
      value: n,
      nonce: f,
      data: s,
      r: Y.allowNull(this.uint256),
      s: Y.allowNull(this.uint256),
      v: Y.allowNull(f),
      creates: Y.allowNull(r, null),
      raw: Y.allowNull(s)
    }, t.transactionRequest = {
      from: Y.allowNull(r),
      nonce: Y.allowNull(f),
      gasLimit: Y.allowNull(n),
      gasPrice: Y.allowNull(n),
      maxPriorityFeePerGas: Y.allowNull(n),
      maxFeePerGas: Y.allowNull(n),
      to: Y.allowNull(r),
      value: Y.allowNull(n),
      data: Y.allowNull(E),
      type: Y.allowNull(f),
      accessList: Y.allowNull(this.accessList.bind(this), null)
    }, t.receiptLog = {
      transactionIndex: f,
      blockNumber: f,
      transactionHash: o,
      address: r,
      topics: Y.arrayOf(o),
      data: s,
      logIndex: f,
      blockHash: o
    }, t.receipt = {
      to: Y.allowNull(this.address, null),
      from: Y.allowNull(this.address, null),
      contractAddress: Y.allowNull(r, null),
      transactionIndex: f,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Y.allowNull(c),
      gasUsed: n,
      logsBloom: Y.allowNull(s),
      blockHash: o,
      transactionHash: o,
      logs: Y.arrayOf(this.receiptLog.bind(this)),
      blockNumber: f,
      confirmations: Y.allowNull(f, null),
      cumulativeGasUsed: n,
      effectiveGasPrice: Y.allowNull(n),
      status: Y.allowNull(f),
      type: m
    }, t.block = {
      hash: Y.allowNull(o),
      parentHash: o,
      number: f,
      timestamp: f,
      nonce: Y.allowNull(c),
      difficulty: this.difficulty.bind(this),
      gasLimit: n,
      gasUsed: n,
      miner: Y.allowNull(r),
      extraData: s,
      transactions: Y.allowNull(Y.arrayOf(o)),
      baseFeePerGas: Y.allowNull(n)
    }, t.blockWithTransactions = se(t.block), t.blockWithTransactions.transactions = Y.allowNull(Y.arrayOf(this.transactionResponse.bind(this))), t.filter = {
      fromBlock: Y.allowNull(i, void 0),
      toBlock: Y.allowNull(i, void 0),
      blockHash: Y.allowNull(o, void 0),
      address: Y.allowNull(r, void 0),
      topics: Y.allowNull(this.topics.bind(this), void 0)
    }, t.filterLog = {
      blockNumber: Y.allowNull(f),
      blockHash: Y.allowNull(o),
      transactionIndex: f,
      removed: Y.allowNull(this.boolean.bind(this)),
      address: r,
      data: Y.allowFalsish(s, "0x"),
      topics: Y.arrayOf(o),
      transactionHash: o,
      logIndex: f
    }, t;
  }
  accessList(t) {
    return gn(t || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(t) {
    return t === "0x" ? 0 : V.from(t).toNumber();
  }
  type(t) {
    return t === "0x" || t == null ? 0 : V.from(t).toNumber();
  }
  // Strict! Used on input.
  bigNumber(t) {
    return V.from(t);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "string") {
      if (t = t.toLowerCase(), t === "true")
        return !0;
      if (t === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + t);
  }
  hex(t, r) {
    return typeof t == "string" && (!r && t.substring(0, 2) !== "0x" && (t = "0x" + t), pt(t)) ? t.toLowerCase() : wn.throwArgumentError("invalid hash", "value", t);
  }
  data(t, r) {
    const n = this.hex(t, r);
    if (n.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + t);
    return n;
  }
  // Requires an address
  // Strict! Used on input.
  address(t) {
    return ne(t);
  }
  callAddress(t) {
    if (!pt(t, 32))
      return null;
    const r = ne(he(t, 12));
    return r === Yu ? null : r;
  }
  contractAddress(t) {
    return Ko(t);
  }
  // Strict! Used on input.
  blockTag(t) {
    if (t == null)
      return "latest";
    if (t === "earliest")
      return "0x0";
    switch (t) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return t;
    }
    if (typeof t == "number" || pt(t))
      return di(t);
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(t, r) {
    const n = this.hex(t, r);
    return Ir(n) !== 32 ? wn.throwArgumentError("invalid hash", "value", t) : n;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(t) {
    if (t == null)
      return null;
    const r = V.from(t);
    try {
      return r.toNumber();
    } catch {
    }
    return null;
  }
  uint256(t) {
    if (!pt(t))
      throw new Error("invalid uint256");
    return Xt(t, 32);
  }
  _block(t, r) {
    t.author != null && t.miner == null && (t.miner = t.author);
    const n = t._difficulty != null ? t._difficulty : t.difficulty, i = Y.check(r, t);
    return i._difficulty = n == null ? null : V.from(n), i;
  }
  block(t) {
    return this._block(t, this.formats.block);
  }
  blockWithTransactions(t) {
    return this._block(t, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(t) {
    return Y.check(this.formats.transactionRequest, t);
  }
  transactionResponse(t) {
    t.gas != null && t.gasLimit == null && (t.gasLimit = t.gas), t.to && V.from(t.to).isZero() && (t.to = "0x0000000000000000000000000000000000000000"), t.input != null && t.data == null && (t.data = t.input), t.to == null && t.creates == null && (t.creates = this.contractAddress(t)), (t.type === 1 || t.type === 2) && t.accessList == null && (t.accessList = []);
    const r = Y.check(this.formats.transaction, t);
    if (t.chainId != null) {
      let n = t.chainId;
      pt(n) && (n = V.from(n).toNumber()), r.chainId = n;
    } else {
      let n = t.networkId;
      n == null && r.v == null && (n = t.chainId), pt(n) && (n = V.from(n).toNumber()), typeof n != "number" && r.v != null && (n = (r.v - 35) / 2, n < 0 && (n = 0), n = parseInt(n)), typeof n != "number" && (n = 0), r.chainId = n;
    }
    return r.blockHash && r.blockHash.replace(/0/g, "") === "x" && (r.blockHash = null), r;
  }
  transaction(t) {
    return zc(t);
  }
  receiptLog(t) {
    return Y.check(this.formats.receiptLog, t);
  }
  receipt(t) {
    const r = Y.check(this.formats.receipt, t);
    if (r.root != null)
      if (r.root.length <= 4) {
        const n = V.from(r.root).toNumber();
        n === 0 || n === 1 ? (r.status != null && r.status !== n && wn.throwArgumentError("alt-root-status/status mismatch", "value", { root: r.root, status: r.status }), r.status = n, delete r.root) : wn.throwArgumentError("invalid alt-root-status", "value.root", r.root);
      } else
        r.root.length !== 66 && wn.throwArgumentError("invalid root hash", "value.root", r.root);
    return r.status != null && (r.byzantium = !0), r;
  }
  topics(t) {
    return Array.isArray(t) ? t.map((r) => this.topics(r)) : t != null ? this.hash(t, !0) : null;
  }
  filter(t) {
    return Y.check(this.formats.filter, t);
  }
  filterLog(t) {
    return Y.check(this.formats.filterLog, t);
  }
  static check(t, r) {
    const n = {};
    for (const i in t)
      try {
        const s = t[i](r[i]);
        s !== void 0 && (n[i] = s);
      } catch (s) {
        throw s.checkKey = i, s.checkValue = r[i], s;
      }
    return n;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(t, r) {
    return function(n) {
      return n == null ? r : t(n);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(t, r) {
    return function(n) {
      return n ? t(n) : r;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(t) {
    return function(r) {
      if (!Array.isArray(r))
        throw new Error("not an array");
      const n = [];
      return r.forEach(function(i) {
        n.push(t(i));
      }), n;
    };
  }
}
var ot = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const ht = new M(Ss), qc = 10;
function vo(e) {
  return e == null ? "null" : (Ir(e) !== 32 && ht.throwArgumentError("invalid topic", "topic", e), e.toLowerCase());
}
function wo(e) {
  for (e = e.slice(); e.length > 0 && e[e.length - 1] == null; )
    e.pop();
  return e.map((t) => {
    if (Array.isArray(t)) {
      const r = {};
      t.forEach((i) => {
        r[vo(i)] = !0;
      });
      const n = Object.keys(r);
      return n.sort(), n.join("|");
    } else
      return vo(t);
  }).join("&");
}
function jc(e) {
  return e === "" ? [] : e.split(/&/g).map((t) => {
    if (t === "")
      return [];
    const r = t.split("|").map((n) => n === "null" ? null : n);
    return r.length === 1 ? r[0] : r;
  });
}
function tn(e) {
  if (typeof e == "string") {
    if (e = e.toLowerCase(), Ir(e) === 32)
      return "tx:" + e;
    if (e.indexOf(":") === -1)
      return e;
  } else {
    if (Array.isArray(e))
      return "filter:*:" + wo(e);
    if (zu.isForkEvent(e))
      throw ht.warn("not implemented"), new Error("not implemented");
    if (e && typeof e == "object")
      return "filter:" + (e.address || "*") + ":" + wo(e.topics || []);
  }
  throw new Error("invalid event - " + e);
}
function An() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function Ao(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
const Qc = ["block", "network", "pending", "poll"];
class Yc {
  constructor(t, r, n) {
    U(this, "tag", t), U(this, "listener", r), U(this, "once", n), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const t = this.tag.split(":");
    return t[0] !== "tx" ? null : t[1];
  }
  get filter() {
    const t = this.tag.split(":");
    if (t[0] !== "filter")
      return null;
    const r = t[1], n = jc(t[2]), i = {};
    return n.length > 0 && (i.topics = n), r && r !== "*" && (i.address = r), i;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || Qc.indexOf(this.tag) >= 0;
  }
}
const Jc = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function is(e) {
  return Xt(V.from(e).toHexString(), 32);
}
function Eo(e) {
  return ls.encode(ge([e, he(fo(fo(e)), 0, 4)]));
}
const Va = new RegExp("^(ipfs)://(.*)$", "i"), bo = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  Va,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function $n(e, t) {
  try {
    return Bn(Rn(e, t));
  } catch {
  }
  return null;
}
function Rn(e, t) {
  if (e === "0x")
    return null;
  const r = V.from(he(e, t, t + 32)).toNumber(), n = V.from(he(e, r, r + 32)).toNumber();
  return he(e, r + 32, r + 32 + n);
}
function ss(e) {
  return e.match(/^ipfs:\/\/ipfs\//i) ? e = e.substring(12) : e.match(/^ipfs:\/\//i) ? e = e.substring(7) : ht.throwArgumentError("unsupported IPFS format", "link", e), `https://gateway.ipfs.io/ipfs/${e}`;
}
function No(e) {
  const t = et(e);
  if (t.length > 32)
    throw new Error("internal; should not happen");
  const r = new Uint8Array(32);
  return r.set(t, 32 - t.length), r;
}
function Kc(e) {
  if (e.length % 32 === 0)
    return e;
  const t = new Uint8Array(Math.ceil(e.length / 32) * 32);
  return t.set(e), t;
}
function za(e) {
  const t = [];
  let r = 0;
  for (let n = 0; n < e.length; n++)
    t.push(null), r += 32;
  for (let n = 0; n < e.length; n++) {
    const i = et(e[n]);
    t[n] = No(r), t.push(No(i.length)), t.push(Kc(i)), r += 32 + Math.ceil(i.length / 32) * 32;
  }
  return de(t);
}
class _o {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(t, r, n, i) {
    U(this, "provider", t), U(this, "name", n), U(this, "address", t.formatter.address(r)), U(this, "_resolvedAddress", i);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((t) => V.from(t).eq(1)).catch((t) => {
      if (t.code === M.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, t;
    })), this._supportsEip2544;
  }
  _fetch(t, r) {
    return ot(this, void 0, void 0, function* () {
      const n = {
        to: this.address,
        ccipReadEnabled: !0,
        data: de([t, Wn(this.name), r || "0x"])
      };
      let i = !1;
      (yield this.supportsWildcard()) && (i = !0, n.data = de(["0x9061b923", za([Th(this.name), n.data])]));
      try {
        let s = yield this.provider.call(n);
        return et(s).length % 32 === 4 && ht.throwError("resolver threw error", M.errors.CALL_EXCEPTION, {
          transaction: n,
          data: s
        }), i && (s = Rn(s, 0)), s;
      } catch (s) {
        if (s.code === M.errors.CALL_EXCEPTION)
          return null;
        throw s;
      }
    });
  }
  _fetchBytes(t, r) {
    return ot(this, void 0, void 0, function* () {
      const n = yield this._fetch(t, r);
      return n != null ? Rn(n, 0) : null;
    });
  }
  _getAddress(t, r) {
    const n = Jc[String(t)];
    if (n == null && ht.throwError(`unsupported coin type: ${t}`, M.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${t})`
    }), n.ilk === "eth")
      return this.provider.formatter.address(r);
    const i = et(r);
    if (n.p2pkh != null) {
      const s = r.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const o = parseInt(s[1], 16);
        if (s[2].length === o * 2 && o >= 1 && o <= 75)
          return Eo(ge([[n.p2pkh], "0x" + s[2]]));
      }
    }
    if (n.p2sh != null) {
      const s = r.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const o = parseInt(s[1], 16);
        if (s[2].length === o * 2 && o >= 1 && o <= 75)
          return Eo(ge([[n.p2sh], "0x" + s[2]]));
      }
    }
    if (n.prefix != null) {
      const s = i[1];
      let o = i[0];
      if (o === 0 ? s !== 20 && s !== 32 && (o = -1) : o = -1, o >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
        const c = mo.toWords(i.slice(2));
        return c.unshift(o), mo.encode(n.prefix, c);
      }
    }
    return null;
  }
  getAddress(t) {
    return ot(this, void 0, void 0, function* () {
      if (t == null && (t = 60), t === 60)
        try {
          const i = yield this._fetch("0x3b3b57de");
          return i === "0x" || i === Zu ? null : this.provider.formatter.callAddress(i);
        } catch (i) {
          if (i.code === M.errors.CALL_EXCEPTION)
            return null;
          throw i;
        }
      const r = yield this._fetchBytes("0xf1cb7e06", is(t));
      if (r == null || r === "0x")
        return null;
      const n = this._getAddress(t, r);
      return n == null && ht.throwError("invalid or unsupported coin data", M.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${t})`,
        coinType: t,
        data: r
      }), n;
    });
  }
  getAvatar() {
    return ot(this, void 0, void 0, function* () {
      const t = [{ type: "name", content: this.name }];
      try {
        const r = yield this.getText("avatar");
        if (r == null)
          return null;
        for (let n = 0; n < bo.length; n++) {
          const i = r.match(bo[n]);
          if (i == null)
            continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case "https":
              return t.push({ type: "url", content: r }), { linkage: t, url: r };
            case "data":
              return t.push({ type: "data", content: r }), { linkage: t, url: r };
            case "ipfs":
              return t.push({ type: "ipfs", content: r }), { linkage: t, url: ss(r) };
            case "erc721":
            case "erc1155": {
              const o = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              t.push({ type: s, content: r });
              const c = this._resolvedAddress || (yield this.getAddress()), f = (i[2] || "").split("/");
              if (f.length !== 2)
                return null;
              const m = yield this.provider.formatter.address(f[0]), E = Xt(V.from(f[1]).toHexString(), 32);
              if (s === "erc721") {
                const F = this.provider.formatter.callAddress(yield this.provider.call({
                  to: m,
                  data: de(["0x6352211e", E])
                }));
                if (c !== F)
                  return null;
                t.push({ type: "owner", content: F });
              } else if (s === "erc1155") {
                const F = V.from(yield this.provider.call({
                  to: m,
                  data: de(["0x00fdd58e", Xt(c, 32), E])
                }));
                if (F.isZero())
                  return null;
                t.push({ type: "balance", content: F.toString() });
              }
              const _ = {
                to: this.provider.formatter.address(f[0]),
                data: de([o, E])
              };
              let S = $n(yield this.provider.call(_), 0);
              if (S == null)
                return null;
              t.push({ type: "metadata-url-base", content: S }), s === "erc1155" && (S = S.replace("{id}", E.substring(2)), t.push({ type: "metadata-url-expanded", content: S })), S.match(/^ipfs:/i) && (S = ss(S)), t.push({ type: "metadata-url", content: S });
              const O = yield Is(S);
              if (!O)
                return null;
              t.push({ type: "metadata", content: JSON.stringify(O) });
              let C = O.image;
              if (typeof C != "string")
                return null;
              if (!C.match(/^(https:\/\/|data:)/i)) {
                if (C.match(Va) == null)
                  return null;
                t.push({ type: "url-ipfs", content: C }), C = ss(C);
              }
              return t.push({ type: "url", content: C }), { linkage: t, url: C };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return ot(this, void 0, void 0, function* () {
      const t = yield this._fetchBytes("0xbc1c58d1");
      if (t == null || t === "0x")
        return null;
      const r = t.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (r) {
        const o = parseInt(r[3], 16);
        if (r[4].length === o * 2)
          return "ipfs://" + ls.encode("0x" + r[1]);
      }
      const n = t.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (n) {
        const o = parseInt(n[3], 16);
        if (n[4].length === o * 2)
          return "ipns://" + ls.encode("0x" + n[1]);
      }
      const i = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (i && i[1].length === 32 * 2)
        return "bzz://" + i[1];
      const s = t.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const o = { "=": "", "+": "-", "/": "_" };
        return "sia://" + Zo("0x" + s[1]).replace(/[=+\/]/g, (c) => o[c]);
      }
      return ht.throwError("invalid or unsupported content hash data", M.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: t
      });
    });
  }
  getText(t) {
    return ot(this, void 0, void 0, function* () {
      let r = Oe(t);
      r = ge([is(64), is(r.length), r]), r.length % 32 !== 0 && (r = ge([r, Xt("0x", 32 - t.length % 32)]));
      const n = yield this._fetchBytes("0x59d1d43c", K(r));
      return n == null || n === "0x" ? null : Bn(n);
    });
  }
}
let os = null, Wc = 1;
class Xc extends vi {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(t) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), U(this, "anyNetwork", t === "any"), this.anyNetwork && (t = this.detectNetwork()), t instanceof Promise)
      this._networkPromise = t, t.catch((r) => {
      }), this._ready().catch((r) => {
      });
    else {
      const r = Ke(new.target, "getNetwork")(t);
      r ? (U(this, "_network", r), this.emit("network", r, null)) : ht.throwArgumentError("invalid network", "network", t);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return ot(this, void 0, void 0, function* () {
      if (this._network == null) {
        let t = null;
        if (this._networkPromise)
          try {
            t = yield this._networkPromise;
          } catch {
          }
        t == null && (t = yield this.detectNetwork()), t || ht.throwError("no network detected", M.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = t : U(this, "_network", t), this.emit("network", t, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return Nn(() => this._ready().then((t) => t, (t) => {
      if (!(t.code === M.errors.NETWORK_ERROR && t.event === "noNetwork"))
        throw t;
    }));
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return os == null && (os = new Y()), os;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(t) {
    return Qu(t ?? "homestead");
  }
  ccipReadFetch(t, r, n) {
    return ot(this, void 0, void 0, function* () {
      if (this.disableCcipRead || n.length === 0)
        return null;
      const i = t.to.toLowerCase(), s = r.toLowerCase(), o = [];
      for (let c = 0; c < n.length; c++) {
        const f = n[c], m = f.replace("{sender}", i).replace("{data}", s), E = f.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: s, sender: i }), _ = yield Is({ url: m, errorPassThrough: !0 }, E, (O, C) => (O.status = C.statusCode, O));
        if (_.data)
          return _.data;
        const S = _.message || "unknown error";
        if (_.status >= 400 && _.status < 500)
          return ht.throwError(`response not found during CCIP fetch: ${S}`, M.errors.SERVER_ERROR, { url: f, errorMessage: S });
        o.push(S);
      }
      return ht.throwError(`error encountered during CCIP fetch: ${o.map((c) => JSON.stringify(c)).join(", ")}`, M.errors.SERVER_ERROR, {
        urls: n,
        errorMessages: o
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(t) {
    return ot(this, void 0, void 0, function* () {
      if (yield this._ready(), t > 0)
        for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if (An() - s.respTime <= t)
              return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i)
              break;
          }
        }
      const r = An(), n = ee({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((i) => null, (i) => i)
      }).then(({ blockNumber: i, networkError: s }) => {
        if (s)
          throw this._internalBlockNumber === n && (this._internalBlockNumber = null), s;
        const o = An();
        return i = V.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), { blockNumber: i, reqTime: r, respTime: o };
      });
      return this._internalBlockNumber = n, n.catch((i) => {
        this._internalBlockNumber === n && (this._internalBlockNumber = null);
      }), (yield n).blockNumber;
    });
  }
  poll() {
    return ot(this, void 0, void 0, function* () {
      const t = Wc++, r = [];
      let n = null;
      try {
        n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (i) {
        this.emit("error", i);
        return;
      }
      if (this._setFastBlockNumber(n), this.emit("poll", t, n), n === this._lastBlockNumber) {
        this.emit("didPoll", t);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3)
        ht.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`), this.emit("error", ht.makeError("network block skew detected", M.errors.NETWORK_ERROR, {
          blockNumber: n,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", n);
      else
        for (let i = this._emitted.block + 1; i <= n; i++)
          this.emit("block", i);
      this._emitted.block !== n && (this._emitted.block = n, Object.keys(this._emitted).forEach((i) => {
        if (i === "block")
          return;
        const s = this._emitted[i];
        s !== "pending" && n - s > 12 && delete this._emitted[i];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = n - 1), this._events.forEach((i) => {
        switch (i.type) {
          case "tx": {
            const s = i.hash;
            let o = this.getTransactionReceipt(s).then((c) => (!c || c.blockNumber == null || (this._emitted["t:" + s] = c.blockNumber, this.emit(s, c)), null)).catch((c) => {
              this.emit("error", c);
            });
            r.push(o);
            break;
          }
          case "filter": {
            if (!i._inflight) {
              i._inflight = !0, i._lastBlockNumber === -2 && (i._lastBlockNumber = n - 1);
              const s = i.filter;
              s.fromBlock = i._lastBlockNumber + 1, s.toBlock = n;
              const o = s.toBlock - this._maxFilterBlockRange;
              o > s.fromBlock && (s.fromBlock = o), s.fromBlock < 0 && (s.fromBlock = 0);
              const c = this.getLogs(s).then((f) => {
                i._inflight = !1, f.length !== 0 && f.forEach((m) => {
                  m.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = m.blockNumber), this._emitted["b:" + m.blockHash] = m.blockNumber, this._emitted["t:" + m.transactionHash] = m.blockNumber, this.emit(s, m);
                });
              }).catch((f) => {
                this.emit("error", f), i._inflight = !1;
              });
              r.push(c);
            }
            break;
          }
        }
      }), this._lastBlockNumber = n, Promise.all(r).then(() => {
        this.emit("didPoll", t);
      }).catch((i) => {
        this.emit("error", i);
      });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(t) {
    this._lastBlockNumber = t - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return ot(this, void 0, void 0, function* () {
      return ht.throwError("provider does not support network detection", M.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return ot(this, void 0, void 0, function* () {
      const t = yield this._ready(), r = yield this.detectNetwork();
      if (t.chainId !== r.chainId) {
        if (this.anyNetwork)
          return this._network = r, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", r, t), yield Ao(0), this._network;
        const n = ht.makeError("underlying network changed", M.errors.NETWORK_ERROR, {
          event: "changed",
          network: t,
          detectedNetwork: r
        });
        throw this.emit("error", n), n;
      }
      return t;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((t) => {
      this._setFastBlockNumber(t);
    }, (t) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(t) {
    t && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !t && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(t) {
    if (typeof t != "number" || t <= 0 || parseInt(String(t)) != t)
      throw new Error("invalid polling interval");
    this._pollingInterval = t, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const t = An();
    return t - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = t, this._fastBlockNumberPromise = this.getBlockNumber().then((r) => ((this._fastBlockNumber == null || r > this._fastBlockNumber) && (this._fastBlockNumber = r), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(t) {
    this._fastBlockNumber != null && t < this._fastBlockNumber || (this._fastQueryDate = An(), (this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t, this._fastBlockNumberPromise = Promise.resolve(t)));
  }
  waitForTransaction(t, r, n) {
    return ot(this, void 0, void 0, function* () {
      return this._waitForTransaction(t, r ?? 1, n || 0, null);
    });
  }
  _waitForTransaction(t, r, n, i) {
    return ot(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(t);
      return (s ? s.confirmations : 0) >= r ? s : new Promise((o, c) => {
        const f = [];
        let m = !1;
        const E = function() {
          return m ? !0 : (m = !0, f.forEach((S) => {
            S();
          }), !1);
        }, _ = (S) => {
          S.confirmations < r || E() || o(S);
        };
        if (this.on(t, _), f.push(() => {
          this.removeListener(t, _);
        }), i) {
          let S = i.startBlock, O = null;
          const C = (F) => ot(this, void 0, void 0, function* () {
            m || (yield Ao(1e3), this.getTransactionCount(i.from).then((L) => ot(this, void 0, void 0, function* () {
              if (!m) {
                if (L <= i.nonce)
                  S = F;
                else {
                  {
                    const D = yield this.getTransaction(t);
                    if (D && D.blockNumber != null)
                      return;
                  }
                  for (O == null && (O = S - 3, O < i.startBlock && (O = i.startBlock)); O <= F; ) {
                    if (m)
                      return;
                    const D = yield this.getBlockWithTransactions(O);
                    for (let P = 0; P < D.transactions.length; P++) {
                      const X = D.transactions[P];
                      if (X.hash === t)
                        return;
                      if (X.from === i.from && X.nonce === i.nonce) {
                        if (m)
                          return;
                        const rt = yield this.waitForTransaction(X.hash, r);
                        if (E())
                          return;
                        let $ = "replaced";
                        X.data === i.data && X.to === i.to && X.value.eq(i.value) ? $ = "repriced" : X.data === "0x" && X.from === X.to && X.value.isZero() && ($ = "cancelled"), c(ht.makeError("transaction was replaced", M.errors.TRANSACTION_REPLACED, {
                          cancelled: $ === "replaced" || $ === "cancelled",
                          reason: $,
                          replacement: this._wrapTransaction(X),
                          hash: t,
                          receipt: rt
                        }));
                        return;
                      }
                    }
                    O++;
                  }
                }
                m || this.once("block", C);
              }
            }), (L) => {
              m || this.once("block", C);
            }));
          });
          if (m)
            return;
          this.once("block", C), f.push(() => {
            this.removeListener("block", C);
          });
        }
        if (typeof n == "number" && n > 0) {
          const S = setTimeout(() => {
            E() || c(ht.makeError("timeout exceeded", M.errors.TIMEOUT, { timeout: n }));
          }, n);
          S.unref && S.unref(), f.push(() => {
            clearTimeout(S);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return ot(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield this.perform("getGasPrice", {});
      try {
        return V.from(t);
      } catch (r) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: t,
          error: r
        });
      }
    });
  }
  getBalance(t, r) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield ee({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(r)
      }), i = yield this.perform("getBalance", n);
      try {
        return V.from(i);
      } catch (s) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "getBalance",
          params: n,
          result: i,
          error: s
        });
      }
    });
  }
  getTransactionCount(t, r) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield ee({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(r)
      }), i = yield this.perform("getTransactionCount", n);
      try {
        return V.from(i).toNumber();
      } catch (s) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: n,
          result: i,
          error: s
        });
      }
    });
  }
  getCode(t, r) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield ee({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(r)
      }), i = yield this.perform("getCode", n);
      try {
        return K(i);
      } catch (s) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "getCode",
          params: n,
          result: i,
          error: s
        });
      }
    });
  }
  getStorageAt(t, r, n) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield ee({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(n),
        position: Promise.resolve(r).then((o) => di(o))
      }), s = yield this.perform("getStorageAt", i);
      try {
        return K(s);
      } catch (o) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: i,
          result: s,
          error: o
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(t, r, n) {
    if (r != null && Ir(r) !== 32)
      throw new Error("invalid response - sendTransaction");
    const i = t;
    return r != null && t.hash !== r && ht.throwError("Transaction hash mismatch from Provider.sendTransaction.", M.errors.UNKNOWN_ERROR, { expectedHash: t.hash, returnedHash: r }), i.wait = (s, o) => ot(this, void 0, void 0, function* () {
      s == null && (s = 1), o == null && (o = 0);
      let c;
      s !== 0 && n != null && (c = {
        data: t.data,
        from: t.from,
        nonce: t.nonce,
        to: t.to,
        value: t.value,
        startBlock: n
      });
      const f = yield this._waitForTransaction(t.hash, s, o, c);
      return f == null && s === 0 ? null : (this._emitted["t:" + t.hash] = f.blockNumber, f.status === 0 && ht.throwError("transaction failed", M.errors.CALL_EXCEPTION, {
        transactionHash: t.hash,
        transaction: t,
        receipt: f
      }), f);
    }), i;
  }
  sendTransaction(t) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Promise.resolve(t).then((s) => K(s)), n = this.formatter.transaction(t);
      n.confirmations == null && (n.confirmations = 0);
      const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform("sendTransaction", { signedTransaction: r });
        return this._wrapTransaction(n, s, i);
      } catch (s) {
        throw s.transaction = n, s.transactionHash = n.hash, s;
      }
    });
  }
  _getTransactionRequest(t) {
    return ot(this, void 0, void 0, function* () {
      const r = yield t, n = {};
      return ["from", "to"].forEach((i) => {
        r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => s ? this._getAddress(s) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((i) => {
        r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => s ? V.from(s) : null));
      }), ["type"].forEach((i) => {
        r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => s ?? null));
      }), r.accessList && (n.accessList = this.formatter.accessList(r.accessList)), ["data"].forEach((i) => {
        r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => s ? K(s) : null));
      }), this.formatter.transactionRequest(yield ee(n));
    });
  }
  _getFilter(t) {
    return ot(this, void 0, void 0, function* () {
      t = yield t;
      const r = {};
      return t.address != null && (r.address = this._getAddress(t.address)), ["blockHash", "topics"].forEach((n) => {
        t[n] != null && (r[n] = t[n]);
      }), ["fromBlock", "toBlock"].forEach((n) => {
        t[n] != null && (r[n] = this._getBlockTag(t[n]));
      }), this.formatter.filter(yield ee(r));
    });
  }
  _call(t, r, n) {
    return ot(this, void 0, void 0, function* () {
      n >= qc && ht.throwError("CCIP read exceeded maximum redirections", M.errors.SERVER_ERROR, {
        redirects: n,
        transaction: t
      });
      const i = t.to, s = yield this.perform("call", { transaction: t, blockTag: r });
      if (n >= 0 && r === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && Ir(s) % 32 === 4)
        try {
          const o = he(s, 4), c = he(o, 0, 32);
          V.from(c).eq(i) || ht.throwError("CCIP Read sender did not match", M.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: s
          });
          const f = [], m = V.from(he(o, 32, 64)).toNumber(), E = V.from(he(o, m, m + 32)).toNumber(), _ = he(o, m + 32);
          for (let D = 0; D < E; D++) {
            const P = $n(_, D * 32);
            P == null && ht.throwError("CCIP Read contained corrupt URL string", M.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: t,
              data: s
            }), f.push(P);
          }
          const S = Rn(o, 64);
          V.from(he(o, 100, 128)).isZero() || ht.throwError("CCIP Read callback selector included junk", M.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: s
          });
          const O = he(o, 96, 100), C = Rn(o, 128), F = yield this.ccipReadFetch(t, S, f);
          F == null && ht.throwError("CCIP Read disabled or provided no URLs", M.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: s
          });
          const L = {
            to: i,
            data: de([O, za([F, C])])
          };
          return this._call(L, r, n + 1);
        } catch (o) {
          if (o.code === M.errors.SERVER_ERROR)
            throw o;
        }
      try {
        return K(s);
      } catch (o) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: t, blockTag: r },
          result: s,
          error: o
        });
      }
    });
  }
  call(t, r) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield ee({
        transaction: this._getTransactionRequest(t),
        blockTag: this._getBlockTag(r),
        ccipReadEnabled: Promise.resolve(t.ccipReadEnabled)
      });
      return this._call(n.transaction, n.blockTag, n.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(t) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield ee({
        transaction: this._getTransactionRequest(t)
      }), n = yield this.perform("estimateGas", r);
      try {
        return V.from(n);
      } catch (i) {
        return ht.throwError("bad result from backend", M.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: r,
          result: n,
          error: i
        });
      }
    });
  }
  _getAddress(t) {
    return ot(this, void 0, void 0, function* () {
      t = yield t, typeof t != "string" && ht.throwArgumentError("invalid address or ENS name", "name", t);
      const r = yield this.resolveName(t);
      return r == null && ht.throwError("ENS name not configured", M.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(t)})`
      }), r;
    });
  }
  _getBlock(t, r) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      let n = -128;
      const i = {
        includeTransactions: !!r
      };
      if (pt(t, 32))
        i.blockHash = t;
      else
        try {
          i.blockTag = yield this._getBlockTag(t), pt(i.blockTag) && (n = parseInt(i.blockTag.substring(2), 16));
        } catch {
          ht.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", t);
        }
      return Nn(() => ot(this, void 0, void 0, function* () {
        const s = yield this.perform("getBlock", i);
        if (s == null)
          return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && n > this._emitted.block ? null : void 0;
        if (r) {
          let o = null;
          for (let f = 0; f < s.transactions.length; f++) {
            const m = s.transactions[f];
            if (m.blockNumber == null)
              m.confirmations = 0;
            else if (m.confirmations == null) {
              o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let E = o - m.blockNumber + 1;
              E <= 0 && (E = 1), m.confirmations = E;
            }
          }
          const c = this.formatter.blockWithTransactions(s);
          return c.transactions = c.transactions.map((f) => this._wrapTransaction(f)), c;
        }
        return this.formatter.block(s);
      }), { oncePoll: this });
    });
  }
  getBlock(t) {
    return this._getBlock(t, !1);
  }
  getBlockWithTransactions(t) {
    return this._getBlock(t, !0);
  }
  getTransaction(t) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      const r = { transactionHash: this.formatter.hash(t, !0) };
      return Nn(() => ot(this, void 0, void 0, function* () {
        const n = yield this.perform("getTransaction", r);
        if (n == null)
          return this._emitted["t:" + t] == null ? null : void 0;
        const i = this.formatter.transactionResponse(n);
        if (i.blockNumber == null)
          i.confirmations = 0;
        else if (i.confirmations == null) {
          let s = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          s <= 0 && (s = 1), i.confirmations = s;
        }
        return this._wrapTransaction(i);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(t) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      const r = { transactionHash: this.formatter.hash(t, !0) };
      return Nn(() => ot(this, void 0, void 0, function* () {
        const n = yield this.perform("getTransactionReceipt", r);
        if (n == null)
          return this._emitted["t:" + t] == null ? null : void 0;
        if (n.blockHash == null)
          return;
        const i = this.formatter.receipt(n);
        if (i.blockNumber == null)
          i.confirmations = 0;
        else if (i.confirmations == null) {
          let s = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          s <= 0 && (s = 1), i.confirmations = s;
        }
        return i;
      }), { oncePoll: this });
    });
  }
  getLogs(t) {
    return ot(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield ee({ filter: this._getFilter(t) }), n = yield this.perform("getLogs", r);
      return n.forEach((i) => {
        i.removed == null && (i.removed = !1);
      }), Y.arrayOf(this.formatter.filterLog.bind(this.formatter))(n);
    });
  }
  getEtherPrice() {
    return ot(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(t) {
    return ot(this, void 0, void 0, function* () {
      if (t = yield t, typeof t == "number" && t < 0) {
        t % 1 && ht.throwArgumentError("invalid BlockTag", "blockTag", t);
        let r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return r += t, r < 0 && (r = 0), this.formatter.blockTag(r);
      }
      return this.formatter.blockTag(t);
    });
  }
  getResolver(t) {
    return ot(this, void 0, void 0, function* () {
      let r = t;
      for (; ; ) {
        if (r === "" || r === "." || t !== "eth" && r === "eth")
          return null;
        const n = yield this._getResolver(r, "getResolver");
        if (n != null) {
          const i = new _o(this, n, t);
          return r !== t && !(yield i.supportsWildcard()) ? null : i;
        }
        r = r.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(t, r) {
    return ot(this, void 0, void 0, function* () {
      r == null && (r = "ENS");
      const n = yield this.getNetwork();
      n.ensAddress || ht.throwError("network does not support ENS", M.errors.UNSUPPORTED_OPERATION, { operation: r, network: n.name });
      try {
        const i = yield this.call({
          to: n.ensAddress,
          data: "0x0178b8bf" + Wn(t).substring(2)
        });
        return this.formatter.callAddress(i);
      } catch {
      }
      return null;
    });
  }
  resolveName(t) {
    return ot(this, void 0, void 0, function* () {
      t = yield t;
      try {
        return Promise.resolve(this.formatter.address(t));
      } catch (n) {
        if (pt(t))
          throw n;
      }
      typeof t != "string" && ht.throwArgumentError("invalid ENS name", "name", t);
      const r = yield this.getResolver(t);
      return r ? yield r.getAddress() : null;
    });
  }
  lookupAddress(t) {
    return ot(this, void 0, void 0, function* () {
      t = yield t, t = this.formatter.address(t);
      const r = t.substring(2).toLowerCase() + ".addr.reverse", n = yield this._getResolver(r, "lookupAddress");
      if (n == null)
        return null;
      const i = $n(yield this.call({
        to: n,
        data: "0x691f3431" + Wn(r).substring(2)
      }), 0);
      return (yield this.resolveName(i)) != t ? null : i;
    });
  }
  getAvatar(t) {
    return ot(this, void 0, void 0, function* () {
      let r = null;
      if (pt(t)) {
        const i = this.formatter.address(t).substring(2).toLowerCase() + ".addr.reverse", s = yield this._getResolver(i, "getAvatar");
        if (!s)
          return null;
        r = new _o(this, s, i);
        try {
          const o = yield r.getAvatar();
          if (o)
            return o.url;
        } catch (o) {
          if (o.code !== M.errors.CALL_EXCEPTION)
            throw o;
        }
        try {
          const o = $n(yield this.call({
            to: s,
            data: "0x691f3431" + Wn(i).substring(2)
          }), 0);
          r = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== M.errors.CALL_EXCEPTION)
            throw o;
          return null;
        }
      } else if (r = yield this.getResolver(t), !r)
        return null;
      const n = yield r.getAvatar();
      return n == null ? null : n.url;
    });
  }
  perform(t, r) {
    return ht.throwError(t + " not implemented", M.errors.NOT_IMPLEMENTED, { operation: t });
  }
  _startEvent(t) {
    this.polling = this._events.filter((r) => r.pollable()).length > 0;
  }
  _stopEvent(t) {
    this.polling = this._events.filter((r) => r.pollable()).length > 0;
  }
  _addEventListener(t, r, n) {
    const i = new Yc(tn(t), r, n);
    return this._events.push(i), this._startEvent(i), this;
  }
  on(t, r) {
    return this._addEventListener(t, r, !1);
  }
  once(t, r) {
    return this._addEventListener(t, r, !0);
  }
  emit(t, ...r) {
    let n = !1, i = [], s = tn(t);
    return this._events = this._events.filter((o) => o.tag !== s ? !0 : (setTimeout(() => {
      o.listener.apply(this, r);
    }, 0), n = !0, o.once ? (i.push(o), !1) : !0)), i.forEach((o) => {
      this._stopEvent(o);
    }), n;
  }
  listenerCount(t) {
    if (!t)
      return this._events.length;
    let r = tn(t);
    return this._events.filter((n) => n.tag === r).length;
  }
  listeners(t) {
    if (t == null)
      return this._events.map((n) => n.listener);
    let r = tn(t);
    return this._events.filter((n) => n.tag === r).map((n) => n.listener);
  }
  off(t, r) {
    if (r == null)
      return this.removeAllListeners(t);
    const n = [];
    let i = !1, s = tn(t);
    return this._events = this._events.filter((o) => o.tag !== s || o.listener != r || i ? !0 : (i = !0, n.push(o), !1)), n.forEach((o) => {
      this._stopEvent(o);
    }), this;
  }
  removeAllListeners(t) {
    let r = [];
    if (t == null)
      r = this._events, this._events = [];
    else {
      const n = tn(t);
      this._events = this._events.filter((i) => i.tag !== n ? !0 : (r.push(i), !1));
    }
    return r.forEach((n) => {
      this._stopEvent(n);
    }), this;
  }
}
const Zc = "abstract-signer/5.7.0";
var De = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const Te = new M(Zc), $c = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], tf = [
  M.errors.INSUFFICIENT_FUNDS,
  M.errors.NONCE_EXPIRED,
  M.errors.REPLACEMENT_UNDERPRICED
];
class Un {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    Ne(this, "getBalance", (t) => De(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), t);
    })), Ne(this, "getTransactionCount", (t) => De(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(
        this.getAddress(),
        t
      );
    })), Ne(this, "estimateGas", (t) => De(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const r = yield ee(this.checkTransaction(t));
      return yield this.provider.estimateGas(r);
    })), Ne(this, "call", (t, r) => De(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const n = yield ee(this.checkTransaction(t));
      return yield this.provider.call(n, r);
    })), Ne(this, "sendTransaction", (t) => De(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const r = yield this.populateTransaction(t), n = yield this.signTransaction(r);
      return yield this.provider.sendTransaction(n);
    })), Ne(this, "getChainId", () => De(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    })), Ne(this, "getGasPrice", () => De(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    })), Ne(this, "getFeeData", () => De(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    })), Ne(this, "resolveName", (t) => De(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(t);
    })), Ne(this, "checkTransaction", (t) => {
      for (const n in t)
        $c.indexOf(n) === -1 && Te.throwArgumentError(
          "invalid transaction key: " + n,
          "transaction",
          t
        );
      const r = se(t);
      return r.from == null ? r.from = this.getAddress() : r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(
        (n) => (n[0].toLowerCase() !== n[1].toLowerCase() && Te.throwArgumentError(
          "from address mismatch",
          "transaction",
          t
        ), n[0])
      ), r;
    }), Ne(this, "populateTransaction", (t) => De(this, void 0, void 0, function* () {
      const r = yield ee(this.checkTransaction(t));
      r.to != null && (r.to = Promise.resolve(r.to).then(
        (i) => De(this, void 0, void 0, function* () {
          if (i == null)
            return null;
          const s = yield this.resolveName(i);
          return s == null && Te.throwArgumentError(
            "provided ENS name resolves to null",
            "tx.to",
            i
          ), s;
        })
      ), r.to.catch((i) => {
      }));
      const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
      if (r.gasPrice != null && (r.type === 2 || n) ? Te.throwArgumentError(
        "eip-1559 transaction do not support gasPrice",
        "transaction",
        t
      ) : (r.type === 0 || r.type === 1) && n && Te.throwArgumentError(
        "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
        "transaction",
        t
      ), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
        r.type = 2;
      else if (r.type === 0 || r.type === 1)
        r.gasPrice == null && (r.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (r.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (r.type = 2, r.gasPrice != null) {
              const s = r.gasPrice;
              delete r.gasPrice, r.maxFeePerGas = s, r.maxPriorityFeePerGas = s;
            } else
              r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null ? (n && Te.throwError(
              "network does not support EIP-1559",
              M.errors.UNSUPPORTED_OPERATION,
              {
                operation: "populateTransaction"
              }
            ), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : Te.throwError(
              "failed to get consistent fee data",
              M.errors.UNSUPPORTED_OPERATION,
              {
                operation: "signer.getFeeData"
              }
            );
        else
          r.type === 2 && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return r.nonce == null && (r.nonce = this.getTransactionCount("pending")), r.gasLimit == null && (r.gasLimit = this.estimateGas(r).catch((i) => {
        if (tf.indexOf(i.code) >= 0)
          throw i;
        return Te.throwError(
          "cannot estimate gas; transaction may fail or may require manual gas limit",
          M.errors.UNPREDICTABLE_GAS_LIMIT,
          {
            error: i,
            tx: r
          }
        );
      })), r.chainId == null ? r.chainId = this.getChainId() : r.chainId = Promise.all([
        Promise.resolve(r.chainId),
        this.getChainId()
      ]).then((i) => (i[1] !== 0 && i[0] !== i[1] && Te.throwArgumentError(
        "chainId address mismatch",
        "transaction",
        t
      ), i[0])), yield ee(r);
    })), Ne(this, "_checkProvider", (t) => {
      this.provider || Te.throwError(
        "missing provider",
        M.errors.UNSUPPORTED_OPERATION,
        {
          operation: t || "_checkProvider"
        }
      );
    }), Te.checkAbstract(new.target, Un), U(this, "_isSigner", !0);
  }
  static isSigner(t) {
    return !!(t && t._isSigner);
  }
}
class Ps extends Un {
  constructor(t, r) {
    super(), U(this, "address", t), U(this, "provider", r || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(t, r) {
    return Promise.resolve().then(() => {
      Te.throwError(t, M.errors.UNSUPPORTED_OPERATION, {
        operation: r
      });
    });
  }
  signMessage(t) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(t) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(t, r, n) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(t) {
    return new Ps(this.address, t);
  }
}
var or = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const re = new M(Ss), ef = ["call", "estimateGas"];
function _n(e, t) {
  if (e == null)
    return null;
  if (typeof e.message == "string" && e.message.match("reverted")) {
    const r = pt(e.data) ? e.data : null;
    if (!t || r)
      return { message: e.message, data: r };
  }
  if (typeof e == "object") {
    for (const r in e) {
      const n = _n(e[r], t);
      if (n)
        return n;
    }
    return null;
  }
  if (typeof e == "string")
    try {
      return _n(JSON.parse(e), t);
    } catch {
    }
  return null;
}
function qa(e, t, r) {
  const n = r.transaction || r.signedTransaction;
  if (e === "call") {
    const s = _n(t, !0);
    if (s)
      return s.data;
    re.throwError("missing revert data in call exception; Transaction reverted without a reason string", M.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: n,
      error: t
    });
  }
  if (e === "estimateGas") {
    let s = _n(t.body, !1);
    s == null && (s = _n(t, !1)), s && re.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", M.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: s.message,
      method: e,
      transaction: n,
      error: t
    });
  }
  let i = t.message;
  throw t.code === M.errors.SERVER_ERROR && t.error && typeof t.error.message == "string" ? i = t.error.message : typeof t.body == "string" ? i = t.body : typeof t.responseText == "string" && (i = t.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && re.throwError("insufficient funds for intrinsic transaction cost", M.errors.INSUFFICIENT_FUNDS, {
    error: t,
    method: e,
    transaction: n
  }), i.match(/nonce (is )?too low/i) && re.throwError("nonce has already been used", M.errors.NONCE_EXPIRED, {
    error: t,
    method: e,
    transaction: n
  }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && re.throwError("replacement fee too low", M.errors.REPLACEMENT_UNDERPRICED, {
    error: t,
    method: e,
    transaction: n
  }), i.match(/only replay-protected/i) && re.throwError("legacy pre-eip-155 transactions not supported", M.errors.UNSUPPORTED_OPERATION, {
    error: t,
    method: e,
    transaction: n
  }), ef.indexOf(e) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && re.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", M.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: t,
    method: e,
    transaction: n
  }), t;
}
function Io(e) {
  return new Promise(function(t) {
    setTimeout(t, e);
  });
}
function rf(e) {
  if (e.error) {
    const t = new Error(e.error.message);
    throw t.code = e.error.code, t.data = e.error.data, t;
  }
  return e.result;
}
function En(e) {
  return e && e.toLowerCase();
}
const ys = {};
class ja extends Un {
  constructor(t, r, n) {
    if (super(), t !== ys)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    U(this, "provider", r), n == null && (n = 0), typeof n == "string" ? (U(this, "_address", this.provider.formatter.address(n)), U(this, "_index", null)) : typeof n == "number" ? (U(this, "_index", n), U(this, "_address", null)) : re.throwArgumentError("invalid address or index", "addressOrIndex", n);
  }
  connect(t) {
    return re.throwError("cannot alter JSON-RPC Signer connection", M.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new nf(ys, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((t) => (t.length <= this._index && re.throwError("unknown account #" + this._index, M.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(t[this._index])));
  }
  sendUncheckedTransaction(t) {
    t = se(t);
    const r = this.getAddress().then((n) => (n && (n = n.toLowerCase()), n));
    if (t.gasLimit == null) {
      const n = se(t);
      n.from = r, t.gasLimit = this.provider.estimateGas(n);
    }
    return t.to != null && (t.to = Promise.resolve(t.to).then((n) => or(this, void 0, void 0, function* () {
      if (n == null)
        return null;
      const i = yield this.provider.resolveName(n);
      return i == null && re.throwArgumentError("provided ENS name resolves to null", "tx.to", n), i;
    }))), ee({
      tx: ee(t),
      sender: r
    }).then(({ tx: n, sender: i }) => {
      n.from != null ? n.from.toLowerCase() !== i && re.throwArgumentError("from address mismatch", "transaction", t) : n.from = i;
      const s = this.provider.constructor.hexlifyTransaction(n, { from: !0 });
      return this.provider.send("eth_sendTransaction", [s]).then((o) => o, (o) => (typeof o.message == "string" && o.message.match(/user denied/i) && re.throwError("user rejected transaction", M.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: n
      }), qa("sendTransaction", o, s)));
    });
  }
  signTransaction(t) {
    return re.throwError("signing transactions is unsupported", M.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(t) {
    return or(this, void 0, void 0, function* () {
      const r = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), n = yield this.sendUncheckedTransaction(t);
      try {
        return yield Nn(() => or(this, void 0, void 0, function* () {
          const i = yield this.provider.getTransaction(n);
          if (i !== null)
            return this.provider._wrapTransaction(i, n, r);
        }), { oncePoll: this.provider });
      } catch (i) {
        throw i.transactionHash = n, i;
      }
    });
  }
  signMessage(t) {
    return or(this, void 0, void 0, function* () {
      const r = typeof t == "string" ? Oe(t) : t, n = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [K(r), n.toLowerCase()]);
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && re.throwError("user rejected signing", M.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: n,
          messageData: t
        }), i;
      }
    });
  }
  _legacySignMessage(t) {
    return or(this, void 0, void 0, function* () {
      const r = typeof t == "string" ? Oe(t) : t, n = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [n.toLowerCase(), K(r)]);
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && re.throwError("user rejected signing", M.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: n,
          messageData: t
        }), i;
      }
    });
  }
  _signTypedData(t, r, n) {
    return or(this, void 0, void 0, function* () {
      const i = yield ve.resolveNames(t, r, n, (o) => this.provider.resolveName(o)), s = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          s.toLowerCase(),
          JSON.stringify(ve.getPayload(i.domain, r, i.value))
        ]);
      } catch (o) {
        throw typeof o.message == "string" && o.message.match(/user denied/i) && re.throwError("user rejected signing", M.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: s,
          messageData: { domain: i.domain, types: r, value: i.value }
        }), o;
      }
    });
  }
  unlock(t) {
    return or(this, void 0, void 0, function* () {
      const r = this.provider, n = yield this.getAddress();
      return r.send("personal_unlockAccount", [n.toLowerCase(), t, null]);
    });
  }
}
class nf extends ja {
  sendTransaction(t) {
    return this.sendUncheckedTransaction(t).then((r) => ({
      hash: r,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (n) => this.provider.waitForTransaction(r, n)
    }));
  }
}
const sf = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
class of extends Xc {
  constructor(t, r) {
    let n = r;
    n == null && (n = new Promise((i, s) => {
      setTimeout(() => {
        this.detectNetwork().then((o) => {
          i(o);
        }, (o) => {
          s(o);
        });
      }, 0);
    })), super(n), t || (t = Ke(this.constructor, "defaultUrl")()), typeof t == "string" ? U(this, "connection", Object.freeze({
      url: t
    })) : U(this, "connection", Object.freeze(se(t))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return or(this, void 0, void 0, function* () {
      yield Io(0);
      let t = null;
      try {
        t = yield this.send("eth_chainId", []);
      } catch {
        try {
          t = yield this.send("net_version", []);
        } catch {
        }
      }
      if (t != null) {
        const r = Ke(this.constructor, "getNetwork");
        try {
          return r(V.from(t).toNumber());
        } catch (n) {
          return re.throwError("could not detect network", M.errors.NETWORK_ERROR, {
            chainId: t,
            event: "invalidNetwork",
            serverError: n
          });
        }
      }
      return re.throwError("could not detect network", M.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(t) {
    return new ja(ys, this, t);
  }
  getUncheckedSigner(t) {
    return this.getSigner(t).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((t) => t.map((r) => this.formatter.address(r)));
  }
  send(t, r) {
    const n = {
      method: t,
      params: r,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: Jr(n),
      provider: this
    });
    const i = ["eth_chainId", "eth_blockNumber"].indexOf(t) >= 0;
    if (i && this._cache[t])
      return this._cache[t];
    const s = Is(this.connection, JSON.stringify(n), rf).then((o) => (this.emit("debug", {
      action: "response",
      request: n,
      response: o,
      provider: this
    }), o), (o) => {
      throw this.emit("debug", {
        action: "response",
        error: o,
        request: n,
        provider: this
      }), o;
    });
    return i && (this._cache[t] = s, setTimeout(() => {
      this._cache[t] = null;
    }, 0)), s;
  }
  prepareRequest(t, r) {
    switch (t) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [En(r.address), r.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [En(r.address), r.blockTag]];
      case "getCode":
        return ["eth_getCode", [En(r.address), r.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [En(r.address), Xt(r.position, 32), r.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [r.signedTransaction]];
      case "getBlock":
        return r.blockTag ? ["eth_getBlockByNumber", [r.blockTag, !!r.includeTransactions]] : r.blockHash ? ["eth_getBlockByHash", [r.blockHash, !!r.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [r.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [r.transactionHash]];
      case "call":
        return ["eth_call", [Ke(this.constructor, "hexlifyTransaction")(r.transaction, { from: !0 }), r.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [Ke(this.constructor, "hexlifyTransaction")(r.transaction, { from: !0 })]];
      case "getLogs":
        return r.filter && r.filter.address != null && (r.filter.address = En(r.filter.address)), ["eth_getLogs", [r.filter]];
    }
    return null;
  }
  perform(t, r) {
    return or(this, void 0, void 0, function* () {
      if (t === "call" || t === "estimateGas") {
        const i = r.transaction;
        if (i && i.type != null && V.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (r = se(r), r.transaction = se(i), delete r.transaction.type);
        }
      }
      const n = this.prepareRequest(t, r);
      n == null && re.throwError(t + " not implemented", M.errors.NOT_IMPLEMENTED, { operation: t });
      try {
        return yield this.send(n[0], n[1]);
      } catch (i) {
        return qa(t, i, r);
      }
    });
  }
  _startEvent(t) {
    t.tag === "pending" && this._startPending(), super._startEvent(t);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const t = this, r = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = r, r.then(function(n) {
      function i() {
        t.send("eth_getFilterChanges", [n]).then(function(s) {
          if (t._pendingFilter != r)
            return null;
          let o = Promise.resolve();
          return s.forEach(function(c) {
            t._emitted["t:" + c.toLowerCase()] = "pending", o = o.then(function() {
              return t.getTransaction(c).then(function(f) {
                return t.emit("pending", f), null;
              });
            });
          }), o.then(function() {
            return Io(1e3);
          });
        }).then(function() {
          if (t._pendingFilter != r) {
            t.send("eth_uninstallFilter", [n]);
            return;
          }
          return setTimeout(function() {
            i();
          }, 0), null;
        }).catch((s) => {
        });
      }
      return i(), n;
    }).catch((n) => {
    });
  }
  _stopEvent(t) {
    t.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(t);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(t, r) {
    const n = se(sf);
    if (r)
      for (const s in r)
        r[s] && (n[s] = !0);
    Uu(t, n);
    const i = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
      if (t[s] == null)
        return;
      const o = di(V.from(t[s]));
      s === "gasLimit" && (s = "gas"), i[s] = o;
    }), ["from", "to", "data"].forEach(function(s) {
      t[s] != null && (i[s] = K(t[s]));
    }), t.accessList && (i.accessList = gn(t.accessList)), i;
  }
}
const af = (e, t) => new of(t || gu[e]), Ln = "abi/5.7.0", ft = new M(Ln), Wr = {};
let So = { calldata: !0, memory: !0, storage: !0 }, uf = { calldata: !0, memory: !0 };
function Qn(e, t) {
  if (e === "bytes" || e === "string") {
    if (So[t])
      return !0;
  } else if (e === "address") {
    if (t === "payable")
      return !0;
  } else if ((e.indexOf("[") >= 0 || e === "tuple") && uf[t])
    return !0;
  return (So[t] || t === "payable") && ft.throwArgumentError("invalid modifier", "name", t), !1;
}
function hf(e, t) {
  let r = e;
  function n(c) {
    ft.throwArgumentError(`unexpected character at position ${c}`, "param", e);
  }
  e = e.replace(/\s/g, " ");
  function i(c) {
    let f = { type: "", name: "", parent: c, state: { allowType: !0 } };
    return t && (f.indexed = !1), f;
  }
  let s = { type: "", name: "", state: { allowType: !0 } }, o = s;
  for (let c = 0; c < e.length; c++) {
    let f = e[c];
    switch (f) {
      case "(":
        o.state.allowType && o.type === "" ? o.type = "tuple" : o.state.allowParams || n(c), o.state.allowType = !1, o.type = en(o.type), o.components = [i(o)], o = o.components[0];
        break;
      case ")":
        delete o.state, o.name === "indexed" && (t || n(c), o.indexed = !0, o.name = ""), Qn(o.type, o.name) && (o.name = ""), o.type = en(o.type);
        let m = o;
        o = o.parent, o || n(c), delete m.parent, o.state.allowParams = !1, o.state.allowName = !0, o.state.allowArray = !0;
        break;
      case ",":
        delete o.state, o.name === "indexed" && (t || n(c), o.indexed = !0, o.name = ""), Qn(o.type, o.name) && (o.name = ""), o.type = en(o.type);
        let E = i(o.parent);
        o.parent.components.push(E), delete o.parent, o = E;
        break;
      case " ":
        o.state.allowType && o.type !== "" && (o.type = en(o.type), delete o.state.allowType, o.state.allowName = !0, o.state.allowParams = !0), o.state.allowName && o.name !== "" && (o.name === "indexed" ? (t || n(c), o.indexed && n(c), o.indexed = !0, o.name = "") : Qn(o.type, o.name) ? o.name = "" : o.state.allowName = !1);
        break;
      case "[":
        o.state.allowArray || n(c), o.type += f, o.state.allowArray = !1, o.state.allowName = !1, o.state.readArray = !0;
        break;
      case "]":
        o.state.readArray || n(c), o.type += f, o.state.readArray = !1, o.state.allowArray = !0, o.state.allowName = !0;
        break;
      default:
        o.state.allowType ? (o.type += f, o.state.allowParams = !0, o.state.allowArray = !0) : o.state.allowName ? (o.name += f, delete o.state.allowArray) : o.state.readArray ? o.type += f : n(c);
    }
  }
  return o.parent && ft.throwArgumentError("unexpected eof", "param", e), delete s.state, o.name === "indexed" ? (t || n(r.length - 7), o.indexed && n(r.length - 7), o.indexed = !0, o.name = "") : Qn(o.type, o.name) && (o.name = ""), s.type = en(s.type), s;
}
function ti(e, t) {
  for (let r in t)
    U(e, r, t[r]);
}
const dt = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
}), lf = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ae {
  constructor(t, r) {
    t !== Wr && ft.throwError("use fromString", M.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), ti(this, r);
    let n = this.type.match(lf);
    n ? ti(this, {
      arrayLength: parseInt(n[2] || "-1"),
      arrayChildren: ae.fromObject({
        type: n[1],
        components: this.components
      }),
      baseType: "array"
    }) : ti(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(t) {
    if (t || (t = dt.sighash), dt[t] || ft.throwArgumentError("invalid format type", "format", t), t === dt.json) {
      let n = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (n.indexed = this.indexed), this.components && (n.components = this.components.map((i) => JSON.parse(i.format(t)))), JSON.stringify(n);
    }
    let r = "";
    return this.baseType === "array" ? (r += this.arrayChildren.format(t), r += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (t !== dt.sighash && (r += this.type), r += "(" + this.components.map((n) => n.format(t)).join(t === dt.full ? ", " : ",") + ")") : r += this.type, t !== dt.sighash && (this.indexed === !0 && (r += " indexed"), t === dt.full && this.name && (r += " " + this.name)), r;
  }
  static from(t, r) {
    return typeof t == "string" ? ae.fromString(t, r) : ae.fromObject(t);
  }
  static fromObject(t) {
    return ae.isParamType(t) ? t : new ae(Wr, {
      name: t.name || null,
      type: en(t.type),
      indexed: t.indexed == null ? null : !!t.indexed,
      components: t.components ? t.components.map(ae.fromObject) : null
    });
  }
  static fromString(t, r) {
    function n(i) {
      return ae.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components
      });
    }
    return n(hf(t, !!r));
  }
  static isParamType(t) {
    return !!(t != null && t._isParamType);
  }
}
function Tn(e, t) {
  return ff(e).map((r) => ae.fromString(r, t));
}
class lr {
  constructor(t, r) {
    t !== Wr && ft.throwError("use a static from method", M.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), ti(this, r), this._isFragment = !0, Object.freeze(this);
  }
  static from(t) {
    return lr.isFragment(t) ? t : typeof t == "string" ? lr.fromString(t) : lr.fromObject(t);
  }
  static fromObject(t) {
    if (lr.isFragment(t))
      return t;
    switch (t.type) {
      case "function":
        return Je.fromObject(t);
      case "event":
        return ur.fromObject(t);
      case "constructor":
        return Ye.fromObject(t);
      case "error":
        return _r.fromObject(t);
      case "fallback":
      case "receive":
        return null;
    }
    return ft.throwArgumentError("invalid fragment object", "value", t);
  }
  static fromString(t) {
    return t = t.replace(/\s/g, " "), t = t.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), t = t.trim(), t.split(" ")[0] === "event" ? ur.fromString(t.substring(5).trim()) : t.split(" ")[0] === "function" ? Je.fromString(t.substring(8).trim()) : t.split("(")[0].trim() === "constructor" ? Ye.fromString(t.trim()) : t.split(" ")[0] === "error" ? _r.fromString(t.substring(5).trim()) : ft.throwArgumentError("unsupported fragment", "value", t);
  }
  static isFragment(t) {
    return !!(t && t._isFragment);
  }
}
class ur extends lr {
  format(t) {
    if (t || (t = dt.sighash), dt[t] || ft.throwArgumentError("invalid format type", "format", t), t === dt.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(t)))
      });
    let r = "";
    return t !== dt.sighash && (r += "event "), r += this.name + "(" + this.inputs.map((n) => n.format(t)).join(t === dt.full ? ", " : ",") + ") ", t !== dt.sighash && this.anonymous && (r += "anonymous "), r.trim();
  }
  static from(t) {
    return typeof t == "string" ? ur.fromString(t) : ur.fromObject(t);
  }
  static fromObject(t) {
    if (ur.isEventFragment(t))
      return t;
    t.type !== "event" && ft.throwArgumentError("invalid event object", "value", t);
    const r = {
      name: On(t.name),
      anonymous: t.anonymous,
      inputs: t.inputs ? t.inputs.map(ae.fromObject) : [],
      type: "event"
    };
    return new ur(Wr, r);
  }
  static fromString(t) {
    let r = t.match(Mn);
    r || ft.throwArgumentError("invalid event string", "value", t);
    let n = !1;
    return r[3].split(" ").forEach((i) => {
      switch (i.trim()) {
        case "anonymous":
          n = !0;
          break;
        case "":
          break;
        default:
          ft.warn("unknown modifier: " + i);
      }
    }), ur.fromObject({
      name: r[1].trim(),
      anonymous: n,
      inputs: Tn(r[2], !0),
      type: "event"
    });
  }
  static isEventFragment(t) {
    return t && t._isFragment && t.type === "event";
  }
}
function Qa(e, t) {
  t.gas = null;
  let r = e.split("@");
  return r.length !== 1 ? (r.length > 2 && ft.throwArgumentError("invalid human-readable ABI signature", "value", e), r[1].match(/^[0-9]+$/) || ft.throwArgumentError("invalid human-readable ABI signature gas", "value", e), t.gas = V.from(r[1]), r[0]) : e;
}
function Ya(e, t) {
  t.constant = !1, t.payable = !1, t.stateMutability = "nonpayable", e.split(" ").forEach((r) => {
    switch (r.trim()) {
      case "constant":
        t.constant = !0;
        break;
      case "payable":
        t.payable = !0, t.stateMutability = "payable";
        break;
      case "nonpayable":
        t.payable = !1, t.stateMutability = "nonpayable";
        break;
      case "pure":
        t.constant = !0, t.stateMutability = "pure";
        break;
      case "view":
        t.constant = !0, t.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + r);
    }
  });
}
function Ja(e) {
  let t = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return e.stateMutability != null ? (t.stateMutability = e.stateMutability, t.constant = t.stateMutability === "view" || t.stateMutability === "pure", e.constant != null && !!e.constant !== t.constant && ft.throwArgumentError("cannot have constant function with mutability " + t.stateMutability, "value", e), t.payable = t.stateMutability === "payable", e.payable != null && !!e.payable !== t.payable && ft.throwArgumentError("cannot have payable function with mutability " + t.stateMutability, "value", e)) : e.payable != null ? (t.payable = !!e.payable, e.constant == null && !t.payable && e.type !== "constructor" && ft.throwArgumentError("unable to determine stateMutability", "value", e), t.constant = !!e.constant, t.constant ? t.stateMutability = "view" : t.stateMutability = t.payable ? "payable" : "nonpayable", t.payable && t.constant && ft.throwArgumentError("cannot have constant payable function", "value", e)) : e.constant != null ? (t.constant = !!e.constant, t.payable = !t.constant, t.stateMutability = t.constant ? "view" : "payable") : e.type !== "constructor" && ft.throwArgumentError("unable to determine stateMutability", "value", e), t;
}
class Ye extends lr {
  format(t) {
    if (t || (t = dt.sighash), dt[t] || ft.throwArgumentError("invalid format type", "format", t), t === dt.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((n) => JSON.parse(n.format(t)))
      });
    t === dt.sighash && ft.throwError("cannot format a constructor for sighash", M.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let r = "constructor(" + this.inputs.map((n) => n.format(t)).join(t === dt.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (r += this.stateMutability + " "), r.trim();
  }
  static from(t) {
    return typeof t == "string" ? Ye.fromString(t) : Ye.fromObject(t);
  }
  static fromObject(t) {
    if (Ye.isConstructorFragment(t))
      return t;
    t.type !== "constructor" && ft.throwArgumentError("invalid constructor object", "value", t);
    let r = Ja(t);
    r.constant && ft.throwArgumentError("constructor cannot be constant", "value", t);
    const n = {
      name: null,
      type: t.type,
      inputs: t.inputs ? t.inputs.map(ae.fromObject) : [],
      payable: r.payable,
      stateMutability: r.stateMutability,
      gas: t.gas ? V.from(t.gas) : null
    };
    return new Ye(Wr, n);
  }
  static fromString(t) {
    let r = { type: "constructor" };
    t = Qa(t, r);
    let n = t.match(Mn);
    return (!n || n[1].trim() !== "constructor") && ft.throwArgumentError("invalid constructor string", "value", t), r.inputs = Tn(n[2].trim(), !1), Ya(n[3].trim(), r), Ye.fromObject(r);
  }
  static isConstructorFragment(t) {
    return t && t._isFragment && t.type === "constructor";
  }
}
class Je extends Ye {
  format(t) {
    if (t || (t = dt.sighash), dt[t] || ft.throwArgumentError("invalid format type", "format", t), t === dt.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((n) => JSON.parse(n.format(t))),
        outputs: this.outputs.map((n) => JSON.parse(n.format(t)))
      });
    let r = "";
    return t !== dt.sighash && (r += "function "), r += this.name + "(" + this.inputs.map((n) => n.format(t)).join(t === dt.full ? ", " : ",") + ") ", t !== dt.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (r += this.stateMutability + " ") : this.constant && (r += "view "), this.outputs && this.outputs.length && (r += "returns (" + this.outputs.map((n) => n.format(t)).join(", ") + ") "), this.gas != null && (r += "@" + this.gas.toString() + " ")), r.trim();
  }
  static from(t) {
    return typeof t == "string" ? Je.fromString(t) : Je.fromObject(t);
  }
  static fromObject(t) {
    if (Je.isFunctionFragment(t))
      return t;
    t.type !== "function" && ft.throwArgumentError("invalid function object", "value", t);
    let r = Ja(t);
    const n = {
      type: t.type,
      name: On(t.name),
      constant: r.constant,
      inputs: t.inputs ? t.inputs.map(ae.fromObject) : [],
      outputs: t.outputs ? t.outputs.map(ae.fromObject) : [],
      payable: r.payable,
      stateMutability: r.stateMutability,
      gas: t.gas ? V.from(t.gas) : null
    };
    return new Je(Wr, n);
  }
  static fromString(t) {
    let r = { type: "function" };
    t = Qa(t, r);
    let n = t.split(" returns ");
    n.length > 2 && ft.throwArgumentError("invalid function string", "value", t);
    let i = n[0].match(Mn);
    if (i || ft.throwArgumentError("invalid function signature", "value", t), r.name = i[1].trim(), r.name && On(r.name), r.inputs = Tn(i[2], !1), Ya(i[3].trim(), r), n.length > 1) {
      let s = n[1].match(Mn);
      (s[1].trim() != "" || s[3].trim() != "") && ft.throwArgumentError("unexpected tokens", "value", t), r.outputs = Tn(s[2], !1);
    } else
      r.outputs = [];
    return Je.fromObject(r);
  }
  static isFunctionFragment(t) {
    return t && t._isFragment && t.type === "function";
  }
}
function Ro(e) {
  const t = e.format();
  return (t === "Error(string)" || t === "Panic(uint256)") && ft.throwArgumentError(`cannot specify user defined ${t} error`, "fragment", e), e;
}
class _r extends lr {
  format(t) {
    if (t || (t = dt.sighash), dt[t] || ft.throwArgumentError("invalid format type", "format", t), t === dt.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(t)))
      });
    let r = "";
    return t !== dt.sighash && (r += "error "), r += this.name + "(" + this.inputs.map((n) => n.format(t)).join(t === dt.full ? ", " : ",") + ") ", r.trim();
  }
  static from(t) {
    return typeof t == "string" ? _r.fromString(t) : _r.fromObject(t);
  }
  static fromObject(t) {
    if (_r.isErrorFragment(t))
      return t;
    t.type !== "error" && ft.throwArgumentError("invalid error object", "value", t);
    const r = {
      type: t.type,
      name: On(t.name),
      inputs: t.inputs ? t.inputs.map(ae.fromObject) : []
    };
    return Ro(new _r(Wr, r));
  }
  static fromString(t) {
    let r = { type: "error" }, n = t.match(Mn);
    return n || ft.throwArgumentError("invalid error signature", "value", t), r.name = n[1].trim(), r.name && On(r.name), r.inputs = Tn(n[2], !1), Ro(_r.fromObject(r));
  }
  static isErrorFragment(t) {
    return t && t._isFragment && t.type === "error";
  }
}
function en(e) {
  return e.match(/^uint($|[^1-9])/) ? e = "uint256" + e.substring(4) : e.match(/^int($|[^1-9])/) && (e = "int256" + e.substring(3)), e;
}
const cf = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function On(e) {
  return (!e || !e.match(cf)) && ft.throwArgumentError(`invalid identifier "${e}"`, "value", e), e;
}
const Mn = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function ff(e) {
  e = e.trim();
  let t = [], r = "", n = 0;
  for (let i = 0; i < e.length; i++) {
    let s = e[i];
    s === "," && n === 0 ? (t.push(r), r = "") : (r += s, s === "(" ? n++ : s === ")" && (n--, n === -1 && ft.throwArgumentError("unbalanced parenthesis", "value", e)));
  }
  return r && t.push(r), t;
}
const ks = new M(Ln);
function df(e) {
  const t = [], r = function(n, i) {
    if (Array.isArray(i))
      for (let s in i) {
        const o = n.slice();
        o.push(s);
        try {
          r(o, i[s]);
        } catch (c) {
          t.push({ path: o, error: c });
        }
      }
  };
  return r([], e), t;
}
class pr {
  constructor(t, r, n, i) {
    this.name = t, this.type = r, this.localName = n, this.dynamic = i;
  }
  _throwError(t, r) {
    ks.throwArgumentError(t, this.localName, r);
  }
}
class vs {
  constructor(t) {
    U(this, "wordSize", t || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(t);
  }
  get data() {
    return de(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(t) {
    return this._data.push(t), this._dataLength += t.length, t.length;
  }
  appendWriter(t) {
    return this._writeData(ge(t._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(t) {
    let r = et(t);
    const n = r.length % this.wordSize;
    return n && (r = ge([r, this._padding.slice(n)])), this._writeData(r);
  }
  _getValue(t) {
    let r = et(V.from(t));
    return r.length > this.wordSize && ks.throwError("value out-of-bounds", M.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: r.length
    }), r.length % this.wordSize && (r = ge([this._padding.slice(r.length % this.wordSize), r])), r;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(t) {
    return this._writeData(this._getValue(t));
  }
  writeUpdatableValue() {
    const t = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (r) => {
      this._data[t] = this._getValue(r);
    };
  }
}
class hi {
  constructor(t, r, n, i) {
    U(this, "_data", et(t)), U(this, "wordSize", r || 32), U(this, "_coerceFunc", n), U(this, "allowLoose", i), this._offset = 0;
  }
  get data() {
    return K(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(t, r) {
    let n = t.match("^u?int([0-9]+)$");
    return n && parseInt(n[1]) <= 48 && (r = r.toNumber()), r;
  }
  coerce(t, r) {
    return this._coerceFunc ? this._coerceFunc(t, r) : hi.coerce(t, r);
  }
  _peekBytes(t, r, n) {
    let i = Math.ceil(r / this.wordSize) * this.wordSize;
    return this._offset + i > this._data.length && (this.allowLoose && n && this._offset + r <= this._data.length ? i = r : ks.throwError("data out-of-bounds", M.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + i
    })), this._data.slice(this._offset, this._offset + i);
  }
  subReader(t) {
    return new hi(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(t, r) {
    let n = this._peekBytes(0, t, !!r);
    return this._offset += n.length, n.slice(0, t);
  }
  readValue() {
    return V.from(this.readBytes(this.wordSize));
  }
}
class pf extends pr {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, r) {
    try {
      r = ne(r);
    } catch (n) {
      this._throwError(n.message, r);
    }
    return t.writeValue(r);
  }
  decode(t) {
    return ne(Xt(t.readValue().toHexString(), 20));
  }
}
class mf extends pr {
  constructor(t) {
    super(t.name, t.type, void 0, t.dynamic), this.coder = t;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(t, r) {
    return this.coder.encode(t, r);
  }
  decode(t) {
    return this.coder.decode(t);
  }
}
const sn = new M(Ln);
function Ka(e, t, r) {
  let n = null;
  if (Array.isArray(r))
    n = r;
  else if (r && typeof r == "object") {
    let f = {};
    n = t.map((m) => {
      const E = m.localName;
      return E || sn.throwError("cannot encode object for signature with missing names", M.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: m,
        value: r
      }), f[E] && sn.throwError("cannot encode object for signature with duplicate names", M.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: m,
        value: r
      }), f[E] = !0, r[E];
    });
  } else
    sn.throwArgumentError("invalid tuple value", "tuple", r);
  t.length !== n.length && sn.throwArgumentError("types/value length mismatch", "tuple", r);
  let i = new vs(e.wordSize), s = new vs(e.wordSize), o = [];
  t.forEach((f, m) => {
    let E = n[m];
    if (f.dynamic) {
      let _ = s.length;
      f.encode(s, E);
      let S = i.writeUpdatableValue();
      o.push((O) => {
        S(O + _);
      });
    } else
      f.encode(i, E);
  }), o.forEach((f) => {
    f(i.length);
  });
  let c = e.appendWriter(i);
  return c += e.appendWriter(s), c;
}
function Wa(e, t) {
  let r = [], n = e.subReader(0);
  t.forEach((s) => {
    let o = null;
    if (s.dynamic) {
      let c = e.readValue(), f = n.subReader(c.toNumber());
      try {
        o = s.decode(f);
      } catch (m) {
        if (m.code === M.errors.BUFFER_OVERRUN)
          throw m;
        o = m, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
    } else
      try {
        o = s.decode(e);
      } catch (c) {
        if (c.code === M.errors.BUFFER_OVERRUN)
          throw c;
        o = c, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
    o != null && r.push(o);
  });
  const i = t.reduce((s, o) => {
    const c = o.localName;
    return c && (s[c] || (s[c] = 0), s[c]++), s;
  }, {});
  t.forEach((s, o) => {
    let c = s.localName;
    if (!c || i[c] !== 1 || (c === "length" && (c = "_length"), r[c] != null))
      return;
    const f = r[o];
    f instanceof Error ? Object.defineProperty(r, c, {
      enumerable: !0,
      get: () => {
        throw f;
      }
    }) : r[c] = f;
  });
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    o instanceof Error && Object.defineProperty(r, s, {
      enumerable: !0,
      get: () => {
        throw o;
      }
    });
  }
  return Object.freeze(r);
}
class gf extends pr {
  constructor(t, r, n) {
    const i = t.type + "[" + (r >= 0 ? r : "") + "]", s = r === -1 || t.dynamic;
    super("array", i, n, s), this.coder = t, this.length = r;
  }
  defaultValue() {
    const t = this.coder.defaultValue(), r = [];
    for (let n = 0; n < this.length; n++)
      r.push(t);
    return r;
  }
  encode(t, r) {
    Array.isArray(r) || this._throwError("expected array value", r);
    let n = this.length;
    n === -1 && (n = r.length, t.writeValue(r.length)), sn.checkArgumentCount(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let s = 0; s < r.length; s++)
      i.push(this.coder);
    return Ka(t, i, r);
  }
  decode(t) {
    let r = this.length;
    r === -1 && (r = t.readValue().toNumber(), r * 32 > t._data.length && sn.throwError("insufficient data length", M.errors.BUFFER_OVERRUN, {
      length: t._data.length,
      count: r
    }));
    let n = [];
    for (let i = 0; i < r; i++)
      n.push(new mf(this.coder));
    return t.coerce(this.name, Wa(t, n));
  }
}
class yf extends pr {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, r) {
    return t.writeValue(r ? 1 : 0);
  }
  decode(t) {
    return t.coerce(this.type, !t.readValue().isZero());
  }
}
class Xa extends pr {
  constructor(t, r) {
    super(t, t, r, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, r) {
    r = et(r);
    let n = t.writeValue(r.length);
    return n += t.writeBytes(r), n;
  }
  decode(t) {
    return t.readBytes(t.readValue().toNumber(), !0);
  }
}
class vf extends Xa {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return t.coerce(this.name, K(super.decode(t)));
  }
}
class wf extends pr {
  constructor(t, r) {
    let n = "bytes" + String(t);
    super(n, n, r, !1), this.size = t;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(t, r) {
    let n = et(r);
    return n.length !== this.size && this._throwError("incorrect data length", r), t.writeBytes(n);
  }
  decode(t) {
    return t.coerce(this.name, K(t.readBytes(this.size)));
  }
}
class Af extends pr {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, r) {
    return r != null && this._throwError("not null", r), t.writeBytes([]);
  }
  decode(t) {
    return t.readBytes(0), t.coerce(this.name, null);
  }
}
class Ef extends pr {
  constructor(t, r, n) {
    const i = (r ? "int" : "uint") + t * 8;
    super(i, i, n, !1), this.size = t, this.signed = r;
  }
  defaultValue() {
    return 0;
  }
  encode(t, r) {
    let n = V.from(r), i = Wu.mask(t.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (n.gt(s) || n.lt(s.add(Ku).mul(Ju))) && this._throwError("value out-of-bounds", r);
    } else
      (n.lt(ta) || n.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", r);
    return n = n.toTwos(this.size * 8).mask(this.size * 8), this.signed && (n = n.fromTwos(this.size * 8).toTwos(8 * t.wordSize)), t.writeValue(n);
  }
  decode(t) {
    let r = t.readValue().mask(this.size * 8);
    return this.signed && (r = r.fromTwos(this.size * 8)), t.coerce(this.name, r);
  }
}
class bf extends Xa {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, r) {
    return super.encode(t, Oe(r));
  }
  decode(t) {
    return Bn(super.decode(t));
  }
}
class Yn extends pr {
  constructor(t, r) {
    let n = !1;
    const i = [];
    t.forEach((o) => {
      o.dynamic && (n = !0), i.push(o.type);
    });
    const s = "tuple(" + i.join(",") + ")";
    super("tuple", s, r, n), this.coders = t;
  }
  defaultValue() {
    const t = [];
    this.coders.forEach((n) => {
      t.push(n.defaultValue());
    });
    const r = this.coders.reduce((n, i) => {
      const s = i.localName;
      return s && (n[s] || (n[s] = 0), n[s]++), n;
    }, {});
    return this.coders.forEach((n, i) => {
      let s = n.localName;
      !s || r[s] !== 1 || (s === "length" && (s = "_length"), t[s] == null && (t[s] = t[i]));
    }), Object.freeze(t);
  }
  encode(t, r) {
    return Ka(t, this.coders, r);
  }
  decode(t) {
    return t.coerce(this.name, Wa(t, this.coders));
  }
}
const Jn = new M(Ln), Nf = new RegExp(/^bytes([0-9]*)$/), _f = new RegExp(/^(u?int)([0-9]*)$/);
class If {
  constructor(t) {
    U(this, "coerceFunc", t || null);
  }
  _getCoder(t) {
    switch (t.baseType) {
      case "address":
        return new pf(t.name);
      case "bool":
        return new yf(t.name);
      case "string":
        return new bf(t.name);
      case "bytes":
        return new vf(t.name);
      case "array":
        return new gf(this._getCoder(t.arrayChildren), t.arrayLength, t.name);
      case "tuple":
        return new Yn((t.components || []).map((n) => this._getCoder(n)), t.name);
      case "":
        return new Af(t.name);
    }
    let r = t.type.match(_f);
    if (r) {
      let n = parseInt(r[2] || "256");
      return (n === 0 || n > 256 || n % 8 !== 0) && Jn.throwArgumentError("invalid " + r[1] + " bit length", "param", t), new Ef(n / 8, r[1] === "int", t.name);
    }
    if (r = t.type.match(Nf), r) {
      let n = parseInt(r[1]);
      return (n === 0 || n > 32) && Jn.throwArgumentError("invalid bytes length", "param", t), new wf(n, t.name);
    }
    return Jn.throwArgumentError("invalid type", "type", t.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(t, r) {
    return new hi(t, this._getWordSize(), this.coerceFunc, r);
  }
  _getWriter() {
    return new vs(this._getWordSize());
  }
  getDefaultValue(t) {
    const r = t.map((n) => this._getCoder(ae.from(n)));
    return new Yn(r, "_").defaultValue();
  }
  encode(t, r) {
    t.length !== r.length && Jn.throwError("types/values length mismatch", M.errors.INVALID_ARGUMENT, {
      count: { types: t.length, values: r.length },
      value: { types: t, values: r }
    });
    const n = t.map((o) => this._getCoder(ae.from(o))), i = new Yn(n, "_"), s = this._getWriter();
    return i.encode(s, r), s.data;
  }
  decode(t, r, n) {
    const i = t.map((s) => this._getCoder(ae.from(s)));
    return new Yn(i, "_").decode(this._getReader(et(r), n));
  }
}
const Sf = new If(), Kt = new M(Ln);
class Rf extends Cn {
}
class Tf extends Cn {
}
class Of extends Cn {
}
class ws extends Cn {
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const Mf = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function To(e, t) {
  const r = new Error(`deferred error during ABI decoding triggered accessing ${e}`);
  return r.error = t, r;
}
class Oo {
  constructor(t) {
    let r = [];
    typeof t == "string" ? r = JSON.parse(t) : r = t, U(this, "fragments", r.map((n) => lr.from(n)).filter((n) => n != null)), U(this, "_abiCoder", Ke(new.target, "getAbiCoder")()), U(this, "functions", {}), U(this, "errors", {}), U(this, "events", {}), U(this, "structs", {}), this.fragments.forEach((n) => {
      let i = null;
      switch (n.type) {
        case "constructor":
          if (this.deploy) {
            Kt.warn("duplicate definition - constructor");
            return;
          }
          U(this, "deploy", n);
          return;
        case "function":
          i = this.functions;
          break;
        case "event":
          i = this.events;
          break;
        case "error":
          i = this.errors;
          break;
        default:
          return;
      }
      let s = n.format();
      if (i[s]) {
        Kt.warn("duplicate definition - " + s);
        return;
      }
      i[s] = n;
    }), this.deploy || U(this, "deploy", Ye.from({
      payable: !1,
      type: "constructor"
    })), U(this, "_isInterface", !0);
  }
  format(t) {
    t || (t = dt.full), t === dt.sighash && Kt.throwArgumentError("interface does not support formatting sighash", "format", t);
    const r = this.fragments.map((n) => n.format(t));
    return t === dt.json ? JSON.stringify(r.map((n) => JSON.parse(n))) : r;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return Sf;
  }
  static getAddress(t) {
    return ne(t);
  }
  static getSighash(t) {
    return he(nn(t.format()), 0, 4);
  }
  static getEventTopic(t) {
    return nn(t.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(t) {
    if (pt(t)) {
      for (const n in this.functions)
        if (t === this.getSighash(n))
          return this.functions[n];
      Kt.throwArgumentError("no matching function", "sighash", t);
    }
    if (t.indexOf("(") === -1) {
      const n = t.trim(), i = Object.keys(this.functions).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === n);
      return i.length === 0 ? Kt.throwArgumentError("no matching function", "name", n) : i.length > 1 && Kt.throwArgumentError("multiple matching functions", "name", n), this.functions[i[0]];
    }
    const r = this.functions[Je.fromString(t).format()];
    return r || Kt.throwArgumentError("no matching function", "signature", t), r;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(t) {
    if (pt(t)) {
      const n = t.toLowerCase();
      for (const i in this.events)
        if (n === this.getEventTopic(i))
          return this.events[i];
      Kt.throwArgumentError("no matching event", "topichash", n);
    }
    if (t.indexOf("(") === -1) {
      const n = t.trim(), i = Object.keys(this.events).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === n);
      return i.length === 0 ? Kt.throwArgumentError("no matching event", "name", n) : i.length > 1 && Kt.throwArgumentError("multiple matching events", "name", n), this.events[i[0]];
    }
    const r = this.events[ur.fromString(t).format()];
    return r || Kt.throwArgumentError("no matching event", "signature", t), r;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(t) {
    if (pt(t)) {
      const n = Ke(this.constructor, "getSighash");
      for (const i in this.errors) {
        const s = this.errors[i];
        if (t === n(s))
          return this.errors[i];
      }
      Kt.throwArgumentError("no matching error", "sighash", t);
    }
    if (t.indexOf("(") === -1) {
      const n = t.trim(), i = Object.keys(this.errors).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === n);
      return i.length === 0 ? Kt.throwArgumentError("no matching error", "name", n) : i.length > 1 && Kt.throwArgumentError("multiple matching errors", "name", n), this.errors[i[0]];
    }
    const r = this.errors[Je.fromString(t).format()];
    return r || Kt.throwArgumentError("no matching error", "signature", t), r;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(t) {
    if (typeof t == "string")
      try {
        t = this.getFunction(t);
      } catch (r) {
        try {
          t = this.getError(t);
        } catch {
          throw r;
        }
      }
    return Ke(this.constructor, "getSighash")(t);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(t) {
    return typeof t == "string" && (t = this.getEvent(t)), Ke(this.constructor, "getEventTopic")(t);
  }
  _decodeParams(t, r) {
    return this._abiCoder.decode(t, r);
  }
  _encodeParams(t, r) {
    return this._abiCoder.encode(t, r);
  }
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  decodeErrorResult(t, r) {
    typeof t == "string" && (t = this.getError(t));
    const n = et(r);
    return K(n.slice(0, 4)) !== this.getSighash(t) && Kt.throwArgumentError(`data signature does not match error ${t.name}.`, "data", K(n)), this._decodeParams(t.inputs, n.slice(4));
  }
  encodeErrorResult(t, r) {
    return typeof t == "string" && (t = this.getError(t)), K(ge([
      this.getSighash(t),
      this._encodeParams(t.inputs, r || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(t, r) {
    typeof t == "string" && (t = this.getFunction(t));
    const n = et(r);
    return K(n.slice(0, 4)) !== this.getSighash(t) && Kt.throwArgumentError(`data signature does not match function ${t.name}.`, "data", K(n)), this._decodeParams(t.inputs, n.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(t, r) {
    return typeof t == "string" && (t = this.getFunction(t)), K(ge([
      this.getSighash(t),
      this._encodeParams(t.inputs, r || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(t, r) {
    typeof t == "string" && (t = this.getFunction(t));
    let n = et(r), i = null, s = "", o = null, c = null, f = null;
    switch (n.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(t.outputs, n);
        } catch {
        }
        break;
      case 4: {
        const m = K(n.slice(0, 4)), E = Mf[m];
        if (E)
          o = this._abiCoder.decode(E.inputs, n.slice(4)), c = E.name, f = E.signature, E.reason && (i = o[0]), c === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}` : c === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`);
        else
          try {
            const _ = this.getError(m);
            o = this._abiCoder.decode(_.inputs, n.slice(4)), c = _.name, f = _.format();
          } catch {
          }
        break;
      }
    }
    return Kt.throwError("call revert exception" + s, M.errors.CALL_EXCEPTION, {
      method: t.format(),
      data: K(r),
      errorArgs: o,
      errorName: c,
      errorSignature: f,
      reason: i
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(t, r) {
    return typeof t == "string" && (t = this.getFunction(t)), K(this._abiCoder.encode(t.outputs, r || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(t, r) {
    typeof t == "string" && (t = this.getEvent(t)), r.length > t.inputs.length && Kt.throwError("too many arguments for " + t.format(), M.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: r
    });
    let n = [];
    t.anonymous || n.push(this.getEventTopic(t));
    const i = (s, o) => s.type === "string" ? nn(o) : s.type === "bytes" ? ie(K(o)) : (s.type === "bool" && typeof o == "boolean" && (o = o ? "0x01" : "0x00"), s.type.match(/^u?int/) && (o = V.from(o).toHexString()), s.type === "address" && this._abiCoder.encode(["address"], [o]), Xt(K(o), 32));
    for (r.forEach((s, o) => {
      let c = t.inputs[o];
      if (!c.indexed) {
        s != null && Kt.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + c.name, s);
        return;
      }
      s == null ? n.push(null) : c.baseType === "array" || c.baseType === "tuple" ? Kt.throwArgumentError("filtering with tuples or arrays not supported", "contract." + c.name, s) : Array.isArray(s) ? n.push(s.map((f) => i(c, f))) : n.push(i(c, s));
    }); n.length && n[n.length - 1] === null; )
      n.pop();
    return n;
  }
  encodeEventLog(t, r) {
    typeof t == "string" && (t = this.getEvent(t));
    const n = [], i = [], s = [];
    return t.anonymous || n.push(this.getEventTopic(t)), r.length !== t.inputs.length && Kt.throwArgumentError("event arguments/values mismatch", "values", r), t.inputs.forEach((o, c) => {
      const f = r[c];
      if (o.indexed)
        if (o.type === "string")
          n.push(nn(f));
        else if (o.type === "bytes")
          n.push(ie(f));
        else {
          if (o.baseType === "tuple" || o.baseType === "array")
            throw new Error("not implemented");
          n.push(this._abiCoder.encode([o.type], [f]));
        }
      else
        i.push(o), s.push(f);
    }), {
      data: this._abiCoder.encode(i, s),
      topics: n
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(t, r, n) {
    if (typeof t == "string" && (t = this.getEvent(t)), n != null && !t.anonymous) {
      let S = this.getEventTopic(t);
      (!pt(n[0], 32) || n[0].toLowerCase() !== S) && Kt.throwError("fragment/topic mismatch", M.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: S, value: n[0] }), n = n.slice(1);
    }
    let i = [], s = [], o = [];
    t.inputs.forEach((S, O) => {
      S.indexed ? S.type === "string" || S.type === "bytes" || S.baseType === "tuple" || S.baseType === "array" ? (i.push(ae.fromObject({ type: "bytes32", name: S.name })), o.push(!0)) : (i.push(S), o.push(!1)) : (s.push(S), o.push(!1));
    });
    let c = n != null ? this._abiCoder.decode(i, ge(n)) : null, f = this._abiCoder.decode(s, r, !0), m = [], E = 0, _ = 0;
    t.inputs.forEach((S, O) => {
      if (S.indexed)
        if (c == null)
          m[O] = new ws({ _isIndexed: !0, hash: null });
        else if (o[O])
          m[O] = new ws({ _isIndexed: !0, hash: c[_++] });
        else
          try {
            m[O] = c[_++];
          } catch (C) {
            m[O] = C;
          }
      else
        try {
          m[O] = f[E++];
        } catch (C) {
          m[O] = C;
        }
      if (S.name && m[S.name] == null) {
        const C = m[O];
        C instanceof Error ? Object.defineProperty(m, S.name, {
          enumerable: !0,
          get: () => {
            throw To(`property ${JSON.stringify(S.name)}`, C);
          }
        }) : m[S.name] = C;
      }
    });
    for (let S = 0; S < m.length; S++) {
      const O = m[S];
      O instanceof Error && Object.defineProperty(m, S, {
        enumerable: !0,
        get: () => {
          throw To(`index ${S}`, O);
        }
      });
    }
    return Object.freeze(m);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(t) {
    let r = this.getFunction(t.data.substring(0, 10).toLowerCase());
    return r ? new Tf({
      args: this._abiCoder.decode(r.inputs, "0x" + t.data.substring(10)),
      functionFragment: r,
      name: r.name,
      signature: r.format(),
      sighash: this.getSighash(r),
      value: V.from(t.value || "0")
    }) : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(t) {
    let r = this.getEvent(t.topics[0]);
    return !r || r.anonymous ? null : new Rf({
      eventFragment: r,
      name: r.name,
      signature: r.format(),
      topic: this.getEventTopic(r),
      args: this.decodeEventLog(r, t.data, t.topics)
    });
  }
  parseError(t) {
    const r = K(t);
    let n = this.getError(r.substring(0, 10).toLowerCase());
    return n ? new Of({
      args: this._abiCoder.decode(n.inputs, "0x" + r.substring(10)),
      errorFragment: n,
      name: n.name,
      signature: n.format(),
      sighash: this.getSighash(n)
    }) : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(t) {
    return !!(t && t._isInterface);
  }
}
const Pf = "contracts/5.7.0";
var Xr = globalThis && globalThis.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function c(E) {
      try {
        m(n.next(E));
      } catch (_) {
        o(_);
      }
    }
    function f(E) {
      try {
        m(n.throw(E));
      } catch (_) {
        o(_);
      }
    }
    function m(E) {
      E.done ? s(E.value) : i(E.value).then(c, f);
    }
    m((n = n.apply(e, t || [])).next());
  });
};
const $t = new M(Pf);
function li(e, t) {
  return Xr(this, void 0, void 0, function* () {
    const r = yield t;
    typeof r != "string" && $t.throwArgumentError("invalid address or ENS name", "name", r);
    try {
      return ne(r);
    } catch {
    }
    e || $t.throwError("a provider or signer is needed to resolve ENS names", M.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const n = yield e.resolveName(r);
    return n == null && $t.throwArgumentError("resolver or addr is not configured for ENS name", "name", r), n;
  });
}
function ei(e, t, r) {
  return Xr(this, void 0, void 0, function* () {
    return Array.isArray(r) ? yield Promise.all(r.map((n, i) => ei(e, Array.isArray(t) ? t[i] : t[n.name], n))) : r.type === "address" ? yield li(e, t) : r.type === "tuple" ? yield ei(e, t, r.components) : r.baseType === "array" ? Array.isArray(t) ? yield Promise.all(t.map((n) => ei(e, n, r.arrayChildren))) : Promise.reject($t.makeError("invalid value for array", M.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: t
    })) : t;
  });
}
function _i(e, t, r) {
  return Xr(this, void 0, void 0, function* () {
    let n = {};
    r.length === t.inputs.length + 1 && typeof r[r.length - 1] == "object" && (n = se(r.pop())), $t.checkArgumentCount(r.length, t.inputs.length, "passed to contract"), e.signer ? n.from ? n.from = ee({
      override: li(e.signer, n.from),
      signer: e.signer.getAddress()
    }).then((m) => Xr(this, void 0, void 0, function* () {
      return ne(m.signer) !== m.override && $t.throwError("Contract with a Signer cannot override from", M.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), m.override;
    })) : n.from = e.signer.getAddress() : n.from && (n.from = li(e.provider, n.from));
    const i = yield ee({
      args: ei(e.signer || e.provider, r, t.inputs),
      address: e.resolvedAddress,
      overrides: ee(n) || {}
    }), s = e.interface.encodeFunctionData(t, i.args), o = {
      data: s,
      to: i.address
    }, c = i.overrides;
    if (c.nonce != null && (o.nonce = V.from(c.nonce).toNumber()), c.gasLimit != null && (o.gasLimit = V.from(c.gasLimit)), c.gasPrice != null && (o.gasPrice = V.from(c.gasPrice)), c.maxFeePerGas != null && (o.maxFeePerGas = V.from(c.maxFeePerGas)), c.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = V.from(c.maxPriorityFeePerGas)), c.from != null && (o.from = c.from), c.type != null && (o.type = c.type), c.accessList != null && (o.accessList = gn(c.accessList)), o.gasLimit == null && t.gas != null) {
      let m = 21e3;
      const E = et(s);
      for (let _ = 0; _ < E.length; _++)
        m += 4, E[_] && (m += 64);
      o.gasLimit = V.from(t.gas).add(m);
    }
    if (c.value) {
      const m = V.from(c.value);
      !m.isZero() && !t.payable && $t.throwError("non-payable method cannot override value", M.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: n.value
      }), o.value = m;
    }
    c.customData && (o.customData = se(c.customData)), c.ccipReadEnabled && (o.ccipReadEnabled = !!c.ccipReadEnabled), delete n.nonce, delete n.gasLimit, delete n.gasPrice, delete n.from, delete n.value, delete n.type, delete n.accessList, delete n.maxFeePerGas, delete n.maxPriorityFeePerGas, delete n.customData, delete n.ccipReadEnabled;
    const f = Object.keys(n).filter((m) => n[m] != null);
    return f.length && $t.throwError(`cannot override ${f.map((m) => JSON.stringify(m)).join(",")}`, M.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: f
    }), o;
  });
}
function kf(e, t) {
  return function(...r) {
    return _i(e, t, r);
  };
}
function xf(e, t) {
  const r = e.signer || e.provider;
  return function(...n) {
    return Xr(this, void 0, void 0, function* () {
      r || $t.throwError("estimate require a provider or signer", M.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const i = yield _i(e, t, n);
      return yield r.estimateGas(i);
    });
  };
}
function Cf(e, t) {
  const r = t.wait.bind(t);
  t.wait = (n) => r(n).then((i) => (i.events = i.logs.map((s) => {
    let o = Jr(s), c = null;
    try {
      c = e.interface.parseLog(s);
    } catch {
    }
    return c && (o.args = c.args, o.decode = (f, m) => e.interface.decodeEventLog(c.eventFragment, f, m), o.event = c.name, o.eventSignature = c.signature), o.removeListener = () => e.provider, o.getBlock = () => e.provider.getBlock(i.blockHash), o.getTransaction = () => e.provider.getTransaction(i.transactionHash), o.getTransactionReceipt = () => Promise.resolve(i), o;
  }), i));
}
function Za(e, t, r) {
  const n = e.signer || e.provider;
  return function(...i) {
    return Xr(this, void 0, void 0, function* () {
      let s;
      if (i.length === t.inputs.length + 1 && typeof i[i.length - 1] == "object") {
        const f = se(i.pop());
        f.blockTag != null && (s = yield f.blockTag), delete f.blockTag, i.push(f);
      }
      e.deployTransaction != null && (yield e._deployed(s));
      const o = yield _i(e, t, i), c = yield n.call(o, s);
      try {
        let f = e.interface.decodeFunctionResult(t, c);
        return r && t.outputs.length === 1 && (f = f[0]), f;
      } catch (f) {
        throw f.code === M.errors.CALL_EXCEPTION && (f.address = e.address, f.args = i, f.transaction = o), f;
      }
    });
  };
}
function Bf(e, t) {
  return function(...r) {
    return Xr(this, void 0, void 0, function* () {
      e.signer || $t.throwError("sending a transaction requires a signer", M.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), e.deployTransaction != null && (yield e._deployed());
      const n = yield _i(e, t, r), i = yield e.signer.sendTransaction(n);
      return Cf(e, i), i;
    });
  };
}
function Mo(e, t, r) {
  return t.constant ? Za(e, t, r) : Bf(e, t);
}
function $a(e) {
  return e.address && (e.topics == null || e.topics.length === 0) ? "*" : (e.address || "*") + "@" + (e.topics ? e.topics.map((t) => Array.isArray(t) ? t.join("|") : t).join(":") : "");
}
class Pn {
  constructor(t, r) {
    U(this, "tag", t), U(this, "filter", r), this._listeners = [];
  }
  addListener(t, r) {
    this._listeners.push({ listener: t, once: r });
  }
  removeListener(t) {
    let r = !1;
    this._listeners = this._listeners.filter((n) => r || n.listener !== t ? !0 : (r = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((t) => t.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(t) {
    const r = this.listenerCount();
    return this._listeners = this._listeners.filter((n) => {
      const i = t.slice();
      return setTimeout(() => {
        n.listener.apply(this, i);
      }, 0), !n.once;
    }), r;
  }
  prepareEvent(t) {
  }
  // Returns the array that will be applied to an emit
  getEmit(t) {
    return [t];
  }
}
class Df extends Pn {
  constructor() {
    super("error", null);
  }
}
class Po extends Pn {
  constructor(t, r, n, i) {
    const s = {
      address: t
    };
    let o = r.getEventTopic(n);
    i ? (o !== i[0] && $t.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [o], super($a(s), s), U(this, "address", t), U(this, "interface", r), U(this, "fragment", n);
  }
  prepareEvent(t) {
    super.prepareEvent(t), t.event = this.fragment.name, t.eventSignature = this.fragment.format(), t.decode = (r, n) => this.interface.decodeEventLog(this.fragment, r, n);
    try {
      t.args = this.interface.decodeEventLog(this.fragment, t.data, t.topics);
    } catch (r) {
      t.args = null, t.decodeError = r;
    }
  }
  getEmit(t) {
    const r = df(t.args);
    if (r.length)
      throw r[0].error;
    const n = (t.args || []).slice();
    return n.push(t), n;
  }
}
class ko extends Pn {
  constructor(t, r) {
    super("*", { address: t }), U(this, "address", t), U(this, "interface", r);
  }
  prepareEvent(t) {
    super.prepareEvent(t);
    try {
      const r = this.interface.parseLog(t);
      t.event = r.name, t.eventSignature = r.signature, t.decode = (n, i) => this.interface.decodeEventLog(r.eventFragment, n, i), t.args = r.args;
    } catch {
    }
  }
}
class Uf {
  constructor(t, r, n) {
    U(this, "interface", Ke(new.target, "getInterface")(r)), n == null ? (U(this, "provider", null), U(this, "signer", null)) : Un.isSigner(n) ? (U(this, "provider", n.provider || null), U(this, "signer", n)) : vi.isProvider(n) ? (U(this, "provider", n), U(this, "signer", null)) : $t.throwArgumentError("invalid signer or provider", "signerOrProvider", n), U(this, "callStatic", {}), U(this, "estimateGas", {}), U(this, "functions", {}), U(this, "populateTransaction", {}), U(this, "filters", {});
    {
      const o = {};
      Object.keys(this.interface.events).forEach((c) => {
        const f = this.interface.events[c];
        U(this.filters, c, (...m) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(f, m)
        })), o[f.name] || (o[f.name] = []), o[f.name].push(c);
      }), Object.keys(o).forEach((c) => {
        const f = o[c];
        f.length === 1 ? U(this.filters, c, this.filters[f[0]]) : $t.warn(`Duplicate definition of ${c} (${f.join(", ")})`);
      });
    }
    if (U(this, "_runningEvents", {}), U(this, "_wrappedEmits", {}), t == null && $t.throwArgumentError("invalid contract address or ENS name", "addressOrName", t), U(this, "address", t), this.provider)
      U(this, "resolvedAddress", li(this.provider, t));
    else
      try {
        U(this, "resolvedAddress", Promise.resolve(ne(t)));
      } catch {
        $t.throwError("provider is required to use ENS name as contract address", M.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((o) => {
    });
    const i = {}, s = {};
    Object.keys(this.interface.functions).forEach((o) => {
      const c = this.interface.functions[o];
      if (s[o]) {
        $t.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`);
        return;
      }
      s[o] = !0;
      {
        const f = c.name;
        i[`%${f}`] || (i[`%${f}`] = []), i[`%${f}`].push(o);
      }
      this[o] == null && U(this, o, Mo(this, c, !0)), this.functions[o] == null && U(this.functions, o, Mo(this, c, !1)), this.callStatic[o] == null && U(this.callStatic, o, Za(this, c, !0)), this.populateTransaction[o] == null && U(this.populateTransaction, o, kf(this, c)), this.estimateGas[o] == null && U(this.estimateGas, o, xf(this, c));
    }), Object.keys(i).forEach((o) => {
      const c = i[o];
      if (c.length > 1)
        return;
      o = o.substring(1);
      const f = c[0];
      try {
        this[o] == null && U(this, o, this[f]);
      } catch {
      }
      this.functions[o] == null && U(this.functions, o, this.functions[f]), this.callStatic[o] == null && U(this.callStatic, o, this.callStatic[f]), this.populateTransaction[o] == null && U(this.populateTransaction, o, this.populateTransaction[f]), this.estimateGas[o] == null && U(this.estimateGas, o, this.estimateGas[f]);
    });
  }
  static getContractAddress(t) {
    return Ko(t);
  }
  static getInterface(t) {
    return Oo.isInterface(t) ? t : new Oo(t);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(t) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, t).then((r) => (r === "0x" && $t.throwError("contract not deployed", M.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(t) {
    this.signer || $t.throwError("sending a transactions require a signer", M.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const r = se(t || {});
    return ["from", "to"].forEach(function(n) {
      r[n] != null && $t.throwError("cannot override " + n, M.errors.UNSUPPORTED_OPERATION, { operation: n });
    }), r.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(r));
  }
  // Reconnect to a different signer or provider
  connect(t) {
    typeof t == "string" && (t = new Ps(t, this.provider));
    const r = new this.constructor(this.address, this.interface, t);
    return this.deployTransaction && U(r, "deployTransaction", this.deployTransaction), r;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(t) {
    return new this.constructor(t, this.interface, this.signer || this.provider);
  }
  static isIndexed(t) {
    return ws.isIndexed(t);
  }
  _normalizeRunningEvent(t) {
    return this._runningEvents[t.tag] ? this._runningEvents[t.tag] : t;
  }
  _getRunningEvent(t) {
    if (typeof t == "string") {
      if (t === "error")
        return this._normalizeRunningEvent(new Df());
      if (t === "event")
        return this._normalizeRunningEvent(new Pn("event", null));
      if (t === "*")
        return this._normalizeRunningEvent(new ko(this.address, this.interface));
      const r = this.interface.getEvent(t);
      return this._normalizeRunningEvent(new Po(this.address, this.interface, r));
    }
    if (t.topics && t.topics.length > 0) {
      try {
        const n = t.topics[0];
        if (typeof n != "string")
          throw new Error("invalid topic");
        const i = this.interface.getEvent(n);
        return this._normalizeRunningEvent(new Po(this.address, this.interface, i, t.topics));
      } catch {
      }
      const r = {
        address: this.address,
        topics: t.topics
      };
      return this._normalizeRunningEvent(new Pn($a(r), r));
    }
    return this._normalizeRunningEvent(new ko(this.address, this.interface));
  }
  _checkRunningEvents(t) {
    if (t.listenerCount() === 0) {
      delete this._runningEvents[t.tag];
      const r = this._wrappedEmits[t.tag];
      r && t.filter && (this.provider.off(t.filter, r), delete this._wrappedEmits[t.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(t, r, n) {
    const i = Jr(r);
    return i.removeListener = () => {
      n && (t.removeListener(n), this._checkRunningEvents(t));
    }, i.getBlock = () => this.provider.getBlock(r.blockHash), i.getTransaction = () => this.provider.getTransaction(r.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(r.transactionHash), t.prepareEvent(i), i;
  }
  _addEventListener(t, r, n) {
    if (this.provider || $t.throwError("events require a provider or a signer with a provider", M.errors.UNSUPPORTED_OPERATION, { operation: "once" }), t.addListener(r, n), this._runningEvents[t.tag] = t, !this._wrappedEmits[t.tag]) {
      const i = (s) => {
        let o = this._wrapEvent(t, s, r);
        if (o.decodeError == null)
          try {
            const c = t.getEmit(o);
            this.emit(t.filter, ...c);
          } catch (c) {
            o.decodeError = c.error;
          }
        t.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o);
      };
      this._wrappedEmits[t.tag] = i, t.filter != null && this.provider.on(t.filter, i);
    }
  }
  queryFilter(t, r, n) {
    const i = this._getRunningEvent(t), s = se(i.filter);
    return typeof r == "string" && pt(r, 32) ? (n != null && $t.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), s.blockHash = r) : (s.fromBlock = r ?? 0, s.toBlock = n ?? "latest"), this.provider.getLogs(s).then((o) => o.map((c) => this._wrapEvent(i, c, null)));
  }
  on(t, r) {
    return this._addEventListener(this._getRunningEvent(t), r, !1), this;
  }
  once(t, r) {
    return this._addEventListener(this._getRunningEvent(t), r, !0), this;
  }
  emit(t, ...r) {
    if (!this.provider)
      return !1;
    const n = this._getRunningEvent(t), i = n.run(r) > 0;
    return this._checkRunningEvents(n), i;
  }
  listenerCount(t) {
    return this.provider ? t == null ? Object.keys(this._runningEvents).reduce((r, n) => r + this._runningEvents[n].listenerCount(), 0) : this._getRunningEvent(t).listenerCount() : 0;
  }
  listeners(t) {
    if (!this.provider)
      return [];
    if (t == null) {
      const r = [];
      for (let n in this._runningEvents)
        this._runningEvents[n].listeners().forEach((i) => {
          r.push(i);
        });
      return r;
    }
    return this._getRunningEvent(t).listeners();
  }
  removeAllListeners(t) {
    if (!this.provider)
      return this;
    if (t == null) {
      for (const n in this._runningEvents) {
        const i = this._runningEvents[n];
        i.removeAllListeners(), this._checkRunningEvents(i);
      }
      return this;
    }
    const r = this._getRunningEvent(t);
    return r.removeAllListeners(), this._checkRunningEvents(r), this;
  }
  off(t, r) {
    if (!this.provider)
      return this;
    const n = this._getRunningEvent(t);
    return n.removeListener(r), this._checkRunningEvents(n), this;
  }
  removeListener(t, r) {
    return this.off(t, r);
  }
}
class Lf extends Uf {
}
const tu = Xu, Ff = {
  [te.Arbitrum]: jr.ARB,
  [te.Ethereum]: jr.ETH,
  [te.Avalanche]: jr.AVAX,
  [te.BinanceSmartChain]: jr.BSC,
  [te.Polygon]: jr.MATIC,
  [te.Optimism]: jr.OP
}, Gf = ["payable", "nonpayable"], Hf = (e) => e.type === 2 || !!e.maxFeePerGas || !!e.maxPriorityFeePerGas, Fn = (e) => !!e.provider || !!e.jsonRpcFetchFunc, Gn = (e, t, r) => new Lf(e, t, r), Vf = (e) => {
  try {
    return ne(e), !0;
  } catch {
    return !1;
  }
}, eu = (e, t) => {
  const r = e.find(
    (n) => n.name === t
  );
  if (!r)
    throw new Error(`No ABI fragment found for function ${t}`);
  return r.stateMutability && Gf.includes(r.stateMutability);
}, ru = (e) => e ? new Fe(e.chain, e.symbol, e.synth, e.ticker) : Sr(te.Ethereum), Ii = async (e, {
  callProvider: t,
  signer: r,
  contractAddress: n,
  abi: i,
  funcName: s,
  funcParams: o = [],
  txOverrides: c
}) => {
  const f = t || e;
  if (!n)
    throw new Error("contractAddress must be provided");
  const m = eu(i, s);
  if (m && Fn(f) && r) {
    const S = await xs(f, {
      contractAddress: n,
      abi: i,
      funcName: s,
      funcParams: o,
      txOverrides: c
    });
    return Si(f, S);
  }
  const E = Gn(n, i, f);
  if (m) {
    if (!r)
      throw new Error("Signer is not defined");
    const S = (c == null ? void 0 : c.from) || await r.getAddress();
    if (!S)
      throw new Error("No signer address found");
    const O = await E.connect(r)[s](...o, {
      ...c,
      /**
       * nonce must be set due to a possible bug with ethers.js,
       * expecting a synchronous nonce while the JsonRpcProvider delivers Promise
       */
      nonce: (c == null ? void 0 : c.nonce) || await f.getTransactionCount(S)
    });
    return typeof (O == null ? void 0 : O.hash) == "string" ? O == null ? void 0 : O.hash : O;
  }
  const _ = await E[s](...o);
  return typeof (_ == null ? void 0 : _.hash) == "string" ? _ == null ? void 0 : _.hash : _;
}, xs = async (e, { contractAddress: t, abi: r, funcName: n, funcParams: i = [], txOverrides: s }) => Gn(t, r, e).populateTransaction[n](
  ...i.concat(s).filter((o) => typeof o < "u")
), nu = async (e, { assetAddress: t, spenderAddress: r, from: n }) => V.from(
  await Ii(e, {
    contractAddress: t,
    abi: pi,
    funcName: "allowance",
    funcParams: [n, r]
  })
).toString(), zf = async (e, { assetAddress: t, spenderAddress: r, from: n, amount: i = tu }) => V.from(await nu(e, { assetAddress: t, spenderAddress: r, from: n })).gte(
  i
), qf = async (e, {
  assetAddress: t,
  spenderAddress: r,
  feeOptionKey: n = Ee.Fast,
  amount: i = tu,
  gasLimitFallback: s,
  from: o,
  nonce: c
}, f, m = !0) => {
  if (!i)
    throw new Error("amount must be provided");
  const E = [r, V.from(i)], _ = {
    contractAddress: t,
    abi: pi,
    funcName: "approve",
    funcParams: E,
    signer: f,
    txOverrides: { from: o }
  };
  if (Fn(e))
    return Si(
      e,
      await xs(e, _)
    );
  const { maxFeePerGas: S, maxPriorityFeePerGas: O, gasPrice: C } = (await Cs(e, m))[n], F = await Bs(e, _).catch(
    () => V.from(s)
  );
  return Ii(e, {
    ..._,
    funcParams: E,
    txOverrides: {
      from: o,
      maxFeePerGas: S,
      maxPriorityFeePerGas: O,
      gasPrice: C,
      gasLimit: F,
      nonce: c
    }
  });
}, jf = async (e, {
  asset: t,
  memo: r,
  amount: n,
  recipient: i,
  feeOptionKey: s = Ee.Fast,
  data: o,
  from: c,
  ...f
}, m, E = !0) => {
  const _ = n.amount(), S = ru(t), O = S.L1Chain;
  if (!qo(S)) {
    const L = su(S, O);
    if (!L)
      throw new Error("No contract address found");
    return Ii(e, {
      signer: m,
      contractAddress: L,
      abi: pi,
      funcName: "transfer",
      funcParams: [i, _],
      txOverrides: { from: c }
    });
  }
  const { hexlify: C } = await Promise.resolve().then(() => fu), F = {
    ...f,
    from: c,
    to: i,
    value: _,
    data: o || C(Oe(r || ""))
  };
  return iu(e, F, s, m, E);
}, Cs = async (e, t = !0) => {
  try {
    const { maxFeePerGas: r, maxPriorityFeePerGas: n, gasPrice: i } = await e.getFeeData();
    switch (t) {
      case !0:
        if (!r || !n)
          throw new Error("No fee data available");
        return {
          [Ee.Average]: {
            maxFeePerGas: r,
            maxPriorityFeePerGas: n
          },
          [Ee.Fast]: {
            maxFeePerGas: r.mul(15).div(10),
            maxPriorityFeePerGas: n.mul(15).div(10)
          },
          [Ee.Fastest]: {
            maxFeePerGas: r.mul(2),
            maxPriorityFeePerGas: n.mul(2)
          }
        };
      case !1:
        if (!i)
          throw new Error("No fee data available");
        return {
          [Ee.Average]: {
            gasPrice: i
          },
          [Ee.Fast]: {
            gasPrice: i.mul(15).div(10)
          },
          [Ee.Fastest]: {
            gasPrice: i.mul(2)
          }
        };
    }
  } catch (r) {
    throw new Error(
      `Failed to estimate gas price: ${r.msg ?? r.toString()}`
    );
  }
}, Bs = async (e, {
  signer: t,
  contractAddress: r,
  abi: n,
  funcName: i,
  funcParams: s = [],
  txOverrides: o
}) => {
  if (!r)
    throw new Error("contractAddress must be provided");
  const c = Gn(r, n, e);
  return t ? c.connect(t).estimateGas[i](...s, o) : c.estimateGas[i](...s, o);
}, Qf = async (e, {
  asset: t,
  recipient: r,
  amount: n,
  memo: i,
  from: s,
  funcName: o,
  funcParams: c,
  txOverrides: f,
  signer: m
}) => {
  const E = n.amount(), _ = ru(t), S = qo(_) ? null : su(_, _.L1Chain);
  return S && o ? Bs(e, {
    contractAddress: S,
    abi: pi,
    funcName: o,
    funcParams: c,
    txOverrides: f,
    signer: m
  }) : e.estimateGas({
    from: s,
    to: r,
    value: E,
    data: i ? Oe(i) : void 0
  });
}, iu = async (e, t, r = Ee.Fast, n, i = !0) => {
  if (!n)
    throw new Error("Signer is not defined");
  const { from: s, to: o, data: c, value: f, ...m } = t;
  if (!o)
    throw new Error("No to address provided");
  const E = {
    ...m,
    data: c || "0x",
    to: o,
    from: s,
    value: V.from(f || 0).toHexString()
  };
  if (Fn(e))
    return Si(e, E);
  const _ = s || await n.getAddress(), S = t.nonce || await e.getTransactionCount(_), O = (await e.getNetwork()).chainId, C = Hf(t) || i, F = C && (!t.maxFeePerGas || !t.maxPriorityFeePerGas) || !t.gasPrice ? Object.entries(
    (await Cs(e, i))[r]
  ).reduce(
    (D, [P, X]) => ({ ...D, [P]: V.from(X).toHexString() }),
    {}
  ) : {};
  let L;
  try {
    L = V.from(
      t.gasLimit || (await e.estimateGas(t)).mul(110).div(100)
    ).toHexString();
  } catch (D) {
    throw new Error(`Error estimating gas limit: ${JSON.stringify(D)}`);
  }
  try {
    const D = {
      ...E,
      chainId: O,
      type: C ? 2 : 0,
      gasLimit: L,
      nonce: S,
      ...F
    }, P = await n.sendTransaction(D);
    return typeof (P == null ? void 0 : P.hash) == "string" ? P.hash : P;
  } catch (D) {
    throw new Error(`Error sending transaction: ${JSON.stringify(D)}`);
  }
}, Si = async (e, { from: t, to: r, data: n, value: i }) => {
  var s, o;
  if (!Fn(e))
    throw new Error("Provider is not EIP-1193 compatible");
  return (o = (s = e.provider) == null ? void 0 : s.request) == null ? void 0 : o.call(s, {
    method: "eth_sendTransaction",
    params: [{ value: V.from(i || 0).toHexString(), from: t, to: r, data: n }]
  });
}, su = ({ chain: e, symbol: t, ticker: r }, n) => {
  try {
    return e === n && t === n && r === n || e === te.BinanceSmartChain && t === "BNB" && r === "BNB" ? Ff[n] : ne(t.slice(r.length + 1).replace(/^0X/, ""));
  } catch {
    return null;
  }
}, Ds = ({
  provider: e,
  signer: t,
  isEIP1559Compatible: r = !0
}) => ({
  approve: (n) => qf(e, n, t, r),
  approvedAmount: (n) => nu(e, n),
  broadcastTransaction: e.sendTransaction,
  call: (n) => Ii(e, { ...n, signer: t }),
  createContract: Gn,
  createContractTxObject: (n) => xs(e, n),
  EIP1193SendTransaction: (n) => Si(e, n),
  estimateCall: (n) => Bs(e, { ...n, signer: t }),
  estimateGasLimit: ({ asset: n, recipient: i, amount: s, memo: o }) => Qf(e, { asset: n, recipient: i, amount: s, memo: o, signer: t }),
  estimateGasPrices: () => Cs(e, r),
  isApproved: (n) => zf(e, n),
  sendTransaction: (n, i) => iu(e, n, i, t, r),
  transfer: (n) => jf(e, n, t, r),
  validateAddress: Vf
}), Yf = async (e, t) => {
  const r = af(te.Avalanche), n = await e.getBalance(t), i = await r.getBalance(t), s = hr(i, cn.AVAX);
  return [
    { asset: Sr(te.Avalanche), amount: s },
    ...n
  ];
}, Jf = () => ({
  chainId: Zr.AvalancheHex,
  chainName: "Avalanche Network",
  nativeCurrency: { name: "Avalanche", symbol: te.Avalanche, decimals: cn.AVAX },
  // Use external rpc URL so wallets don't throw warning to user
  rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
  blockExplorerUrls: [Go[te.Avalanche]]
}), Zf = ({
  api: e,
  provider: t,
  signer: r,
  covalentApiKey: n
}) => {
  const i = e || jo({ apiKey: n, chainId: Zr.Avalanche });
  return {
    ...Ds({ provider: t, signer: r }),
    getNetworkParams: Jf,
    getBalance: (s) => Yf(i, s)
  };
}, Kf = async (e, t, r) => {
  const n = await t.getBalance(r), i = await e.getBalance(r);
  return [
    {
      asset: Sr(te.BinanceSmartChain),
      amount: hr(i, cn.BSC)
    },
    ...n
  ];
}, Wf = () => ({
  chainId: Zr.BinanceSmartChainHex,
  chainName: "Smart Chain",
  nativeCurrency: { name: "Binance Coin", symbol: te.Binance, decimals: cn.BSC },
  rpcUrls: ["https://bsc-dataseed.binance.org"],
  blockExplorerUrls: [Go[te.BinanceSmartChain]]
}), $f = ({
  api: e,
  provider: t,
  signer: r,
  covalentApiKey: n
}) => {
  const i = e || jo({ apiKey: n, chainId: Zr.BinanceSmartChain }), s = Ds({ provider: t, signer: r, isEIP1559Compatible: !1 }), o = async (c, {
    callProvider: f,
    signer: m,
    contractAddress: E,
    abi: _,
    funcName: S,
    funcParams: O = [],
    txOverrides: C
  }) => {
    const F = f || c;
    if (!E)
      throw new Error("contractAddress must be provided");
    const L = eu(_, S), D = L ? { ...(await s.estimateGasPrices()).average } : {};
    if (L && Fn(F) && m) {
      const rt = await s.createContractTxObject({
        contractAddress: E,
        abi: _,
        funcName: S,
        funcParams: O,
        txOverrides: { ...D, ...C }
      });
      return s.EIP1193SendTransaction(rt);
    }
    const P = Gn(E, _, F);
    if (L) {
      if (!m)
        throw new Error("Signer is not defined");
      const rt = (C == null ? void 0 : C.from) || await m.getAddress();
      if (!rt)
        throw new Error("No signer address found");
      const $ = await P.connect(m)[S](...O, {
        ...D,
        ...C,
        /**
         * nonce must be set due to a possible bug with ethers.js,
         * expecting a synchronous nonce while the JsonRpcProvider delivers Promise
         */
        nonce: (C == null ? void 0 : C.nonce) || await F.getTransactionCount(rt)
      });
      return typeof ($ == null ? void 0 : $.hash) == "string" ? $ == null ? void 0 : $.hash : $;
    }
    const X = await P[S](...O);
    return typeof (X == null ? void 0 : X.hash) == "string" ? X == null ? void 0 : X.hash : X;
  };
  return {
    ...s,
    call: (c) => o(t, { signer: r, ...c }),
    getNetworkParams: Wf,
    getBalance: (c) => Kf(t, i, c)
  };
}, Xf = async (e, t, r) => {
  const n = await t.getBalance(r), i = await e.getBalance(r), s = hr(i, cn.ETH);
  return [
    { asset: Sr(te.Ethereum), amount: s },
    ...n
  ];
}, t0 = ({
  api: e,
  ethplorerApiKey: t,
  signer: r,
  provider: n
}) => {
  const i = e || Cu(t);
  return {
    ...Ds({ provider: n, signer: r }),
    getBalance: (s) => Xf(n, i, s)
  };
};
export {
  Zf as AVAXToolbox,
  $f as BSCToolbox,
  Ds as BaseEVMToolbox,
  Si as EIP1193SendTransaction,
  t0 as ETHToolbox,
  tu as MAX_APPROVAL,
  jo as covalentApi,
  Cu as ethplorerApi,
  af as getProvider,
  su as getTokenAddress
};
