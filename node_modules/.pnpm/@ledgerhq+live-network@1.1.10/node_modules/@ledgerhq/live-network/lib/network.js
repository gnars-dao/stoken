"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorInterceptor = exports.responseInterceptor = exports.requestInterceptor = void 0;
const errors_1 = require("@ledgerhq/errors");
const live_env_1 = require("@ledgerhq/live-env");
const live_promise_1 = require("@ledgerhq/live-promise");
const logs_1 = require("@ledgerhq/logs");
const axios_1 = __importDefault(require("axios"));
const invariant_1 = __importDefault(require("invariant"));
const requestInterceptor = (request) => {
    if (!(0, live_env_1.getEnv)("ENABLE_NETWORK_LOGS")) {
        return request;
    }
    const { baseURL, url, method = "", data } = request;
    (0, logs_1.log)("network", `${method} ${baseURL || ""}${url}`, { data });
    const req = request;
    req.metadata = {
        startTime: Date.now(),
    };
    return req;
};
exports.requestInterceptor = requestInterceptor;
const responseInterceptor = (response) => {
    if (!(0, live_env_1.getEnv)("ENABLE_NETWORK_LOGS")) {
        return response;
    }
    const { baseURL, url, method = "", metadata } = response.config;
    const { startTime = 0 } = metadata || {};
    (0, logs_1.log)("network-success", `${response.status} ${method} ${baseURL || ""}${url} (${(Date.now() - startTime).toFixed(0)}ms)`, { data: response.data });
    return response;
};
exports.responseInterceptor = responseInterceptor;
const errorInterceptor = (error) => {
    var _a;
    const config = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.config;
    if (!config)
        throw error;
    const { baseURL, url, method = "", metadata } = config;
    const { startTime = 0 } = metadata || {};
    const duration = `${(Date.now() - startTime).toFixed(0)}ms`;
    let errorToThrow;
    if (error.response) {
        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        const { data, status } = error.response;
        let msg;
        try {
            if (data && typeof data === "string") {
                msg = extractErrorMessage(data);
            }
            else if (data && typeof data === "object") {
                msg = getErrorMessage(data);
            }
        }
        catch (e) {
            (0, logs_1.log)("warn", "can't parse server result " + String(e));
        }
        if (msg) {
            errorToThrow = makeError(msg, status, url, method);
        }
        else {
            errorToThrow = makeError(`API HTTP ${status}`, status, url, method);
        }
        (0, logs_1.log)("network-error", `${status} ${method} ${baseURL || ""}${url} (${duration}): ${errorToThrow.message}`, (0, live_env_1.getEnv)("DEBUG_HTTP_RESPONSE") ? { data: data } : {});
        throw errorToThrow;
    }
    else if (error.request) {
        (0, logs_1.log)("network-down", `DOWN ${method} ${baseURL || ""}${url} (${duration})`);
        throw new errors_1.NetworkDown();
    }
    throw error;
};
exports.errorInterceptor = errorInterceptor;
axios_1.default.interceptors.request.use(exports.requestInterceptor);
axios_1.default.interceptors.response.use(exports.responseInterceptor, exports.errorInterceptor);
// not react native
if (!(typeof navigator !== "undefined" && navigator.product === "ReactNative")) {
    // the keepAlive is necessary when we make a lot of request in in parallel, especially for bitcoin sync. Otherwise, it may raise "connect ETIMEDOUT" error
    // refer to https://stackoverflow.com/questions/63064393/getting-axios-error-connect-etimedout-when-making-high-volume-of-calls
    // eslint-disable-next-line global-require,@typescript-eslint/no-var-requires
    const https = require("https");
    axios_1.default.defaults.httpsAgent = new https.Agent({ keepAlive: true });
}
const makeError = (msg, status, url, method) => {
    const obj = {
        status,
        url,
        method,
    };
    return (status || "").toString().startsWith("4")
        ? new errors_1.LedgerAPI4xx(msg, obj)
        : new errors_1.LedgerAPI5xx(msg, obj);
};
const getErrorMessage = (data) => {
    if (!data)
        return "";
    if (typeof data === "string")
        return data;
    if (data.errors) {
        return getErrorMessage(data.errors[0]);
    }
    return data.message || data.error_message || data.error || data.msg;
};
const extractErrorMessage = (raw) => {
    let data = JSON.parse(raw);
    if (data && Array.isArray(data))
        data = data[0];
    let msg = getErrorMessage(data);
    if (typeof msg === "string") {
        const m = msg.match(/^JsDefined\((.*)\)$/);
        const innerPart = m ? m[1] : msg;
        const r = JSON.parse(innerPart);
        let message = r.message;
        if (typeof message === "object") {
            message = message.message;
        }
        if (typeof message === "string") {
            msg = message;
        }
        return msg ? String(msg) : undefined;
    }
    return;
};
const implementation = (arg) => {
    (0, invariant_1.default)(typeof arg === "object", "network takes an object as parameter");
    let promise;
    if (arg.method === "GET") {
        if (!("timeout" in arg)) {
            arg.timeout = (0, live_env_1.getEnv)("GET_CALLS_TIMEOUT");
        }
        promise = (0, live_promise_1.retry)(() => (0, axios_1.default)(arg), {
            maxRetry: (0, live_env_1.getEnv)("GET_CALLS_RETRY"),
        });
    }
    else {
        promise = (0, axios_1.default)(arg);
    }
    return promise;
};
// attach the env "LEDGER_CLIENT_VERSION" to set the header globally for axios
function setAxiosLedgerClientVersionHeader(value) {
    if (value) {
        axios_1.default.defaults.headers.common["X-Ledger-Client-Version"] = value;
    }
    else {
        delete axios_1.default.defaults.headers.common["X-Ledger-Client-Version"];
    }
}
setAxiosLedgerClientVersionHeader((0, live_env_1.getEnv)("LEDGER_CLIENT_VERSION"));
live_env_1.changes.subscribe(e => {
    if (e.name === "LEDGER_CLIENT_VERSION") {
        setAxiosLedgerClientVersionHeader(e.value);
    }
});
exports.default = implementation;
//# sourceMappingURL=network.js.map