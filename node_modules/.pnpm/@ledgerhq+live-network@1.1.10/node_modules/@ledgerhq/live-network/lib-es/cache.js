import LRU from "lru-cache";
/**
 * Creates an LRU cache function that wraps the given async function `f`.
 * By default it will have a lifespan of 300 seconds and a change in the key
 * will invalidate its value.
 *
 * @param {(...args: A) => Promise<T>} f - The async function to be cached.
 * @param {(...args: A) => string} [keyExtractor] - A function that extracts a cache key from the arguments passed to `f`.
 * @param {LRU.Options<string, any>} [lruOpts] - Options for the internal LRU cache.
 *
 * @returns {CacheRes<A, T>} A cached version of the async function `f`.
 */
export const makeLRUCache = (f, keyExtractor = () => "", lruOpts = {
    max: 100,
    ttl: 5 * 60 * 1000,
}) => {
    // LRU-Cache is written in JS and do not enforce in its code the type checking.
    // Regarding its [documentation](https://github.com/isaacs/node-lru-cache/#ttl), `max` or `ttlAutopurge` must be set.
    // As the code in live use sometimes `max` property with `ttl`, we check it's defined in `lruOpts` to add or not `ttlAutopurge`.
    // eslint-disable-next-line
    // @ts-ignore: TS-2339
    lruOpts = lruOpts.max
        ? lruOpts
        : Object.assign(Object.assign({}, lruOpts), { ttlAutopurge: true });
    const cache = new LRU(lruOpts);
    const result = (...args) => {
        const key = keyExtractor(...args);
        let promise = cache.get(key);
        if (promise)
            return promise;
        promise = f(...args).catch(e => {
            cache.delete(key);
            throw e;
        });
        cache.set(key, promise);
        return promise;
    };
    result.force = (...args) => {
        const key = keyExtractor(...args);
        const promise = f(...args).catch(e => {
            cache.delete(key);
            throw e;
        });
        cache.set(key, promise);
        return promise;
    };
    result.hydrate = (key, value) => {
        cache.set(key, Promise.resolve(value));
    };
    result.clear = (key) => {
        cache.delete(key);
    };
    result.reset = () => {
        cache.clear();
    };
    return result;
};
//# sourceMappingURL=cache.js.map