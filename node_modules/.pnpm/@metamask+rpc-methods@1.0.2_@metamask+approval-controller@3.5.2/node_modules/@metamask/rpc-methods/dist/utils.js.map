{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,iDAAmE;AAEnE,2CAOyB;AACzB,6CAA6D;AAC7D,6CAA8C;AAE9C,MAAM,cAAc,GAAG,UAAU,CAAC;AAWlC;;;;;;;;;;;GAWG;AACH,SAAgB,WAAW,CAIzB,KAAY,EACZ,SAAqC;IAErC,IAAI,SAAS,EAAE;QACb,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CAClC,CAAC,UAAU,EAAE,SAAS,EAAE,EAAE;YACxB,MAAM,QAAQ,GAAG,SAAqB,CAAC;YACvC,UAAU,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;YACvC,OAAO,UAAU,CAAC;QACpB,CAAC,EACD,EAAE,CACsB,CAAC;KAC5B;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAlBD,kCAkBC;AAED;;;;;;GAMG;AACH,SAAS,sBAAsB,CAAC,IAAgB;IAC9C,MAAM,KAAK,GAAwB,EAAE,CAAC;IACtC,MAAM,IAAI,GAAG,IAAA,sBAAc,EAAC,IAAI,CAAC,CAAC;IAElC,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE;QACtC,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAEzC,2EAA2E;QAC3E,0EAA0E;QAC1E,mCAAmC;QACnC,sCAAsC;QACtC,MAAM,SAAS,GAAG,CAAC,MAAM,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QAClD,KAAK,CAAC,IAAI,CAAC,SAAS,SAAS,GAAG,cAAc,GAAY,CAAC,CAAC;KAC7D;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAyBD;;;;;;;;;;;;;;GAcG;AACI,KAAK,UAAU,aAAa,CAAC,EAClC,KAAK,EACL,IAAI,GAAG,EAAE,EACT,cAAc,EACd,KAAK,GACgB;IACrB,MAAM,UAAU,GAAG,IAAA,qBAAa,EAAC,KAAK,CAAC,CAAC;IACxC,MAAM,SAAS,GAAG,IAAA,qBAAa,EAAC,IAAI,CAAC,CAAC;IAEtC,4CAA4C;IAC5C,MAAM,IAAI,GAAG,IAAA,iBAAS,EAAC,IAAA,mBAAW,EAAC,CAAC,UAAU,EAAE,IAAA,iBAAS,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACxE,MAAM,sBAAsB,GAAG,sBAAsB,CAAC,IAAI,CAAC,CAAC;IAE5D,uCAAuC;IACvC,MAAM,EAAE,UAAU,EAAE,GAAG,MAAM,qBAAU,CAAC,kBAAkB,CAAC;QACzD,cAAc,EAAE;YACd,cAAc;YACd,SAAS,KAAK,EAAE;YAChB,GAAG,sBAAsB;SAC1B;QACD,KAAK,EAAE,WAAW;KACnB,CAAC,CAAC;IAEH,6DAA6D;IAC7D,IAAA,cAAM,EAAC,UAAU,EAAE,+BAA+B,CAAC,CAAC;IAEpD,OAAO,IAAA,aAAK,EAAC,UAAU,CAAC,CAAC;AAC3B,CAAC;AA3BD,sCA2BC;AAwBD;;;;;;GAMG;AACH,SAAgB,SAAS,CACvB,QAAW;IAEX,OAAO,IAAA,qBAAO,EAAC,QAA0B,CAAC,CAAC;AAC7C,CAAC;AAJD,8BAIC","sourcesContent":["import { HardenedBIP32Node, SLIP10Node } from '@metamask/key-tree';\nimport { MagicValue } from '@metamask/snaps-utils';\nimport {\n  add0x,\n  assert,\n  concatBytes,\n  createDataView,\n  Hex,\n  stringToBytes,\n} from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\nimport { literal, Struct } from 'superstruct';\n\nconst HARDENED_VALUE = 0x80000000;\n\n/**\n * Maps an interface with method hooks to an object, using the keys of the\n * interface, and `true` as value. This ensures that the `methodHooks` object\n * has the same values as the interface.\n */\nexport type MethodHooksObject<HooksType extends Record<string, unknown>> = {\n  [Key in keyof HooksType]: true;\n};\n\n/**\n * Returns the subset of the specified `hooks` that are included in the\n * `hookNames` object. This is a Principle of Least Authority (POLA) measure\n * to ensure that each RPC method implementation only has access to the\n * API \"hooks\" it needs to do its job.\n *\n * @param hooks - The hooks to select from.\n * @param hookNames - The names of the hooks to select.\n * @returns The selected hooks.\n * @template Hooks - The hooks to select from.\n * @template HookName - The names of the hooks to select.\n */\nexport function selectHooks<\n  Hooks extends Record<string, unknown>,\n  HookName extends keyof Hooks,\n>(\n  hooks: Hooks,\n  hookNames?: Record<HookName, boolean>,\n): Pick<Hooks, HookName> | undefined {\n  if (hookNames) {\n    return Object.keys(hookNames).reduce<Partial<Pick<Hooks, HookName>>>(\n      (hookSubset, _hookName) => {\n        const hookName = _hookName as HookName;\n        hookSubset[hookName] = hooks[hookName];\n        return hookSubset;\n      },\n      {},\n    ) as Pick<Hooks, HookName>;\n  }\n  return undefined;\n}\n\n/**\n * Get a BIP-32 derivation path array from a hash, which is compatible with\n * `@metamask/key-tree`. The hash is assumed to be 32 bytes long.\n *\n * @param hash - The hash to derive indices from.\n * @returns The derived indices as a {@link HardenedBIP32Node} array.\n */\nfunction getDerivationPathArray(hash: Uint8Array): HardenedBIP32Node[] {\n  const array: HardenedBIP32Node[] = [];\n  const view = createDataView(hash);\n\n  for (let index = 0; index < 8; index++) {\n    const uint32 = view.getUint32(index * 4);\n\n    // This is essentially `index | 0x80000000`. Because JavaScript numbers are\n    // signed, we use the bitwise unsigned right shift operator to ensure that\n    // the result is a positive number.\n    // eslint-disable-next-line no-bitwise\n    const pathIndex = (uint32 | HARDENED_VALUE) >>> 0;\n    array.push(`bip32:${pathIndex - HARDENED_VALUE}'` as const);\n  }\n\n  return array;\n}\n\ntype DeriveEntropyOptions = {\n  /**\n   * The input value to derive entropy from.\n   */\n  input: string;\n\n  /**\n   * An optional salt to use when deriving entropy.\n   */\n  salt?: string;\n\n  /**\n   * The mnemonic phrase to use for entropy derivation.\n   */\n  mnemonicPhrase: Uint8Array;\n\n  /**\n   * A hardened BIP-32 index, which is used to derive the root key from the\n   * mnemonic phrase.\n   */\n  magic: MagicValue;\n};\n\n/**\n * Derive entropy from the given mnemonic phrase and salt.\n *\n * This is based on the reference implementation of\n * [SIP-6](https://metamask.github.io/SIPs/SIPS/sip-6).\n *\n * @param options - The options for entropy derivation.\n * @param options.input - The input value to derive entropy from.\n * @param options.salt - An optional salt to use when deriving entropy.\n * @param options.mnemonicPhrase - The mnemonic phrase to use for entropy\n * derivation.\n * @param options.magic - A hardened BIP-32 index, which is used to derive the\n * root key from the mnemonic phrase.\n * @returns The derived entropy.\n */\nexport async function deriveEntropy({\n  input,\n  salt = '',\n  mnemonicPhrase,\n  magic,\n}: DeriveEntropyOptions): Promise<Hex> {\n  const inputBytes = stringToBytes(input);\n  const saltBytes = stringToBytes(salt);\n\n  // Get the derivation path from the snap ID.\n  const hash = keccak256(concatBytes([inputBytes, keccak256(saltBytes)]));\n  const computedDerivationPath = getDerivationPathArray(hash);\n\n  // Derive the private key using BIP-32.\n  const { privateKey } = await SLIP10Node.fromDerivationPath({\n    derivationPath: [\n      mnemonicPhrase,\n      `bip32:${magic}`,\n      ...computedDerivationPath,\n    ],\n    curve: 'secp256k1',\n  });\n\n  // This should never happen, but this keeps TypeScript happy.\n  assert(privateKey, 'Failed to derive the entropy.');\n\n  return add0x(privateKey);\n}\n\n/**\n * Get the enum values as union type. This allows using both the enum string\n * values and the enum itself as values.\n *\n * Note: This only works for string enums.\n *\n * @example\n * ```typescript\n * enum Foo {\n *   Bar = 'bar',\n *   Baz = 'baz',\n * }\n *\n * type FooValue = EnumToUnion<Foo>;\n * // FooValue is 'bar' | 'baz'\n *\n * const foo: FooValue = Foo.Bar; // Works\n * const foo: FooValue = 'bar'; // Also works\n * ```\n */\nexport type EnumToUnion<Type extends string> = `${Type}`;\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<T extends string>(\n  constant: T,\n): Struct<EnumToUnion<T>, EnumToUnion<T>> {\n  return literal(constant as EnumToUnion<T>);\n}\n"]}