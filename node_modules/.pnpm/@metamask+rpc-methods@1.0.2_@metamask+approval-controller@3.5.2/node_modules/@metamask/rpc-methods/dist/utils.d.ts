import { MagicValue } from '@metamask/snaps-utils';
import { Hex } from '@metamask/utils';
import { Struct } from 'superstruct';
/**
 * Maps an interface with method hooks to an object, using the keys of the
 * interface, and `true` as value. This ensures that the `methodHooks` object
 * has the same values as the interface.
 */
export declare type MethodHooksObject<HooksType extends Record<string, unknown>> = {
    [Key in keyof HooksType]: true;
};
/**
 * Returns the subset of the specified `hooks` that are included in the
 * `hookNames` object. This is a Principle of Least Authority (POLA) measure
 * to ensure that each RPC method implementation only has access to the
 * API "hooks" it needs to do its job.
 *
 * @param hooks - The hooks to select from.
 * @param hookNames - The names of the hooks to select.
 * @returns The selected hooks.
 * @template Hooks - The hooks to select from.
 * @template HookName - The names of the hooks to select.
 */
export declare function selectHooks<Hooks extends Record<string, unknown>, HookName extends keyof Hooks>(hooks: Hooks, hookNames?: Record<HookName, boolean>): Pick<Hooks, HookName> | undefined;
declare type DeriveEntropyOptions = {
    /**
     * The input value to derive entropy from.
     */
    input: string;
    /**
     * An optional salt to use when deriving entropy.
     */
    salt?: string;
    /**
     * The mnemonic phrase to use for entropy derivation.
     */
    mnemonicPhrase: Uint8Array;
    /**
     * A hardened BIP-32 index, which is used to derive the root key from the
     * mnemonic phrase.
     */
    magic: MagicValue;
};
/**
 * Derive entropy from the given mnemonic phrase and salt.
 *
 * This is based on the reference implementation of
 * [SIP-6](https://metamask.github.io/SIPs/SIPS/sip-6).
 *
 * @param options - The options for entropy derivation.
 * @param options.input - The input value to derive entropy from.
 * @param options.salt - An optional salt to use when deriving entropy.
 * @param options.mnemonicPhrase - The mnemonic phrase to use for entropy
 * derivation.
 * @param options.magic - A hardened BIP-32 index, which is used to derive the
 * root key from the mnemonic phrase.
 * @returns The derived entropy.
 */
export declare function deriveEntropy({ input, salt, mnemonicPhrase, magic, }: DeriveEntropyOptions): Promise<Hex>;
/**
 * Get the enum values as union type. This allows using both the enum string
 * values and the enum itself as values.
 *
 * Note: This only works for string enums.
 *
 * @example
 * ```typescript
 * enum Foo {
 *   Bar = 'bar',
 *   Baz = 'baz',
 * }
 *
 * type FooValue = EnumToUnion<Foo>;
 * // FooValue is 'bar' | 'baz'
 *
 * const foo: FooValue = Foo.Bar; // Works
 * const foo: FooValue = 'bar'; // Also works
 * ```
 */
export declare type EnumToUnion<Type extends string> = `${Type}`;
/**
 * Superstruct struct for validating an enum value. This allows using both the
 * enum string values and the enum itself as values.
 *
 * @param constant - The enum to validate against.
 * @returns The superstruct struct.
 */
export declare function enumValue<T extends string>(constant: T): Struct<EnumToUnion<T>, EnumToUnion<T>>;
export {};
