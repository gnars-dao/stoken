"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermittedDerivationPathsCaveatSpecification = exports.validateBIP32CaveatPaths = exports.validateBIP32Path = exports.permittedDerivationPathsCaveatMapper = void 0;
const snaps_utils_1 = require("@metamask/snaps-utils");
const utils_1 = require("@metamask/utils");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const superstruct_1 = require("superstruct");
/**
 * Map a raw value from the `initialPermissions` to a caveat specification.
 * Note that this function does not do any validation, that's handled by the
 * PermissionsController when the permission is requested.
 *
 * @param value - The raw value from the `initialPermissions`.
 * @returns The caveat specification.
 */
function permittedDerivationPathsCaveatMapper(value) {
    return {
        caveats: [
            {
                type: snaps_utils_1.SnapCaveatType.PermittedDerivationPaths,
                value,
            },
        ],
    };
}
exports.permittedDerivationPathsCaveatMapper = permittedDerivationPathsCaveatMapper;
/**
 * Validate a caveat path object. The object must consist of a `path` array and
 * a `curve` string. Paths must start with `m`, and must contain at
 * least two indices. If `ed25519` is used, this checks if all the path indices
 * are hardened.
 *
 * @param value - The value to validate.
 * @throws If the value is invalid.
 */
function validateBIP32Path(value) {
    (0, utils_1.assertStruct)(value, snaps_utils_1.Bip32EntropyStruct, 'Invalid BIP-32 entropy path definition', eth_rpc_errors_1.ethErrors.rpc.invalidParams);
}
exports.validateBIP32Path = validateBIP32Path;
/**
 * Validate the path values associated with a caveat. This validates that the
 * value is a non-empty array with valid derivation paths and curves.
 *
 * @param caveat - The caveat to validate.
 * @throws If the value is invalid.
 */
function validateBIP32CaveatPaths(caveat) {
    (0, utils_1.assertStruct)(caveat, (0, superstruct_1.type)({ value: (0, superstruct_1.size)((0, superstruct_1.array)(snaps_utils_1.Bip32EntropyStruct), 1, Infinity) }), 'Invalid BIP-32 entropy caveat', eth_rpc_errors_1.ethErrors.rpc.internal);
}
exports.validateBIP32CaveatPaths = validateBIP32CaveatPaths;
exports.PermittedDerivationPathsCaveatSpecification = {
    [snaps_utils_1.SnapCaveatType.PermittedDerivationPaths]: Object.freeze({
        type: snaps_utils_1.SnapCaveatType.PermittedDerivationPaths,
        decorator: (method, caveat) => {
            return async (args) => {
                const { params } = args;
                validateBIP32Path(params);
                const path = caveat.value.find((caveatPath) => (0, snaps_utils_1.isEqual)(params.path.slice(0, caveatPath.path.length), caveatPath.path) && caveatPath.curve === params.curve);
                if (!path) {
                    throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                        message: 'The requested path is not permitted. Allowed paths must be specified in the snap manifest.',
                    });
                }
                return await method(args);
            };
        },
        validator: (caveat) => validateBIP32CaveatPaths(caveat),
    }),
};
//# sourceMappingURL=permittedDerivationPaths.js.map