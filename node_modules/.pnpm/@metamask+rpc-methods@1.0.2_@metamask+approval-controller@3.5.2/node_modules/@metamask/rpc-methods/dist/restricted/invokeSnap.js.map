{"version":3,"file":"invokeSnap.js","sourceRoot":"","sources":["../../src/restricted/invokeSnap.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  PermissionType,\n  PermissionValidatorConstraint,\n  PermissionSideEffect,\n} from '@metamask/permission-controller';\nimport {\n  Snap,\n  SnapId,\n  HandlerType,\n  SnapRpcHookArgs,\n  SnapCaveatType,\n  RequestedSnapPermissions,\n  InstallSnapsResult,\n} from '@metamask/snaps-utils';\nimport { isJsonRpcRequest, Json, NonEmptyArray } from '@metamask/utils';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { nanoid } from 'nanoid';\n\nimport { MethodHooksObject } from '../utils';\n\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\n// Redeclare installSnaps action type to avoid circular dependencies\nexport type InstallSnaps = {\n  type: `SnapController:install`;\n  handler: (\n    origin: string,\n    requestedSnaps: RequestedSnapPermissions,\n  ) => Promise<InstallSnapsResult>;\n};\n\nexport type GetPermittedSnaps = {\n  type: `SnapController:getPermitted`;\n  handler: (origin: string) => InstallSnapsResult;\n};\n\ntype AllowedActions = InstallSnaps | GetPermittedSnaps;\n\nexport type InvokeSnapMethodHooks = {\n  getSnap: (snapId: SnapId) => Snap | undefined;\n  handleSnapRpcRequest: ({\n    snapId,\n    origin,\n    handler,\n    request,\n  }: SnapRpcHookArgs & { snapId: SnapId }) => Promise<unknown>;\n};\n\ntype InvokeSnapSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: InvokeSnapMethodHooks;\n};\n\ntype InvokeSnapSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof WALLET_SNAP_PERMISSION_KEY;\n  methodImplementation: ReturnType<typeof getInvokeSnapImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n  sideEffect: {\n    onPermitted: PermissionSideEffect<AllowedActions, never>['onPermitted'];\n  };\n}>;\n\nexport type InvokeSnapParams = {\n  snapId: string;\n  request: Record<string, unknown>;\n};\n\n/**\n * The side-effect method to handle the snap install.\n *\n * @param params - The side-effect params.\n * @param params.requestData - The request data associated to the requested permission.\n * @param params.messagingSystem - The messenger to call an action.\n */\nexport const handleSnapInstall: PermissionSideEffect<\n  AllowedActions,\n  never\n>['onPermitted'] = async ({ requestData, messagingSystem }) => {\n  const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]\n    .value as RequestedSnapPermissions;\n\n  const permittedSnaps = messagingSystem.call(\n    `SnapController:getPermitted`,\n    requestData.metadata.origin,\n  );\n\n  const dedupedSnaps = Object.keys(snaps).reduce<RequestedSnapPermissions>(\n    (filteredSnaps, snap) => {\n      if (!permittedSnaps[snap]) {\n        filteredSnaps[snap] = snaps[snap];\n      }\n      return filteredSnaps;\n    },\n    {},\n  );\n\n  return messagingSystem.call(\n    `SnapController:install`,\n    requestData.metadata.origin,\n    dedupedSnaps,\n  );\n};\n/**\n * The specification builder for the `wallet_snap_*` permission.\n *\n * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.\n *\n * Requesting its corresponding permission will attempt to connect to the Snap,\n * and install it if it's not available yet.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `wallet_snap_*` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  InvokeSnapSpecificationBuilderOptions,\n  InvokeSnapSpecification\n> = ({ methodHooks }: InvokeSnapSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: WALLET_SNAP_PERMISSION_KEY,\n    allowedCaveats: [SnapCaveatType.SnapIds],\n    methodImplementation: getInvokeSnapImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (caveats?.length !== 1 || caveats[0].type !== SnapCaveatType.SnapIds) {\n        throw ethErrors.rpc.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.SnapIds}\" caveat.`,\n        });\n      }\n    },\n    sideEffect: {\n      onPermitted: handleSnapInstall,\n    },\n  };\n};\n\nconst methodHooks: MethodHooksObject<InvokeSnapMethodHooks> = {\n  getSnap: true,\n  handleSnapRpcRequest: true,\n};\n\nexport const invokeSnapBuilder = Object.freeze({\n  targetName: WALLET_SNAP_PERMISSION_KEY,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `wallet_snap_*`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.getSnap - A function that retrieves all information stored about a snap.\n * @param hooks.handleSnapRpcRequest - A function that sends an RPC request to a snap's RPC handler or throws if that fails.\n * @returns The method implementation which returns the result of `handleSnapRpcRequest`.\n * @throws If the params are invalid.\n */\nexport function getInvokeSnapImplementation({\n  getSnap,\n  handleSnapRpcRequest,\n}: InvokeSnapMethodHooks) {\n  return async function invokeSnap(\n    options: RestrictedMethodOptions<Record<string, Json>>,\n  ): Promise<Json> {\n    const { params = {}, context } = options;\n\n    const { snapId, request } = params as InvokeSnapParams;\n\n    const rpcRequest = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...request,\n    };\n\n    if (!isJsonRpcRequest(rpcRequest)) {\n      throw ethErrors.rpc.invalidParams({\n        message:\n          'Must specify a valid JSON-RPC request object as single parameter.',\n      });\n    }\n\n    if (!getSnap(snapId)) {\n      throw ethErrors.rpc.invalidRequest({\n        message: `The snap \"${snapId}\" is not installed. Please install it first, before invoking the snap.`,\n      });\n    }\n\n    const { origin } = context;\n\n    return (await handleSnapRpcRequest({\n      snapId,\n      origin,\n      request: rpcRequest,\n      handler: HandlerType.OnRpcRequest,\n    })) as Json;\n  };\n}\n"]}