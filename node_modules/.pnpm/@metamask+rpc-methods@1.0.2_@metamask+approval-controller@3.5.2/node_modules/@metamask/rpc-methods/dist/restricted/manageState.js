"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidatedParams = exports.getManageStateImplementation = exports.STORAGE_SIZE_LIMIT = exports.ManageStateOperation = exports.manageStateBuilder = exports.specificationBuilder = exports.STATE_ENCRYPTION_SALT = void 0;
const browser_passworder_1 = require("@metamask/browser-passworder");
const permission_controller_1 = require("@metamask/permission-controller");
const snaps_utils_1 = require("@metamask/snaps-utils");
const utils_1 = require("@metamask/utils");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_2 = require("../utils");
// The salt used for SIP-6-based entropy derivation.
exports.STATE_ENCRYPTION_SALT = 'snap_manageState encryption';
const methodName = 'snap_manageState';
/**
 * The specification builder for the `snap_manageState` permission.
 * `snap_manageState` lets the Snap store and manage some of its state on
 * your device.
 *
 * @param options - The specification builder options.
 * @param options.allowedCaveats - The optional allowed caveats for the permission.
 * @param options.methodHooks - The RPC method hooks needed by the method implementation.
 * @returns The specification for the `snap_manageState` permission.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        permissionType: permission_controller_1.PermissionType.RestrictedMethod,
        targetName: methodName,
        allowedCaveats,
        methodImplementation: getManageStateImplementation(methodHooks),
        subjectTypes: [permission_controller_1.SubjectType.Snap],
    };
};
exports.specificationBuilder = specificationBuilder;
const methodHooks = {
    getMnemonic: true,
    getUnlockPromise: true,
    clearSnapState: true,
    getSnapState: true,
    updateSnapState: true,
};
exports.manageStateBuilder = Object.freeze({
    targetName: methodName,
    specificationBuilder: exports.specificationBuilder,
    methodHooks,
});
var ManageStateOperation;
(function (ManageStateOperation) {
    ManageStateOperation["ClearState"] = "clear";
    ManageStateOperation["GetState"] = "get";
    ManageStateOperation["UpdateState"] = "update";
})(ManageStateOperation = exports.ManageStateOperation || (exports.ManageStateOperation = {}));
exports.STORAGE_SIZE_LIMIT = 104857600; // In bytes (100MB)
/**
 * Get a deterministic encryption key to use for encrypting and decrypting the
 * state.
 *
 * This key should only be used for state encryption using `snap_manageState`.
 * To get other encryption keys, a different salt can be used.
 *
 * @param args - The encryption key args.
 * @param args.snapId - The ID of the snap to get the encryption key for.
 * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key
 * from.
 * @returns The state encryption key.
 */
async function getEncryptionKey({ mnemonicPhrase, snapId, }) {
    return await (0, utils_2.deriveEntropy)({
        mnemonicPhrase,
        input: snapId,
        salt: exports.STATE_ENCRYPTION_SALT,
        magic: snaps_utils_1.STATE_ENCRYPTION_MAGIC_VALUE,
    });
}
/**
 * Encrypt the state using a deterministic encryption algorithm, based on the
 * snap ID and mnemonic phrase.
 *
 * @param args - The encryption args.
 * @param args.state - The state to encrypt.
 * @param args.snapId - The ID of the snap to get the encryption key for.
 * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key
 * from.
 * @returns The encrypted state.
 */
async function encryptState({ state, ...keyArgs }) {
    const encryptionKey = await getEncryptionKey(keyArgs);
    return await (0, browser_passworder_1.encrypt)(encryptionKey, state);
}
/**
 * Decrypt the state using a deterministic decryption algorithm, based on the
 * snap ID and mnemonic phrase.
 *
 * @param args - The encryption args.
 * @param args.state - The state to decrypt.
 * @param args.snapId - The ID of the snap to get the encryption key for.
 * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key
 * from.
 * @returns The encrypted state.
 */
async function decryptState({ state, ...keyArgs }) {
    try {
        const encryptionKey = await getEncryptionKey(keyArgs);
        const decryptedState = await (0, browser_passworder_1.decrypt)(encryptionKey, state);
        (0, utils_1.assert)((0, utils_1.isValidJson)(decryptedState));
        return decryptedState;
    }
    catch {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: 'Failed to decrypt snap state, the state must be corrupted.',
        });
    }
}
/**
 * Builds the method implementation for `snap_manageState`.
 *
 * @param hooks - The RPC method hooks.
 * @param hooks.clearSnapState - A function that clears the state stored for a
 * snap.
 * @param hooks.getSnapState - A function that fetches the persisted decrypted
 * state for a snap.
 * @param hooks.updateSnapState - A function that updates the state stored for a
 * snap.
 * @param hooks.getMnemonic - A function to retrieve the Secret Recovery Phrase
 * of the user.
 * @param hooks.getUnlockPromise - A function that resolves once the MetaMask
 * extension is unlocked and prompts the user to unlock their MetaMask if it is
 * locked.
 * @returns The method implementation which either returns `null` for a
 * successful state update/deletion or returns the decrypted state.
 * @throws If the params are invalid.
 */
function getManageStateImplementation({ getMnemonic, getUnlockPromise, clearSnapState, getSnapState, updateSnapState, }) {
    return async function manageState(options) {
        const { params = {}, method, context: { origin }, } = options;
        const { operation, newState } = getValidatedParams(params, method);
        await getUnlockPromise(true);
        const mnemonicPhrase = await getMnemonic();
        switch (operation) {
            case ManageStateOperation.ClearState:
                await clearSnapState(origin);
                return null;
            case ManageStateOperation.GetState: {
                const state = await getSnapState(origin);
                if (state === null) {
                    return state;
                }
                return await decryptState({
                    state,
                    mnemonicPhrase,
                    snapId: origin,
                });
            }
            case ManageStateOperation.UpdateState: {
                (0, utils_1.assert)(newState);
                const encryptedState = await encryptState({
                    state: newState,
                    mnemonicPhrase,
                    snapId: origin,
                });
                await updateSnapState(origin, encryptedState);
                return null;
            }
            default:
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid ${method} operation: "${operation}"`);
        }
    };
}
exports.getManageStateImplementation = getManageStateImplementation;
/**
 * Validates the manageState method `params` and returns them cast to the correct
 * type. Throws if validation fails.
 *
 * @param params - The unvalidated params object from the method request.
 * @param method - RPC method name used for debugging errors.
 * @param storageSizeLimit - Maximum allowed size (in bytes) of a new state object.
 * @returns The validated method parameter object.
 */
function getValidatedParams(params, method, storageSizeLimit = exports.STORAGE_SIZE_LIMIT) {
    if (!(0, utils_1.isObject)(params)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Expected params to be a single object.',
        });
    }
    const { operation, newState } = params;
    if (!operation ||
        typeof operation !== 'string' ||
        !Object.values(ManageStateOperation).includes(operation)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Must specify a valid manage state "operation".',
        });
    }
    if (operation === ManageStateOperation.UpdateState) {
        if (!(0, utils_1.isObject)(newState)) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: `Invalid ${method} "updateState" parameter: The new state must be a plain object.`,
                data: {
                    receivedNewState: typeof newState === 'undefined' ? 'undefined' : newState,
                },
            });
        }
        let size;
        try {
            // `getJsonSize` will throw if the state is not JSON serializable.
            size = (0, utils_1.getJsonSize)(newState);
        }
        catch {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: `Invalid ${method} "updateState" parameter: The new state must be JSON serializable.`,
                data: {
                    receivedNewState: typeof newState === 'undefined' ? 'undefined' : newState,
                },
            });
        }
        if (size > storageSizeLimit) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: `Invalid ${method} "updateState" parameter: The new state must not exceed ${storageSizeLimit} bytes in size.`,
                data: {
                    receivedNewState: typeof newState === 'undefined' ? 'undefined' : newState,
                },
            });
        }
    }
    return params;
}
exports.getValidatedParams = getValidatedParams;
//# sourceMappingURL=manageState.js.map