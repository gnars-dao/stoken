{"version":3,"file":"manageState.js","sourceRoot":"","sources":["../../src/restricted/manageState.ts"],"names":[],"mappings":"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","sourcesContent":["import { decrypt, encrypt } from '@metamask/browser-passworder';\nimport {\n  PermissionSpecificationBuilder,\n  PermissionType,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  SubjectType,\n} from '@metamask/permission-controller';\nimport { STATE_ENCRYPTION_MAGIC_VALUE } from '@metamask/snaps-utils';\nimport {\n  Json,\n  NonEmptyArray,\n  isObject,\n  getJsonSize,\n  assert,\n  isValidJson,\n} from '@metamask/utils';\nimport { ethErrors } from 'eth-rpc-errors';\n\nimport { deriveEntropy, EnumToUnion, MethodHooksObject } from '../utils';\n\n// The salt used for SIP-6-based entropy derivation.\nexport const STATE_ENCRYPTION_SALT = 'snap_manageState encryption';\n\nconst methodName = 'snap_manageState';\n\nexport type ManageStateMethodHooks = {\n  /**\n   * @returns The mnemonic of the user's primary keyring.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n\n  /**\n   * Waits for the extension to be unlocked.\n   *\n   * @returns A promise that resolves once the extension is unlocked.\n   */\n  getUnlockPromise: (shouldShowUnlockRequest: boolean) => Promise<void>;\n\n  /**\n   * A function that clears the state of the requesting Snap.\n   */\n  clearSnapState: (snapId: string) => Promise<void>;\n\n  /**\n   * A function that gets the encrypted state of the requesting Snap.\n   *\n   * @returns The current state of the Snap.\n   */\n  getSnapState: (snapId: string) => Promise<string>;\n\n  /**\n   * A function that updates the state of the requesting Snap.\n   *\n   * @param newState - The new state of the Snap.\n   */\n  updateSnapState: (snapId: string, newState: string) => Promise<void>;\n};\n\ntype ManageStateSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: ManageStateMethodHooks;\n};\n\ntype ManageStateSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof methodName;\n  methodImplementation: ReturnType<typeof getManageStateImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n}>;\n\n/**\n * The specification builder for the `snap_manageState` permission.\n * `snap_manageState` lets the Snap store and manage some of its state on\n * your device.\n *\n * @param options - The specification builder options.\n * @param options.allowedCaveats - The optional allowed caveats for the permission.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `snap_manageState` permission.\n */\nexport const specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  ManageStateSpecificationBuilderOptions,\n  ManageStateSpecification\n> = ({\n  allowedCaveats = null,\n  methodHooks,\n}: ManageStateSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: methodName,\n    allowedCaveats,\n    methodImplementation: getManageStateImplementation(methodHooks),\n    subjectTypes: [SubjectType.Snap],\n  };\n};\n\nconst methodHooks: MethodHooksObject<ManageStateMethodHooks> = {\n  getMnemonic: true,\n  getUnlockPromise: true,\n  clearSnapState: true,\n  getSnapState: true,\n  updateSnapState: true,\n};\n\nexport const manageStateBuilder = Object.freeze({\n  targetName: methodName,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\nexport type ManageStateArgs = {\n  operation: EnumToUnion<ManageStateOperation>;\n  newState?: Record<string, Json>;\n};\n\nexport const STORAGE_SIZE_LIMIT = 104857600; // In bytes (100MB)\n\ntype GetEncryptionKeyArgs = {\n  snapId: string;\n  mnemonicPhrase: Uint8Array;\n};\n\n/**\n * Get a deterministic encryption key to use for encrypting and decrypting the\n * state.\n *\n * This key should only be used for state encryption using `snap_manageState`.\n * To get other encryption keys, a different salt can be used.\n *\n * @param args - The encryption key args.\n * @param args.snapId - The ID of the snap to get the encryption key for.\n * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key\n * from.\n * @returns The state encryption key.\n */\nasync function getEncryptionKey({\n  mnemonicPhrase,\n  snapId,\n}: GetEncryptionKeyArgs) {\n  return await deriveEntropy({\n    mnemonicPhrase,\n    input: snapId,\n    salt: STATE_ENCRYPTION_SALT,\n    magic: STATE_ENCRYPTION_MAGIC_VALUE,\n  });\n}\n\ntype EncryptStateArgs = GetEncryptionKeyArgs & {\n  state: Json;\n};\n\n/**\n * Encrypt the state using a deterministic encryption algorithm, based on the\n * snap ID and mnemonic phrase.\n *\n * @param args - The encryption args.\n * @param args.state - The state to encrypt.\n * @param args.snapId - The ID of the snap to get the encryption key for.\n * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key\n * from.\n * @returns The encrypted state.\n */\nasync function encryptState({ state, ...keyArgs }: EncryptStateArgs) {\n  const encryptionKey = await getEncryptionKey(keyArgs);\n  return await encrypt(encryptionKey, state);\n}\n\ntype DecryptStateArgs = GetEncryptionKeyArgs & {\n  state: string;\n};\n\n/**\n * Decrypt the state using a deterministic decryption algorithm, based on the\n * snap ID and mnemonic phrase.\n *\n * @param args - The encryption args.\n * @param args.state - The state to decrypt.\n * @param args.snapId - The ID of the snap to get the encryption key for.\n * @param args.mnemonicPhrase - The mnemonic phrase to derive the encryption key\n * from.\n * @returns The encrypted state.\n */\nasync function decryptState({ state, ...keyArgs }: DecryptStateArgs) {\n  try {\n    const encryptionKey = await getEncryptionKey(keyArgs);\n    const decryptedState = await decrypt(encryptionKey, state);\n\n    assert(isValidJson(decryptedState));\n\n    return decryptedState as Record<string, Json>;\n  } catch {\n    throw ethErrors.rpc.internal({\n      message: 'Failed to decrypt snap state, the state must be corrupted.',\n    });\n  }\n}\n\n/**\n * Builds the method implementation for `snap_manageState`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.clearSnapState - A function that clears the state stored for a\n * snap.\n * @param hooks.getSnapState - A function that fetches the persisted decrypted\n * state for a snap.\n * @param hooks.updateSnapState - A function that updates the state stored for a\n * snap.\n * @param hooks.getMnemonic - A function to retrieve the Secret Recovery Phrase\n * of the user.\n * @param hooks.getUnlockPromise - A function that resolves once the MetaMask\n * extension is unlocked and prompts the user to unlock their MetaMask if it is\n * locked.\n * @returns The method implementation which either returns `null` for a\n * successful state update/deletion or returns the decrypted state.\n * @throws If the params are invalid.\n */\nexport function getManageStateImplementation({\n  getMnemonic,\n  getUnlockPromise,\n  clearSnapState,\n  getSnapState,\n  updateSnapState,\n}: ManageStateMethodHooks) {\n  return async function manageState(\n    options: RestrictedMethodOptions<ManageStateArgs>,\n  ): Promise<null | Record<string, Json>> {\n    const {\n      params = {},\n      method,\n      context: { origin },\n    } = options;\n    const { operation, newState } = getValidatedParams(params, method);\n\n    await getUnlockPromise(true);\n    const mnemonicPhrase = await getMnemonic();\n\n    switch (operation) {\n      case ManageStateOperation.ClearState:\n        await clearSnapState(origin);\n        return null;\n\n      case ManageStateOperation.GetState: {\n        const state = await getSnapState(origin);\n        if (state === null) {\n          return state;\n        }\n        return await decryptState({\n          state,\n          mnemonicPhrase,\n          snapId: origin,\n        });\n      }\n\n      case ManageStateOperation.UpdateState: {\n        assert(newState);\n\n        const encryptedState = await encryptState({\n          state: newState,\n          mnemonicPhrase,\n          snapId: origin,\n        });\n\n        await updateSnapState(origin, encryptedState);\n        return null;\n      }\n\n      default:\n        throw ethErrors.rpc.invalidParams(\n          `Invalid ${method} operation: \"${operation as string}\"`,\n        );\n    }\n  };\n}\n\n/**\n * Validates the manageState method `params` and returns them cast to the correct\n * type. Throws if validation fails.\n *\n * @param params - The unvalidated params object from the method request.\n * @param method - RPC method name used for debugging errors.\n * @param storageSizeLimit - Maximum allowed size (in bytes) of a new state object.\n * @returns The validated method parameter object.\n */\nexport function getValidatedParams(\n  params: unknown,\n  method: string,\n  storageSizeLimit = STORAGE_SIZE_LIMIT,\n): ManageStateArgs {\n  if (!isObject(params)) {\n    throw ethErrors.rpc.invalidParams({\n      message: 'Expected params to be a single object.',\n    });\n  }\n\n  const { operation, newState } = params;\n\n  if (\n    !operation ||\n    typeof operation !== 'string' ||\n    !(Object.values(ManageStateOperation) as string[]).includes(operation)\n  ) {\n    throw ethErrors.rpc.invalidParams({\n      message: 'Must specify a valid manage state \"operation\".',\n    });\n  }\n\n  if (operation === ManageStateOperation.UpdateState) {\n    if (!isObject(newState)) {\n      throw ethErrors.rpc.invalidParams({\n        message: `Invalid ${method} \"updateState\" parameter: The new state must be a plain object.`,\n        data: {\n          receivedNewState:\n            typeof newState === 'undefined' ? 'undefined' : newState,\n        },\n      });\n    }\n\n    let size;\n    try {\n      // `getJsonSize` will throw if the state is not JSON serializable.\n      size = getJsonSize(newState);\n    } catch {\n      throw ethErrors.rpc.invalidParams({\n        message: `Invalid ${method} \"updateState\" parameter: The new state must be JSON serializable.`,\n        data: {\n          receivedNewState:\n            typeof newState === 'undefined' ? 'undefined' : newState,\n        },\n      });\n    }\n\n    if (size > storageSizeLimit) {\n      throw ethErrors.rpc.invalidParams({\n        message: `Invalid ${method} \"updateState\" parameter: The new state must not exceed ${storageSizeLimit} bytes in size.`,\n        data: {\n          receivedNewState:\n            typeof newState === 'undefined' ? 'undefined' : newState,\n        },\n      });\n    }\n  }\n\n  return params as ManageStateArgs;\n}\n"]}