"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermittedCoinTypesCaveatSpecification = exports.validateBIP44Caveat = exports.validateBIP44Params = exports.permittedCoinTypesCaveatMapper = void 0;
const snaps_utils_1 = require("@metamask/snaps-utils");
const utils_1 = require("@metamask/utils");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/**
 * Map a raw value from the `initialPermissions` to a caveat specification.
 * Note that this function does not do any validation, that's handled by the
 * PermissionsController when the permission is requested.
 *
 * @param value - The raw value from the `initialPermissions`.
 * @returns The caveat specification.
 */
function permittedCoinTypesCaveatMapper(value) {
    return {
        caveats: [
            {
                type: snaps_utils_1.SnapCaveatType.PermittedCoinTypes,
                value,
            },
        ],
    };
}
exports.permittedCoinTypesCaveatMapper = permittedCoinTypesCaveatMapper;
/**
 * Validate the params for `snap_getBip44Entropy`.
 *
 * @param value - The params to validate.
 * @throws If the params are invalid.
 */
function validateBIP44Params(value) {
    if (!(0, utils_1.isPlainObject)(value) || !(0, utils_1.hasProperty)(value, 'coinType')) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Expected a plain object containing a coin type.',
        });
    }
    if (typeof value.coinType !== 'number' ||
        !Number.isInteger(value.coinType) ||
        value.coinType < 0 ||
        value.coinType > 0x7fffffff) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Invalid "coinType" parameter. Coin type must be a non-negative integer.',
        });
    }
    if (snaps_utils_1.FORBIDDEN_COIN_TYPES.includes(value.coinType)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Coin type ${value.coinType} is forbidden.`,
        });
    }
}
exports.validateBIP44Params = validateBIP44Params;
/**
 * Validate the coin types values associated with a caveat. This checks if the
 * values are non-negative integers (>= 0).
 *
 * @param caveat - The caveat to validate.
 * @throws If the caveat is invalid.
 */
function validateBIP44Caveat(caveat) {
    if (!(0, utils_1.hasProperty)(caveat, 'value') ||
        !Array.isArray(caveat.value) ||
        caveat.value.length === 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Expected non-empty array of coin types.',
        });
    }
    caveat.value.forEach(validateBIP44Params);
}
exports.validateBIP44Caveat = validateBIP44Caveat;
exports.PermittedCoinTypesCaveatSpecification = {
    [snaps_utils_1.SnapCaveatType.PermittedCoinTypes]: Object.freeze({
        type: snaps_utils_1.SnapCaveatType.PermittedCoinTypes,
        decorator: (method, caveat) => {
            return async (args) => {
                const { params } = args;
                validateBIP44Params(params);
                const coinType = caveat.value.find((caveatValue) => caveatValue.coinType === params.coinType);
                if (!coinType) {
                    throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                        message: 'The requested coin type is not permitted. Allowed coin types must be specified in the snap manifest.',
                    });
                }
                return await method(args);
            };
        },
        validator: (caveat) => validateBIP44Caveat(caveat),
    }),
};
//# sourceMappingURL=permittedCoinTypes.js.map