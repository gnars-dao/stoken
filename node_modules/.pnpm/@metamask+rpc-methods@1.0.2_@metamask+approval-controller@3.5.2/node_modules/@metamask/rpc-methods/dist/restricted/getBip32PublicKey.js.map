{"version":3,"file":"getBip32PublicKey.js","sourceRoot":"","sources":["../../src/restricted/getBip32PublicKey.ts"],"names":[],"mappings":";;;AAAA,iDAA2D;AAC3D,2EAOyC;AACzC,uDAI+B;AAC/B,2CAA8D;AAC9D,mDAA2C;AAC3C,6CAA+D;AAI/D,MAAM,UAAU,GAAG,wBAAwB,CAAC;AAkC/B,QAAA,wBAAwB,GAAG,IAAA,0BAAY,EAClD,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,6BAAe;IACrB,KAAK,EAAE,IAAA,mBAAK,EAAC,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;IACvC,UAAU,EAAE,IAAA,sBAAQ,EAAC,IAAA,qBAAO,GAAE,CAAC;CAChC,CAAC,CACH,CAAC;AAEF;;;;;;;;GAQG;AACH,MAAM,oBAAoB,GAItB,CAAC,EAAE,WAAW,EAAgD,EAAE,EAAE;IACpE,OAAO;QACL,cAAc,EAAE,sCAAc,CAAC,gBAAgB;QAC/C,UAAU;QACV,cAAc,EAAE,CAAC,4BAAc,CAAC,wBAAwB,CAAC;QACzD,oBAAoB,EAAE,+BAA+B,CAAC,WAAW,CAAC;QAClE,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;YACzB,IACE,OAAO,EAAE,MAAM,KAAK,CAAC;gBACrB,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,4BAAc,CAAC,wBAAwB,EAC3D;gBACA,MAAM,0BAAS,CAAC,GAAG,CAAC,aAAa,CAAC;oBAChC,OAAO,EAAE,sBAAsB,4BAAc,CAAC,wBAAwB,WAAW;iBAClF,CAAC,CAAC;aACJ;QACH,CAAC;QACD,YAAY,EAAE,CAAC,mCAAW,CAAC,IAAI,CAAC;KACjC,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,WAAW,GAAoD;IACnE,WAAW,EAAE,IAAI;IACjB,gBAAgB,EAAE,IAAI;CACvB,CAAC;AAEW,QAAA,wBAAwB,GAAG,MAAM,CAAC,MAAM,CAAC;IACpD,UAAU;IACV,oBAAoB;IACpB,WAAW;CACH,CAAC,CAAC;AAEZ;;;;;;;;;GASG;AACH,SAAgB,+BAA+B,CAAC,EAC9C,WAAW,EACX,gBAAgB,GACa;IAC7B,OAAO,KAAK,UAAU,iBAAiB,CACrC,IAA0D;QAE1D,MAAM,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAE7B,IAAA,oBAAY,EACV,IAAI,CAAC,MAAM,EACX,gCAAwB,EACxB,kCAAkC,EAClC,0BAAS,CAAC,GAAG,CAAC,aAAa,CAC5B,CAAC;QAEF,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QAExB,MAAM,IAAI,GAAG,MAAM,qBAAU,CAAC,kBAAkB,CAAC;YAC/C,KAAK,EAAE,MAAM,CAAC,KAAK;YACnB,cAAc,EAAE;gBACd,MAAM,WAAW,EAAE;gBACnB,GAAG,MAAM,CAAC,IAAI;qBACX,KAAK,CAAC,CAAC,CAAC;qBACR,GAAG,CAAY,CAAC,KAAK,EAAE,EAAE,CAAC,SAAS,KAAK,EAAe,CAAC;aAC5D;SACF,CAAC,CAAC;QAEH,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,OAAO,IAAI,CAAC,mBAAmB,CAAC;SACjC;QAED,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC,CAAC;AACJ,CAAC;AAlCD,0EAkCC","sourcesContent":["import { BIP32Node, SLIP10Node } from '@metamask/key-tree';\nimport {\n  PermissionSpecificationBuilder,\n  PermissionType,\n  PermissionValidatorConstraint,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  SubjectType,\n} from '@metamask/permission-controller';\nimport {\n  bip32entropy,\n  Bip32PathStruct,\n  SnapCaveatType,\n} from '@metamask/snaps-utils';\nimport { NonEmptyArray, assertStruct } from '@metamask/utils';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { boolean, enums, object, optional } from 'superstruct';\n\nimport { MethodHooksObject } from '../utils';\n\nconst targetName = 'snap_getBip32PublicKey';\n\nexport type GetBip32PublicKeyMethodHooks = {\n  /**\n   * @returns The mnemonic of the user's primary keyring.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n\n  /**\n   * Waits for the extension to be unlocked.\n   *\n   * @returns A promise that resolves once the extension is unlocked.\n   */\n  getUnlockPromise: (shouldShowUnlockRequest: boolean) => Promise<void>;\n};\n\ntype GetBip32PublicKeySpecificationBuilderOptions = {\n  methodHooks: GetBip32PublicKeyMethodHooks;\n};\n\ntype GetBip32PublicKeySpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof targetName;\n  methodImplementation: ReturnType<typeof getBip32PublicKeyImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n}>;\n\ntype GetBip32PublicKeyParameters = {\n  path: ['m', ...(`${number}` | `${number}'`)[]];\n  curve: 'secp256k1' | 'ed25519';\n  compressed?: boolean;\n};\n\nexport const Bip32PublicKeyArgsStruct = bip32entropy(\n  object({\n    path: Bip32PathStruct,\n    curve: enums(['ed225519', 'secp256k1']),\n    compressed: optional(boolean()),\n  }),\n);\n\n/**\n * The specification builder for the `snap_getBip32PublicKey` permission.\n * `snap_getBip32PublicKey` lets the Snap retrieve public keys for a particular\n * BIP-32 node.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `snap_getBip32PublicKey` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  GetBip32PublicKeySpecificationBuilderOptions,\n  GetBip32PublicKeySpecification\n> = ({ methodHooks }: GetBip32PublicKeySpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName,\n    allowedCaveats: [SnapCaveatType.PermittedDerivationPaths],\n    methodImplementation: getBip32PublicKeyImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (\n        caveats?.length !== 1 ||\n        caveats[0].type !== SnapCaveatType.PermittedDerivationPaths\n      ) {\n        throw ethErrors.rpc.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.PermittedDerivationPaths}\" caveat.`,\n        });\n      }\n    },\n    subjectTypes: [SubjectType.Snap],\n  };\n};\n\nconst methodHooks: MethodHooksObject<GetBip32PublicKeyMethodHooks> = {\n  getMnemonic: true,\n  getUnlockPromise: true,\n};\n\nexport const getBip32PublicKeyBuilder = Object.freeze({\n  targetName,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `snap_getBip32PublicKey`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.getMnemonic - A function to retrieve the Secret Recovery Phrase of the user.\n * @param hooks.getUnlockPromise - A function that resolves once the MetaMask extension is unlocked\n * and prompts the user to unlock their MetaMask if it is locked.\n * @returns The method implementation which returns a public key.\n * @throws If the params are invalid.\n */\nexport function getBip32PublicKeyImplementation({\n  getMnemonic,\n  getUnlockPromise,\n}: GetBip32PublicKeyMethodHooks) {\n  return async function getBip32PublicKey(\n    args: RestrictedMethodOptions<GetBip32PublicKeyParameters>,\n  ): Promise<string> {\n    await getUnlockPromise(true);\n\n    assertStruct(\n      args.params,\n      Bip32PublicKeyArgsStruct,\n      'Invalid BIP-32 public key params',\n      ethErrors.rpc.invalidParams,\n    );\n\n    const { params } = args;\n\n    const node = await SLIP10Node.fromDerivationPath({\n      curve: params.curve,\n      derivationPath: [\n        await getMnemonic(),\n        ...params.path\n          .slice(1)\n          .map<BIP32Node>((index) => `bip32:${index}` as BIP32Node),\n      ],\n    });\n\n    if (params.compressed) {\n      return node.compressedPublicKey;\n    }\n\n    return node.publicKey;\n  };\n}\n"]}