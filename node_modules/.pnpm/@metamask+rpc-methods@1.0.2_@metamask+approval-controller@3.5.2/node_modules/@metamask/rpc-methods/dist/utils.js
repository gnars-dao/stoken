"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enumValue = exports.deriveEntropy = exports.selectHooks = void 0;
const key_tree_1 = require("@metamask/key-tree");
const utils_1 = require("@metamask/utils");
const sha3_1 = require("@noble/hashes/sha3");
const superstruct_1 = require("superstruct");
const HARDENED_VALUE = 0x80000000;
/**
 * Returns the subset of the specified `hooks` that are included in the
 * `hookNames` object. This is a Principle of Least Authority (POLA) measure
 * to ensure that each RPC method implementation only has access to the
 * API "hooks" it needs to do its job.
 *
 * @param hooks - The hooks to select from.
 * @param hookNames - The names of the hooks to select.
 * @returns The selected hooks.
 * @template Hooks - The hooks to select from.
 * @template HookName - The names of the hooks to select.
 */
function selectHooks(hooks, hookNames) {
    if (hookNames) {
        return Object.keys(hookNames).reduce((hookSubset, _hookName) => {
            const hookName = _hookName;
            hookSubset[hookName] = hooks[hookName];
            return hookSubset;
        }, {});
    }
    return undefined;
}
exports.selectHooks = selectHooks;
/**
 * Get a BIP-32 derivation path array from a hash, which is compatible with
 * `@metamask/key-tree`. The hash is assumed to be 32 bytes long.
 *
 * @param hash - The hash to derive indices from.
 * @returns The derived indices as a {@link HardenedBIP32Node} array.
 */
function getDerivationPathArray(hash) {
    const array = [];
    const view = (0, utils_1.createDataView)(hash);
    for (let index = 0; index < 8; index++) {
        const uint32 = view.getUint32(index * 4);
        // This is essentially `index | 0x80000000`. Because JavaScript numbers are
        // signed, we use the bitwise unsigned right shift operator to ensure that
        // the result is a positive number.
        // eslint-disable-next-line no-bitwise
        const pathIndex = (uint32 | HARDENED_VALUE) >>> 0;
        array.push(`bip32:${pathIndex - HARDENED_VALUE}'`);
    }
    return array;
}
/**
 * Derive entropy from the given mnemonic phrase and salt.
 *
 * This is based on the reference implementation of
 * [SIP-6](https://metamask.github.io/SIPs/SIPS/sip-6).
 *
 * @param options - The options for entropy derivation.
 * @param options.input - The input value to derive entropy from.
 * @param options.salt - An optional salt to use when deriving entropy.
 * @param options.mnemonicPhrase - The mnemonic phrase to use for entropy
 * derivation.
 * @param options.magic - A hardened BIP-32 index, which is used to derive the
 * root key from the mnemonic phrase.
 * @returns The derived entropy.
 */
async function deriveEntropy({ input, salt = '', mnemonicPhrase, magic, }) {
    const inputBytes = (0, utils_1.stringToBytes)(input);
    const saltBytes = (0, utils_1.stringToBytes)(salt);
    // Get the derivation path from the snap ID.
    const hash = (0, sha3_1.keccak_256)((0, utils_1.concatBytes)([inputBytes, (0, sha3_1.keccak_256)(saltBytes)]));
    const computedDerivationPath = getDerivationPathArray(hash);
    // Derive the private key using BIP-32.
    const { privateKey } = await key_tree_1.SLIP10Node.fromDerivationPath({
        derivationPath: [
            mnemonicPhrase,
            `bip32:${magic}`,
            ...computedDerivationPath,
        ],
        curve: 'secp256k1',
    });
    // This should never happen, but this keeps TypeScript happy.
    (0, utils_1.assert)(privateKey, 'Failed to derive the entropy.');
    return (0, utils_1.add0x)(privateKey);
}
exports.deriveEntropy = deriveEntropy;
/**
 * Superstruct struct for validating an enum value. This allows using both the
 * enum string values and the enum itself as values.
 *
 * @param constant - The enum to validate against.
 * @returns The superstruct struct.
 */
function enumValue(constant) {
    return (0, superstruct_1.literal)(constant);
}
exports.enumValue = enumValue;
//# sourceMappingURL=utils.js.map