{"version":3,"sources":["../../../src/derivers/shared.ts"],"sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n) {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = generateEntropy({\n      chainCode: node.chainCodeBytes,\n      extension: secretExtension,\n    });\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = generateEntropy({\n    chainCode: node.chainCodeBytes,\n    extension: publicExtension,\n  });\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never | undefined;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: (\n    error: unknown,\n    args: DeriveNodeArgs,\n  ) => Promise<DeriveNodeArgs>,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey({\n        entropy,\n        privateKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        isHardened,\n        curve,\n      });\n    }\n\n    return await derivePublicChildKey({\n      entropy,\n      publicKey,\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      childIndex,\n      curve,\n    });\n  } catch (error) {\n    return await deriveNode(await handleError(error, options), handleError);\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs) {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs) {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey({\n  entropy,\n  privateKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  isHardened,\n  curve,\n}: DerivePrivateChildKeyArgs): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    privateKey: childPrivateKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey({\n  entropy,\n  publicKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  curve,\n}: DerivePublicChildKeyArgs): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: childIndex,\n    curve: curve.name,\n  });\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @returns The generated entropy bytes.\n */\nexport function generateEntropy({ chainCode, extension }: GenerateEntropyArgs) {\n  return hmac(sha512, chainCode, extension);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nfunction getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n) {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"],"names":["deriveChildKey","deriveSecretExtension","derivePublicExtension","derivePublicChildKey","privateAdd","generateEntropy","validateNode","path","node","curve","handleError","childIndex","isHardened","getValidatedPath","args","chainCode","chainCodeBytes","depth","parentFingerprint","fingerprint","masterFingerprint","privateKeyBytes","secretExtension","privateKey","entropy","extension","deriveNode","publicExtension","parentPublicKey","compressedPublicKeyBytes","publicKey","options","derivePrivateChildKey","error","concatBytes","Uint8Array","numberToUint32","BIP_32_HARDENED_OFFSET","getPublicKey","generateKey","keyMaterial","slice","childChainCode","name","childPrivateKey","actualChildIndex","SLIP10Node","fromExtendedKey","index","generatePublicKey","childPublicKey","publicAdd","tweakBytes","assert","isValidBytesKey","bytesToBigInt","tweak","n","Error","added","mod","bytes","hexToBytes","toString","padStart","isValidPrivateKey","hmac","sha512","validatePath","endsWith","deriveUnhardenedKeys","indexPart","split","parseInt","UNPREFIXED_PATH_REGEX","test","Number","isInteger","includes"],"mappings":"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"}