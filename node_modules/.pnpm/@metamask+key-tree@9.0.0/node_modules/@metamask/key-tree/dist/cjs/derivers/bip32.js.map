{"version":3,"sources":["../../../src/derivers/bip32.ts"],"sourcesContent":["import { assert } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = generateEntropy({\n      chainCode,\n      extension: secretExtension,\n    });\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"],"names":["privateKeyToEthAddress","publicKeyToEthAddress","deriveChildKey","key","assert","Uint8Array","isValidBytesKey","BYTES_KEY_LENGTH","publicKey","secp256k1","getPublicKey","publicKeyLength","keccak256","slice","options","curve","name","sharedDeriveChildKey","handleError","_","childIndex","privateKey","isHardened","chainCode","validateBIP32Index","secretExtension","deriveSecretExtension","newEntropy","generateEntropy","extension","entropy","publicExtension","derivePublicExtension","parentPublicKey"],"mappings":";;;;;;;;;;;IA2BgBA,sBAAsB;eAAtBA;;IAqBAC,qBAAqB;eAArBA;;IAmBMC,cAAc;eAAdA;;;uBAnEC;sBACiB;2BAGP;wBACP;wBAE0B;wBAO7C;AAaA,SAASF,uBAAuBG,GAAe;IACpDC,IAAAA,aAAM,EACJD,eAAeE,cAAcC,IAAAA,uBAAe,EAACH,KAAKI,2BAAgB,GAClE;IAGF,MAAMC,YAAYC,iBAAS,CAACC,YAAY,CAACP,KAAK;IAC9C,OAAOF,sBAAsBO;AAC/B;AAaO,SAASP,sBAAsBE,GAAe;IACnDC,IAAAA,aAAM,EACJD,eAAeE,cACbC,IAAAA,uBAAe,EAACH,KAAKM,iBAAS,CAACE,eAAe,GAChD;IAGF,OAAOC,IAAAA,gBAAS,EAACT,IAAIU,KAAK,CAAC,IAAIA,KAAK,CAAC,CAAC;AACxC;AAWO,eAAeX,eACpBY,OAA2B;IAE3BV,IAAAA,aAAM,EACJU,QAAQC,KAAK,CAACC,IAAI,KAAK,aACvB;IAGF,OAAOC,IAAAA,sBAAoB,EAACH,SAASI;AACvC;AAEA;;;;;;;;CAQC,GACD,eAAeA,YACbC,CAAU,EACVL,OAAuB;IAEvB,MAAM,EAAEM,UAAU,EAAEC,UAAU,EAAEb,SAAS,EAAEc,UAAU,EAAEP,KAAK,EAAEQ,SAAS,EAAE,GACvET;IAEFU,IAAAA,0BAAkB,EAACJ,aAAa;IAEhC,IAAIC,YAAY;QACd,MAAMI,kBAAkB,MAAMC,IAAAA,6BAAqB,EAAC;YAClDL;YACAD,YAAYA,aAAa;YACzBE;YACAP;QACF;QAEA,MAAMY,aAAaC,IAAAA,uBAAe,EAAC;YACjCL;YACAM,WAAWJ;QACb;QAEA,OAAO;YACL,GAAGX,OAAO;YACVM,YAAYA,aAAa;YACzBU,SAASH;QACX;IACF;IAEA,MAAMI,kBAAkBC,IAAAA,6BAAqB,EAAC;QAC5CC,iBAAiBzB;QACjBY,YAAYA,aAAa;IAC3B;IAEA,MAAMO,aAAaC,IAAAA,uBAAe,EAAC;QACjCL;QACAM,WAAWE;IACb;IAEA,OAAO;QACL,GAAGjB,OAAO;QACVM,YAAYA,aAAa;QACzBU,SAASH;IACX;AACF"}