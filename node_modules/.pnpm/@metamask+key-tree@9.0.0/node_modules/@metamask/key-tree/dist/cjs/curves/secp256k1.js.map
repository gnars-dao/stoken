{"version":3,"sources":["../../../src/curves/secp256k1.ts"],"sourcesContent":["import { assert, stringToBytes } from '@metamask/utils';\nimport {\n  getPublicKey as getSecp256k1PublicKey,\n  Point,\n  utils,\n} from '@noble/secp256k1';\n\nimport { isValidBytesKey } from '../utils';\n\nexport { CURVE as curve } from '@noble/secp256k1';\n\nexport const name = 'secp256k1';\n\n// Secret is defined in BIP-32 and SLIP-10:\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('Bitcoin seed');\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 65;\n\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  return utils.isValidPrivateKey(privateKey);\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  compressed?: boolean,\n): Uint8Array => getSecp256k1PublicKey(privateKey, compressed);\n\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  assert(\n    isValidBytesKey(tweak, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const point = Point.fromHex(publicKey);\n\n  // The returned child key Ki is point(parse256(IL)) + Kpar.\n  // This multiplies the tweak with the base point of the curve (Gx, Gy).\n  // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key\n  const newPoint = point.add(Point.fromPrivateKey(tweak));\n  newPoint.assertValidity();\n\n  return newPoint.toRawBytes(false);\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  const point = Point.fromHex(publicKey);\n  return point.toRawBytes(true);\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // This calculates a point on the elliptic curve from a compressed public key. We can then use\n  // this to get the uncompressed version of the public key.\n  const point = Point.fromHex(publicKey);\n  return point.toRawBytes(false);\n};\n"],"names":["curve","CURVE","name","secret","deriveUnhardenedKeys","publicKeyLength","isValidPrivateKey","getPublicKey","publicAdd","compressPublicKey","decompressPublicKey","stringToBytes","privateKey","utils","compressed","getSecp256k1PublicKey","publicKey","tweak","assert","isValidBytesKey","point","Point","fromHex","newPoint","add","fromPrivateKey","assertValidity","toRawBytes"],"mappings":";;;;;;;;;;;IASkBA,KAAK;eAAdC,gBAAK;;IAEDC,IAAI;eAAJA;;IAKAC,MAAM;eAANA;;IAEAC,oBAAoB;eAApBA;;IAEAC,eAAe;eAAfA;;IAEAC,iBAAiB;eAAjBA;;IAIAC,YAAY;eAAZA;;IAKAC,SAAS;eAATA;;IAoBAC,iBAAiB;eAAjBA;;IAKAC,mBAAmB;eAAnBA;;;uBAxDyB;2BAK/B;wBAEyB;AAIzB,MAAMR,OAAO;AAKb,MAAMC,SAASQ,IAAAA,oBAAa,EAAC;AAE7B,MAAMP,uBAAuB;AAE7B,MAAMC,kBAAkB;AAExB,MAAMC,oBAAoB,CAACM;IAChC,OAAOC,gBAAK,CAACP,iBAAiB,CAACM;AACjC;AAEO,MAAML,eAAe,CAC1BK,YACAE,aACeC,IAAAA,uBAAqB,EAACH,YAAYE;AAE5C,MAAMN,YAAY,CACvBQ,WACAC;IAEAC,IAAAA,aAAM,EACJC,IAAAA,uBAAe,EAACF,OAAO,KACvB;IAGF,MAAMG,QAAQC,gBAAK,CAACC,OAAO,CAACN;IAE5B,2DAA2D;IAC3D,uEAAuE;IACvE,uIAAuI;IACvI,MAAMO,WAAWH,MAAMI,GAAG,CAACH,gBAAK,CAACI,cAAc,CAACR;IAChDM,SAASG,cAAc;IAEvB,OAAOH,SAASI,UAAU,CAAC;AAC7B;AAEO,MAAMlB,oBAAoB,CAACO;IAChC,MAAMI,QAAQC,gBAAK,CAACC,OAAO,CAACN;IAC5B,OAAOI,MAAMO,UAAU,CAAC;AAC1B;AAEO,MAAMjB,sBAAsB,CAACM;IAClC,8FAA8F;IAC9F,0DAA0D;IAC1D,MAAMI,QAAQC,gBAAK,CAACC,OAAO,CAACN;IAC5B,OAAOI,MAAMO,UAAU,CAAC;AAC1B"}