{"version":3,"sources":["../../../src/curves/secp256k1.ts"],"sourcesContent":["import { assert, stringToBytes } from '@metamask/utils';\nimport {\n  getPublicKey as getSecp256k1PublicKey,\n  Point,\n  utils,\n} from '@noble/secp256k1';\n\nimport { isValidBytesKey } from '../utils';\n\nexport { CURVE as curve } from '@noble/secp256k1';\n\nexport const name = 'secp256k1';\n\n// Secret is defined in BIP-32 and SLIP-10:\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('Bitcoin seed');\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 65;\n\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  return utils.isValidPrivateKey(privateKey);\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  compressed?: boolean,\n): Uint8Array => getSecp256k1PublicKey(privateKey, compressed);\n\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  assert(\n    isValidBytesKey(tweak, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const point = Point.fromHex(publicKey);\n\n  // The returned child key Ki is point(parse256(IL)) + Kpar.\n  // This multiplies the tweak with the base point of the curve (Gx, Gy).\n  // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key\n  const newPoint = point.add(Point.fromPrivateKey(tweak));\n  newPoint.assertValidity();\n\n  return newPoint.toRawBytes(false);\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  const point = Point.fromHex(publicKey);\n  return point.toRawBytes(true);\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // This calculates a point on the elliptic curve from a compressed public key. We can then use\n  // this to get the uncompressed version of the public key.\n  const point = Point.fromHex(publicKey);\n  return point.toRawBytes(false);\n};\n"],"names":["assert","stringToBytes","getPublicKey","getSecp256k1PublicKey","Point","utils","isValidBytesKey","CURVE","curve","name","secret","deriveUnhardenedKeys","publicKeyLength","isValidPrivateKey","privateKey","compressed","publicAdd","publicKey","tweak","point","fromHex","newPoint","add","fromPrivateKey","assertValidity","toRawBytes","compressPublicKey","decompressPublicKey"],"mappings":"AAAA,SAASA,MAAM,EAAEC,aAAa,QAAQ,kBAAkB;AACxD,SACEC,gBAAgBC,qBAAqB,EACrCC,KAAK,EACLC,KAAK,QACA,mBAAmB;AAE1B,SAASC,eAAe,QAAQ,WAAW;AAE3C,SAASC,SAASC,KAAK,QAAQ,mBAAmB;AAElD,OAAO,MAAMC,OAAO,YAAY;AAEhC,2CAA2C;AAC3C,yHAAyH;AACzH,wHAAwH;AACxH,OAAO,MAAMC,SAAST,cAAc,gBAAgB;AAEpD,OAAO,MAAMU,uBAAuB,KAAK;AAEzC,OAAO,MAAMC,kBAAkB,GAAG;AAElC,OAAO,MAAMC,oBAAoB,CAACC;IAChC,OAAOT,MAAMQ,iBAAiB,CAACC;AACjC,EAAE;AAEF,OAAO,MAAMZ,eAAe,CAC1BY,YACAC,aACeZ,sBAAsBW,YAAYC,YAAY;AAE/D,OAAO,MAAMC,YAAY,CACvBC,WACAC;IAEAlB,OACEM,gBAAgBY,OAAO,KACvB;IAGF,MAAMC,QAAQf,MAAMgB,OAAO,CAACH;IAE5B,2DAA2D;IAC3D,uEAAuE;IACvE,uIAAuI;IACvI,MAAMI,WAAWF,MAAMG,GAAG,CAAClB,MAAMmB,cAAc,CAACL;IAChDG,SAASG,cAAc;IAEvB,OAAOH,SAASI,UAAU,CAAC;AAC7B,EAAE;AAEF,OAAO,MAAMC,oBAAoB,CAACT;IAChC,MAAME,QAAQf,MAAMgB,OAAO,CAACH;IAC5B,OAAOE,MAAMM,UAAU,CAAC;AAC1B,EAAE;AAEF,OAAO,MAAME,sBAAsB,CAACV;IAClC,8FAA8F;IAC9F,0DAA0D;IAC1D,MAAME,QAAQf,MAAMgB,OAAO,CAACH;IAC5B,OAAOE,MAAMM,UAAU,CAAC;AAC1B,EAAE"}