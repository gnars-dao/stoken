{"version":3,"sources":["../../src/derivation.ts"],"sourcesContent":["import { assert } from '@metamask/utils';\n\nimport { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport { BIP44Node } from './BIP44Node';\nimport type { SLIP10Path } from './constants';\nimport {\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MIN_BIP_44_DEPTH,\n  SLIP_10_PATH_REGEX,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport type { Deriver } from './derivers';\nimport { derivers } from './derivers';\nimport { SLIP10Node } from './SLIP10Node';\n\n/**\n * Ethereum default seed path: \"m/44'/60'/0'/0/{account_index}\"\n * Multipath: \"bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}\"\n *\n * m: { privateKey, chainCode } = sha512Hmac(\"Bitcoin seed\", masterSeed)\n * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n */\n\ntype BaseDeriveKeyFromPathArgs = {\n  path: SLIP10Path;\n  depth?: number;\n};\n\ntype DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {\n  node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\ntype DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {\n  curve: SupportedCurve;\n};\n\ntype DeriveKeyFromPathArgs =\n  | DeriveKeyFromPathNodeArgs\n  | DeriveKeyFromPathCurveArgs;\n\n/**\n * Takes a full or partial HD path string and returns the key corresponding to\n * the given path, with the following constraints:\n *\n * - If the path starts with a BIP-32 node, a parent key must be provided.\n * - If the path starts with a BIP-39 node, a parent key must NOT be provided.\n * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by\n * a single BIP-39 node.\n *\n * WARNING: It is the consumer's responsibility to ensure that the path is valid\n * relative to its parent key.\n *\n * @param args - The arguments for deriving a key from a path.\n * @param args.path - A full or partial HD path, e.g.:\n * `bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0`.\n * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.\n * @param args.node - The node to derive from.\n * @param args.depth - The depth of the segment.\n * @returns The derived key.\n */\nexport async function deriveKeyFromPath(\n  args: DeriveKeyFromPathArgs,\n): Promise<SLIP10Node> {\n  const { path, depth = path.length } = args;\n\n  const node = 'node' in args ? args.node : undefined;\n  const curve = 'curve' in args ? args.curve : node?.curve;\n\n  if (\n    node &&\n    !(node instanceof SLIP10Node) &&\n    !(node instanceof BIP44Node) &&\n    !(node instanceof BIP44CoinTypeNode)\n  ) {\n    throw new Error(\n      'Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.',\n    );\n  }\n\n  if (!curve) {\n    throw new Error(\n      'Invalid arguments: Must specify either a parent node or curve.',\n    );\n  }\n\n  validatePathSegment(\n    path,\n    Boolean(node?.privateKey) || Boolean(node?.publicKey),\n    depth,\n  );\n\n  // Derive through each part of path. `pathSegment` needs to be cast because\n  // `HDPathTuple.reduce()` doesn't work. Note that the first element of the\n  // path can be a Uint8Array.\n  return await (path as readonly [Uint8Array | string, ...string[]]).reduce<\n    Promise<SLIP10Node>\n  >(async (promise, pathNode, index) => {\n    const derivedNode = await promise;\n\n    if (typeof pathNode === 'string') {\n      const [pathType, pathPart] = pathNode.split(':');\n\n      assert(pathType);\n      assert(pathPart);\n      assert(hasDeriver(pathType), `Unknown derivation type: \"${pathType}\".`);\n\n      const deriver = derivers[pathType] as Deriver;\n      return await deriver.deriveChildKey({\n        path: pathPart,\n        node: derivedNode,\n        curve: getCurveByName(curve),\n      });\n    }\n\n    // Only the first path segment can be a Uint8Array.\n    assert(index === 0, getMalformedError());\n\n    return await derivers.bip39.deriveChildKey({\n      path: pathNode,\n      node: derivedNode,\n      curve: getCurveByName(curve),\n    });\n  }, Promise.resolve(node as SLIP10Node));\n}\n\n/**\n * Check if the given path type is a valid deriver.\n *\n * @param pathType - The path type to check.\n * @returns Whether the path type is a valid deriver.\n */\nfunction hasDeriver(pathType: string): pathType is keyof typeof derivers {\n  return pathType in derivers;\n}\n\n/**\n * The path segment must be one of the following:\n * - A lone BIP-32 path node.\n * - A lone BIP-39 path node.\n * - A multipath.\n *\n * @param path - The path segment string to validate.\n * @param hasKey - Whether the path segment has a key.\n * @param depth - The depth of the segment.\n */\nexport function validatePathSegment(\n  path: SLIP10Path,\n  hasKey: boolean,\n  depth?: number,\n) {\n  if ((path as any).length === 0) {\n    throw new Error(`Invalid HD path segment: The segment must not be empty.`);\n  }\n\n  let startsWithBip39 = false;\n  path.forEach((node, index) => {\n    if (index === 0) {\n      startsWithBip39 =\n        node instanceof Uint8Array || BIP_39_PATH_REGEX.test(node);\n\n      if (\n        // TypeScript is unable to infer that `node` is a string here, so we\n        // need to explicitly check it again.\n        !(node instanceof Uint8Array) &&\n        !startsWithBip39 &&\n        !BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node)\n      ) {\n        throw getMalformedError();\n      }\n    } else if (\n      node instanceof Uint8Array ||\n      (!BIP_32_PATH_REGEX.test(node) && !SLIP_10_PATH_REGEX.test(node))\n    ) {\n      throw getMalformedError();\n    }\n  });\n\n  if (depth === MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {\n    throw new Error(\n      `Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${MIN_BIP_44_DEPTH}. Received: \"${String(\n        path,\n      )}\".`,\n    );\n  }\n\n  if (!hasKey && !startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.',\n    );\n  }\n\n  if (hasKey && startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.',\n    );\n  }\n\n  const pathWithoutKey = (startsWithBip39 ? path.slice(1) : path) as string[];\n  if (pathWithoutKey.length > 0) {\n    const firstSegmentType = pathWithoutKey[0]?.split(':')[0];\n    assert(firstSegmentType);\n    assert(\n      pathWithoutKey.every((segment) =>\n        segment.startsWith(`${firstSegmentType}:`),\n      ),\n      `Invalid HD path segment: Cannot mix 'bip32' and 'slip10' path segments.`,\n    );\n  }\n}\n\n/**\n * Get the error for a malformed path segment.\n *\n * @returns The error.\n */\nfunction getMalformedError() {\n  return new Error('Invalid HD path segment: The path segment is malformed.');\n}\n"],"names":["assert","BIP44CoinTypeNode","BIP44Node","BIP_32_PATH_REGEX","BIP_39_PATH_REGEX","MIN_BIP_44_DEPTH","SLIP_10_PATH_REGEX","getCurveByName","derivers","SLIP10Node","deriveKeyFromPath","args","path","depth","length","node","undefined","curve","Error","validatePathSegment","Boolean","privateKey","publicKey","reduce","promise","pathNode","index","derivedNode","pathType","pathPart","split","hasDeriver","deriver","deriveChildKey","getMalformedError","bip39","Promise","resolve","hasKey","startsWithBip39","forEach","Uint8Array","test","String","pathWithoutKey","slice","firstSegmentType","every","segment","startsWith"],"mappings":"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"}