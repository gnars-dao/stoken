{"version":3,"sources":["../../../src/derivers/bip32.ts"],"sourcesContent":["import { assert } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = generateEntropy({\n      chainCode,\n      extension: secretExtension,\n    });\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"],"names":["assert","keccak_256","keccak256","BYTES_KEY_LENGTH","secp256k1","isValidBytesKey","validateBIP32Index","deriveChildKey","sharedDeriveChildKey","deriveSecretExtension","generateEntropy","derivePublicExtension","privateKeyToEthAddress","key","Uint8Array","publicKey","getPublicKey","publicKeyToEthAddress","publicKeyLength","slice","options","curve","name","handleError","_","childIndex","privateKey","isHardened","chainCode","secretExtension","newEntropy","extension","entropy","publicExtension","parentPublicKey"],"mappings":"AAAA,SAASA,MAAM,QAAQ,kBAAkB;AACzC,SAASC,cAAcC,SAAS,QAAQ,qBAAqB;AAG7D,SAASC,gBAAgB,QAAQ,eAAe;AAChD,SAASC,SAAS,QAAQ,YAAY;AAEtC,SAASC,eAAe,EAAEC,kBAAkB,QAAQ,WAAW;AAE/D,SACEC,kBAAkBC,oBAAoB,EACtCC,qBAAqB,EACrBC,eAAe,EACfC,qBAAqB,QAChB,WAAW;AAElB;;;;;;;;;;CAUC,GACD,OAAO,SAASC,uBAAuBC,GAAe;IACpDb,OACEa,eAAeC,cAAcT,gBAAgBQ,KAAKV,mBAClD;IAGF,MAAMY,YAAYX,UAAUY,YAAY,CAACH,KAAK;IAC9C,OAAOI,sBAAsBF;AAC/B;AAEA;;;;;;;;;;CAUC,GACD,OAAO,SAASE,sBAAsBJ,GAAe;IACnDb,OACEa,eAAeC,cACbT,gBAAgBQ,KAAKT,UAAUc,eAAe,GAChD;IAGF,OAAOhB,UAAUW,IAAIM,KAAK,CAAC,IAAIA,KAAK,CAAC,CAAC;AACxC;AAEA;;;;;;;;CAQC,GACD,OAAO,eAAeZ,eACpBa,OAA2B;IAE3BpB,OACEoB,QAAQC,KAAK,CAACC,IAAI,KAAK,aACvB;IAGF,OAAOd,qBAAqBY,SAASG;AACvC;AAEA;;;;;;;;CAQC,GACD,eAAeA,YACbC,CAAU,EACVJ,OAAuB;IAEvB,MAAM,EAAEK,UAAU,EAAEC,UAAU,EAAEX,SAAS,EAAEY,UAAU,EAAEN,KAAK,EAAEO,SAAS,EAAE,GACvER;IAEFd,mBAAmBmB,aAAa;IAEhC,IAAIC,YAAY;QACd,MAAMG,kBAAkB,MAAMpB,sBAAsB;YAClDiB;YACAD,YAAYA,aAAa;YACzBE;YACAN;QACF;QAEA,MAAMS,aAAapB,gBAAgB;YACjCkB;YACAG,WAAWF;QACb;QAEA,OAAO;YACL,GAAGT,OAAO;YACVK,YAAYA,aAAa;YACzBO,SAASF;QACX;IACF;IAEA,MAAMG,kBAAkBtB,sBAAsB;QAC5CuB,iBAAiBnB;QACjBU,YAAYA,aAAa;IAC3B;IAEA,MAAMK,aAAapB,gBAAgB;QACjCkB;QACAG,WAAWE;IACb;IAEA,OAAO;QACL,GAAGb,OAAO;QACVK,YAAYA,aAAa;QACzBO,SAASF;IACX;AACF"}