{"version":3,"sources":["../../../src/derivers/shared.ts"],"sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n) {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = generateEntropy({\n      chainCode: node.chainCodeBytes,\n      extension: secretExtension,\n    });\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = generateEntropy({\n    chainCode: node.chainCodeBytes,\n    extension: publicExtension,\n  });\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never | undefined;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: (\n    error: unknown,\n    args: DeriveNodeArgs,\n  ) => Promise<DeriveNodeArgs>,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey({\n        entropy,\n        privateKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        isHardened,\n        curve,\n      });\n    }\n\n    return await derivePublicChildKey({\n      entropy,\n      publicKey,\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      childIndex,\n      curve,\n    });\n  } catch (error) {\n    return await deriveNode(await handleError(error, options), handleError);\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs) {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs) {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey({\n  entropy,\n  privateKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  isHardened,\n  curve,\n}: DerivePrivateChildKeyArgs): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    privateKey: childPrivateKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey({\n  entropy,\n  publicKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  curve,\n}: DerivePublicChildKeyArgs): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: childIndex,\n    curve: curve.name,\n  });\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @returns The generated entropy bytes.\n */\nexport function generateEntropy({ chainCode, extension }: GenerateEntropyArgs) {\n  return hmac(sha512, chainCode, extension);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nfunction getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n) {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"],"names":["assert","bytesToBigInt","concatBytes","hexToBytes","hmac","sha512","BIP_32_HARDENED_OFFSET","UNPREFIXED_PATH_REGEX","mod","SLIP10Node","isValidBytesKey","numberToUint32","deriveChildKey","path","node","curve","handleError","validateNode","childIndex","isHardened","getValidatedPath","args","chainCode","chainCodeBytes","depth","parentFingerprint","fingerprint","masterFingerprint","privateKeyBytes","secretExtension","deriveSecretExtension","privateKey","entropy","generateEntropy","extension","deriveNode","publicExtension","derivePublicExtension","parentPublicKey","compressedPublicKeyBytes","publicKey","options","derivePrivateChildKey","derivePublicChildKey","error","Uint8Array","getPublicKey","generateKey","keyMaterial","slice","childChainCode","name","childPrivateKey","privateAdd","actualChildIndex","fromExtendedKey","index","generatePublicKey","childPublicKey","publicAdd","tweakBytes","tweak","n","Error","added","bytes","toString","padStart","isValidPrivateKey","validatePath","endsWith","deriveUnhardenedKeys","indexPart","split","parseInt","test","Number","isInteger","includes"],"mappings":"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"}