{"version":3,"sources":["../../../src/derivers/bip39.ts"],"sourcesContent":["import { mnemonicToSeed } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert } from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { BIP39StringNode } from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { Curve } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path.\n * @param options.curve - The curve to use for derivation.\n * @returns The node.\n */\nexport async function deriveChildKey({\n  path,\n  curve,\n}: DeriveChildKeyArgs): Promise<SLIP10Node> {\n  return createBip39KeyFromSeed(\n    await mnemonicToSeed(path, englishWordlist),\n    curve,\n  );\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Curve,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = hmac(sha512, curve.secret, seed);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey, true),\n  );\n\n  return SLIP10Node.fromExtendedKey({\n    privateKey,\n    chainCode,\n    masterFingerprint,\n    depth: 0,\n    parentFingerprint: 0,\n    index: 0,\n    curve: curve.name,\n  });\n}\n"],"names":["mnemonicToSeed","wordlist","englishWordlist","assert","hmac","sha512","BYTES_KEY_LENGTH","SLIP10Node","getFingerprint","bip39MnemonicToMultipath","mnemonic","toLowerCase","trim","deriveChildKey","path","curve","createBip39KeyFromSeed","seed","length","key","secret","privateKey","slice","chainCode","isValidPrivateKey","masterFingerprint","getPublicKey","fromExtendedKey","depth","parentFingerprint","index","name"],"mappings":"AAAA,SAASA,cAAc,QAAQ,wBAAwB;AACvD,SAASC,YAAYC,eAAe,QAAQ,+CAA+C;AAC3F,SAASC,MAAM,QAAQ,kBAAkB;AACzC,SAASC,IAAI,QAAQ,qBAAqB;AAC1C,SAASC,MAAM,QAAQ,uBAAuB;AAI9C,SAASC,gBAAgB,QAAQ,eAAe;AAEhD,SAASC,UAAU,QAAQ,gBAAgB;AAC3C,SAASC,cAAc,QAAQ,WAAW;AAE1C;;;;;CAKC,GACD,OAAO,SAASC,yBAAyBC,QAAgB;IACvD,OAAO,CAAC,MAAM,EAAEA,SAASC,WAAW,GAAGC,IAAI,GAAG,CAAC;AACjD;AAEA;;;;;;;CAOC,GACD,OAAO,eAAeC,eAAe,EACnCC,IAAI,EACJC,KAAK,EACc;IACnB,OAAOC,uBACL,MAAMhB,eAAec,MAAMZ,kBAC3Ba;AAEJ;AAEA;;;;;;;CAOC,GACD,OAAO,eAAeC,uBACpBC,IAAgB,EAChBF,KAAY;IAEZZ,OACEc,KAAKC,MAAM,IAAI,MAAMD,KAAKC,MAAM,IAAI,IACpC;IAGF,MAAMC,MAAMf,KAAKC,QAAQU,MAAMK,MAAM,EAAEH;IACvC,MAAMI,aAAaF,IAAIG,KAAK,CAAC,GAAGhB;IAChC,MAAMiB,YAAYJ,IAAIG,KAAK,CAAChB;IAE5BH,OACEY,MAAMS,iBAAiB,CAACH,aACxB;IAGF,MAAMI,oBAAoBjB,eACxB,MAAMO,MAAMW,YAAY,CAACL,YAAY;IAGvC,OAAOd,WAAWoB,eAAe,CAAC;QAChCN;QACAE;QACAE;QACAG,OAAO;QACPC,mBAAmB;QACnBC,OAAO;QACPf,OAAOA,MAAMgB,IAAI;IACnB;AACF"}