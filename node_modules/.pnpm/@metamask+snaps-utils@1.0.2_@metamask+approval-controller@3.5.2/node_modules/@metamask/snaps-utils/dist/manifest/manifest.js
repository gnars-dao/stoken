"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNpmSnapManifest = exports.getWritableManifest = exports.getSnapIcon = exports.getSnapSourceCode = exports.fixManifest = exports.checkManifest = void 0;
const utils_1 = require("@metamask/utils");
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const deep_clone_1 = require("../deep-clone");
const fs_2 = require("../fs");
const npm_1 = require("../npm");
const snaps_1 = require("../snaps");
const types_1 = require("../types");
const virtual_file_1 = require("../virtual-file");
const MANIFEST_SORT_ORDER = {
    version: 1,
    description: 2,
    proposedName: 3,
    repository: 4,
    source: 5,
    initialPermissions: 6,
    manifestVersion: 7,
};
/**
 * Validates a snap.manifest.json file. Attempts to fix the manifest and write
 * the fixed version to disk if `writeManifest` is true. Throws if validation
 * fails.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param writeManifest - Whether to write the fixed manifest to disk.
 * @param sourceCode - The source code of the Snap.
 * @returns Whether the manifest was updated, and an array of warnings that
 * were encountered during processing of the manifest files.
 */
async function checkManifest(basePath, writeManifest = true, sourceCode) {
    const warnings = [];
    const errors = [];
    let updated = false;
    const manifestPath = path_1.default.join(basePath, types_1.NpmSnapFileNames.Manifest);
    const manifestFile = await (0, fs_2.readJsonFile)(manifestPath);
    const unvalidatedManifest = manifestFile.result;
    const packageFile = await (0, fs_2.readJsonFile)(path_1.default.join(basePath, types_1.NpmSnapFileNames.PackageJson));
    const snapFiles = {
        manifest: manifestFile,
        packageJson: packageFile,
        sourceCode: await getSnapSourceCode(basePath, unvalidatedManifest, sourceCode),
        svgIcon: await getSnapIcon(basePath, unvalidatedManifest),
    };
    let manifest;
    try {
        ({ manifest } = (0, npm_1.validateNpmSnap)(snapFiles));
    }
    catch (error) {
        if (error instanceof snaps_1.ProgrammaticallyFixableSnapError) {
            errors.push(error.message);
            // If we get here, the files at least have the correct shape.
            const partiallyValidatedFiles = snapFiles;
            let isInvalid = true;
            let currentError = error;
            const maxAttempts = Object.keys(types_1.SnapValidationFailureReason).length;
            // Attempt to fix all fixable validation failure reasons. All such reasons
            // are enumerated by the `SnapValidationFailureReason` enum, so we only
            // attempt to fix the manifest the same amount of times as there are
            // reasons in the enum.
            for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {
                manifest = fixManifest(manifest
                    ? { ...partiallyValidatedFiles, manifest }
                    : partiallyValidatedFiles, currentError);
                try {
                    validateNpmSnapManifest({ ...partiallyValidatedFiles, manifest });
                    isInvalid = false;
                }
                catch (nextValidationError) {
                    currentError = nextValidationError;
                    /* istanbul ignore next: this should be impossible */
                    if (!(nextValidationError instanceof snaps_1.ProgrammaticallyFixableSnapError) ||
                        (attempts === maxAttempts && !isInvalid)) {
                        throw new Error(`Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\n${error.message}`);
                    }
                    errors.push(currentError.message);
                }
            }
            updated = true;
        }
        else {
            throw error;
        }
    }
    // TypeScript assumes `manifest` can still be undefined, that is not the case.
    // But we assert to keep TypeScript happy.
    (0, utils_1.assert)(manifest);
    const validatedManifest = manifest.result;
    // Check presence of recommended keys
    const recommendedFields = ['repository'];
    const missingRecommendedFields = recommendedFields.filter((key) => !validatedManifest[key]);
    if (missingRecommendedFields.length > 0) {
        warnings.push(`Missing recommended package.json properties:\n${missingRecommendedFields.reduce((allMissing, currentField) => {
            return `${allMissing}\t${currentField}\n`;
        }, '')}`);
    }
    if (writeManifest) {
        try {
            const newManifest = `${JSON.stringify(getWritableManifest(validatedManifest), null, 2)}\n`;
            if (updated || newManifest !== manifestFile.value) {
                await fs_1.promises.writeFile(path_1.default.join(basePath, types_1.NpmSnapFileNames.Manifest), newManifest);
            }
        }
        catch (error) {
            // Note: This error isn't pushed to the errors array, because it's not an
            // error in the manifest itself.
            throw new Error(`Failed to update snap.manifest.json: ${error.message}`);
        }
    }
    return { manifest: validatedManifest, updated, warnings, errors };
}
exports.checkManifest = checkManifest;
/**
 * Given the relevant Snap files (manifest, `package.json`, and bundle) and a
 * Snap manifest validation error, fixes the fault in the manifest that caused
 * the error.
 *
 * @param snapFiles - The contents of all Snap files.
 * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.
 * @returns A copy of the manifest file where the cause of the error is fixed.
 */
function fixManifest(snapFiles, error) {
    const { manifest, packageJson } = snapFiles;
    const clonedFile = manifest.clone();
    const manifestCopy = clonedFile.result;
    switch (error.reason) {
        case types_1.SnapValidationFailureReason.NameMismatch:
            manifestCopy.source.location.npm.packageName = packageJson.result.name;
            break;
        case types_1.SnapValidationFailureReason.VersionMismatch:
            manifestCopy.version = packageJson.result.version;
            break;
        case types_1.SnapValidationFailureReason.RepositoryMismatch:
            manifestCopy.repository = packageJson.result.repository
                ? (0, deep_clone_1.deepClone)(packageJson.result.repository)
                : undefined;
            break;
        case types_1.SnapValidationFailureReason.ShasumMismatch:
            manifestCopy.source.shasum = (0, snaps_1.getSnapChecksum)(snapFiles);
            break;
        /* istanbul ignore next */
        default:
            (0, utils_1.assertExhaustive)(error.reason);
    }
    clonedFile.result = manifestCopy;
    clonedFile.value = JSON.stringify(manifestCopy);
    return clonedFile;
}
exports.fixManifest = fixManifest;
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * bundle source file location and read the file.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param manifest - The unvalidated Snap manifest file contents.
 * @param sourceCode - Override source code for plugins.
 * @returns The contents of the bundle file, if any.
 */
async function getSnapSourceCode(basePath, manifest, sourceCode) {
    if (!(0, utils_1.isPlainObject)(manifest)) {
        return undefined;
    }
    const sourceFilePath = manifest.source?.location
        ?.npm?.filePath;
    if (!sourceFilePath) {
        return undefined;
    }
    if (sourceCode) {
        return new virtual_file_1.VirtualFile({
            path: path_1.default.join(basePath, sourceFilePath),
            value: sourceCode,
        });
    }
    try {
        const virtualFile = await (0, virtual_file_1.readVirtualFile)(path_1.default.join(basePath, sourceFilePath), 'utf8');
        return virtualFile;
    }
    catch (error) {
        throw new Error(`Failed to read Snap bundle file: ${error.message}`);
    }
}
exports.getSnapSourceCode = getSnapSourceCode;
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * icon and read the file.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param manifest - The unvalidated Snap manifest file contents.
 * @returns The contents of the icon, if any.
 */
async function getSnapIcon(basePath, manifest) {
    if (!(0, utils_1.isPlainObject)(manifest)) {
        return undefined;
    }
    const iconPath = manifest.source?.location?.npm
        ?.iconPath;
    if (!iconPath) {
        return undefined;
    }
    try {
        const virtualFile = await (0, virtual_file_1.readVirtualFile)(path_1.default.join(basePath, iconPath), 'utf8');
        return virtualFile;
    }
    catch (error) {
        throw new Error(`Failed to read Snap icon file: ${error.message}`);
    }
}
exports.getSnapIcon = getSnapIcon;
/**
 * Sorts the given manifest in our preferred sort order and removes the
 * `repository` field if it is falsy (it may be `null`).
 *
 * @param manifest - The manifest to sort and modify.
 * @returns The disk-ready manifest.
 */
function getWritableManifest(manifest) {
    const { repository, ...remaining } = manifest;
    const keys = Object.keys(repository ? { ...remaining, repository } : remaining);
    const writableManifest = keys
        .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])
        .reduce((result, key) => ({
        ...result,
        [key]: manifest[key],
    }), {});
    return writableManifest;
}
exports.getWritableManifest = getWritableManifest;
/**
 * Validates the fields of an npm Snap manifest that has already passed JSON
 * Schema validation.
 *
 * @param snapFiles - The relevant snap files to validate.
 * @param snapFiles.manifest - The npm Snap manifest to validate.
 * @param snapFiles.packageJson - The npm Snap's `package.json`.
 * @param snapFiles.sourceCode - The Snap's source code.
 * @param snapFiles.svgIcon - The Snap's optional icon.
 */
function validateNpmSnapManifest({ manifest, packageJson, sourceCode, svgIcon, }) {
    const packageJsonName = packageJson.result.name;
    const packageJsonVersion = packageJson.result.version;
    const packageJsonRepository = packageJson.result.repository;
    const manifestPackageName = manifest.result.source.location.npm.packageName;
    const manifestPackageVersion = manifest.result.version;
    const manifestRepository = manifest.result.repository;
    if (packageJsonName !== manifestPackageName) {
        throw new snaps_1.ProgrammaticallyFixableSnapError(`"${types_1.NpmSnapFileNames.Manifest}" npm package name ("${manifestPackageName}") does not match the "${types_1.NpmSnapFileNames.PackageJson}" "name" field ("${packageJsonName}").`, types_1.SnapValidationFailureReason.NameMismatch);
    }
    if (packageJsonVersion !== manifestPackageVersion) {
        throw new snaps_1.ProgrammaticallyFixableSnapError(`"${types_1.NpmSnapFileNames.Manifest}" npm package version ("${manifestPackageVersion}") does not match the "${types_1.NpmSnapFileNames.PackageJson}" "version" field ("${packageJsonVersion}").`, types_1.SnapValidationFailureReason.VersionMismatch);
    }
    if (
    // The repository may be `undefined` in package.json but can only be defined
    // or `null` in the Snap manifest due to TS@<4.4 issues.
    (packageJsonRepository || manifestRepository) &&
        !(0, fast_deep_equal_1.default)(packageJsonRepository, manifestRepository)) {
        throw new snaps_1.ProgrammaticallyFixableSnapError(`"${types_1.NpmSnapFileNames.Manifest}" "repository" field does not match the "${types_1.NpmSnapFileNames.PackageJson}" "repository" field.`, types_1.SnapValidationFailureReason.RepositoryMismatch);
    }
    (0, snaps_1.validateSnapShasum)({ manifest, sourceCode, svgIcon }, `"${types_1.NpmSnapFileNames.Manifest}" "shasum" field does not match computed shasum.`);
}
exports.validateNpmSnapManifest = validateNpmSnapManifest;
//# sourceMappingURL=manifest.js.map