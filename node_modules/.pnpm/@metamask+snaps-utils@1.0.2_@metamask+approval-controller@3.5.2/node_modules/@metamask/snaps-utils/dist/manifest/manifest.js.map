{"version":3,"file":"manifest.js","sourceRoot":"","sources":["../../src/manifest/manifest.ts"],"names":[],"mappings":"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","sourcesContent":["import { Json, assertExhaustive, assert, isPlainObject } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { validateNpmSnap } from '../npm';\nimport {\n  getSnapChecksum,\n  ProgrammaticallyFixableSnapError,\n  validateSnapShasum,\n} from '../snaps';\nimport {\n  NpmSnapFileNames,\n  SnapFiles,\n  SnapValidationFailureReason,\n  UnvalidatedSnapFiles,\n} from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file';\nimport { SnapManifest } from './validation';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  version: 1,\n  description: 2,\n  proposedName: 3,\n  repository: 4,\n  source: 5,\n  initialPermissions: 6,\n  manifestVersion: 7,\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was updated.\n * @property warnings - An array of warnings that were encountered during\n * processing of the manifest files. These warnings are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n * @property errors - An array of errors that were encountered during\n * processing of the manifest files. These errors are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n */\nexport type CheckManifestResult = {\n  manifest: SnapManifest;\n  updated?: boolean;\n  warnings: string[];\n  errors: string[];\n};\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param writeManifest - Whether to write the fixed manifest to disk.\n * @param sourceCode - The source code of the Snap.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  writeManifest = true,\n  sourceCode?: string,\n): Promise<CheckManifestResult> {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  let updated = false;\n\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n  };\n\n  let manifest: VirtualFile<SnapManifest> | undefined;\n  try {\n    ({ manifest } = validateNpmSnap(snapFiles));\n  } catch (error) {\n    if (error instanceof ProgrammaticallyFixableSnapError) {\n      errors.push(error.message);\n\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      let currentError = error;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the `SnapValidationFailureReason` enum, so we only\n      // attempt to fix the manifest the same amount of times as there are\n      // reasons in the enum.\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = fixManifest(\n          manifest\n            ? { ...partiallyValidatedFiles, manifest }\n            : partiallyValidatedFiles,\n          currentError,\n        );\n\n        try {\n          validateNpmSnapManifest({ ...partiallyValidatedFiles, manifest });\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          currentError = nextValidationError;\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n\n          errors.push(currentError.message);\n        }\n      }\n\n      updated = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript assumes `manifest` can still be undefined, that is not the case.\n  // But we assert to keep TypeScript happy.\n  assert(manifest);\n\n  const validatedManifest = manifest.result;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    warnings.push(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  if (writeManifest) {\n    try {\n      const newManifest = `${JSON.stringify(\n        getWritableManifest(validatedManifest),\n        null,\n        2,\n      )}\\n`;\n\n      if (updated || newManifest !== manifestFile.value) {\n        await fs.writeFile(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          newManifest,\n        );\n      }\n    } catch (error) {\n      // Note: This error isn't pushed to the errors array, because it's not an\n      // error in the manifest itself.\n      throw new Error(`Failed to update snap.manifest.json: ${error.message}`);\n    }\n  }\n\n  return { manifest: validatedManifest, updated, warnings, errors };\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nexport function fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): VirtualFile<SnapManifest> {\n  const { manifest, packageJson } = snapFiles;\n  const clonedFile = manifest.clone();\n  const manifestCopy = clonedFile.result;\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.result.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.result.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.result.repository\n        ? deepClone(packageJson.result.repository)\n        : undefined;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = getSnapChecksum(snapFiles);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(error.reason);\n  }\n\n  clonedFile.result = manifestCopy;\n  clonedFile.value = JSON.stringify(manifestCopy);\n  return clonedFile;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read Snap bundle file: ${error.message}`);\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read Snap icon file: ${error.message}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n\n/**\n * Validates the fields of an npm Snap manifest that has already passed JSON\n * Schema validation.\n *\n * @param snapFiles - The relevant snap files to validate.\n * @param snapFiles.manifest - The npm Snap manifest to validate.\n * @param snapFiles.packageJson - The npm Snap's `package.json`.\n * @param snapFiles.sourceCode - The Snap's source code.\n * @param snapFiles.svgIcon - The Snap's optional icon.\n */\nexport function validateNpmSnapManifest({\n  manifest,\n  packageJson,\n  sourceCode,\n  svgIcon,\n}: SnapFiles) {\n  const packageJsonName = packageJson.result.name;\n  const packageJsonVersion = packageJson.result.version;\n  const packageJsonRepository = packageJson.result.repository;\n\n  const manifestPackageName = manifest.result.source.location.npm.packageName;\n  const manifestPackageVersion = manifest.result.version;\n  const manifestRepository = manifest.result.repository;\n\n  if (packageJsonName !== manifestPackageName) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package name (\"${manifestPackageName}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"name\" field (\"${packageJsonName}\").`,\n      SnapValidationFailureReason.NameMismatch,\n    );\n  }\n\n  if (packageJsonVersion !== manifestPackageVersion) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package version (\"${manifestPackageVersion}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"version\" field (\"${packageJsonVersion}\").`,\n      SnapValidationFailureReason.VersionMismatch,\n    );\n  }\n\n  if (\n    // The repository may be `undefined` in package.json but can only be defined\n    // or `null` in the Snap manifest due to TS@<4.4 issues.\n    (packageJsonRepository || manifestRepository) &&\n    !deepEqual(packageJsonRepository, manifestRepository)\n  ) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" \"repository\" field does not match the \"${NpmSnapFileNames.PackageJson}\" \"repository\" field.`,\n      SnapValidationFailureReason.RepositoryMismatch,\n    );\n  }\n\n  validateSnapShasum(\n    { manifest, sourceCode, svgIcon },\n    `\"${NpmSnapFileNames.Manifest}\" \"shasum\" field does not match computed shasum.`,\n  );\n}\n"]}