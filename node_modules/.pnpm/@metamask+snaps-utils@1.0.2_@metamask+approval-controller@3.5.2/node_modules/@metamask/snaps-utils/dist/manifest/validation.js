"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSnapManifest = exports.assertIsSnapManifest = exports.isSnapManifest = exports.SnapManifestStruct = exports.PermissionsStruct = exports.SnapGetBip32EntropyPermissionsStruct = exports.Bip32EntropyStruct = exports.bip32entropy = exports.Bip32PathStruct = exports.FORBIDDEN_COIN_TYPES = void 0;
const key_tree_1 = require("@metamask/key-tree");
const utils_1 = require("@metamask/utils");
const superstruct_1 = require("superstruct");
const array_1 = require("../array");
const cronjob_1 = require("../cronjob");
const entropy_1 = require("../entropy");
const json_rpc_1 = require("../json-rpc");
const namespace_1 = require("../namespace");
const types_1 = require("../types");
// BIP-43 purposes that cannot be used for entropy derivation. These are in the
// string form, ending with `'`.
const FORBIDDEN_PURPOSES = [
    entropy_1.SIP_6_MAGIC_VALUE,
    entropy_1.STATE_ENCRYPTION_MAGIC_VALUE,
];
exports.FORBIDDEN_COIN_TYPES = [60];
const FORBIDDEN_PATHS = exports.FORBIDDEN_COIN_TYPES.map((coinType) => [
    'm',
    "44'",
    `${coinType}'`,
]);
exports.Bip32PathStruct = (0, superstruct_1.refine)((0, superstruct_1.array)((0, superstruct_1.string)()), 'BIP-32 path', (path) => {
    if (path.length === 0) {
        return 'Path must be a non-empty BIP-32 derivation path array';
    }
    if (path[0] !== 'm') {
        return 'Path must start with "m".';
    }
    if (path.length < 3) {
        return 'Paths must have a length of at least three.';
    }
    if (path.slice(1).some((part) => !(0, key_tree_1.isValidBIP32PathSegment)(part))) {
        return 'Path must be a valid BIP-32 derivation path array.';
    }
    if (FORBIDDEN_PURPOSES.includes(path[1])) {
        return `The purpose "${path[1]}" is not allowed for entropy derivation.`;
    }
    if (FORBIDDEN_PATHS.some((forbiddenPath) => (0, array_1.isEqual)(path.slice(0, forbiddenPath.length), forbiddenPath))) {
        return `The path "${path.join('/')}" is not allowed for entropy derivation.`;
    }
    return true;
});
const bip32entropy = (struct) => (0, superstruct_1.refine)(struct, 'BIP-32 entropy', (value) => {
    if (value.curve === 'ed25519' &&
        value.path.slice(1).some((part) => !part.endsWith("'"))) {
        return 'Ed25519 does not support unhardened paths.';
    }
    return true;
});
exports.bip32entropy = bip32entropy;
// Used outside @metamask/snap-utils
exports.Bip32EntropyStruct = (0, exports.bip32entropy)((0, superstruct_1.type)({
    path: exports.Bip32PathStruct,
    curve: (0, superstruct_1.enums)(['ed25519', 'secp256k1']),
}));
exports.SnapGetBip32EntropyPermissionsStruct = (0, superstruct_1.size)((0, superstruct_1.array)(exports.Bip32EntropyStruct), 1, Infinity);
/* eslint-disable @typescript-eslint/naming-convention */
exports.PermissionsStruct = (0, superstruct_1.type)({
    'endowment:long-running': (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    'endowment:network-access': (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    'endowment:webassembly': (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    'endowment:transaction-insight': (0, superstruct_1.optional)((0, superstruct_1.object)({
        allowTransactionOrigin: (0, superstruct_1.optional)((0, superstruct_1.boolean)()),
    })),
    'endowment:cronjob': (0, superstruct_1.optional)((0, superstruct_1.object)({ jobs: cronjob_1.CronjobSpecificationArrayStruct })),
    'endowment:rpc': (0, superstruct_1.optional)(json_rpc_1.RpcOriginsStruct),
    snap_dialog: (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    // TODO: Remove
    snap_confirm: (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    snap_manageState: (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    snap_notify: (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    snap_getBip32Entropy: (0, superstruct_1.optional)(exports.SnapGetBip32EntropyPermissionsStruct),
    snap_getBip32PublicKey: (0, superstruct_1.optional)(exports.SnapGetBip32EntropyPermissionsStruct),
    snap_getBip44Entropy: (0, superstruct_1.optional)((0, superstruct_1.size)((0, superstruct_1.array)((0, superstruct_1.object)({ coinType: (0, superstruct_1.size)((0, superstruct_1.integer)(), 0, 2 ** 32 - 1) })), 1, Infinity)),
    snap_getEntropy: (0, superstruct_1.optional)((0, superstruct_1.object)({})),
    'endowment:keyring': (0, superstruct_1.optional)((0, superstruct_1.object)({
        namespaces: namespace_1.NamespacesStruct,
    })),
});
exports.SnapManifestStruct = (0, superstruct_1.object)({
    version: utils_1.VersionStruct,
    description: (0, superstruct_1.size)((0, superstruct_1.string)(), 1, 280),
    proposedName: (0, superstruct_1.size)((0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u), 1, 214),
    repository: (0, superstruct_1.optional)((0, superstruct_1.object)({
        type: (0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity),
        url: (0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity),
    })),
    source: (0, superstruct_1.object)({
        shasum: utils_1.ChecksumStruct,
        location: (0, superstruct_1.object)({
            npm: (0, superstruct_1.object)({
                filePath: (0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity),
                iconPath: (0, superstruct_1.optional)((0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity)),
                packageName: types_1.NameStruct,
                registry: (0, superstruct_1.union)([
                    (0, superstruct_1.literal)('https://registry.npmjs.org'),
                    (0, superstruct_1.literal)('https://registry.npmjs.org/'),
                ]),
            }),
        }),
    }),
    initialPermissions: exports.PermissionsStruct,
    manifestVersion: (0, superstruct_1.literal)('0.1'),
});
/**
 * Check if the given value is a valid {@link SnapManifest} object.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link SnapManifest} object.
 */
function isSnapManifest(value) {
    return (0, superstruct_1.is)(value, exports.SnapManifestStruct);
}
exports.isSnapManifest = isSnapManifest;
/**
 * Assert that the given value is a valid {@link SnapManifest} object.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid {@link SnapManifest} object.
 */
function assertIsSnapManifest(value) {
    (0, utils_1.assertStruct)(value, exports.SnapManifestStruct, `"${types_1.NpmSnapFileNames.Manifest}" is invalid`);
}
exports.assertIsSnapManifest = assertIsSnapManifest;
/**
 * Creates a {@link SnapManifest} object from JSON.
 *
 *
 * @param value - The value to check.
 * @throws If the value cannot be coerced to a {@link SnapManifest} object.
 * @returns The created {@link SnapManifest} object.
 */
function createSnapManifest(value) {
    // TODO: Add a utility to prefix these errors similar to assertStruct
    return (0, superstruct_1.create)(value, exports.SnapManifestStruct);
}
exports.createSnapManifest = createSnapManifest;
//# sourceMappingURL=validation.js.map