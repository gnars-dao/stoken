"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNpmSnap = exports.SnapFileNameFromKey = exports.EXPECTED_SNAP_FILES = exports.SVG_MAX_BYTE_SIZE_TEXT = exports.SVG_MAX_BYTE_SIZE = void 0;
const manifest_1 = require("./manifest/manifest");
const validation_1 = require("./manifest/validation");
const types_1 = require("./types");
exports.SVG_MAX_BYTE_SIZE = 100000;
exports.SVG_MAX_BYTE_SIZE_TEXT = `${Math.floor(exports.SVG_MAX_BYTE_SIZE / 1000)}kb`;
exports.EXPECTED_SNAP_FILES = [
    'manifest',
    'packageJson',
    'sourceCode',
];
exports.SnapFileNameFromKey = {
    manifest: types_1.NpmSnapFileNames.Manifest,
    packageJson: types_1.NpmSnapFileNames.PackageJson,
    sourceCode: 'source code bundle',
};
/**
 * Validates the files extracted from an npm Snap package tarball by ensuring
 * that they're non-empty and that the Json files match their respective schemas
 * and the Snaps publishing specification.
 *
 * @param snapFiles - The object containing the expected Snap file contents,
 * if any.
 * @param errorPrefix - The prefix of the error message.
 * @returns A tuple of the Snap manifest object and the Snap source code.
 */
function validateNpmSnap(snapFiles, errorPrefix) {
    exports.EXPECTED_SNAP_FILES.forEach((key) => {
        if (!snapFiles[key]) {
            throw new Error(`${errorPrefix ?? ''}Missing file "${exports.SnapFileNameFromKey[key]}".`);
        }
    });
    // Typecast: We are assured that the required files exist if we get here.
    const { manifest, packageJson, sourceCode, svgIcon } = snapFiles;
    try {
        (0, validation_1.assertIsSnapManifest)(manifest.result);
    }
    catch (error) {
        throw new Error(`${errorPrefix ?? ''}${error.message}`);
    }
    const validatedManifest = manifest;
    const { iconPath } = validatedManifest.result.source.location.npm;
    if (iconPath && !svgIcon) {
        throw new Error(`Missing file "${iconPath}".`);
    }
    try {
        (0, types_1.assertIsNpmSnapPackageJson)(packageJson.result);
    }
    catch (error) {
        throw new Error(`${errorPrefix ?? ''}${error.message}`);
    }
    const validatedPackageJson = packageJson;
    (0, manifest_1.validateNpmSnapManifest)({
        manifest: validatedManifest,
        packageJson: validatedPackageJson,
        sourceCode,
        svgIcon,
    });
    if (svgIcon) {
        if (Buffer.byteLength(svgIcon.value, 'utf8') > exports.SVG_MAX_BYTE_SIZE) {
            throw new Error(`${errorPrefix ?? ''}The specified SVG icon exceeds the maximum size of ${exports.SVG_MAX_BYTE_SIZE_TEXT}.`);
        }
    }
    return {
        manifest: validatedManifest,
        packageJson: validatedPackageJson,
        sourceCode,
        svgIcon,
    };
}
exports.validateNpmSnap = validateNpmSnap;
//# sourceMappingURL=npm.js.map