{"version":3,"file":"VirtualFile.js","sourceRoot":"","sources":["../../src/virtual-file/VirtualFile.ts"],"names":[],"mappings":";;;AAAA,0HAA0H;AAC1H,iEAAiE;AACjE,2FAA2F;AAC3F,wFAAwF;AACxF,EAAE;AACF,oHAAoH;AACpH,qGAAqG;AACrG,sDAAsD;AACtD,2CAAyC;AAEzC,8CAA0C;AA+B1C,MAAa,WAAW;IACtB,YAAY,KAA0B;QACpC,IAAI,OAA4B,CAAC;QACjC,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,YAAY,UAAU,EAAE;YAC5D,OAAO,GAAG,EAAE,KAAK,EAAE,CAAC;SACrB;aAAM;YACL,OAAO,GAAG,KAAK,CAAC;SACjB;QAED,IAAI,CAAC,KAAK,GAAG,OAAO,EAAE,KAAK,IAAI,EAAE,CAAC;QAClC,wDAAwD;QACxD,gEAAgE;QAChE,4DAA4D;QAC5D,EAAE;QACF,wEAAwE;QACxE,4EAA4E;QAC5E,8EAA8E;QAC9E,EAAE;QACF,iDAAiD;QACjD,IAAI,CAAC,MAAM,GAAG,OAAO,EAAE,MAAM,IAAK,SAAiB,CAAC;QACpD,IAAI,CAAC,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC;QAChC,IAAI,CAAC,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,GAAG,CAAC;IACnC,CAAC;IAUD,QAAQ,CAAC,QAAiB;QACxB,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE;YAClC,IAAA,cAAM,EAAC,QAAQ,KAAK,SAAS,EAAE,yBAAyB,CAAC,CAAC;YAC1D,OAAO,IAAI,CAAC,KAAK,CAAC;SACnB;QACD,MAAM,OAAO,GAAG,IAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC1C,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,KAAK;QACH,MAAM,KAAK,GAAG,IAAI,WAAW,EAAU,CAAC;QACxC,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE;YAClC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;SAC1B;aAAM;YACL,mFAAmF;YACnF,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SACnC;QACD,KAAK,CAAC,MAAM,GAAG,IAAA,sBAAS,EAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtC,KAAK,CAAC,IAAI,GAAG,IAAA,sBAAS,EAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAClC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAtDD,kCAsDC","sourcesContent":["// TODO(ritave): Move into separate package @metamask/vfile / @metamask/utils + @metamask/to-vfile when passes code review\n// TODO(ritave): Streaming vfile contents similar to vinyl maybe?\n// TODO(ritave): Move fixing manifest in cli and bundler plugins to write messages to vfile\n//               similar to unified instead of throwing \"ProgrammaticallyFixableErrors\".\n//\n// Using https://github.com/vfile/vfile would be helpful, but they only support ESM and we need to support CommonJS.\n// https://github.com/gulpjs/vinyl is also good, but they normalize paths, which we can't do, because\n// we're calculating checksums based on original path.\nimport { assert } from '@metamask/utils';\n\nimport { deepClone } from '../deep-clone';\n\n/**\n * This map registers the type of the {@link VirtualFile.data} key of a {@link VirtualFile}.\n *\n * This type can be augmented to register custom `data` types.\n *\n * @example\n * declare module '@metamask/snaps-utils' {\n *   interface DataMap {\n *     // `file.data.name` is typed as `string`\n *     name: string\n *   }\n * }\n */\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-empty-interface\nexport interface DataMap {}\n\nexport type Value = string | Uint8Array;\nexport type Compatible<Result = unknown> =\n  | string\n  | Uint8Array\n  | Options<Result>;\nexport type Data = Record<string, unknown> & Partial<DataMap>;\nexport type Options<Result = unknown> = {\n  value: Value;\n  path?: string;\n  data?: Data;\n  result?: Result;\n};\n\nexport class VirtualFile<Result = unknown> {\n  constructor(value?: Compatible<Result>) {\n    let options: Options | undefined;\n    if (typeof value === 'string' || value instanceof Uint8Array) {\n      options = { value };\n    } else {\n      options = value;\n    }\n\n    this.value = options?.value ?? '';\n    // This situations happens when there's no .result used,\n    // we expect the file to have default generic in that situation:\n    // VirtualFile<unknown> which will handle undefined properly\n    //\n    // While not 100% type safe, it'll be way less frustrating to work with.\n    // The alternative would be to have VirtualFile.result be Result | undefined\n    // and that would result in needing to branch out and check in all situations.\n    //\n    // In short, optimizing for most common use case.\n    this.result = options?.result ?? (undefined as any);\n    this.data = options?.data ?? {};\n    this.path = options?.path ?? '/';\n  }\n\n  value: Value;\n\n  result: Result;\n\n  data: Data;\n\n  path: string;\n\n  toString(encoding?: string) {\n    if (typeof this.value === 'string') {\n      assert(encoding === undefined, 'Tried to encode string.');\n      return this.value;\n    }\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(this.value);\n  }\n\n  clone() {\n    const vfile = new VirtualFile<Result>();\n    if (typeof this.value === 'string') {\n      vfile.value = this.value;\n    } else {\n      // deep-clone doesn't clone Buffer properly, even if it's a sub-class of Uint8Array\n      vfile.value = this.value.slice(0);\n    }\n    vfile.result = deepClone(this.result);\n    vfile.data = deepClone(this.data);\n    vfile.path = this.path;\n    return vfile;\n  }\n}\n"]}