{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["import { assertStruct, Json, VersionStruct } from '@metamask/utils';\nimport {\n  Infer,\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  Struct,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from 'superstruct';\n\nimport { SnapCaveatType } from './caveats';\nimport { SnapFunctionExports, SnapKeyring as Keyring } from './handlers';\nimport { SnapManifest } from './manifest';\nimport { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n};\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport type SnapId = string;\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport enum HandlerType {\n  OnRpcRequest = 'onRpcRequest',\n  OnTransaction = 'onTransaction',\n  SnapKeyring = 'keyring',\n  OnCronjob = 'onCronjob',\n}\n\nexport const SNAP_EXPORT_NAMES = Object.values(HandlerType);\n\nexport type SnapRpcHookArgs = {\n  origin: string;\n  handler: HandlerType;\n  request: Record<string, unknown>;\n};\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\ntype KeyringParameter<Fn> = Fn extends (...args: any[]) => unknown\n  ? Parameters<Fn>\n  : never;\n\ntype KeyringParameters = KeyringParameter<Keyring[keyof Keyring]>;\n\nexport type SnapExportsParameters =\n  | ObjectParameters<SnapFunctionExports>\n  | KeyringParameters;\n\ntype UriOptions<T extends string> = {\n  protocol?: Struct<T>;\n  hash?: Struct<T>;\n  port?: Struct<T>;\n  hostname?: Struct<T>;\n  pathname?: Struct<T>;\n  search?: Struct<T>;\n};\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"]}