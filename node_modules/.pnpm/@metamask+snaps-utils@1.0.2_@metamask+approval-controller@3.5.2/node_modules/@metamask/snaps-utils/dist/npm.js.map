{"version":3,"file":"npm.js","sourceRoot":"","sources":["../src/npm.ts"],"names":[],"mappings":";;;AAAA,kDAA8D;AAC9D,sDAA6D;AAC7D,mCAKiB;AAEJ,QAAA,iBAAiB,GAAG,MAAO,CAAC;AAC5B,QAAA,sBAAsB,GAAG,GAAG,IAAI,CAAC,KAAK,CACjD,yBAAiB,GAAG,IAAI,CACzB,IAAI,CAAC;AAEO,QAAA,mBAAmB,GAAG;IACjC,UAAU;IACV,aAAa;IACb,YAAY;CACJ,CAAC;AAEE,QAAA,mBAAmB,GAAG;IACjC,QAAQ,EAAE,wBAAgB,CAAC,QAAQ;IACnC,WAAW,EAAE,wBAAgB,CAAC,WAAW;IACzC,UAAU,EAAE,oBAAoB;CACxB,CAAC;AAEX;;;;;;;;;GASG;AACH,SAAgB,eAAe,CAC7B,SAA+B,EAC/B,WAA2B;IAE3B,2BAAmB,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;QAClC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;YACnB,MAAM,IAAI,KAAK,CACb,GAAG,WAAW,IAAI,EAAE,iBAAiB,2BAAmB,CAAC,GAAG,CAAC,IAAI,CAClE,CAAC;SACH;IACH,CAAC,CAAC,CAAC;IAEH,yEAAyE;IACzE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,OAAO,EAAE,GAAG,SAAsB,CAAC;IAC9E,IAAI;QACF,IAAA,iCAAoB,EAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;KACvC;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,GAAG,WAAW,IAAI,EAAE,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;KACzD;IACD,MAAM,iBAAiB,GAAG,QAAQ,CAAC;IAEnC,MAAM,EAAE,QAAQ,EAAE,GAAG,iBAAiB,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC;IAClE,IAAI,QAAQ,IAAI,CAAC,OAAO,EAAE;QACxB,MAAM,IAAI,KAAK,CAAC,iBAAiB,QAAQ,IAAI,CAAC,CAAC;KAChD;IAED,IAAI;QACF,IAAA,kCAA0B,EAAC,WAAW,CAAC,MAAM,CAAC,CAAC;KAChD;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,GAAG,WAAW,IAAI,EAAE,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;KACzD;IACD,MAAM,oBAAoB,GAAG,WAAW,CAAC;IAEzC,IAAA,kCAAuB,EAAC;QACtB,QAAQ,EAAE,iBAAiB;QAC3B,WAAW,EAAE,oBAAoB;QACjC,UAAU;QACV,OAAO;KACR,CAAC,CAAC;IAEH,IAAI,OAAO,EAAE;QACX,IAAI,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,yBAAiB,EAAE;YAChE,MAAM,IAAI,KAAK,CACb,GACE,WAAW,IAAI,EACjB,sDAAsD,8BAAsB,GAAG,CAChF,CAAC;SACH;KACF;IAED,OAAO;QACL,QAAQ,EAAE,iBAAiB;QAC3B,WAAW,EAAE,oBAAoB;QACjC,UAAU;QACV,OAAO;KACR,CAAC;AACJ,CAAC;AAxDD,0CAwDC","sourcesContent":["import { validateNpmSnapManifest } from './manifest/manifest';\nimport { assertIsSnapManifest } from './manifest/validation';\nimport {\n  assertIsNpmSnapPackageJson,\n  NpmSnapFileNames,\n  SnapFiles,\n  UnvalidatedSnapFiles,\n} from './types';\n\nexport const SVG_MAX_BYTE_SIZE = 100_000;\nexport const SVG_MAX_BYTE_SIZE_TEXT = `${Math.floor(\n  SVG_MAX_BYTE_SIZE / 1000,\n)}kb`;\n\nexport const EXPECTED_SNAP_FILES = [\n  'manifest',\n  'packageJson',\n  'sourceCode',\n] as const;\n\nexport const SnapFileNameFromKey = {\n  manifest: NpmSnapFileNames.Manifest,\n  packageJson: NpmSnapFileNames.PackageJson,\n  sourceCode: 'source code bundle',\n} as const;\n\n/**\n * Validates the files extracted from an npm Snap package tarball by ensuring\n * that they're non-empty and that the Json files match their respective schemas\n * and the Snaps publishing specification.\n *\n * @param snapFiles - The object containing the expected Snap file contents,\n * if any.\n * @param errorPrefix - The prefix of the error message.\n * @returns A tuple of the Snap manifest object and the Snap source code.\n */\nexport function validateNpmSnap(\n  snapFiles: UnvalidatedSnapFiles,\n  errorPrefix?: `${string}: `,\n): SnapFiles {\n  EXPECTED_SNAP_FILES.forEach((key) => {\n    if (!snapFiles[key]) {\n      throw new Error(\n        `${errorPrefix ?? ''}Missing file \"${SnapFileNameFromKey[key]}\".`,\n      );\n    }\n  });\n\n  // Typecast: We are assured that the required files exist if we get here.\n  const { manifest, packageJson, sourceCode, svgIcon } = snapFiles as SnapFiles;\n  try {\n    assertIsSnapManifest(manifest.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n  const validatedManifest = manifest;\n\n  const { iconPath } = validatedManifest.result.source.location.npm;\n  if (iconPath && !svgIcon) {\n    throw new Error(`Missing file \"${iconPath}\".`);\n  }\n\n  try {\n    assertIsNpmSnapPackageJson(packageJson.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n  const validatedPackageJson = packageJson;\n\n  validateNpmSnapManifest({\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n  });\n\n  if (svgIcon) {\n    if (Buffer.byteLength(svgIcon.value, 'utf8') > SVG_MAX_BYTE_SIZE) {\n      throw new Error(\n        `${\n          errorPrefix ?? ''\n        }The specified SVG icon exceeds the maximum size of ${SVG_MAX_BYTE_SIZE_TEXT}.`,\n      );\n    }\n  }\n\n  return {\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n  };\n}\n"]}