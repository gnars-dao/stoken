"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createNumber: function() {
        return createNumber;
    },
    createBigInt: function() {
        return createBigInt;
    },
    createBytes: function() {
        return createBytes;
    },
    createHex: function() {
        return createHex;
    }
});
const _superstruct = require("superstruct");
const _assert = require("./assert");
const _bytes = require("./bytes");
const _hex = require("./hex");
const NumberLikeStruct = (0, _superstruct.union)([
    (0, _superstruct.number)(),
    (0, _superstruct.bigint)(),
    (0, _superstruct.string)(),
    _hex.StrictHexStruct
]);
const NumberCoercer = (0, _superstruct.coerce)((0, _superstruct.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, _superstruct.coerce)((0, _superstruct.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, _superstruct.union)([
    _hex.StrictHexStruct,
    (0, _superstruct.instance)(Uint8Array)
]);
const BytesCoercer = (0, _superstruct.coerce)((0, _superstruct.instance)(Uint8Array), (0, _superstruct.union)([
    _hex.StrictHexStruct
]), _bytes.hexToBytes);
const HexCoercer = (0, _superstruct.coerce)(_hex.StrictHexStruct, (0, _superstruct.instance)(Uint8Array), _bytes.bytesToHex);
function createNumber(value) {
    try {
        const result = (0, _superstruct.create)(value, NumberCoercer);
        (0, _assert.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    } catch (error) {
        if (error instanceof _superstruct.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */ throw error;
    }
}
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, _superstruct.create)(value, BigIntCoercer);
    } catch (error) {
        if (error instanceof _superstruct.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */ throw error;
    }
}
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, _superstruct.create)(value, BytesCoercer);
    } catch (error) {
        if (error instanceof _superstruct.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */ throw error;
    }
}
function createHex(value) {
    if (value instanceof Uint8Array && value.length === 0 || typeof value === 'string' && value.toLowerCase() === '0x') {
        return '0x';
    }
    try {
        return (0, _superstruct.create)(value, HexCoercer);
    } catch (error) {
        if (error instanceof _superstruct.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */ throw error;
    }
}

//# sourceMappingURL=coercers.js.map