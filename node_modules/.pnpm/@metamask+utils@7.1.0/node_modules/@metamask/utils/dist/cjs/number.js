"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    numberToHex: function() {
        return numberToHex;
    },
    bigIntToHex: function() {
        return bigIntToHex;
    },
    hexToNumber: function() {
        return hexToNumber;
    },
    hexToBigInt: function() {
        return hexToBigInt;
    }
});
const _assert = require("./assert");
const _hex = require("./hex");
const numberToHex = (value)=>{
    (0, _assert.assert)(typeof value === 'number', 'Value must be a number.');
    (0, _assert.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, _assert.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, _hex.add0x)(value.toString(16));
};
const bigIntToHex = (value)=>{
    (0, _assert.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, _assert.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, _hex.add0x)(value.toString(16));
};
const hexToNumber = (value)=>{
    (0, _hex.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, _assert.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
const hexToBigInt = (value)=>{
    (0, _hex.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, _hex.add0x)(value));
};

//# sourceMappingURL=number.js.map