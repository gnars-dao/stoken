"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeExtendedKey = exports.decodeExtendedKey = exports.PRIVATE_KEY_VERSION = exports.PUBLIC_KEY_VERSION = void 0;
const utils_1 = require("@metamask/utils");
const BIP44Node_1 = require("./BIP44Node");
const secp256k1_1 = require("./curves/secp256k1");
const utils_2 = require("./utils");
// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#Serialization_format
exports.PUBLIC_KEY_VERSION = 0x0488b21e;
exports.PRIVATE_KEY_VERSION = 0x0488ade4;
/**
 * Decodes an extended public or private key. In the case of an extended public key, the public key
 * is returned in the uncompressed form.
 *
 * Throws an error if the extended key is invalid.
 *
 * @param extendedKey - The extended key string to attempt to decode.
 * @returns The decoded extended key.
 */
const decodeExtendedKey = (extendedKey) => {
    const bytes = (0, utils_2.decodeBase58check)(extendedKey);
    if (bytes.length !== 78) {
        throw new Error(`Invalid extended key: Expected a length of 78, got ${bytes.length}.`);
    }
    const view = (0, utils_1.createDataView)(bytes);
    const version = view.getUint32(0, false);
    const depth = view.getUint8(4);
    (0, BIP44Node_1.validateBIP44Depth)(depth);
    const parentFingerprint = view.getUint32(5, false);
    const index = view.getUint32(9, false);
    const chainCode = bytes.slice(13, 45);
    if (!(0, utils_2.isValidBytesKey)(chainCode, 32)) {
        throw new Error(`Invalid extended key: Chain code must be a 32-byte non-zero byte array.`);
    }
    const key = bytes.slice(45, 78);
    if (!(0, utils_2.isValidBytesKey)(key, 33)) {
        throw new Error(`Invalid extended key: Key must be a 33-byte non-zero byte array.`);
    }
    const keyView = (0, utils_1.createDataView)(key);
    if (version === exports.PUBLIC_KEY_VERSION) {
        if (keyView.getUint8(0) !== 0x02 && keyView.getUint8(0) !== 0x03) {
            throw new Error(`Invalid extended key: Public key must start with 0x02 or 0x03.`);
        }
        return {
            version,
            depth,
            parentFingerprint,
            index,
            chainCode,
            publicKey: (0, secp256k1_1.decompressPublicKey)(key),
        };
    }
    if (version === exports.PRIVATE_KEY_VERSION) {
        if (keyView.getUint8(0) !== 0x00) {
            throw new Error(`Invalid extended key: Private key must start with 0x00.`);
        }
        return {
            version,
            depth,
            parentFingerprint,
            index,
            chainCode,
            privateKey: key.slice(1),
        };
    }
    throw new Error(`Invalid extended key: Expected a public (xpub) or private key (xprv) version.`);
};
exports.decodeExtendedKey = decodeExtendedKey;
/**
 * Encodes an extended public or private key. Assumes that all the inputs are verified beforehand.
 *
 * @param extendedKey - The extended key data to encode.
 * @returns The encoded extended key.
 */
const encodeExtendedKey = (extendedKey) => {
    const { version, depth, parentFingerprint, index, chainCode } = extendedKey;
    const bytes = new Uint8Array(78);
    const view = (0, utils_1.createDataView)(bytes);
    view.setUint32(0, version, false);
    view.setUint8(4, depth);
    view.setUint32(5, parentFingerprint, false);
    view.setUint32(9, index, false);
    bytes.set(chainCode, 13);
    if (extendedKey.version === exports.PUBLIC_KEY_VERSION) {
        const { publicKey } = extendedKey;
        const compressedPublicKey = (0, secp256k1_1.compressPublicKey)(publicKey);
        bytes.set(compressedPublicKey, 45);
    }
    if (extendedKey.version === exports.PRIVATE_KEY_VERSION) {
        const { privateKey } = extendedKey;
        bytes.set(privateKey, 46);
    }
    return (0, utils_2.encodeBase58check)(bytes);
};
exports.encodeExtendedKey = encodeExtendedKey;
//# sourceMappingURL=extended-keys.js.map