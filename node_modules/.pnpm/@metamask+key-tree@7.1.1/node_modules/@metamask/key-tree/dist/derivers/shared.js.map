{"version":3,"file":"shared.js","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":";;;AAAA,2CAKyB;AACzB,6CAA0C;AAC1C,iDAA8C;AAG9C,4CAA6E;AAC7E,sCAAuC;AACvC,8CAA2C;AAC3C,oCAA2D;AAO3D;;;;;;;;;;;;;GAaG;AACI,KAAK,UAAU,cAAc,CAClC,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAsB,EACzC,WAAyB;IAEzB,YAAY,CAAC,IAAI,CAAC,CAAC;IAEnB,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAEvE,MAAM,IAAI,GAAG;QACX,SAAS,EAAE,IAAI,CAAC,cAAc;QAC9B,UAAU;QACV,UAAU;QACV,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,iBAAiB,EAAE,IAAI,CAAC,WAAW;QACnC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;QACzC,KAAK;KACN,CAAC;IAEF,IAAI,IAAI,CAAC,eAAe,EAAE;QACxB,MAAM,eAAe,GAAG,MAAM,qBAAqB,CAAC;YAClD,UAAU,EAAE,IAAI,CAAC,eAAe;YAChC,UAAU;YACV,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,OAAO,GAAG,eAAe,CAAC;YAC9B,SAAS,EAAE,IAAI,CAAC,cAAc;YAC9B,SAAS,EAAE,eAAe;SAC3B,CAAC,CAAC;QAEH,OAAO,MAAM,UAAU,iBAEnB,UAAU,EAAE,IAAI,CAAC,eAAe,EAChC,OAAO,IACJ,IAAI,GAET,WAAW,CACZ,CAAC;KACH;IAED,MAAM,eAAe,GAAG,qBAAqB,CAAC;QAC5C,eAAe,EAAE,IAAI,CAAC,wBAAwB;QAC9C,UAAU;KACX,CAAC,CAAC;IAEH,MAAM,OAAO,GAAG,eAAe,CAAC;QAC9B,SAAS,EAAE,IAAI,CAAC,cAAc;QAC9B,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,OAAO,MAAM,UAAU,iBAEnB,SAAS,EAAE,IAAI,CAAC,wBAAwB,EACxC,OAAO,IACJ,IAAI,GAET,WAAW,CACZ,CAAC;AACJ,CAAC;AA3DD,wCA2DC;AAgCD;;;;;;;;;;;;;;;;GAgBG;AACH,KAAK,UAAU,UAAU,CACvB,OAAuB,EACvB,WAG4B;IAE5B,MAAM,EACJ,UAAU,EACV,SAAS,EACT,OAAO,EACP,UAAU,EACV,UAAU,EACV,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,KAAK,GACN,GAAG,OAAO,CAAC;IAEZ,IAAI;QACF,IAAI,UAAU,EAAE;YACd,OAAO,MAAM,qBAAqB,CAAC;gBACjC,OAAO;gBACP,UAAU;gBACV,KAAK;gBACL,iBAAiB;gBACjB,iBAAiB;gBACjB,UAAU;gBACV,UAAU;gBACV,KAAK;aACN,CAAC,CAAC;SACJ;QAED,OAAO,MAAM,oBAAoB,CAAC;YAChC,OAAO;YACP,SAAS;YACT,KAAK;YACL,iBAAiB;YACjB,iBAAiB;YACjB,UAAU;YACV,KAAK;SACN,CAAC,CAAC;KACJ;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,MAAM,UAAU,CAAC,MAAM,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC,CAAC;KACzE;AACH,CAAC;AAED;;;;;;;;;GASG;AACI,KAAK,UAAU,qBAAqB,CAAC,EAC1C,UAAU,EACV,UAAU,EACV,UAAU,EACV,KAAK,GACqB;IAC1B,IAAI,UAAU,EAAE;QACd,iBAAiB;QACjB,OAAO,IAAA,mBAAW,EAAC;YACjB,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YACnB,UAAU;YACV,IAAA,sBAAc,EAAC,UAAU,GAAG,kCAAsB,CAAC;SACpD,CAAC,CAAC;KACJ;IAED,eAAe;IACf,MAAM,eAAe,GAAG,MAAM,KAAK,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IACnE,OAAO,qBAAqB,CAAC,EAAE,eAAe,EAAE,UAAU,EAAE,CAAC,CAAC;AAChE,CAAC;AAlBD,sDAkBC;AAOD;;;;;;;GAOG;AACH,SAAgB,qBAAqB,CAAC,EACpC,eAAe,EACf,UAAU,GACgB;IAC1B,OAAO,IAAA,mBAAW,EAAC,CAAC,eAAe,EAAE,IAAA,sBAAc,EAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACpE,CAAC;AALD,sDAKC;AAQD;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CAAC,EACzB,UAAU,EACV,OAAO,EACP,KAAK,GACW;IAChB,MAAM,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACzC,MAAM,cAAc,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAEzC,kEAAkE;IAClE,wIAAwI;IACxI,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;QAC5B,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QACxD,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,SAAS,EAAE,cAAc,EAAE,CAAC;KAC1E;IAED,MAAM,eAAe,GAAG,UAAU,CAAC,UAAU,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;IACnE,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;IAE5D,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,EAAE,SAAS,EAAE,cAAc,EAAE,CAAC;AAC/E,CAAC;AAaD;;;;;;;;;;;;;GAaG;AACH,KAAK,UAAU,qBAAqB,CAAC,EACnC,OAAO,EACP,UAAU,EACV,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,UAAU,EACV,UAAU,EACV,KAAK,GACqB;IAC1B,MAAM,gBAAgB,GACpB,UAAU,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,kCAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAEzD,MAAM,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,EAAE,cAAc,EAAE,GAC9D,MAAM,WAAW,CAAC;QAChB,UAAU;QACV,OAAO;QACP,KAAK;KACN,CAAC,CAAC;IAEL,OAAO,MAAM,uBAAU,CAAC,eAAe,CAAC;QACtC,UAAU,EAAE,eAAe;QAC3B,SAAS,EAAE,cAAc;QACzB,KAAK,EAAE,KAAK,GAAG,CAAC;QAChB,iBAAiB;QACjB,iBAAiB;QACjB,KAAK,EAAE,gBAAgB;QACvB,KAAK,EAAE,KAAK,CAAC,IAAI;KAClB,CAAC,CAAC;AACL,CAAC;AAQD;;;;;;;;GAQG;AACH,SAAS,iBAAiB,CAAC,EACzB,SAAS,EACT,OAAO,EACP,KAAK,GACiB;IACtB,MAAM,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACzC,MAAM,cAAc,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAEzC,0DAA0D;IAC1D,MAAM,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IAE/D,OAAO;QACL,SAAS,EAAE,cAAc;QACzB,SAAS,EAAE,cAAc;KAC1B,CAAC;AACJ,CAAC;AAYD;;;;;;;;;;;;GAYG;AACI,KAAK,UAAU,oBAAoB,CAAC,EACzC,OAAO,EACP,SAAS,EACT,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,UAAU,EACV,KAAK,GACoB;IACzB,MAAM,EAAE,SAAS,EAAE,cAAc,EAAE,SAAS,EAAE,cAAc,EAAE,GAC5D,iBAAiB,CAAC;QAChB,SAAS;QACT,OAAO;QACP,KAAK;KACN,CAAC,CAAC;IAEL,OAAO,MAAM,uBAAU,CAAC,eAAe,CAAC;QACtC,SAAS,EAAE,cAAc;QACzB,SAAS,EAAE,cAAc;QACzB,KAAK,EAAE,KAAK,GAAG,CAAC;QAChB,iBAAiB;QACjB,iBAAiB;QACjB,KAAK,EAAE,UAAU;QACjB,KAAK,EAAE,KAAK,CAAC,IAAI;KAClB,CAAC,CAAC;AACL,CAAC;AAzBD,oDAyBC;AAED;;;;;;;;GAQG;AACH,SAAgB,UAAU,CACxB,eAA2B,EAC3B,UAAsB,EACtB,KAAY;IAEZ,IAAA,cAAM,EACJ,IAAA,uBAAe,EAAC,UAAU,EAAE,EAAE,CAAC,EAC/B,6DAA6D,CAC9D,CAAC;IAEF,MAAM,UAAU,GAAG,IAAA,qBAAa,EAAC,eAAe,CAAC,CAAC;IAClD,MAAM,KAAK,GAAG,IAAA,qBAAa,EAAC,UAAU,CAAC,CAAC;IAExC,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;KACzE;IAED,MAAM,KAAK,GAAG,IAAA,YAAG,EAAC,UAAU,GAAG,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACrD,MAAM,KAAK,GAAG,IAAA,kBAAU,EAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;IAE/D,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;QACnC,MAAM,IAAI,KAAK,CACb,qEAAqE,CACtE,CAAC;KACH;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AA3BD,gCA2BC;AAOD;;;;;;;;GAQG;AACH,SAAgB,eAAe,CAAC,EAAE,SAAS,EAAE,SAAS,EAAuB;IAC3E,OAAO,IAAA,WAAI,EAAC,eAAM,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AAC5C,CAAC;AAFD,0CAEC;AAED;;;;;GAKG;AACH,SAAgB,YAAY,CAAC,IAAiB;IAC5C,IAAA,cAAM,EAAC,IAAI,EAAE,yDAAyD,CAAC,CAAC;AAC1E,CAAC;AAFD,oCAEC;AAED;;;;;;;GAOG;AACH,SAAS,YAAY,CACnB,IAAyB,EACzB,IAAgB,EAChB,KAAY;IAEZ,IAAA,cAAM,EAAC,OAAO,IAAI,KAAK,QAAQ,EAAE,iCAAiC,CAAC,CAAC;IAEpE,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;IACtC,IAAA,cAAM,EACJ,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAC9B,8EAA8E,CAC/E,CAAC;IACF,IAAA,cAAM,EACJ,UAAU,IAAI,KAAK,CAAC,oBAAoB,EACxC,0DAA0D,KAAK,CAAC,IAAI,GAAG,CACxE,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,gBAAgB,CACvB,IAAyB,EACzB,IAAgB,EAChB,KAAY;IAEZ,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAEhC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACrC,MAAM,UAAU,GAAG,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;IAE3C,IACE,CAAC,iCAAqB,CAAC,IAAI,CAAC,SAAS,CAAC;QACtC,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC;QAC7B,UAAU,GAAG,CAAC;QACd,UAAU,IAAI,kCAAsB,EACpC;QACA,MAAM,IAAI,KAAK,CACb,4EAA4E,kCAAsB,GAAG,CACtG,CAAC;KACH;IAED,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;AACxD,CAAC","sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport { Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n) {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = generateEntropy({\n      chainCode: node.chainCodeBytes,\n      extension: secretExtension,\n    });\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = generateEntropy({\n    chainCode: node.chainCodeBytes,\n    extension: publicExtension,\n  });\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: (\n    error: unknown,\n    args: DeriveNodeArgs,\n  ) => Promise<DeriveNodeArgs>,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey({\n        entropy,\n        privateKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        isHardened,\n        curve,\n      });\n    }\n\n    return await derivePublicChildKey({\n      entropy,\n      publicKey,\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      childIndex,\n      curve,\n    });\n  } catch (error) {\n    return await deriveNode(await handleError(error, options), handleError);\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs) {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs) {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey({\n  entropy,\n  privateKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  isHardened,\n  curve,\n}: DerivePrivateChildKeyArgs): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    privateKey: childPrivateKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey({\n  entropy,\n  publicKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  curve,\n}: DerivePublicChildKeyArgs): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: childIndex,\n    curve: curve.name,\n  });\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @returns The generated entropy bytes.\n */\nexport function generateEntropy({ chainCode, extension }: GenerateEntropyArgs) {\n  return hmac(sha512, chainCode, extension);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nfunction getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n) {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"]}