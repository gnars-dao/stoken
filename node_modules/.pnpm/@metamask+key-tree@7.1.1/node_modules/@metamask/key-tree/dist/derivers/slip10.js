"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = void 0;
const utils_1 = require("@metamask/utils");
const constants_1 = require("../constants");
const utils_2 = require("../utils");
const shared_1 = require("./shared");
/**
 * Derive a SLIP-10 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @returns A tuple containing the derived private key, public key and chain
 * code.
 */
async function deriveChildKey(options) {
    return await (0, shared_1.deriveChildKey)(options, handleError);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Handle an error that occurs during SLIP-10 derivation.
 *
 * @param error - The error that occurred.
 * @param options - The options that were used for derivation.
 * @returns The new options to use for derivation.
 */
async function handleError(error, options) {
    const { curve, isHardened, childIndex, entropy, chainCode } = options;
    // `ed25519` keys are always valid, so this error should never be thrown. If
    // it is, we re-throw it.
    if (curve.name === 'ed25519') {
        throw error;
    }
    const actualChildIndex = isHardened
        ? childIndex + constants_1.BIP_32_HARDENED_OFFSET
        : childIndex;
    // As per SLIP-10, if the resulting key is invalid, the new entropy is
    // generated as follows:
    // Key material (32 bytes), child chain code (32 bytes) =
    //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).
    const newEntropy = (0, shared_1.generateEntropy)({
        chainCode,
        extension: (0, utils_1.concatBytes)([
            0x01,
            entropy.slice(32, 64),
            (0, utils_2.numberToUint32)(actualChildIndex),
        ]),
    });
    return Object.assign(Object.assign({}, options), { entropy: newEntropy });
}
//# sourceMappingURL=slip10.js.map