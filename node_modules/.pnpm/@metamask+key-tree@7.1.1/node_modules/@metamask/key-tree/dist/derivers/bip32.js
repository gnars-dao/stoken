"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = exports.publicKeyToEthAddress = exports.privateKeyToEthAddress = void 0;
const utils_1 = require("@metamask/utils");
const sha3_1 = require("@noble/hashes/sha3");
const constants_1 = require("../constants");
const curves_1 = require("../curves");
const utils_2 = require("../utils");
const shared_1 = require("./shared");
/**
 * Converts a BIP-32 private key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` private key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function privateKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array && (0, utils_2.isValidBytesKey)(key, constants_1.BYTES_KEY_LENGTH), 'Invalid key: The key must be a 32-byte, non-zero Uint8Array.');
    const publicKey = curves_1.secp256k1.getPublicKey(key, false);
    return publicKeyToEthAddress(publicKey);
}
exports.privateKeyToEthAddress = privateKeyToEthAddress;
/**
 * Converts a BIP-32 public key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` public key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function publicKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array &&
        (0, utils_2.isValidBytesKey)(key, curves_1.secp256k1.publicKeyLength), 'Invalid key: The key must be a 65-byte, non-zero Uint8Array.');
    return (0, sha3_1.keccak_256)(key.slice(1)).slice(-20);
}
exports.publicKeyToEthAddress = publicKeyToEthAddress;
/**
 * Derive a BIP-32 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @param options.path - The derivation path part to derive.
 * @param options.node - The node to derive from.
 * @param options.curve - The curve to use for derivation.
 * @returns The derived child key as a {@link SLIP10Node}.
 */
async function deriveChildKey(options) {
    (0, utils_1.assert)(options.curve.name === 'secp256k1', 'Invalid curve: Only secp256k1 is supported by BIP-32.');
    return (0, shared_1.deriveChildKey)(options, handleError);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Handles an error thrown during derivation by incrementing the child index
 * and retrying.
 *
 * @param _ - The error that was thrown.
 * @param options - The options for deriving a child key.
 * @returns The options for deriving a child key with the child index
 * incremented by one.
 */
async function handleError(_, options) {
    const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } = options;
    (0, utils_2.validateBIP32Index)(childIndex + 1);
    if (privateKey) {
        const secretExtension = await (0, shared_1.deriveSecretExtension)({
            privateKey,
            childIndex: childIndex + 1,
            isHardened,
            curve,
        });
        const newEntropy = (0, shared_1.generateEntropy)({
            chainCode,
            extension: secretExtension,
        });
        return Object.assign(Object.assign({}, options), { childIndex: childIndex + 1, entropy: newEntropy });
    }
    const publicExtension = (0, shared_1.derivePublicExtension)({
        parentPublicKey: publicKey,
        childIndex: childIndex + 1,
    });
    const newEntropy = (0, shared_1.generateEntropy)({
        chainCode,
        extension: publicExtension,
    });
    return Object.assign(Object.assign({}, options), { childIndex: childIndex + 1, entropy: newEntropy });
}
//# sourceMappingURL=bip32.js.map