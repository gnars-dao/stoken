{"version":3,"file":"bip32.js","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":";;;AAAA,2CAAyC;AACzC,6CAA6D;AAG7D,4CAAgD;AAChD,sCAAsC;AAEtC,oCAA+D;AAC/D,qCAMkB;AAElB;;;;;;;;;;GAUG;AACH,SAAgB,sBAAsB,CAAC,GAAe;IACpD,IAAA,cAAM,EACJ,GAAG,YAAY,UAAU,IAAI,IAAA,uBAAe,EAAC,GAAG,EAAE,4BAAgB,CAAC,EACnE,8DAA8D,CAC/D,CAAC;IAEF,MAAM,SAAS,GAAG,kBAAS,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACrD,OAAO,qBAAqB,CAAC,SAAS,CAAC,CAAC;AAC1C,CAAC;AARD,wDAQC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,qBAAqB,CAAC,GAAe;IACnD,IAAA,cAAM,EACJ,GAAG,YAAY,UAAU;QACvB,IAAA,uBAAe,EAAC,GAAG,EAAE,kBAAS,CAAC,eAAe,CAAC,EACjD,8DAA8D,CAC/D,CAAC;IAEF,OAAO,IAAA,iBAAS,EAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C,CAAC;AARD,sDAQC;AAED;;;;;;;;GAQG;AACI,KAAK,UAAU,cAAc,CAClC,OAA2B;IAE3B,IAAA,cAAM,EACJ,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAClC,uDAAuD,CACxD,CAAC;IAEF,OAAO,IAAA,uBAAoB,EAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AACpD,CAAC;AATD,wCASC;AAED;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CACxB,CAAU,EACV,OAAuB;IAEvB,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE,GACvE,OAAO,CAAC;IAEV,IAAA,0BAAkB,EAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,UAAU,EAAE;QACd,MAAM,eAAe,GAAG,MAAM,IAAA,8BAAqB,EAAC;YAClD,UAAU;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,IAAA,wBAAe,EAAC;YACjC,SAAS;YACT,SAAS,EAAE,eAAe;SAC3B,CAAC,CAAC;QAEH,uCACK,OAAO,KACV,UAAU,EAAE,UAAU,GAAG,CAAC,EAC1B,OAAO,EAAE,UAAU,IACnB;KACH;IAED,MAAM,eAAe,GAAG,IAAA,8BAAqB,EAAC;QAC5C,eAAe,EAAE,SAAS;QAC1B,UAAU,EAAE,UAAU,GAAG,CAAC;KAC3B,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,IAAA,wBAAe,EAAC;QACjC,SAAS;QACT,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,uCACK,OAAO,KACV,UAAU,EAAE,UAAU,GAAG,CAAC,EAC1B,OAAO,EAAE,UAAU,IACnB;AACJ,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport { DeriveChildKeyArgs } from '.';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport { secp256k1 } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\nimport {\n  DeriveNodeArgs,\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = generateEntropy({\n      chainCode,\n      extension: secretExtension,\n    });\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"]}