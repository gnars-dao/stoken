"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BIP44Node_node;
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBIP44Depth = exports.BIP44Node = void 0;
const utils_1 = require("@metamask/utils");
const constants_1 = require("./constants");
const extended_keys_1 = require("./extended-keys");
const SLIP10Node_1 = require("./SLIP10Node");
const utils_2 = require("./utils");
/**
 * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.
 * cryptographic keys used to generate keypairs and addresses for cryptocurrency
 * protocols.
 *
 * This class contains methods and fields that may not serialize well. Use
 * {@link BIP44Node.toJSON} to get a JSON-compatible representation.
 */
class BIP44Node {
    constructor(node) {
        _BIP44Node_node.set(this, void 0);
        __classPrivateFieldSet(this, _BIP44Node_node, node, "f");
        Object.freeze(this);
    }
    /**
     * Wrapper of the {@link fromExtendedKey} function. Refer to that function
     * for documentation.
     *
     * @param json - The JSON representation of a SLIP-10 node.
     */
    static async fromJSON(json) {
        return BIP44Node.fromExtendedKey(json);
    }
    /**
     * Create a new BIP-44 node from a key and chain code. You must specify
     * either a private key or a public key. When specifying a private key,
     * the public key will be derived from the private key.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param options - An object containing the extended key, or an extended
     * public (xpub) or private (xprv) key.
     * @param options.depth - The depth of the node.
     * @param options.privateKey - The private key for the node.
     * @param options.publicKey - The public key for the node. If a private key is
     * specified, this parameter is ignored.
     * @param options.chainCode - The chain code for the node.
     */
    static async fromExtendedKey(options) {
        if (typeof options === 'string') {
            const extendedKey = (0, extended_keys_1.decodeExtendedKey)(options);
            const { chainCode, depth, parentFingerprint, index } = extendedKey;
            if (extendedKey.version === extended_keys_1.PRIVATE_KEY_VERSION) {
                const { privateKey } = extendedKey;
                return BIP44Node.fromExtendedKey({
                    depth,
                    parentFingerprint,
                    index,
                    privateKey,
                    chainCode,
                });
            }
            const { publicKey } = extendedKey;
            return BIP44Node.fromExtendedKey({
                depth,
                parentFingerprint,
                index,
                publicKey,
                chainCode,
            });
        }
        const { privateKey, publicKey, chainCode, depth, parentFingerprint, index, } = options;
        validateBIP44Depth(depth);
        const node = await SLIP10Node_1.SLIP10Node.fromExtendedKey({
            privateKey,
            publicKey,
            chainCode,
            depth,
            parentFingerprint,
            index,
            curve: 'secp256k1',
        });
        return new BIP44Node(node);
    }
    /**
     * Create a new BIP-44 node from a derivation path. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
     * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of
     * BIP-39 seed phrase words.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param options - An object containing the derivation path.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     */
    static async fromDerivationPath({ derivationPath, }) {
        validateBIP44Depth(derivationPath.length - 1);
        validateBIP44DerivationPath(derivationPath, constants_1.MIN_BIP_44_DEPTH);
        const node = await SLIP10Node_1.SLIP10Node.fromDerivationPath({
            derivationPath,
            curve: 'secp256k1',
        });
        return new BIP44Node(node);
    }
    get depth() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").depth;
    }
    get privateKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").privateKeyBytes;
    }
    get publicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").publicKeyBytes;
    }
    get chainCodeBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").chainCodeBytes;
    }
    get privateKey() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").privateKey;
    }
    get publicKey() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").publicKey;
    }
    get compressedPublicKey() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").compressedPublicKey;
    }
    get compressedPublicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").compressedPublicKeyBytes;
    }
    get chainCode() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").chainCode;
    }
    get address() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").address;
    }
    get masterFingerprint() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").masterFingerprint;
    }
    get parentFingerprint() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").parentFingerprint;
    }
    get fingerprint() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").fingerprint;
    }
    get index() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").index;
    }
    get extendedKey() {
        const data = {
            depth: this.depth,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            chainCode: this.chainCodeBytes,
        };
        if (this.privateKeyBytes) {
            return (0, extended_keys_1.encodeExtendedKey)(Object.assign(Object.assign({}, data), { version: extended_keys_1.PRIVATE_KEY_VERSION, privateKey: this.privateKeyBytes }));
        }
        return (0, extended_keys_1.encodeExtendedKey)(Object.assign(Object.assign({}, data), { version: extended_keys_1.PUBLIC_KEY_VERSION, publicKey: this.publicKeyBytes }));
    }
    get curve() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").curve;
    }
    /**
     * Get a neutered version of this node, i.e. a node without a private key.
     *
     * @returns A neutered version of this node.
     */
    neuter() {
        const node = __classPrivateFieldGet(this, _BIP44Node_node, "f").neuter();
        return new BIP44Node(node);
    }
    /**
     * Derives a child of the key contains be this node and returns a new
     * {@link BIP44Node} containing the child key.
     *
     * The specified path must be a valid HD path from this node, per BIP-44.
     * At present, this means that the path must consist of no more than 5 BIP-32
     * nodes, depending on the depth of this node.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param path - The partial (non-rooted) BIP-44 HD tree path will be used
     * to derive a child key from the parent key contained within this node.
     * @returns The {@link BIP44Node} corresponding to the derived child key.
     */
    async derive(path) {
        if (this.depth === constants_1.MAX_BIP_44_DEPTH) {
            throw new Error('Illegal operation: This HD tree node is already a leaf node.');
        }
        const newDepth = this.depth + path.length;
        validateBIP44Depth(newDepth);
        validateBIP44DerivationPath(path, (this.depth + 1));
        const node = await __classPrivateFieldGet(this, _BIP44Node_node, "f").derive(path);
        return new BIP44Node(node);
    }
    // This is documented in the interface of this class.
    toJSON() {
        return {
            depth: this.depth,
            masterFingerprint: this.masterFingerprint,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            privateKey: this.privateKey,
            publicKey: this.publicKey,
            chainCode: this.chainCode,
        };
    }
}
exports.BIP44Node = BIP44Node;
_BIP44Node_node = new WeakMap();
/**
 * Validates a BIP-44 path depth. Effectively, asserts that the depth is an
 * integer `number` N such that 0 <= N <= 5. Throws an error if validation
 * fails.
 *
 * @param depth - The depth to validate.
 */
function validateBIP44Depth(depth) {
    (0, SLIP10Node_1.validateBIP32Depth)(depth);
    if (depth < constants_1.MIN_BIP_44_DEPTH || depth > constants_1.MAX_BIP_44_DEPTH) {
        throw new Error(`Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: "${depth}"`);
    }
}
exports.validateBIP44Depth = validateBIP44Depth;
/**
 * Ensures that the given derivation is valid by BIP-44.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param path - The path to validate.
 * @param startingDepth - The depth of the first node of the derivation path.
 */
function validateBIP44DerivationPath(path, startingDepth) {
    path.forEach((nodeToken, index) => {
        const currentDepth = startingDepth + index;
        if (currentDepth === constants_1.MIN_BIP_44_DEPTH) {
            if (!(nodeToken instanceof Uint8Array) &&
                !constants_1.BIP_39_PATH_REGEX.test(nodeToken)) {
                throw new Error('Invalid derivation path: The "m" / seed node (depth 0) must be a BIP-39 node.');
            }
            return;
        }
        (0, utils_1.assert)(typeof nodeToken === 'string');
        // eslint-disable-next-line default-case
        switch (currentDepth) {
            case 1:
                if (nodeToken !== constants_1.BIP44PurposeNodeToken) {
                    throw new Error(`Invalid derivation path: The "purpose" node (depth 1) must be the string "${constants_1.BIP44PurposeNodeToken}".`);
                }
                break;
            case 2:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || !(0, utils_2.isHardened)(nodeToken)) {
                    throw new Error('Invalid derivation path: The "coin_type" node (depth 2) must be a hardened BIP-32 node.');
                }
                break;
            case 3:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || !(0, utils_2.isHardened)(nodeToken)) {
                    throw new Error('Invalid derivation path: The "account" node (depth 3) must be a hardened BIP-32 node.');
                }
                break;
            case 4:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken)) {
                    throw new Error('Invalid derivation path: The "change" node (depth 4) must be a BIP-32 node.');
                }
                break;
            case constants_1.MAX_BIP_44_DEPTH: // 5
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken)) {
                    throw new Error('Invalid derivation path: The "address_index" node (depth 5) must be a BIP-32 node.');
                }
                break;
        }
    });
}
//# sourceMappingURL=BIP44Node.js.map