"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BIP44CoinTypeNode_node;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP44CoinTypeNode = exports.BIP_44_COIN_TYPE_DEPTH = void 0;
const BIP44Node_1 = require("./BIP44Node");
const constants_1 = require("./constants");
const SLIP10Node_1 = require("./SLIP10Node");
const utils_1 = require("./utils");
exports.BIP_44_COIN_TYPE_DEPTH = 2;
/**
 * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index
 * specifying the protocol for which deeper keys are intended. For the
 * authoritative list of coin types, please see
 * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 */
class BIP44CoinTypeNode {
    // Constructors cannot use hash names.
    // eslint-disable-next-line no-restricted-syntax
    constructor(node, coin_type) {
        _BIP44CoinTypeNode_node.set(this, void 0);
        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
        this.coin_type = coin_type;
        this.path = (0, utils_1.getBIP44CoinTypePathString)(coin_type);
        Object.freeze(this);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param json - The {@link JsonBIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    static async fromJSON(json, coin_type) {
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(json.depth);
        const node = await BIP44Node_1.BIP44Node.fromExtendedKey({
            depth: json.depth,
            index: json.index,
            parentFingerprint: json.parentFingerprint,
            chainCode: (0, utils_1.hexStringToBytes)(json.chainCode),
            privateKey: (0, utils_1.nullableHexStringToBytes)(json.privateKey),
            publicKey: (0, utils_1.hexStringToBytes)(json.publicKey),
        });
        return new BIP44CoinTypeNode(node, coin_type);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param derivationPath - The derivation path for the key of this node.
     */
    static async fromDerivationPath(derivationPath) {
        validateCoinTypeNodeDepth(derivationPath.length - 1);
        const node = await BIP44Node_1.BIP44Node.fromDerivationPath({
            derivationPath,
        });
        // Split the bip32 string token and extract the coin_type index
        const coinType = Number.parseInt(derivationPath[exports.BIP_44_COIN_TYPE_DEPTH].split(':')[1].replace(`'`, ''), 10);
        return new BIP44CoinTypeNode(node, coinType);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param node - The {@link BIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    static async fromNode(node, coin_type) {
        if (!(node instanceof BIP44Node_1.BIP44Node)) {
            throw new Error('Invalid node: Expected an instance of BIP44Node.');
        }
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(node.depth);
        // TODO: Make this function not async in a future version.
        return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));
    }
    get depth() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").depth;
    }
    get privateKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKeyBytes;
    }
    get publicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKeyBytes;
    }
    get chainCodeBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCodeBytes;
    }
    get privateKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKey;
    }
    get publicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKey;
    }
    get compressedPublicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKey;
    }
    get compressedPublicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKeyBytes;
    }
    get chainCode() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCode;
    }
    get address() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").address;
    }
    get masterFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").masterFingerprint;
    }
    get parentFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").parentFingerprint;
    }
    get fingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").fingerprint;
    }
    get index() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").index;
    }
    get curve() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").curve;
    }
    get extendedKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").extendedKey;
    }
    /**
     * Derives a BIP-44 `address_index` key corresponding to the path of this
     * node and the specified `account`, `change`, and `address_index` values.
     * `address_index` keys are normally the keys used to generate user account
     * addresses.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param indices - The BIP-44 index values to use in key derivation.
     * @param indices.account - The `account` index. Default: `0`
     * @param indices.change - The `change` index. Default: `0`
     * @param indices.address_index - The `address_index` index.
     * @returns The derived BIP-44 `address_index` node.
     */
    async deriveBIP44AddressKey({ account = 0, change = 0, address_index, }) {
        return await __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").derive((0, utils_1.getBIP44CoinTypeToAddressPathTuple)({ account, change, address_index }));
    }
    toJSON() {
        return Object.assign(Object.assign({}, __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").toJSON()), { coin_type: this.coin_type, path: this.path });
    }
}
exports.BIP44CoinTypeNode = BIP44CoinTypeNode;
_BIP44CoinTypeNode_node = new WeakMap();
/**
 * Validates the depth of a `coin_type` node. Simply, ensures that it is the
 * number `2`. An error is thrown if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateCoinTypeNodeDepth(depth) {
    if (depth !== exports.BIP_44_COIN_TYPE_DEPTH) {
        throw new Error(`Invalid depth: Coin type nodes must be of depth ${exports.BIP_44_COIN_TYPE_DEPTH}. Received: "${depth}"`);
    }
}
/**
 * Validates that the coin type is a non-negative integer number. An error is
 * thrown if validation fails.
 *
 * @param coin_type - The coin type to validate.
 */
function validateCoinType(coin_type) {
    if (typeof coin_type !== 'number' ||
        !Number.isInteger(coin_type) ||
        coin_type < 0) {
        throw new Error('Invalid coin type: The specified coin type must be a non-negative integer number.');
    }
}
/**
 * Derives a BIP-44 address key corresponding to the specified derivation path,
 * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param parentKeyOrNode - The `coin_type` parent key to derive from.
 * @param indices - The BIP-44 index values to use in key derivation.
 * @param indices.account - The `account` index. Default: `0`.
 * @param indices.change - The `change` index. Default: `0`.
 * @param indices.address_index - The `address_index` index.
 * @returns The derived `address_index` key for the specified derivation path.
 */
async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }) {
    const path = (0, utils_1.getBIP44CoinTypeToAddressPathTuple)({
        account,
        change,
        address_index,
    });
    const node = await getNode(parentKeyOrNode);
    const childNode = await (0, SLIP10Node_1.deriveChildNode)({
        path,
        node,
    });
    return new BIP44Node_1.BIP44Node(childNode);
}
exports.deriveBIP44AddressKey = deriveBIP44AddressKey;
/**
 * Creates a function that derives BIP-44 address keys corresponding to the
 * specified derivation path, given either by a {@link BIP44CoinTypeNode} or
 * derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.
 * This node contains a BIP-44 key of depth 2, `coin_type`.
 * @param accountAndChangeIndices - The `account` and `change` indices that
 * will be used to derive addresses.
 * @returns The deriver function for the derivation path specified by the
 * `coin_type` node, `account`, and `change` indices.
 */
async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
    const { account = 0, change = 0 } = accountAndChangeIndices !== null && accountAndChangeIndices !== void 0 ? accountAndChangeIndices : {};
    const actualNode = await getNode(node);
    const accountNode = (0, utils_1.getHardenedBIP32NodeToken)(account);
    const changeNode = (0, utils_1.getBIP32NodeToken)(change);
    const bip44AddressKeyDeriver = async (address_index, isHardened = false) => {
        const slip10Node = await (0, SLIP10Node_1.deriveChildNode)({
            path: [
                accountNode,
                changeNode,
                isHardened
                    ? (0, utils_1.getHardenedBIP32NodeToken)(address_index)
                    : (0, utils_1.getUnhardenedBIP32NodeToken)(address_index),
            ],
            node: actualNode,
        });
        return new BIP44Node_1.BIP44Node(slip10Node);
    };
    bip44AddressKeyDeriver.coin_type = actualNode.coin_type;
    bip44AddressKeyDeriver.path = (0, utils_1.getBIP44ChangePathString)(actualNode.path, {
        account,
        change,
    });
    Object.freeze(bip44AddressKeyDeriver);
    return bip44AddressKeyDeriver;
}
exports.getBIP44AddressKeyDeriver = getBIP44AddressKeyDeriver;
/**
 * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type
 * node is provided, the same node is returned.
 *
 * The depth of the node is validated to be a valid coin type node.
 *
 * @param node - A BIP-44 coin type node, JSON node or extended key.
 */
async function getNode(node) {
    if (node instanceof BIP44CoinTypeNode) {
        validateCoinTypeNodeDepth(node.depth);
        return node;
    }
    if (typeof node === 'string') {
        const bip44Node = await BIP44Node_1.BIP44Node.fromExtendedKey(node);
        const coinTypeNode = await BIP44CoinTypeNode.fromNode(bip44Node, bip44Node.index - constants_1.BIP_32_HARDENED_OFFSET);
        validateCoinTypeNodeDepth(coinTypeNode.depth);
        return coinTypeNode;
    }
    return BIP44CoinTypeNode.fromJSON(node, node.coin_type);
}
//# sourceMappingURL=BIP44CoinTypeNode.js.map