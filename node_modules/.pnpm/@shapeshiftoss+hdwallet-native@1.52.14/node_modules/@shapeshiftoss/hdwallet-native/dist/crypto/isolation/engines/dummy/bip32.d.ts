import { BIP32, Digest, SecP256K1 } from "../../core";
import { ByteArray, Uint32 } from "../../types";
import { ParsedXpubTree } from "./types";
export * from "../../core/bip32";
export declare class Node implements BIP32.Node, SecP256K1.ECDSARecoverableKey, SecP256K1.ECDHKey {
    readonly xpubTree: ParsedXpubTree;
    protected constructor(xpubTree: ParsedXpubTree);
    static create(xpubTree: ParsedXpubTree): Promise<BIP32.Node>;
    getPublicKey(): Promise<SecP256K1.CompressedPoint>;
    getChainCode(): Promise<BIP32.ChainCode>;
    ecdsaSign(digestAlgorithm: null, msg: ByteArray<32>, counter?: Uint32): Promise<SecP256K1.Signature>;
    ecdsaSign(digestAlgorithm: Digest.AlgorithmName<32>, msg: Uint8Array, counter?: Uint32): Promise<SecP256K1.Signature>;
    ecdsaSignRecoverable(digestAlgorithm: null, msg: ByteArray<32>, counter?: Uint32): Promise<SecP256K1.RecoverableSignature>;
    ecdsaSignRecoverable(digestAlgorithm: Digest.AlgorithmName<32>, msg: Uint8Array, counter?: Uint32): Promise<SecP256K1.RecoverableSignature>;
    derive(index: Uint32): Promise<this>;
    ecdh(publicKey: SecP256K1.CurvePoint, digestAlgorithm?: Digest.AlgorithmName<32>): Promise<ByteArray<32>>;
    ecdhRaw(publicKey: SecP256K1.CurvePoint): Promise<SecP256K1.UncompressedPoint>;
}
export declare class Seed implements BIP32.Seed {
    readonly xpubTree: ParsedXpubTree;
    protected constructor(xpubTree: ParsedXpubTree);
    static create(xpubTree: ParsedXpubTree): Promise<BIP32.Seed>;
    toMasterKey(): Promise<BIP32.Node>;
    toMasterKey(hmacKey: string | Uint8Array): never;
}
//# sourceMappingURL=bip32.d.ts.map