import { Literal, Object as Obj, Static, Union } from "funtypes";
import { BigEndianInteger, Uint32 } from "../../types";
import * as Digest from "../digest";
import { ECDSAKey } from "./interfaces";
declare const _fieldElementBase: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, Uint8Array & {
    length: 32;
}, unknown>;
export type FieldElement = Static<typeof _fieldElementBase>;
declare const _fieldElement: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, Uint8Array & {
    length: 32;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    isHigh: <T_2 extends number>(x: BigEndianInteger<T_2>) => boolean;
    isOdd: <T_3 extends number>(x: BigEndianInteger<T_3>) => boolean;
};
export declare const FieldElement: typeof _fieldElement;
declare const _uncompressedPointBase: import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    0: Literal<4>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>;
export type UncompressedPoint = Static<typeof _uncompressedPointBase>;
declare const _compressedPointBase: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<33>;
}, false>]>, Obj<{
    0: Union<[Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 33;
} & {
    0: 2 | 3;
}, unknown>;
export type CompressedPoint = Static<typeof _compressedPointBase>;
declare const _uncompressedPoint: import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    0: Literal<4>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => UncompressedPoint;
    fromCompressed: (p: CompressedPoint) => UncompressedPoint;
    x: (p: UncompressedPoint) => FieldElement;
    y: (p: UncompressedPoint) => FieldElement;
    yIsOdd: (p: UncompressedPoint) => boolean;
};
export declare const UncompressedPoint: typeof _uncompressedPoint;
declare const _compressedPoint: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<33>;
}, false>]>, Obj<{
    0: Union<[Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 33;
} & {
    0: 2 | 3;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => CompressedPoint;
    fromUncompressed: (p: UncompressedPoint) => CompressedPoint;
    x: (p: CompressedPoint) => FieldElement;
    yIsOdd: (p: CompressedPoint) => boolean;
};
export declare const CompressedPoint: typeof _compressedPoint;
export type CurvePoint = CompressedPoint | UncompressedPoint;
declare const _curvePoint: Union<[import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<33>;
}, false>]>, Obj<{
    0: Union<[Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 33;
} & {
    0: 2 | 3;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => CompressedPoint;
    fromUncompressed: (p: UncompressedPoint) => CompressedPoint;
    x: (p: CompressedPoint) => FieldElement;
    yIsOdd: (p: CompressedPoint) => boolean;
}, import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    0: Literal<4>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => UncompressedPoint;
    fromCompressed: (p: CompressedPoint) => UncompressedPoint;
    x: (p: UncompressedPoint) => FieldElement;
    y: (p: UncompressedPoint) => FieldElement;
    yIsOdd: (p: UncompressedPoint) => boolean;
}]> & {
    x: (p: CurvePoint) => FieldElement;
    yIsOdd: (p: CurvePoint) => boolean;
    equal: (lhs: CurvePoint, rhs: CurvePoint) => boolean;
};
export declare const CurvePoint: typeof _curvePoint;
declare const _recoveryParamBase: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
export type RecoveryParam = Static<typeof _recoveryParamBase>;
declare const _recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
export declare const RecoveryParam: typeof _recoveryParam;
declare const _messageWithPreimageBase: import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]>;
export type MessageWithPreimage = Static<typeof _messageWithPreimageBase>;
declare const _messageWithPreimage: import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
};
export declare const MessageWithPreimage: typeof _messageWithPreimage;
declare const _messageBase: Union<[import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
}, import("funtypes").InstanceOf<Uint8Array>]>;
export type Message = Static<typeof _messageBase>;
declare const _message: Union<[import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
}, import("funtypes").InstanceOf<Uint8Array>]> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
};
export declare const Message: typeof _message;
declare const _signatureBase: import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<64>;
}, false>]>, Uint8Array & {
    length: 64;
}, unknown>, Uint8Array & {
    length: 64;
}, unknown>;
export type Signature = Static<typeof _signatureBase>;
declare const _signature: import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<64>;
}, false>]>, Uint8Array & {
    length: 64;
}, unknown>, Uint8Array & {
    length: 64;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    r: (x: Signature) => FieldElement;
    s: (x: Signature) => FieldElement;
    isLowR: (x: Signature) => boolean;
    isLowS: (x: Signature) => boolean;
    isCanonical: (x: Signature) => boolean;
    signCanonically: (x: ECDSAKey, digestAlgorithm: Digest.AlgorithmName<32> | null, message: Uint8Array, counter?: Uint32) => Promise<Signature>;
    verify: (x: Signature, digestAlgorithm: Digest.AlgorithmName<32> | null, message: Uint8Array, publicKey: CurvePoint) => boolean;
};
export declare const Signature: typeof _signature;
declare const _recoverableSignatureBase: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    64: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    64: 0 | 2 | 1 | 3;
}, unknown>;
export type RecoverableSignature = Static<typeof _recoverableSignatureBase>;
declare const _recoverableSignature: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    64: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    64: 0 | 2 | 1 | 3;
}, unknown> & {
    from: (x: Signature, recoveryParam: RecoveryParam) => RecoverableSignature;
    fromSignature: (x: Signature, digestAlgorithm: Digest.AlgorithmName<32> | null, message: Uint8Array, publicKey: CurvePoint) => Promise<RecoverableSignature>;
    sig: (x: RecoverableSignature) => Signature;
    recoveryParam: (x: RecoverableSignature) => RecoveryParam;
    isLowRecoveryParam: (x: RecoverableSignature) => boolean;
    isCanonical: (x: RecoverableSignature) => boolean;
    signCanonically: (x: ECDSAKey, digestAlgorithm: Digest.AlgorithmName<32> | null, message: Uint8Array, counter?: Uint32) => Promise<RecoverableSignature>;
    recoverPublicKey: (x: RecoverableSignature, digestAlgorithm: Digest.AlgorithmName<32> | null, message: Uint8Array) => Promise<CurvePoint>;
    r: (x: RecoverableSignature) => FieldElement;
    s: (x: RecoverableSignature) => FieldElement;
    isLowR: (x: RecoverableSignature) => boolean;
    isLowS: (x: RecoverableSignature) => boolean;
    verify: (x: RecoverableSignature, digestAlgorithm: Digest.AlgorithmName<32> | null, message: Uint8Array, publicKey: CurvePoint) => boolean;
};
export declare const RecoverableSignature: typeof _recoverableSignature;
export {};
//# sourceMappingURL=types.d.ts.map