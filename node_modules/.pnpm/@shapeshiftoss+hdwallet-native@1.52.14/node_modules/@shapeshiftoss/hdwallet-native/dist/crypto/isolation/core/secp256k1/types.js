"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecoverableSignature = exports.Signature = exports.Message = exports.MessageWithPreimage = exports.RecoveryParam = exports.CurvePoint = exports.CompressedPoint = exports.UncompressedPoint = exports.FieldElement = void 0;
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const funtypes_1 = require("funtypes");
const p_lazy_1 = __importDefault(require("p-lazy"));
const tinyecc = __importStar(require("tiny-secp256k1"));
const types_1 = require("../../types");
const Digest = __importStar(require("../digest"));
const ethers = p_lazy_1.default.from(() => Promise.resolve().then(() => __importStar(require("ethers"))));
const _fieldElementBase = (0, types_1.BigEndianInteger)(32).withConstraint((x) => tinyecc.isPrivate((0, types_1.safeBufferFrom)(x)) || `expected ${x} to be within the order of the curve`, { name: "FieldElement" });
const _fieldElementStatic = {};
const _fieldElement = Object.assign(_fieldElementBase, types_1.BigEndianInteger, _fieldElementStatic);
exports.FieldElement = _fieldElement;
const _uncompressedPointBase = (0, types_1.ByteArray)(65)
    .And((0, funtypes_1.Object)({
    0: (0, funtypes_1.Literal)(0x04),
}))
    .withConstraint((p) => exports.FieldElement.test(p.slice(1, 33)) || `expected ${p}.x to be within the order of the curve`, {
    name: "UncompressedPoint.x",
})
    .withConstraint((p) => {
    if (!exports.FieldElement.test(p.slice(33, 65)))
        return `expected ${p}.y to be within the order of the curve`;
    const pBuf = Buffer.from(p);
    if (!types_1.ByteArray.equal(tinyecc.pointCompress(tinyecc.pointCompress(pBuf, true), false), pBuf))
        return `expected ${p} to be on the curve`;
    return true;
}, { name: "UncompressedPoint.y" });
const _compressedPointBase = (0, types_1.ByteArray)(33)
    .And((0, funtypes_1.Object)({
    0: (0, funtypes_1.Literal)(0x02).Or((0, funtypes_1.Literal)(0x03)),
}))
    .withConstraint((p) => exports.FieldElement.test(p.slice(1)) || `expected ${p}.x to be within the order of the curve`, {
    name: "CompressedPoint.x",
});
const _uncompressedPointStatic = {
    from: (p) => {
        return p.length === 65 ? p : exports.UncompressedPoint.fromCompressed((0, types_1.checkType)(exports.CompressedPoint, p));
    },
    fromCompressed: (p) => {
        return (0, types_1.checkType)(exports.UncompressedPoint, tinyecc.pointCompress(Buffer.from(p), false));
    },
    x: (p) => {
        return (0, types_1.checkType)(exports.FieldElement, p.slice(1, 33));
    },
    y: (p) => {
        return (0, types_1.checkType)(exports.FieldElement, p.slice(33, 65));
    },
    yIsOdd: (p) => {
        return exports.FieldElement.isOdd(exports.UncompressedPoint.y(p));
    },
};
const _uncompressedPoint = Object.assign(_uncompressedPointBase, types_1.ByteArray, _uncompressedPointStatic);
exports.UncompressedPoint = _uncompressedPoint;
const _compressedPointStatic = {
    from: (p) => {
        return p.length === 33 ? p : exports.CompressedPoint.fromUncompressed((0, types_1.checkType)(exports.UncompressedPoint, p));
    },
    fromUncompressed: (p) => {
        const out = new Uint8Array(33);
        out[0] = exports.UncompressedPoint.yIsOdd(p) ? 0x03 : 0x02;
        out.set(exports.UncompressedPoint.x(p), 1);
        exports.CompressedPoint.assert(out);
        return out;
    },
    x: (p) => {
        return (0, types_1.checkType)(exports.FieldElement, p.slice(1));
    },
    yIsOdd: (p) => {
        return p[0] === 0x03;
    },
};
const _compressedPoint = Object.assign(_compressedPointBase, types_1.ByteArray, _compressedPointStatic);
exports.CompressedPoint = _compressedPoint;
const _curvePointBase = exports.CompressedPoint.Or(exports.UncompressedPoint);
const _curvePointStatic = {
    x: (p) => (p[0] === 0x04 ? exports.UncompressedPoint.x(p) : exports.CompressedPoint.x(p)),
    yIsOdd: (p) => (p[0] === 0x04 ? exports.UncompressedPoint.yIsOdd(p) : exports.CompressedPoint.yIsOdd(p)),
    // Equivalent to CompressedPoint.equal(CompressedPoint.from(lhs), CompressedPoint.from(rhs)), but avoids allocations
    equal: (lhs, rhs) => exports.CurvePoint.yIsOdd(lhs) === exports.CurvePoint.yIsOdd(rhs) && exports.FieldElement.equal(exports.CurvePoint.x(lhs), exports.CurvePoint.x(rhs)),
};
const _curvePoint = Object.assign(_curvePointBase, _curvePointStatic);
exports.CurvePoint = _curvePoint;
const _recoveryParamBase = (0, funtypes_1.Union)((0, funtypes_1.Literal)(0), (0, funtypes_1.Literal)(1), (0, funtypes_1.Literal)(2), (0, funtypes_1.Literal)(3));
const _recoveryParamStatic = {};
const _recoveryParam = Object.assign(_recoveryParamBase, _recoveryParamStatic);
exports.RecoveryParam = _recoveryParam;
const _messageWithPreimageBase = (0, types_1.ByteArray)(32).And(Digest.Digest());
const _messageWithPreimageStatic = {};
const _messageWithPreimage = Object.assign(_messageWithPreimageBase, types_1.ByteArray, _messageWithPreimageStatic);
exports.MessageWithPreimage = _messageWithPreimage;
const _messageBase = exports.MessageWithPreimage.Or((0, types_1.ByteArray)());
const _messageStatic = {};
const _message = Object.assign(_messageBase, types_1.ByteArray, _messageWithPreimageStatic, _messageStatic);
exports.Message = _message;
const _signatureBase = (0, types_1.ByteArray)(64)
    .withConstraint((x) => exports.FieldElement.test(x.slice(0, 32)) || `expected ${x}.r to be within the order of the curve`, {
    name: "Signature.r",
})
    .withConstraint((x) => exports.FieldElement.test(x.slice(32, 64)) || `expected ${x}.s to be within the order of the curve`, {
    name: "Signature.s",
});
const _signatureStatic = {
    r: (x) => {
        return (0, types_1.checkType)(exports.FieldElement, x.slice(0, 32));
    },
    s: (x) => {
        return (0, types_1.checkType)(exports.FieldElement, x.slice(32, 64));
    },
    isLowR: (x) => {
        return !exports.FieldElement.isHigh(exports.Signature.r(x));
    },
    isLowS: (x) => {
        return !exports.FieldElement.isHigh(exports.Signature.s(x));
    },
    isCanonical: (x) => {
        return exports.Signature.isLowR(x) && exports.Signature.isLowS(x);
    },
    signCanonically: (x, digestAlgorithm, message, counter) => __awaiter(void 0, void 0, void 0, function* () {
        (0, types_1.assertType)((0, types_1.ByteArray)(), message);
        counter === undefined || types_1.Uint32.assert(counter);
        for (let i = counter; i === undefined || i < (counter !== null && counter !== void 0 ? counter : 0) + 128; i = (i !== null && i !== void 0 ? i : -1) + 1) {
            const sig = yield (() => __awaiter(void 0, void 0, void 0, function* () {
                if (digestAlgorithm === null) {
                    (0, types_1.assertType)((0, types_1.ByteArray)(32), message);
                    return i === undefined
                        ? yield x.ecdsaSign(digestAlgorithm, message)
                        : yield x.ecdsaSign(digestAlgorithm, message, i);
                }
                else {
                    return i === undefined
                        ? yield x.ecdsaSign(digestAlgorithm, message)
                        : yield x.ecdsaSign(digestAlgorithm, message, i);
                }
            }))();
            if (sig === undefined)
                break;
            //TODO: do integrated lowS correction
            if (exports.Signature.isCanonical(sig))
                return sig;
        }
        // This is cryptographically impossible (2^-128 chance) if the key is implemented correctly.
        throw new Error(`Unable to generate canonical signature with public key ${x} over message ${message}; is your key implementation broken?`);
    }),
    verify: (x, digestAlgorithm, message, publicKey) => {
        const msgOrDigest = digestAlgorithm === null
            ? (0, types_1.checkType)((0, types_1.ByteArray)(32), message)
            : Digest.Algorithms[digestAlgorithm]((0, types_1.checkType)((0, types_1.ByteArray)(), message));
        return tinyecc.verify(Buffer.from(msgOrDigest), Buffer.from(publicKey), Buffer.from(x));
    },
};
const _signature = Object.assign(_signatureBase, types_1.ByteArray, _signatureStatic);
exports.Signature = _signature;
const _recoverableSignatureBase = (0, types_1.ByteArray)(65)
    .And((0, funtypes_1.Object)({
    64: exports.RecoveryParam,
}))
    .withConstraint((x) => exports.Signature.test(x.slice(0, 64)) || `expected ${x}.sig to be a valid signature`, {
    name: "Signature",
});
const _recoverableSignatureStatic = {
    from: (x, recoveryParam) => {
        return (0, types_1.checkType)(exports.RecoverableSignature, core.compatibleBufferConcat([x, new Uint8Array([recoveryParam])]));
    },
    fromSignature: (x, digestAlgorithm, message, publicKey) => __awaiter(void 0, void 0, void 0, function* () {
        for (let recoveryParam = 0; recoveryParam < 4; recoveryParam++) {
            const out = exports.RecoverableSignature.from(x, recoveryParam);
            if (!exports.CurvePoint.equal(publicKey, yield exports.RecoverableSignature.recoverPublicKey(out, digestAlgorithm, message)))
                continue;
            return out;
        }
        throw new Error(`couldn't find recovery parameter producing public key ${publicKey} for signature ${x} over message ${message}`);
    }),
    sig: (x) => (0, types_1.checkType)(exports.Signature, x.slice(0, 64)),
    recoveryParam: (x) => (0, types_1.checkType)(exports.RecoveryParam, x[64]),
    isLowRecoveryParam: (x) => [0, 1].includes(exports.RecoverableSignature.recoveryParam(x)),
    isCanonical: (x) => exports.Signature.isCanonical((0, types_1.checkType)(exports.Signature, exports.RecoverableSignature.sig(x))) &&
        exports.RecoverableSignature.isLowRecoveryParam(x),
    signCanonically: (x, digestAlgorithm, message, counter) => __awaiter(void 0, void 0, void 0, function* () {
        const publicKey = yield x.getPublicKey();
        (0, types_1.assertType)((0, types_1.ByteArray)(), message);
        counter === undefined || types_1.Uint32.assert(counter);
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const isIndexable = (x) => x !== null && ["object", "function"].includes(typeof x);
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const isECDSARecoverableKey = (x) => isIndexable(x) && "ecdsaSignRecoverable" in x && typeof x.ecdsaSignRecoverable === "function";
        const ecdsaSignRecoverable = isECDSARecoverableKey(x)
            ? // eslint-disable-next-line @typescript-eslint/no-shadow
                (digestAlgorithm, message, counter) => __awaiter(void 0, void 0, void 0, function* () {
                    if (digestAlgorithm === null) {
                        (0, types_1.assertType)((0, types_1.ByteArray)(32), message);
                        return counter === undefined
                            ? yield x.ecdsaSignRecoverable(digestAlgorithm, message)
                            : yield x.ecdsaSignRecoverable(digestAlgorithm, message, counter);
                    }
                    else {
                        return counter === undefined
                            ? yield x.ecdsaSignRecoverable(digestAlgorithm, message)
                            : yield x.ecdsaSignRecoverable(digestAlgorithm, message, counter);
                    }
                })
            : // eslint-disable-next-line @typescript-eslint/no-shadow
                (digestAlgorithm, message, counter) => __awaiter(void 0, void 0, void 0, function* () {
                    const sig = yield exports.Signature.signCanonically(x, digestAlgorithm, message, counter);
                    if (sig === undefined)
                        return undefined;
                    return yield exports.RecoverableSignature.fromSignature(sig, digestAlgorithm, message, publicKey);
                });
        // Technically, this may waste cycles; if Signature.signCanonically grinds the counter to find a canonical signature which then
        // ends up to have a non-canonical recovery parameter, those values will all be re-ground. However, signatures can have
        // non-canonical recovery parameters only with negligible probability, so optimization for that case would be silly.
        for (let i = counter; i === undefined || i < (counter !== null && counter !== void 0 ? counter : 0) + 128; i = (i !== null && i !== void 0 ? i : -1) + 1) {
            const recoverableSig = yield ecdsaSignRecoverable(digestAlgorithm, message, i);
            if (recoverableSig === undefined)
                break;
            //TODO: do integrated lowS correction
            if (exports.RecoverableSignature.isCanonical(recoverableSig))
                return recoverableSig;
        }
        // This is cryptographically impossible (2^-128 chance) if the key is implemented correctly.
        throw new Error(`Unable to generate canonical recoverable signature with public key ${Buffer.from(publicKey).toString("hex")} over message ${Buffer.from(message).toString("hex")}; is your key implementation broken?`);
    }),
    recoverPublicKey: (x, digestAlgorithm, message) => __awaiter(void 0, void 0, void 0, function* () {
        // TODO: do this better
        const msgOrDigest = digestAlgorithm === null
            ? (0, types_1.checkType)((0, types_1.ByteArray)(32), message)
            : Digest.Algorithms[digestAlgorithm]((0, types_1.checkType)((0, types_1.ByteArray)(), message));
        const sig = exports.RecoverableSignature.sig(x);
        const recoveryParam = exports.RecoverableSignature.recoveryParam(x);
        const ethSig = core.compatibleBufferConcat([sig, Buffer.from([recoveryParam])]);
        const ethRecovered = (yield ethers).utils.recoverPublicKey(msgOrDigest, (yield ethers).utils.splitSignature(ethSig));
        return (0, types_1.checkType)(exports.UncompressedPoint, Buffer.from(ethRecovered.slice(2), "hex"));
    }),
    r: (x) => exports.Signature.r(exports.RecoverableSignature.sig(x)),
    s: (x) => exports.Signature.s(exports.RecoverableSignature.sig(x)),
    isLowR: (x) => exports.Signature.isLowR(exports.RecoverableSignature.sig(x)),
    isLowS: (x) => exports.Signature.isLowS(exports.RecoverableSignature.sig(x)),
    verify: (x, digestAlgorithm, message, publicKey) => {
        return exports.Signature.verify(exports.RecoverableSignature.sig(x), digestAlgorithm, message, publicKey);
    },
};
const _recoverableSignature = Object.assign(_recoverableSignatureBase, _recoverableSignatureStatic);
exports.RecoverableSignature = _recoverableSignature;
//# sourceMappingURL=types.js.map