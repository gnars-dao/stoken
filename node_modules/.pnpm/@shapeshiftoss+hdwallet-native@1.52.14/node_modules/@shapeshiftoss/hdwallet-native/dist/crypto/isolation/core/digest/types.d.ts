import { Enum, Literal, Object as Obj, Runtype } from "funtypes";
import { ByteArray, NonNegativeInteger } from "../../types";
import { AlgorithmLength } from "./algorithms";
declare function algorithmNameBase<L extends NonNegativeInteger | undefined = undefined>(length?: L): Enum<{
    [N in AlgorithmName<L>]: N;
}>;
type algorithmNameInner<K, L> = K extends keyof typeof AlgorithmLength ? typeof AlgorithmLength[K] extends L ? K : never : never;
export type AlgorithmName<L extends NonNegativeInteger | undefined = undefined> = L extends undefined ? keyof typeof AlgorithmLength : algorithmNameInner<keyof typeof AlgorithmLength, L>;
declare const algorithmName: typeof algorithmNameBase & Enum<{
    sha1: "sha1";
    ripemd160: "ripemd160";
    hash160: "hash160";
    sha256: "sha256";
    hash256: "hash256";
    keccak256: "keccak256";
    sha512: "sha512";
}> & {
    forEach(callbackfn: (value: AlgorithmName, index: number, array: AlgorithmName[]) => void, thisarg?: any): void;
};
export declare const AlgorithmName: typeof algorithmName;
declare function unverifiedDigestBase<N extends AlgorithmName = AlgorithmName>(name?: N): Runtype<UnverifiedDigest<N>>;
type unverifiedDigestInner<N> = N extends keyof typeof AlgorithmLength ? ByteArray<typeof AlgorithmLength[N]> & {
    preimage: ByteArray;
    algorithm: N;
} : never;
type UnverifiedDigest<N extends AlgorithmName = AlgorithmName> = unverifiedDigestInner<N>;
declare const unverifiedDigest: typeof unverifiedDigestBase & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
};
declare const UnverifiedDigest: typeof unverifiedDigest;
export type Digest<N extends AlgorithmName> = UnverifiedDigest<N>;
export type Algorithm<N extends AlgorithmName = AlgorithmName> = (_: ByteArray) => Digest<N>;
export declare const Algorithms: {
    readonly sha1: Algorithm<"sha1">;
    readonly ripemd160: Algorithm<"ripemd160">;
    readonly hash160: Algorithm<"hash160">;
    readonly sha256: Algorithm<"sha256">;
    readonly hash256: Algorithm<"hash256">;
    readonly keccak256: Algorithm<"keccak256">;
    readonly sha512: Algorithm<"sha512">;
};
declare function digestBase(name?: AlgorithmName): import("funtypes").Constraint<Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>;
declare const digest: typeof digestBase & typeof unverifiedDigestBase & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
};
export declare const Digest: typeof digest;
export {};
//# sourceMappingURL=types.d.ts.map