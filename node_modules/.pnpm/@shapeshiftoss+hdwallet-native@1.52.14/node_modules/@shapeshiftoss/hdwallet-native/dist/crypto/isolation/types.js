"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeBufferFrom = exports.BigEndianInteger = exports.ByteArray = exports.checkType = exports.assertType = exports.BoundedString = exports.BoundedUint = exports.Uint8 = exports.Uint16 = exports.Uint32 = exports.Uint = exports.NonNegativeInteger = exports.NonPositiveInteger = exports.NegativeInteger = exports.PositiveInteger = exports.Integer = exports.integer = exports.NonPositive = exports.NonNegative = exports.Negative = exports.Positive = void 0;
const funtypes_1 = require("funtypes");
const positive = funtypes_1.Number.withConstraint((x) => x > 0 || `expected ${x} to be positive`, { name: "Positive" });
exports.Positive = positive;
const negative = funtypes_1.Number.withConstraint((x) => x < 0 || `expected ${x} to be negative`, { name: "Negative" });
exports.Negative = negative;
const nonNegative = funtypes_1.Number.withConstraint((x) => x >= 0 || `expected ${x} to be non-negative`, { name: "NonNegative" });
exports.NonNegative = nonNegative;
const nonPositive = funtypes_1.Number.withConstraint((x) => x <= 0 || `expected ${x} to be non-positive`, { name: "NonPositive" });
exports.NonPositive = nonPositive;
exports.integer = funtypes_1.Number.withConstraint((x) => Number.isSafeInteger(x) || `expected ${x} to be an integer`, {
    name: "Integer",
});
exports.Integer = exports.integer;
const positiveInteger = exports.Integer.And(exports.Positive);
exports.PositiveInteger = positiveInteger;
const negativeInteger = exports.Integer.And(exports.Negative);
exports.NegativeInteger = negativeInteger;
const nonPositiveInteger = exports.Integer.And(exports.NonPositive);
exports.NonPositiveInteger = nonPositiveInteger;
const nonNegativeInteger = exports.Integer.And(exports.NonNegative);
exports.NonNegativeInteger = nonNegativeInteger;
const uint = exports.NonNegativeInteger.Or(funtypes_1.Never);
exports.Uint = uint;
const uint32 = funtypes_1.Number.withConstraint((x) => x === (x & 0xffffffff) >>> 0 || `expected ${x} to be an unsigned 32-bit integer.`, { name: "Uint32" });
exports.Uint32 = uint32;
const uint16 = funtypes_1.Number.withConstraint((x) => x === (x & 0xffff) >>> 0 || `expected ${x} to be an unsigned 16-bit integer`, {
    name: "Uint16",
});
exports.Uint16 = uint16;
const uint8 = funtypes_1.Number.withConstraint((x) => x === (x & 0xff) >>> 0 || `expected ${x} to be an unsigned 8-bit integer`, {
    name: "Uint8",
});
exports.Uint8 = uint8;
function boundedUintBase(max) {
    return Object.assign(exports.Uint.withConstraint((x) => x <= max || `expected ${x} to be less than or equal to ${max}`, {
        name: `BoundedUint(${max})`,
    }), { max });
}
const boundedUintStatic = {};
const boundedUint = Object.assign(boundedUintBase, boundedUintStatic);
exports.BoundedUint = boundedUint;
function boundedStringBase(regex) {
    return Object.assign(funtypes_1.String.withConstraint((x) => regex.test(x) || `expected ${x} to match regex ${regex}`, {
        name: `BoundedString(${regex})`,
    }), { regex });
}
const boundedStringStatic = {};
const boundedString = Object.assign(boundedStringBase, boundedStringStatic);
exports.BoundedString = boundedString;
function assertType(rt, value) {
    rt.assert(value);
}
exports.assertType = assertType;
function checkType(rt, value) {
    assertType(rt, value);
    return value;
}
exports.checkType = checkType;
function byteArrayBase(length) {
    length === undefined || exports.NonNegativeInteger.assert(length);
    const indefinite = (0, funtypes_1.InstanceOf)(Uint8Array);
    const literalConstraint = length !== undefined ? (0, funtypes_1.Literal)(length) : funtypes_1.Unknown;
    const definite = (0, funtypes_1.InstanceOf)(Uint8Array).And((0, funtypes_1.Object)({
        length: literalConstraint,
    }));
    return (length === undefined ? indefinite : definite);
}
const byteArrayStatic = {
    equal(lhs, rhs) {
        const length = lhs.length;
        if (length !== rhs.length)
            return false;
        for (let i = 0; i < length; i++) {
            if (lhs[i] !== rhs[i])
                return false;
        }
        return true;
    },
};
const byteArray = Object.assign(byteArrayBase, byteArrayStatic);
exports.ByteArray = byteArray;
function bigEndianIntegerBase(length) {
    return (0, exports.ByteArray)(length);
}
const bigEndianIntegerStatic = {
    isHigh: (x) => (x[0] & 0x80) !== 0,
    isOdd: (x) => (x[x.length - 1] & 1) === 1,
};
const bigEndianInteger = Object.assign(bigEndianIntegerBase, exports.ByteArray, bigEndianIntegerStatic);
exports.BigEndianInteger = bigEndianInteger;
function safeBufferFrom(input) {
    if (Buffer.isBuffer(input))
        return input;
    input = checkType((0, exports.ByteArray)(), input);
    return Buffer.alloc(input.byteLength).fill(input);
}
exports.safeBufferFrom = safeBufferFrom;
//# sourceMappingURL=types.js.map