"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CryptoHelper_engine;
Object.defineProperty(exports, "__esModule", { value: true });
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const bip39 = __importStar(require("bip39"));
const classes_1 = require("./classes");
const engines_1 = require("./engines");
const utils = __importStar(require("./utils"));
/**
 * This class is only intended to be used by the EncryptedWallet class
 */
class CryptoHelper {
    constructor(engine) {
        _CryptoHelper_engine.set(this, void 0);
        if (!engine) {
            throw new Error("Missing cryptography engine");
        }
        __classPrivateFieldSet(this, _CryptoHelper_engine, engine, "f");
    }
    // Safely compare two values in a way that protects against timing attacks (Double HMAC Verification).
    // ref: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/
    // ref: https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy
    compare(a, b) {
        return __awaiter(this, void 0, void 0, function* () {
            const macKey = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").randomBytes(32);
            const mac1 = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").hmac(a, macKey);
            const mac2 = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").hmac(b, macKey);
            if (mac1.byteLength !== mac2.byteLength) {
                return false;
            }
            const arr1 = new Uint8Array(mac1);
            const arr2 = new Uint8Array(mac2);
            for (let i = 0; i < arr2.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        });
    }
    aesEncrypt(data, key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data == null || !(data instanceof ArrayBuffer || data instanceof Uint8Array))
                throw new Error("Required parameter [data] is not of type ArrayBuffer or Uint8Array");
            if (data instanceof Uint8Array)
                data = core.toArrayBuffer(data);
            if (key == null || key.encKey == null || key.macKey == null)
                throw new Error("Required parameter [key] is not of type SymmetricCryptoKey");
            const iv = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").randomBytes(16);
            const encData = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").encrypt(data, key.encKey, iv);
            const macData = new Uint8Array(iv.byteLength + encData.byteLength);
            macData.set(new Uint8Array(iv), 0);
            macData.set(new Uint8Array(encData), iv.byteLength);
            const mac = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").hmac(macData.buffer.slice(macData.byteOffset, macData.byteOffset + macData.byteLength), key.macKey);
            return new classes_1.EncryptedObject({ key, iv, data: encData, mac });
        });
    }
    aesDecrypt(data, iv, mac, key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data == null || !(data instanceof ArrayBuffer || data instanceof Uint8Array))
                throw new Error("Required parameter [data] is not of type ArrayBuffer or Uint8Array");
            if (data instanceof Uint8Array)
                data = core.toArrayBuffer(data);
            if (iv == null || !(iv instanceof ArrayBuffer || iv instanceof Uint8Array))
                throw new Error("Required parameter [iv] is not of type ArrayBuffer or Uint8Array");
            if (iv instanceof Uint8Array)
                iv = core.toArrayBuffer(iv);
            if (mac == null || !(mac instanceof ArrayBuffer || mac instanceof Uint8Array))
                throw new Error("Required parameter [mac] is not of type ArrayBuffer or Uint8Array");
            if (mac instanceof Uint8Array)
                mac = core.toArrayBuffer(mac);
            if (key == null || key.encKey == null || key.macKey == null)
                throw new Error("Required parameter [key] is not of type SymmetricCryptoKey");
            const macData = new Uint8Array(iv.byteLength + data.byteLength);
            macData.set(new Uint8Array(iv), 0);
            macData.set(new Uint8Array(data), iv.byteLength);
            const computedMac = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").hmac(core.toArrayBuffer(macData), key.macKey);
            const macsMatch = yield this.compare(mac, computedMac);
            if (!macsMatch)
                throw new Error("HMAC signature is not valid or data has been tampered with");
            return __classPrivateFieldGet(this, _CryptoHelper_engine, "f").decrypt(data, key.encKey, iv);
        });
    }
    // @see: https://tools.ietf.org/html/rfc5869
    hkdfExpand(prk, info, size) {
        return __awaiter(this, void 0, void 0, function* () {
            const hashLen = 32; // sha256
            const okm = new Uint8Array(size);
            let previousT = new Uint8Array(0);
            const n = Math.ceil(size / hashLen);
            for (let i = 0; i < n; i++) {
                const t = new Uint8Array(previousT.length + info.length + 1);
                t.set(previousT);
                t.set(info, previousT.length);
                t.set([i + 1], t.length - 1);
                previousT = new Uint8Array(yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").hmac(core.toArrayBuffer(t), prk));
                okm.set(previousT, i * hashLen);
            }
            return okm;
        });
    }
    pbkdf2(password, salt, iterations) {
        return __awaiter(this, void 0, void 0, function* () {
            password = typeof password !== "string" ? password : core.toArrayBuffer(utils.fromUtf8ToArray(password));
            salt = typeof salt !== "string" ? salt : core.toArrayBuffer(utils.fromUtf8ToArray(salt));
            return __classPrivateFieldGet(this, _CryptoHelper_engine, "f").pbkdf2(password, salt, { iterations, keyLen: 32 });
        });
    }
    makeKey(password, email) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(password && email && typeof password === "string" && typeof email === "string")) {
                throw new Error("A password and email are required to make a symmetric crypto key.");
            }
            const salt = core.toArrayBuffer(utils.fromUtf8ToArray(email));
            // The same email/password MUST always generate the same encryption key, so
            // scrypt parameters are hard-coded to ensure compatibility across implementations
            const key = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").scrypt(core.toArrayBuffer(utils.fromUtf8ToArray(password)), salt, {
                iterations: 16384,
                blockSize: 8,
                parallelism: 1,
                keyLength: 32,
            });
            const hashKey = yield this.pbkdf2(key, password, 1);
            const stretchedKey = yield this.hkdfExpand(key, utils.fromUtf8ToArray("enc"), 32);
            const macKey = yield this.hkdfExpand(key, utils.fromUtf8ToArray("mac"), 32);
            return new classes_1.SymmetricCryptoKey(hashKey, stretchedKey, macKey);
        });
    }
    decrypt(cipherString, key) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = utils.fromB64ToArray(cipherString.data);
            const iv = utils.fromB64ToArray(cipherString.iv);
            const mac = utils.fromB64ToArray(cipherString.mac);
            const decipher = yield this.aesDecrypt(data, iv, mac, key);
            return utils.fromBufferToUtf8(decipher);
        });
    }
    // use entropyToMnemonic to generate mnemonic so we can utilize provided randomBytes function
    generateMnemonic(strength = 128) {
        return __awaiter(this, void 0, void 0, function* () {
            const entropy = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").randomBytes(strength / 8);
            return bip39.entropyToMnemonic(Buffer.from(entropy));
        });
    }
    /**
     * Generates a base64 hash based on the provided data
     * Should be used to calculate a device ID for the wallet based on the mnemonic
     */
    getDeviceId(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(typeof data === "string" && data.length > 0))
                throw new Error("Invalid data to hash");
            const digest = yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").digest(engines_1.DigestAlgorithm.SHA256, yield __classPrivateFieldGet(this, _CryptoHelper_engine, "f").digest(engines_1.DigestAlgorithm.SHA512, Buffer.from(data)));
            return utils.fromBufferToB64(digest);
        });
    }
}
_CryptoHelper_engine = new WeakMap();
exports.default = CryptoHelper;
//# sourceMappingURL=CryptoHelper.js.map