"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _NativeHDWalletBase_events, _NativeHDWallet_deviceId, _NativeHDWallet_initialized, _NativeHDWallet_masterKey;
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.info = exports.isNative = exports.NativeHDWallet = exports.NativeHDWalletBase = exports.NativeHDWalletInfoBase = exports.NativeEvents = void 0;
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const bip39 = __importStar(require("bip39"));
const eventemitter2 = __importStar(require("eventemitter2"));
const isObject_1 = __importDefault(require("lodash/isObject"));
const arkeo_1 = require("./arkeo");
const binance_1 = require("./binance");
const bitcoin_1 = require("./bitcoin");
const cosmos_1 = require("./cosmos");
const Isolation = __importStar(require("./crypto/isolation"));
const ethereum_1 = require("./ethereum");
const fio_1 = require("./fio");
const kava_1 = require("./kava");
const networks_1 = require("./networks");
const osmosis_1 = require("./osmosis");
const secret_1 = require("./secret");
const terra_1 = require("./terra");
const thorchain_1 = require("./thorchain");
var NativeEvents;
(function (NativeEvents) {
    NativeEvents["MNEMONIC_REQUIRED"] = "MNEMONIC_REQUIRED";
    NativeEvents["READY"] = "READY";
})(NativeEvents || (exports.NativeEvents = NativeEvents = {}));
function isMnemonicInterface(x) {
    return core.isIndexable(x) && typeof x.toSeed === "function";
}
class NativeHDWalletInfoBase {
    getVendor() {
        return "Native";
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return false;
    }
    hasOnDeviceDisplay() {
        return false;
    }
    hasOnDeviceRecovery() {
        return false;
    }
    hasNativeShapeShift() {
        return false;
    }
    supportsBip44Accounts() {
        return true;
    }
    supportsOfflineSigning() {
        return true;
    }
    supportsBroadcast() {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    describePath(msg) {
        throw new Error("unreachable");
    }
}
exports.NativeHDWalletInfoBase = NativeHDWalletInfoBase;
class NativeHDWalletBase extends NativeHDWalletInfoBase {
    constructor() {
        super();
        _NativeHDWalletBase_events.set(this, void 0);
        __classPrivateFieldSet(this, _NativeHDWalletBase_events, new eventemitter2.EventEmitter2(), "f");
    }
    get events() {
        return __classPrivateFieldGet(this, _NativeHDWalletBase_events, "f");
    }
    /**
     * Wrap a function call that needs a mnemonic seed
     * Raise an event if the wallet hasn't been initialized with a mnemonic seed
     */
    needsMnemonic(hasMnemonic, callback) {
        if (hasMnemonic) {
            return callback();
        }
        __classPrivateFieldGet(this, _NativeHDWalletBase_events, "f").emit(NativeEvents.MNEMONIC_REQUIRED, core.makeEvent({
            message_type: NativeEvents.MNEMONIC_REQUIRED,
            from_wallet: true,
        }));
        return null;
    }
}
exports.NativeHDWalletBase = NativeHDWalletBase;
_NativeHDWalletBase_events = new WeakMap();
class NativeHDWalletInfo extends (0, bitcoin_1.MixinNativeBTCWalletInfo)((0, fio_1.MixinNativeFioWalletInfo)((0, ethereum_1.MixinNativeETHWalletInfo)((0, cosmos_1.MixinNativeCosmosWalletInfo)((0, binance_1.MixinNativeBinanceWalletInfo)((0, thorchain_1.MixinNativeThorchainWalletInfo)((0, secret_1.MixinNativeSecretWalletInfo)((0, terra_1.MixinNativeTerraWalletInfo)((0, kava_1.MixinNativeKavaWalletInfo)((0, arkeo_1.MixinNativeArkeoWalletInfo)((0, osmosis_1.MixinNativeOsmosisWalletInfo)(NativeHDWalletBase))))))))))) {
    describePath(msg) {
        switch (msg.coin.toLowerCase()) {
            case "bitcoin":
            case "bitcoincash":
            case "dash":
            case "digibyte":
            case "dogecoin":
            case "litecoin":
            case "testnet": {
                const unknown = core.unknownUTXOPath(msg.path, msg.coin, msg.scriptType);
                if (!msg.scriptType)
                    return unknown;
                if (!super.btcSupportsCoinSync(msg.coin))
                    return unknown;
                if (!super.btcSupportsScriptTypeSync(msg.coin, msg.scriptType))
                    return unknown;
                return core.describeUTXOPath(msg.path, msg.coin, msg.scriptType);
            }
            case "ethereum":
                return core.describeETHPath(msg.path);
            case "atom":
                return core.cosmosDescribePath(msg.path);
            case "rune":
            case "trune":
            case "thorchain":
                return core.thorchainDescribePath(msg.path);
            case "secret":
            case "scrt":
            case "tscrt":
                return core.secretDescribePath(msg.path);
            case "luna":
            case "terra":
            case "tluna":
                return core.terraDescribePath(msg.path);
            case "kava":
            case "tkava":
                return core.kavaDescribePath(msg.path);
            case "binance":
                return core.binanceDescribePath(msg.path);
            case "osmosis":
            case "osmo":
                return core.osmosisDescribePath(msg.path);
            case "fio":
                return core.fioDescribePath(msg.path);
            case "arkeo":
                return core.arkeoDescribePath(msg.path);
            default:
                throw new Error("Unsupported path");
        }
    }
}
class NativeHDWallet extends (0, bitcoin_1.MixinNativeBTCWallet)((0, fio_1.MixinNativeFioWallet)((0, ethereum_1.MixinNativeETHWallet)((0, cosmos_1.MixinNativeCosmosWallet)((0, binance_1.MixinNativeBinanceWallet)((0, thorchain_1.MixinNativeThorchainWallet)((0, secret_1.MixinNativeSecretWallet)((0, terra_1.MixinNativeTerraWallet)((0, kava_1.MixinNativeKavaWallet)((0, osmosis_1.MixinNativeOsmosisWallet)((0, arkeo_1.MixinNativeArkeoWallet)(NativeHDWalletInfo))))))))))) {
    constructor({ mnemonic, deviceId, masterKey }) {
        super();
        this._supportsBTC = true;
        this._supportsETH = true;
        this._supportsCosmos = true;
        this._supportsEthSwitchChain = false;
        this._supportsAvalanche = true;
        this._supportsOptimism = true;
        this._supportsBSC = true;
        this._supportsPolygon = true;
        this._supportsGnosis = true;
        this._supportsArbitrum = true;
        this._supportsArbitrumNova = true;
        this._supportsOsmosis = true;
        this._supportsBinance = true;
        this._supportsFio = true;
        this._supportsThorchain = true;
        this._supportsSecret = true;
        this._supportsTerra = true;
        this._supportsKava = true;
        this._supportsArkeo = true;
        this._isNative = true;
        _NativeHDWallet_deviceId.set(this, void 0);
        _NativeHDWallet_initialized.set(this, false);
        _NativeHDWallet_masterKey.set(this, undefined);
        if (masterKey) {
            __classPrivateFieldSet(this, _NativeHDWallet_masterKey, Promise.resolve(masterKey), "f");
        }
        else if (mnemonic) {
            __classPrivateFieldSet(this, _NativeHDWallet_masterKey, (() => __awaiter(this, void 0, void 0, function* () {
                const isolatedMnemonic = typeof mnemonic === "string" ? yield Isolation.Engines.Default.BIP39.Mnemonic.create(mnemonic) : mnemonic;
                const seed = yield isolatedMnemonic.toSeed();
                return yield seed.toMasterKey();
            }))(), "f");
        }
        __classPrivateFieldSet(this, _NativeHDWallet_deviceId, deviceId, "f");
    }
    getFeatures() {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    getDeviceID() {
        return __awaiter(this, void 0, void 0, function* () {
            return __classPrivateFieldGet(this, _NativeHDWallet_deviceId, "f");
        });
    }
    getFirmwareVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return "Software";
        });
    }
    getModel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "Native";
        });
    }
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "Native";
        });
    }
    /*
     * @see: https://github.com/satoshilabs/slips/blob/master/slip-0132.md
     * to supports different styles of xpubs as can be defined by passing in a network to `fromSeed`
     */
    getPublicKeys(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.needsMnemonic(!!__classPrivateFieldGet(this, _NativeHDWallet_masterKey, "f"), () => __awaiter(this, void 0, void 0, function* () {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const masterKey = yield __classPrivateFieldGet(this, _NativeHDWallet_masterKey, "f");
                return yield Promise.all(msg.map((getPublicKey) => __awaiter(this, void 0, void 0, function* () {
                    const { addressNList } = getPublicKey;
                    const network = (0, networks_1.getNetwork)(getPublicKey.coin, getPublicKey.scriptType);
                    // TODO: return the xpub that's actually asked for, not the key of the hardened path
                    // It's done this way for hilarious historical reasons and will break ETH if fixed
                    const hardenedPath = core.hardenedPath(addressNList);
                    let node = yield Isolation.Adapters.BIP32.create(masterKey, network);
                    if (hardenedPath.length > 0)
                        node = yield node.derivePath(core.addressNListToBIP32(hardenedPath));
                    const xpub = node.neutered().toBase58();
                    return { xpub };
                })));
            }));
        });
    }
    isInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            return !!__classPrivateFieldGet(this, _NativeHDWallet_initialized, "f");
        });
    }
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    clearSession() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    initialize() {
        const _super = Object.create(null, {
            btcInitializeWallet: { get: () => super.btcInitializeWallet },
            ethInitializeWallet: { get: () => super.ethInitializeWallet },
            cosmosInitializeWallet: { get: () => super.cosmosInitializeWallet },
            osmosisInitializeWallet: { get: () => super.osmosisInitializeWallet },
            binanceInitializeWallet: { get: () => super.binanceInitializeWallet },
            fioInitializeWallet: { get: () => super.fioInitializeWallet },
            thorchainInitializeWallet: { get: () => super.thorchainInitializeWallet },
            secretInitializeWallet: { get: () => super.secretInitializeWallet },
            terraInitializeWallet: { get: () => super.terraInitializeWallet },
            kavaInitializeWallet: { get: () => super.kavaInitializeWallet },
            arkeoInitializeWallet: { get: () => super.arkeoInitializeWallet }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return this.needsMnemonic(!!__classPrivateFieldGet(this, _NativeHDWallet_masterKey, "f"), () => __awaiter(this, void 0, void 0, function* () {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const masterKey = yield __classPrivateFieldGet(this, _NativeHDWallet_masterKey, "f");
                try {
                    yield Promise.all([
                        _super.btcInitializeWallet.call(this, masterKey),
                        _super.ethInitializeWallet.call(this, masterKey),
                        _super.cosmosInitializeWallet.call(this, masterKey),
                        _super.osmosisInitializeWallet.call(this, masterKey),
                        _super.binanceInitializeWallet.call(this, masterKey),
                        _super.fioInitializeWallet.call(this, masterKey),
                        _super.thorchainInitializeWallet.call(this, masterKey),
                        _super.secretInitializeWallet.call(this, masterKey),
                        _super.terraInitializeWallet.call(this, masterKey),
                        _super.kavaInitializeWallet.call(this, masterKey),
                        _super.arkeoInitializeWallet.call(this, masterKey),
                    ]);
                    __classPrivateFieldSet(this, _NativeHDWallet_initialized, true, "f");
                }
                catch (e) {
                    console.error("NativeHDWallet:initialize:error", e);
                    __classPrivateFieldSet(this, _NativeHDWallet_initialized, false, "f");
                    yield this.wipe();
                }
                return __classPrivateFieldGet(this, _NativeHDWallet_initialized, "f");
            }));
        });
    }
    ping(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return { msg: msg.msg };
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    sendPin() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    sendPassphrase() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    sendCharacter() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    sendWord() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    cancel() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    wipe() {
        const _super = Object.create(null, {
            btcWipe: { get: () => super.btcWipe },
            ethWipe: { get: () => super.ethWipe },
            cosmosWipe: { get: () => super.cosmosWipe },
            osmosisWipe: { get: () => super.osmosisWipe },
            binanceWipe: { get: () => super.binanceWipe },
            fioWipe: { get: () => super.fioWipe },
            thorchainWipe: { get: () => super.thorchainWipe },
            secretWipe: { get: () => super.secretWipe },
            terraWipe: { get: () => super.terraWipe },
            kavaWipe: { get: () => super.kavaWipe },
            arkeoWipe: { get: () => super.arkeoWipe }
        });
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const oldMasterKey = __classPrivateFieldGet(this, _NativeHDWallet_masterKey, "f");
            __classPrivateFieldSet(this, _NativeHDWallet_initialized, false, "f");
            __classPrivateFieldSet(this, _NativeHDWallet_masterKey, undefined, "f");
            _super.btcWipe.call(this);
            _super.ethWipe.call(this);
            _super.cosmosWipe.call(this);
            _super.osmosisWipe.call(this);
            _super.binanceWipe.call(this);
            _super.fioWipe.call(this);
            _super.thorchainWipe.call(this);
            _super.secretWipe.call(this);
            _super.terraWipe.call(this);
            _super.kavaWipe.call(this);
            _super.arkeoWipe.call(this);
            (_b = (_a = (yield oldMasterKey)) === null || _a === void 0 ? void 0 : _a.revoke) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    reset() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    recover() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    loadDevice(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _NativeHDWallet_masterKey, Promise.resolve(yield ((mnemonic, masterKey) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (masterKey !== undefined) {
                    return masterKey;
                }
                else if (mnemonic !== undefined) {
                    const isolatedMnemonic = yield (() => __awaiter(this, void 0, void 0, function* () {
                        if (isMnemonicInterface(mnemonic))
                            return mnemonic;
                        if (typeof mnemonic === "string" && bip39.validateMnemonic(mnemonic)) {
                            return yield Isolation.Engines.Default.BIP39.Mnemonic.create(mnemonic);
                        }
                        throw new Error("Required property [mnemonic] is invalid");
                    }))();
                    const seed = yield isolatedMnemonic.toSeed();
                    (_a = seed.addRevoker) === null || _a === void 0 ? void 0 : _a.call(seed, () => { var _a; return (_a = isolatedMnemonic.revoke) === null || _a === void 0 ? void 0 : _a.call(isolatedMnemonic); });
                    const out = yield seed.toMasterKey();
                    (_b = out.addRevoker) === null || _b === void 0 ? void 0 : _b.call(out, () => { var _a; return (_a = seed.revoke) === null || _a === void 0 ? void 0 : _a.call(seed); });
                    return out;
                }
                throw new Error("Either [mnemonic] or [masterKey] is required");
            }))(msg === null || msg === void 0 ? void 0 : msg.mnemonic, msg === null || msg === void 0 ? void 0 : msg.masterKey)), "f");
            if (typeof (msg === null || msg === void 0 ? void 0 : msg.deviceId) === "string")
                __classPrivateFieldSet(this, _NativeHDWallet_deviceId, msg === null || msg === void 0 ? void 0 : msg.deviceId, "f");
            __classPrivateFieldSet(this, _NativeHDWallet_initialized, false, "f");
            yield this.initialize();
            // Once we've been seeded with a mnemonic we re-emit the connected event
            this.events.emit(NativeEvents.READY, core.makeEvent({
                message_type: NativeEvents.READY,
                from_wallet: true,
            }));
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.wipe();
        });
    }
}
exports.NativeHDWallet = NativeHDWallet;
_NativeHDWallet_deviceId = new WeakMap(), _NativeHDWallet_initialized = new WeakMap(), _NativeHDWallet_masterKey = new WeakMap();
function isNative(wallet) {
    return (0, isObject_1.default)(wallet) && wallet._isNative;
}
exports.isNative = isNative;
function info() {
    return new NativeHDWalletInfo();
}
exports.info = info;
function create(args) {
    return new NativeHDWallet(args);
}
exports.create = create;
// This prevents any malicious code from overwriting the prototype
// to potentially steal the mnemonic when calling "loadDevice"
Object.freeze(Object.getPrototypeOf(NativeHDWallet));
//# sourceMappingURL=native.js.map