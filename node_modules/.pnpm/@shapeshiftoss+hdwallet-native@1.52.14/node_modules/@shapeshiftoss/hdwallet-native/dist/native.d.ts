/// <reference types="node" />
import * as core from "@shapeshiftoss/hdwallet-core";
import * as eventemitter2 from "eventemitter2";
import type { NativeAdapterArgs } from "./adapter";
import * as Isolation from "./crypto/isolation";
export declare enum NativeEvents {
    MNEMONIC_REQUIRED = "MNEMONIC_REQUIRED",
    READY = "READY"
}
type LoadDevice = Omit<core.LoadDevice, "mnemonic"> & {
    deviceId?: string;
} & ({
    mnemonic: string | Isolation.Core.BIP39.Mnemonic;
    masterKey?: never;
} | {
    mnemonic?: never;
    masterKey: Isolation.Core.BIP32.Node;
});
export declare class NativeHDWalletInfoBase implements core.HDWalletInfo {
    getVendor(): string;
    hasOnDevicePinEntry(): boolean;
    hasOnDevicePassphrase(): boolean;
    hasOnDeviceDisplay(): boolean;
    hasOnDeviceRecovery(): boolean;
    hasNativeShapeShift(): boolean;
    supportsBip44Accounts(): boolean;
    supportsOfflineSigning(): boolean;
    supportsBroadcast(): boolean;
    describePath(msg: core.DescribePath): core.PathDescription;
}
export declare class NativeHDWalletBase extends NativeHDWalletInfoBase {
    #private;
    constructor();
    get events(): eventemitter2.EventEmitter2;
    /**
     * Wrap a function call that needs a mnemonic seed
     * Raise an event if the wallet hasn't been initialized with a mnemonic seed
     */
    needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
}
declare const NativeHDWalletInfo_base: {
    new (...args: any[]): {
        readonly _supportsBTCInfo: true;
        btcSupportsCoinSync(coin: string): boolean;
        btcSupportsCoin(coin: string): Promise<boolean>;
        btcSupportsScriptTypeSync(coin: string, scriptType?: core.BTCInputScriptType | undefined): boolean;
        btcSupportsScriptType(coin: string, scriptType: core.BTCInputScriptType): Promise<boolean>;
        btcSupportsSecureTransfer(): Promise<boolean>;
        btcSupportsNativeShapeShift(): boolean;
        btcGetAccountPaths(msg: core.BTCGetAccountPaths): core.BTCAccountPath[];
        btcIsSameAccount(msg: core.BTCAccountPath[]): boolean;
        btcNextAccountPath(msg: core.BTCAccountPath): core.BTCAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsFioInfo: true;
        fioSupportsNetwork(): Promise<boolean>;
        fioSupportsSecureTransfer(): Promise<boolean>;
        fioSupportsNativeShapeShift(): boolean;
        fioGetAccountPaths(msg: core.FioGetAccountPaths): core.FioAccountPath[];
        fioNextAccountPath(msg: core.FioAccountPath): core.FioAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsETHInfo: true;
        _chainId: number;
        ethSupportsNetwork(): Promise<boolean>;
        ethSupportsSecureTransfer(): Promise<boolean>;
        ethSupportsNativeShapeShift(): boolean;
        ethSupportsEIP1559(): Promise<boolean>;
        ethGetAccountPaths(msg: core.ETHGetAccountPath): core.ETHAccountPath[];
        ethNextAccountPath(msg: core.ETHAccountPath): core.ETHAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsCosmosInfo: true;
        cosmosSupportsNetwork(): Promise<boolean>;
        cosmosSupportsSecureTransfer(): Promise<boolean>;
        cosmosSupportsNativeShapeShift(): boolean;
        cosmosGetAccountPaths(msg: core.CosmosGetAccountPaths): core.CosmosAccountPath[];
        cosmosNextAccountPath(msg: core.CosmosAccountPath): core.CosmosAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsBinanceInfo: true;
        binanceSupportsNetwork(): Promise<boolean>;
        binanceSupportsSecureTransfer(): Promise<boolean>;
        binanceSupportsNativeShapeShift(): boolean;
        binanceGetAccountPaths(msg: core.BinanceGetAccountPaths): core.BinanceAccountPath[];
        binanceNextAccountPath(msg: core.BinanceAccountPath): core.BinanceAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsThorchainInfo: true;
        thorchainSupportsNetwork(): Promise<boolean>;
        thorchainSupportsSecureTransfer(): Promise<boolean>;
        thorchainSupportsNativeShapeShift(): boolean;
        thorchainGetAccountPaths(msg: core.ThorchainGetAccountPaths): core.ThorchainAccountPath[];
        thorchainNextAccountPath(msg: core.ThorchainAccountPath): core.ThorchainAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsSecretInfo: true;
        secretSupportsNetwork(): Promise<boolean>;
        secretSupportsSecureTransfer(): Promise<boolean>;
        secretSupportsNativeShapeShift(): boolean;
        secretGetAccountPaths(msg: core.SecretGetAccountPaths): core.SecretAccountPath[];
        secretNextAccountPath(msg: core.SecretAccountPath): core.SecretAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsTerraInfo: true;
        terraSupportsNetwork(): Promise<boolean>;
        terraSupportsSecureTransfer(): Promise<boolean>;
        terraSupportsNativeShapeShift(): boolean;
        terraGetAccountPaths(msg: core.TerraGetAccountPaths): core.TerraAccountPath[];
        terraNextAccountPath(msg: core.TerraAccountPath): core.TerraAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsKavaInfo: true;
        kavaSupportsNetwork(): Promise<boolean>;
        kavaSupportsSecureTransfer(): Promise<boolean>;
        kavaSupportsNativeShapeShift(): boolean;
        kavaGetAccountPaths(msg: core.KavaGetAccountPaths): core.KavaAccountPath[];
        kavaNextAccountPath(msg: core.KavaAccountPath): core.KavaAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsArkeoInfo: true;
        arkeoSupportsNetwork(): Promise<boolean>;
        arkeoSupportsSecureTransfer(): Promise<boolean>;
        arkeoSupportsNativeShapeShift(): boolean;
        arkeoGetAccountPaths(msg: core.ArkeoGetAccountPaths): core.ArkeoAccountPath[];
        arkeoNextAccountPath(msg: core.ArkeoAccountPath): core.ArkeoAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsOsmosisInfo: true;
        osmosisSupportsNetwork(): Promise<boolean>;
        osmosisSupportsSecureTransfer(): Promise<boolean>;
        osmosisSupportsNativeShapeShift(): boolean;
        osmosisGetAccountPaths(msg: core.OsmosisGetAccountPaths): core.OsmosisAccountPath[];
        osmosisNextAccountPath(msg: core.OsmosisAccountPath): core.OsmosisAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(srcCoin: string, dstCoin: string): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & typeof NativeHDWalletBase;
declare class NativeHDWalletInfo extends NativeHDWalletInfo_base implements core.HDWalletInfo {
    describePath(msg: core.DescribePath): core.PathDescription;
}
declare const NativeHDWallet_base: {
    new (...args: any[]): {
        readonly _supportsBTC: true;
        "__#13@#masterKey": Isolation.Core.BIP32.Node | undefined;
        btcInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        btcWipe(): void;
        createPayment(pubkey: Buffer, scriptType?: import("./bitcoin").BTCScriptType | undefined, network?: import("@shapeshiftoss/bitcoinjs-lib").Network | undefined): import("@shapeshiftoss/bitcoinjs-lib").Payment;
        validateVoutOrdering(msg: core.BTCSignTxNative, tx: import("@shapeshiftoss/bitcoinjs-lib").Transaction): boolean;
        buildInput(coin: string, input: core.BTCSignTxInputNative): Promise<((Buffer | {
            script: Buffer;
            amount: number;
        }) | {
            redeemScript?: Buffer | undefined;
            witnessScript?: Buffer | undefined;
        } | {
            sighashType?: number | undefined;
        }) | null>;
        btcGetAddress(msg: core.BTCGetAddress): Promise<string | null>;
        btcSignTx(msg: core.BTCSignTxNative): Promise<core.BTCSignedTx | null>;
        btcSignMessage(msg: core.BTCSignMessage): Promise<core.BTCSignedMessage>;
        btcVerifyMessage(msg: core.BTCVerifyMessage): Promise<boolean>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsFio: true;
        baseUrl: string;
        "__#5@#masterKey": Isolation.Core.BIP32.Node | undefined;
        fioInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        fioWipe(): void;
        getFioSdk(addressNList: core.BIP32Path): Promise<import("@shapeshiftoss/fiosdk").FIOSDK | null>;
        fioGetAddress(msg: core.FioGetAddress): Promise<string | null>;
        fioSignTx(msg: core.FioSignTx): Promise<core.FioSignedTx | null>;
        fioEncryptRequestContent<T_1 extends core.Fio.ContentType>(msg: core.FioEncryptRequestContentMsg<T_1>): Promise<string | null>;
        fioDecryptRequestContent<T_2 extends core.Fio.ContentType>(msg: core.FioDecryptRequestContentMsg<T_2>): Promise<core.Fio.Content<T_2> | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsETH: true;
        "__#4@#ethSigner": Isolation.Adapters.Ethereum | undefined;
        ethInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        ethWipe(): void;
        ethGetAddress(msg: core.ETHGetAddress): Promise<string | null>;
        ethSignTx(msg: core.ETHSignTx): Promise<core.ETHSignedTx | null>;
        ethSignMessage(msg: core.ETHSignMessage): Promise<core.ETHSignedMessage | null>;
        ethSignTypedData(msg: core.ETHSignTypedData): Promise<core.ETHSignedTypedData | null>;
        ethVerifyMessage({ address, message, signature }: core.ETHVerifyMessage): Promise<boolean>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsCosmos: true;
        "__#3@#masterKey": Isolation.Core.BIP32.Node | undefined;
        cosmosInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        cosmosWipe(): void;
        cosmosBech32ify(address: ArrayLike<number>, prefix: string): string;
        createCosmosAddress(publicKey: string): string;
        cosmosGetAddress(msg: core.CosmosGetAddress): Promise<string | null>;
        cosmosSignTx(msg: core.CosmosSignTx): Promise<core.CosmosSignedTx | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsBinance: true;
        "__#2@#masterKey": Isolation.Core.BIP32.Node | undefined;
        binanceInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        binanceWipe(): void;
        binanceBech32ify(address: ArrayLike<number>, prefix: string): string;
        createBinanceAddress(publicKey: string, testnet?: boolean | undefined): string;
        binanceGetAddress(msg: core.BinanceGetAddress & {
            testnet?: boolean | undefined;
        }): Promise<string | null>;
        binanceSignTx(msg: core.BinanceSignTx & {
            testnet?: boolean | undefined;
        }): Promise<core.BinanceSignedTx | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsThorchain: true;
        "__#10@#masterKey": Isolation.Core.BIP32.Node | undefined;
        thorchainInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        thorchainWipe(): void;
        thorchainBech32ify(address: ArrayLike<number>, prefix: string): string;
        createThorchainAddress(publicKey: string): string;
        thorchainGetAddress(msg: core.ThorchainGetAddress): Promise<string | null>;
        thorchainSignTx(msg: core.ThorchainSignTx): Promise<core.ThorchainSignedTx | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsSecret: true;
        "__#8@#masterKey": Isolation.Core.BIP32.Node | undefined;
        secretInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        secretWipe(): void;
        secretBech32ify(address: ArrayLike<number>, prefix: string): string;
        createSecretAddress(publicKey: string): string;
        secretGetAddress(msg: core.SecretGetAddress): Promise<string | null>;
        secretSignTx(msg: core.SecretSignTx): Promise<any>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsTerra: true;
        "__#9@#masterKey": Isolation.Core.BIP32.Node | undefined;
        terraInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        terraWipe(): void;
        terraBech32ify(address: ArrayLike<number>, prefix: string): string;
        createTerraAddress(publicKey: string): string;
        terraGetAddress(msg: core.TerraGetAddress): Promise<string | null>;
        terraSignTx(msg: core.TerraSignTx): Promise<any>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsKava: true;
        "__#6@#masterKey": Isolation.Core.BIP32.Node | undefined;
        kavaInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        kavaWipe(): void;
        kavaBech32ify(address: ArrayLike<number>, prefix: string): string;
        createKavaAddress(publicKey: string): string;
        kavaGetAddress(msg: core.KavaGetAddress): Promise<string | null>;
        kavaSignTx(msg: core.KavaSignTx): Promise<core.KavaTx | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsOsmosis: true;
        "__#7@#masterKey": Isolation.Core.BIP32.Node | undefined;
        osmosisInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        osmosisWipe(): void;
        osmosisBech32ify(address: ArrayLike<number>, prefix: string): string;
        createOsmosisAddress(publicKey: string): string;
        osmosisGetAddress(msg: core.OsmosisGetAddress): Promise<string | null>;
        osmosisSignTx(msg: core.OsmosisSignTx): Promise<core.CosmosSignedTx | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsArkeo: true;
        "__#1@#masterKey": Isolation.Core.BIP32.Node | undefined;
        arkeoInitializeWallet(masterKey: Isolation.Core.BIP32.Node): Promise<void>;
        arkeoWipe(): void;
        arkeoBech32ify(address: ArrayLike<number>, prefix: string): string;
        createArkeoAddress(publicKey: string): string;
        arkeoGetAddress(msg: core.ArkeoGetAddress): Promise<string | null>;
        arkeoSignTx(msg: core.ArkeoSignTx): Promise<core.CosmosSignedTx | null>;
        readonly "__#11@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        hasNativeShapeShift(): boolean;
        supportsBip44Accounts(): boolean;
        supportsOfflineSigning(): boolean;
        supportsBroadcast(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & typeof NativeHDWalletInfo;
export declare class NativeHDWallet extends NativeHDWallet_base implements core.HDWallet, core.BTCWallet, core.ETHWallet, core.CosmosWallet, core.OsmosisWallet, core.FioWallet, core.ThorchainWallet, core.SecretWallet, core.TerraWallet, core.KavaWallet, core.ArkeoWallet {
    #private;
    readonly _supportsBTC = true;
    readonly _supportsETH = true;
    readonly _supportsCosmos = true;
    readonly _supportsEthSwitchChain = false;
    readonly _supportsAvalanche = true;
    readonly _supportsOptimism = true;
    readonly _supportsBSC = true;
    readonly _supportsPolygon = true;
    readonly _supportsGnosis = true;
    readonly _supportsArbitrum = true;
    readonly _supportsArbitrumNova = true;
    readonly _supportsOsmosis = true;
    readonly _supportsBinance = true;
    readonly _supportsFio = true;
    readonly _supportsThorchain = true;
    readonly _supportsSecret = true;
    readonly _supportsTerra = true;
    readonly _supportsKava = true;
    readonly _supportsArkeo = true;
    readonly _isNative = true;
    constructor({ mnemonic, deviceId, masterKey }: NativeAdapterArgs);
    getFeatures(): Promise<Record<string, any>>;
    getDeviceID(): Promise<string>;
    getFirmwareVersion(): Promise<string>;
    getModel(): Promise<string>;
    getLabel(): Promise<string>;
    getPublicKeys(msg: Array<core.GetPublicKey>): Promise<core.PublicKey[] | null>;
    isInitialized(): Promise<boolean>;
    isLocked(): Promise<boolean>;
    clearSession(): Promise<void>;
    initialize(): Promise<boolean | null>;
    ping(msg: core.Ping): Promise<core.Pong>;
    sendPin(): Promise<void>;
    sendPassphrase(): Promise<void>;
    sendCharacter(): Promise<void>;
    sendWord(): Promise<void>;
    cancel(): Promise<void>;
    wipe(): Promise<void>;
    reset(): Promise<void>;
    recover(): Promise<void>;
    loadDevice(msg?: LoadDevice): Promise<void>;
    disconnect(): Promise<void>;
}
export declare function isNative(wallet: core.HDWallet): wallet is NativeHDWallet;
export declare function info(): NativeHDWalletInfo;
export declare function create(args: NativeAdapterArgs): NativeHDWallet;
export {};
//# sourceMappingURL=native.d.ts.map