import { BigNumber } from "bignumber.js";
import type { Observable } from "rxjs";
import type { CryptoCurrency } from "@ledgerhq/types-cryptoassets";
import type { AccountLike, Account, AccountRaw } from "./account";
import type { SignOperationEvent, SignedOperation, TransactionCommon, TransactionStatusCommon } from "./transaction";
import type { Operation } from "./operation";
import type { DerivationMode } from "./derivation";
import type { SyncConfig } from "./pagination";
import { CryptoCurrencyIds, NFTCollectionMetadata, NFTCollectionMetadataResponse, NFTMetadata, NFTMetadataResponse } from "./nft";
export type ScanAccountEvent = {
    type: "discovered";
    account: Account;
};
/**
 * More events will come in the future
 */
export type ScanAccountEventRaw = {
    type: "discovered";
    account: AccountRaw;
};
/**
 * Unique identifier of a device. It will depend on the underlying implementation.
 */
export type DeviceId = string;
/**
 *
 */
export type PreloadStrategy = Partial<{
    preloadMaxAge: number;
}>;
/**
 *
 */
export type BroadcastArg0 = {
    account: Account;
    signedOperation: SignedOperation;
};
/**
 *
 */
export type SignOperationArg0<T> = {
    account: Account;
    transaction: T;
    deviceId: DeviceId;
};
/**
 *
 */
export type SignOperationFnSignature<T> = (arg0: SignOperationArg0<T>) => Observable<SignOperationEvent>;
export type BroadcastFnSignature = (arg0: BroadcastArg0) => Promise<Operation>;
export type Bridge<T extends TransactionCommon> = {
    currencyBridge: CurrencyBridge;
    accountBridge: AccountBridge<T>;
};
export type ScanInfo = {
    currency: CryptoCurrency;
    deviceId: DeviceId;
    scheme?: DerivationMode | null | undefined;
    syncConfig: SyncConfig;
    preferredNewAccountScheme?: DerivationMode;
};
/**
 * Abstraction related to a currency
 */
export interface CurrencyBridge {
    preload(currency: CryptoCurrency): Promise<Record<string, any>>;
    hydrate(data: unknown, currency: CryptoCurrency): void;
    scanAccounts(info: ScanInfo): Observable<ScanAccountEvent>;
    getPreloadStrategy?: (currency: CryptoCurrency) => PreloadStrategy;
    nftResolvers?: {
        nftMetadata: (arg: {
            contract: string;
            tokenId: string;
            currencyId: string;
            metadata?: NFTMetadata;
        }) => Promise<NFTMetadataResponse>;
        collectionMetadata: (arg: {
            contract: string;
            currencyId: string;
            metadata?: NFTCollectionMetadata;
        }) => Promise<NFTCollectionMetadataResponse>;
    };
}
/**
 * Abstraction related to an account
 */
export interface AccountBridge<T extends TransactionCommon> {
    sync(initialAccount: Account, syncConfig: SyncConfig): Observable<(arg0: Account) => Account>;
    receive(account: Account, arg1: {
        verify?: boolean;
        deviceId: string;
        subAccountId?: string;
        freshAddressIndex?: number;
    }): Observable<{
        address: string;
        path: string;
    }>;
    createTransaction(account: AccountLike): T;
    updateTransaction(t: T, patch: Partial<T>): T;
    prepareTransaction(account: Account, transaction: T): Promise<T>;
    getTransactionStatus(account: Account, transaction: T): Promise<TransactionStatusCommon>;
    estimateMaxSpendable(arg0: {
        account: AccountLike;
        parentAccount?: Account | null | undefined;
        transaction?: T | null | undefined;
    }): Promise<BigNumber>;
    /**
     * This function mutates the 'accountRaw' object in-place to add any extra fields that the coin may need to set.
     * It is called during the serialization mechanism, for instance bitcoinResources need to be serialized.
     *
     * @param {Account} account - The original account object.
     * @param {AccountRaw} accountRaw - The account in its serialized form.
     */
    assignToAccountRaw?: (account: Account, accountRaw: AccountRaw) => void;
    /**
     * This function mutates the 'account' object in-place to add any extra fields that the coin may need to set.
     * It is called during the deserialization mechanism, for instance bitcoinResources need to be deserialized.
     *
     * @param {AccountRaw} accountRaw - The account in its serialized form.
     * @param {Account} account - The original account object.
     */
    assignFromAccountRaw?: (accountRaw: AccountRaw, account: Account) => void;
    /**
     * This function mutates the 'account' object to extend it with any extra fields of the coin.
     * For instance bitcoinResources needs to be created.
     *
     * @param {Account} account - The original account object to mutates in-place.
     */
    initAccount?: (account: Account) => void;
    signOperation: SignOperationFnSignature<T>;
    broadcast: BroadcastFnSignature;
}
type ExpectFn = (...args: Array<any>) => any;
type CurrencyTransaction<T extends TransactionCommon> = {
    name: string;
    transaction: T | ((transaction: T, account: Account, accountBridge: AccountBridge<T>) => T);
    expectedStatus?: Partial<TransactionStatusCommon> | ((account: Account, transaction: T, status: TransactionStatusCommon) => Partial<TransactionStatusCommon>);
    test?: (arg0: ExpectFn, arg1: T, arg2: TransactionStatusCommon, arg3: AccountBridge<T>) => any;
    apdus?: string;
    testSignedOperation?: (arg0: ExpectFn, arg1: SignedOperation, arg2: Account, arg3: T, arg4: TransactionStatusCommon, arg5: AccountBridge<T>) => any;
};
/**
 *
 */
export type CurrenciesData<T extends TransactionCommon> = {
    FIXME_ignoreAccountFields?: string[];
    FIXME_ignoreOperationFields?: string[];
    FIXME_ignorePreloadFields?: string[];
    IgnorePrepareTransactionFields?: string[];
    mockDeviceOptions?: any;
    scanAccounts?: Array<{
        name: string;
        apdus: string;
        unstableAccounts?: boolean;
        test?: (expect: ExpectFn, scanned: Account[], bridge: CurrencyBridge) => any;
    }>;
    accounts?: Array<{
        implementations?: string[];
        raw: AccountRaw;
        FIXME_tests?: Array<string | RegExp>;
        transactions?: Array<CurrencyTransaction<T>>;
        test?: (arg0: ExpectFn, arg1: Account, arg2: AccountBridge<T>) => any;
    }>;
    test?: (arg0: ExpectFn, arg1: CurrencyBridge) => any;
};
/**
 *
 */
export type DatasetTest<T extends TransactionCommon> = {
    implementations: string[];
    currencies: Record<CryptoCurrencyIds, CurrenciesData<T>> | Record<string, never>;
};
export {};
//# sourceMappingURL=bridge.d.ts.map