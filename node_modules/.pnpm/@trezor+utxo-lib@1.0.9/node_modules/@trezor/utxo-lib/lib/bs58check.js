"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeAddress = exports.decodeAddress = exports.decode = exports.encode = exports.encodeBlake256 = exports.decodeBlake256 = exports.decodeBlake256Key = exports.decodeBlake = void 0;
const networks_1 = require("./networks");
const bchaddrjs = require("bchaddrjs");
const bs58 = require("bs58");
const bs58check = require("bs58check");
const crypto_1 = require("./crypto");
function decodeBlake(buffer) {
    const want = buffer.slice(-4);
    const payload = buffer.slice(0, -4);
    const got = (0, crypto_1.blake256)((0, crypto_1.blake256)(payload)).slice(0, 4);
    if ((want[0] ^ got[0]) | (want[1] ^ got[1]) | (want[2] ^ got[2]) | (want[3] ^ got[3]))
        throw new Error('invalid checksum');
    return payload;
}
exports.decodeBlake = decodeBlake;
function decodeBlake256Key(key) {
    const bytes = bs58.decode(key);
    const buffer = Buffer.from(bytes);
    return decodeBlake(buffer);
}
exports.decodeBlake256Key = decodeBlake256Key;
function decodeBlake256(address) {
    const bytes = bs58.decode(address);
    const buffer = Buffer.from(bytes);
    if (buffer.length !== 26)
        throw new Error(`${address} invalid address length`);
    let payload;
    try {
        payload = decodeBlake(buffer);
    }
    catch (e) {
        if (e instanceof Error) {
            throw new Error(`${address} ${e.message}`);
        }
        throw new Error(`${address} ${e}`);
    }
    return payload;
}
exports.decodeBlake256 = decodeBlake256;
function encodeBlake256(payload) {
    const checksum = (0, crypto_1.blake256)((0, crypto_1.blake256)(payload)).slice(0, 4);
    return bs58.encode(Buffer.concat([payload, checksum]));
}
exports.encodeBlake256 = encodeBlake256;
function encode(payload, network = networks_1.bitcoin) {
    return (0, networks_1.isNetworkType)('decred', network) ? encodeBlake256(payload) : bs58check.encode(payload);
}
exports.encode = encode;
function decode(payload, network = networks_1.bitcoin) {
    return (0, networks_1.isNetworkType)('decred', network) ? decodeBlake256(payload) : bs58check.decode(payload);
}
exports.decode = decode;
function decodeAddress(address, network = networks_1.bitcoin) {
    let payload;
    if ((0, networks_1.isNetworkType)('bitcoinCash', network)) {
        if (!bchaddrjs.isCashAddress(address))
            throw Error(`${address} is not a cash address`);
        payload = Buffer.from(bs58check.decode(bchaddrjs.toLegacyAddress(address)));
    }
    else {
        payload = Buffer.from(decode(address, network));
    }
    if (payload.length < 21)
        throw new TypeError(`${address} is too short`);
    if (payload.length > 22)
        throw new TypeError(`${address} is too long`);
    const multibyte = payload.length === 22;
    const offset = multibyte ? 2 : 1;
    const version = multibyte ? payload.readUInt16BE(0) : payload[0];
    const hash = payload.slice(offset);
    return { version, hash };
}
exports.decodeAddress = decodeAddress;
function encodeAddress(hash, version, network = networks_1.bitcoin) {
    const multibyte = version > 0xff;
    const size = multibyte ? 22 : 21;
    const offset = multibyte ? 2 : 1;
    const payload = Buffer.allocUnsafe(size);
    if (multibyte) {
        payload.writeUInt16BE(version, 0);
    }
    else {
        payload.writeUInt8(version, 0);
    }
    hash.copy(payload, offset);
    const encoded = encode(payload, network);
    return (0, networks_1.isNetworkType)('bitcoinCash', network) ? bchaddrjs.toCashAddress(encoded) : encoded;
}
exports.encodeAddress = encodeAddress;
//# sourceMappingURL=bs58check.js.map