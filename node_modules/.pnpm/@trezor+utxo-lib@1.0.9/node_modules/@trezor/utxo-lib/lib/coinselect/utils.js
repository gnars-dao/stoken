"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterCoinbase = exports.sortByScore = exports.utxoScore = exports.anyOf = exports.finalize = exports.getFee = exports.sumOrNaN = exports.bignumberOrNaN = exports.dustThreshold = exports.transactionBytes = exports.transactionWeight = exports.getFeeForBytes = exports.outputBytes = exports.outputWeight = exports.inputBytes = exports.inputWeight = exports.getVarIntSize = exports.OUTPUT_SCRIPT_LENGTH = exports.INPUT_SCRIPT_LENGTH = exports.ZERO = void 0;
const BN = require("bn.js");
exports.ZERO = new BN(0);
exports.INPUT_SCRIPT_LENGTH = {
    p2pkh: 108,
    p2sh: 107,
    p2tr: 65,
    p2wpkh: 107,
    p2wsh: 107,
};
exports.OUTPUT_SCRIPT_LENGTH = {
    p2pkh: 25,
    p2sh: 23,
    p2tr: 34,
    p2wpkh: 22,
    p2wsh: 34,
};
const SEGWIT_INPUT_SCRIPT_TYPES = ['p2sh', 'p2tr', 'p2wpkh', 'p2wsh'];
const TX_BASE = 32;
const INPUT_SIZE = 160;
function getVarIntSize(length) {
    if (length < 253)
        return 1;
    if (length < 65536)
        return 3;
    if (length < 4294967296)
        return 5;
    return 9;
}
exports.getVarIntSize = getVarIntSize;
function inputWeight(input) {
    if (input.weight)
        return input.weight;
    let weight = INPUT_SIZE;
    if (!SEGWIT_INPUT_SCRIPT_TYPES.includes(input.type)) {
        weight += 4 * input.script.length;
    }
    else {
        if (input.type === 'p2sh') {
            weight += 4 * (2 + 22);
        }
        else {
            weight += 4;
        }
        weight += 1 + input.script.length;
    }
    return weight;
}
exports.inputWeight = inputWeight;
function inputBytes(input) {
    return Math.ceil(inputWeight(input) / 4);
}
exports.inputBytes = inputBytes;
function outputWeight(output) {
    if (output.weight)
        return output.weight;
    return 4 * (8 + 1 + output.script.length);
}
exports.outputWeight = outputWeight;
function outputBytes(output) {
    return Math.ceil(outputWeight(output) / 4);
}
exports.outputBytes = outputBytes;
function getFeeForBytes(feeRate, bytes) {
    return Math.ceil(feeRate * bytes);
}
exports.getFeeForBytes = getFeeForBytes;
function transactionWeight(inputs, outputs) {
    const segwitInputs = inputs.filter(i => SEGWIT_INPUT_SCRIPT_TYPES.includes(i.type)).length;
    return (TX_BASE +
        4 * getVarIntSize(inputs.length) +
        inputs.reduce((x, i) => x + inputWeight(i), 0) +
        4 * getVarIntSize(outputs.length) +
        outputs.reduce((x, o) => x + outputWeight(o), 0) +
        (segwitInputs ? 2 + (inputs.length - segwitInputs) : 0));
}
exports.transactionWeight = transactionWeight;
function transactionBytes(inputs, outputs) {
    return Math.ceil(transactionWeight(inputs, outputs) / 4);
}
exports.transactionBytes = transactionBytes;
function dustThreshold(feeRate, options) {
    const size = transactionBytes([
        {
            type: options.txType,
            script: {
                length: exports.INPUT_SCRIPT_LENGTH[options.txType],
            },
        },
    ], [
        {
            script: {
                length: exports.OUTPUT_SCRIPT_LENGTH[options.txType],
            },
        },
    ]);
    const price = getFeeForBytes(feeRate, size);
    return Math.max(options.dustThreshold, price);
}
exports.dustThreshold = dustThreshold;
function bignumberOrNaN(v, forgiving = false) {
    if (BN.isBN(v))
        return v;
    const defaultValue = forgiving ? exports.ZERO : undefined;
    if (!v || typeof v !== 'string' || !/^\d+$/.test(v))
        return defaultValue;
    try {
        return new BN(v);
    }
    catch (error) {
        return defaultValue;
    }
}
exports.bignumberOrNaN = bignumberOrNaN;
function sumOrNaN(range, forgiving = false) {
    return range.reduce((a, x) => {
        if (!a)
            return a;
        const value = bignumberOrNaN(x.value);
        if (!value)
            return forgiving ? exports.ZERO.add(a) : undefined;
        return value.add(a);
    }, exports.ZERO);
}
exports.sumOrNaN = sumOrNaN;
function getFee(feeRate, bytes, options, outputs) {
    const defaultFee = getFeeForBytes(feeRate, bytes);
    let baseFee = options.baseFee || 0;
    if (baseFee && bytes) {
        if (options.floorBaseFee) {
            baseFee *= Math.floor((baseFee + defaultFee) / baseFee);
        }
        else {
            baseFee += defaultFee;
        }
    }
    if (options.dustOutputFee && options.dustThreshold) {
        for (let i = 0; i < outputs.length; i++) {
            const { value } = outputs[i];
            if (value && new BN(value).sub(new BN(options.dustThreshold)).isNeg()) {
                baseFee += options.dustOutputFee;
            }
        }
    }
    return baseFee || defaultFee;
}
exports.getFee = getFee;
function finalize(inputs, outputs, feeRate, options) {
    const bytesAccum = transactionBytes(inputs, outputs);
    const blankOutputBytes = outputBytes({
        script: { length: exports.OUTPUT_SCRIPT_LENGTH[options.txType] },
    });
    const fee = getFee(feeRate, bytesAccum, options, outputs);
    const feeAfterExtraOutput = getFee(feeRate, bytesAccum + blankOutputBytes, options, outputs);
    const sumInputs = sumOrNaN(inputs);
    const sumOutputs = sumOrNaN(outputs);
    if (!sumInputs || !sumOutputs || sumInputs.sub(sumOutputs).lt(new BN(fee))) {
        return { fee };
    }
    const remainderAfterExtraOutput = sumInputs.sub(sumOutputs.add(new BN(feeAfterExtraOutput)));
    const dust = dustThreshold(feeRate, options);
    const finalOutputs = outputs.map(o => Object.assign({}, o, {
        value: o.value,
    }));
    if (remainderAfterExtraOutput.gt(new BN(dust))) {
        finalOutputs.push({
            value: remainderAfterExtraOutput.toString(),
            script: {
                length: exports.OUTPUT_SCRIPT_LENGTH[options.txType],
            },
        });
    }
    return {
        inputs,
        outputs: finalOutputs,
        fee: sumInputs.sub(sumOrNaN(finalOutputs, true)).toNumber(),
    };
}
exports.finalize = finalize;
function anyOf(algorithms) {
    return (utxos, outputs, feeRate, options) => {
        let result = { fee: 0 };
        for (let i = 0; i < algorithms.length; i++) {
            const algorithm = algorithms[i];
            result = algorithm(utxos, outputs, feeRate, options);
            if (result.inputs) {
                return result;
            }
        }
        return result;
    };
}
exports.anyOf = anyOf;
function utxoScore(x, feeRate) {
    return new BN(x.value).sub(new BN(getFeeForBytes(feeRate, inputBytes(x))));
}
exports.utxoScore = utxoScore;
function sortByScore(feeRate) {
    return (a, b) => {
        const difference = utxoScore(a, feeRate).sub(utxoScore(b, feeRate));
        if (difference.eq(exports.ZERO)) {
            return a.i - b.i;
        }
        return difference.isNeg() ? 1 : -1;
    };
}
exports.sortByScore = sortByScore;
function filterCoinbase(utxos, minConfCoinbase) {
    return utxos.filter(utxo => {
        if (utxo.coinbase && !utxo.required) {
            return utxo.confirmations >= minConfCoinbase;
        }
        return true;
    });
}
exports.filterCoinbase = filterCoinbase;
//# sourceMappingURL=utils.js.map