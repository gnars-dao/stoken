"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFeeRate = exports.convertOutputs = exports.getScriptFromAddress = exports.convertInputs = void 0;
const BitcoinJsAddress = require("../address");
const utils_1 = require("../coinselect/utils");
function convertInputs(inputs, height = 0, txType) {
    return inputs
        .map((input, i) => ({
        type: txType,
        i,
        script: { length: utils_1.INPUT_SCRIPT_LENGTH[txType] },
        value: input.value,
        own: input.own,
        coinbase: input.coinbase,
        confirmations: input.height == null ? 0 : 1 + height - input.height,
        required: input.required,
    }))
        .map(input => Object.assign(input, { weight: (0, utils_1.inputWeight)(input) }));
}
exports.convertInputs = convertInputs;
function getScriptFromAddress(address, network) {
    return {
        length: BitcoinJsAddress.toOutputScript(address, network).length,
    };
}
exports.getScriptFromAddress = getScriptFromAddress;
function convertOutputs(outputs, network, txType) {
    const script = { length: utils_1.OUTPUT_SCRIPT_LENGTH[txType] };
    return outputs
        .map(output => {
        if (output.type === 'complete') {
            return {
                value: output.amount,
                script: getScriptFromAddress(output.address, network),
            };
        }
        if (output.type === 'noaddress') {
            return {
                value: output.amount,
                script,
            };
        }
        if (output.type === 'opreturn') {
            return {
                value: '0',
                script: { length: 2 + output.dataHex.length / 2 },
            };
        }
        if (output.type === 'send-max') {
            return {
                script: getScriptFromAddress(output.address, network),
            };
        }
        if (output.type === 'send-max-noaddress') {
            return {
                script,
            };
        }
        throw new Error('WRONG-OUTPUT-TYPE');
    })
        .map(output => Object.assign(output, { weight: (0, utils_1.outputWeight)(output) }));
}
exports.convertOutputs = convertOutputs;
function convertFeeRate(rate) {
    const feeRate = typeof rate === 'string' ? Number(rate) : rate;
    if (Number.isNaN(feeRate) ||
        !Number.isFinite(feeRate) ||
        feeRate > Number.MAX_SAFE_INTEGER ||
        feeRate <= 0) {
        return;
    }
    return feeRate;
}
exports.convertFeeRate = convertFeeRate;
//# sourceMappingURL=utils.js.map