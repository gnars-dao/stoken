"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransaction = void 0;
const BN = require("bn.js");
const BitcoinJsAddress = require("../address");
const embed_1 = require("../payments/embed");
const permutation_1 = require("./permutation");
const bufferutils_1 = require("../bufferutils");
function convertInput(utxo, basePath) {
    return {
        hash: (0, bufferutils_1.reverseBuffer)(Buffer.from(utxo.transactionHash, 'hex')),
        index: utxo.index,
        path: basePath.concat([...utxo.addressPath]),
        amount: utxo.value,
    };
}
function convertOpReturnOutput(opReturnData) {
    const opReturnDataBuffer = Buffer.from(opReturnData, 'hex');
    const output = {
        opReturnData: opReturnDataBuffer,
        value: undefined,
    };
    const script = (0, embed_1.p2data)({ data: [opReturnDataBuffer] }).output;
    return {
        output,
        script,
    };
}
function convertOutput(address, value, network, basePath, changeId, isChange) {
    const output = isChange
        ? {
            path: [...basePath, 1, changeId],
            value,
        }
        : {
            address,
            value,
        };
    return {
        output,
        script: BitcoinJsAddress.toOutputScript(address, network),
    };
}
function inputComparator(aHash, aVout, bHash, bVout) {
    return (0, bufferutils_1.reverseBuffer)(aHash).compare((0, bufferutils_1.reverseBuffer)(bHash)) || aVout - bVout;
}
function outputComparator(aScript, aValue, bScript, bValue) {
    return new BN(aValue).cmp(new BN(bValue)) || aScript.compare(bScript);
}
function createTransaction(allInputs, selectedInputs, allOutputs, selectedOutputs, basePath, changeId, changeAddress, network, skipPermutation) {
    const convertedInputs = selectedInputs.map(input => convertInput(allInputs[input.i], basePath));
    const convertedOutputs = selectedOutputs.map((output, i) => {
        const isChange = i === allOutputs.length;
        const original = allOutputs[i];
        if (original && original.type === 'opreturn') {
            return convertOpReturnOutput(original.dataHex);
        }
        const address = !original ? changeAddress : original.address;
        const amount = output.value;
        return convertOutput(address, amount, network, basePath, changeId, isChange);
    });
    if (skipPermutation) {
        return {
            inputs: convertedInputs,
            outputs: new permutation_1.Permutation(convertedOutputs.map(o => o.output), convertedOutputs.map((_o, i) => i)),
        };
    }
    convertedInputs.sort((a, b) => inputComparator(a.hash, a.index, b.hash, b.index));
    const permutedOutputs = permutation_1.Permutation.fromFunction(convertedOutputs, (a, b) => {
        const aValue = typeof a.output.value === 'string' ? a.output.value : '0';
        const bValue = typeof b.output.value === 'string' ? b.output.value : '0';
        return outputComparator(a.script, aValue, b.script, bValue);
    }).map(o => o.output);
    return {
        inputs: convertedInputs,
        outputs: permutedOutputs,
    };
}
exports.createTransaction = createTransaction;
//# sourceMappingURL=transaction.js.map