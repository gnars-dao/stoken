"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coinselect = void 0;
const BN = require("bn.js");
const split_1 = require("../coinselect/outputs/split");
const coinselect_1 = require("../coinselect");
const utils_1 = require("../coinselect/utils");
const utils = require("./utils");
function coinselect(txType, utxos, rOutputs, height, feeRate, countMax, countMaxId, dustThreshold, network, baseFee, floorBaseFee, dustOutputFee, skipPermutation) {
    const inputs0 = utils.convertInputs(utxos, height, txType);
    const outputs0 = utils.convertOutputs(rOutputs, network, txType);
    const options = {
        txType,
        dustThreshold,
        baseFee,
        floorBaseFee,
        dustOutputFee,
        skipPermutation,
    };
    const algorithm = countMax ? split_1.split : coinselect_1.coinselect;
    const result = algorithm(inputs0, outputs0, feeRate, options);
    if (!result.inputs || !result.outputs) {
        return {
            type: 'false',
        };
    }
    const { fee, inputs, outputs } = result;
    const max = countMaxId !== -1 ? outputs[countMaxId].value : undefined;
    const totalSpent = outputs
        .filter((_output, i) => i !== rOutputs.length)
        .map(o => o.value)
        .reduce((a, b) => a.add(new BN(b)), new BN(0))
        .add(new BN(fee))
        .toString();
    const bytes = (0, utils_1.transactionBytes)(inputs, outputs);
    const feePerByte = fee / bytes;
    return {
        type: 'true',
        result: {
            inputs,
            outputs,
            fee,
            feePerByte,
            bytes,
            max,
            totalSpent,
        },
    };
}
exports.coinselect = coinselect;
//# sourceMappingURL=coinselect.js.map