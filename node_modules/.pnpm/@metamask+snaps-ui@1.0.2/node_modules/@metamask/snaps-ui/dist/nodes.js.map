{"version":3,"file":"nodes.js","sourceRoot":"","sources":["../src/nodes.ts"],"names":[],"mappings":";;;AAAA,6CAaqB;AAErB,MAAM,UAAU,GAAG,IAAA,oBAAM,EAAC;IACxB,IAAI,EAAE,IAAA,oBAAM,GAAE;CACf,CAAC,CAAC;AASH,MAAM,YAAY,GAAG,IAAA,oBAAM,EACzB,UAAU,EACV,IAAA,oBAAM,EAAC;IACL,sEAAsE;IACtE,mEAAmE;IACnE,QAAQ,EAAE,IAAA,mBAAK,EAAC,IAAA,kBAAI,EAAC,GAAG,EAAE,CAAC,uBAAe,CAAC,CAAC;CAC7C,CAAC,CACH,CAAC;AAUF,MAAM,aAAa,GAAG,IAAA,oBAAM,EAC1B,UAAU,EACV,IAAA,oBAAM,EAAC;IACL,KAAK,EAAE,IAAA,qBAAO,GAAE;CACjB,CAAC,CACH,CAAC;AAUF,IAAY,QAOX;AAPD,WAAY,QAAQ;IAClB,iCAAqB,CAAA;IACrB,+BAAmB,CAAA;IACnB,+BAAmB,CAAA;IACnB,2BAAe,CAAA;IACf,+BAAmB,CAAA;IACnB,yBAAa,CAAA;AACf,CAAC,EAPW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAOnB;AAEY,QAAA,cAAc,GAAG,IAAA,oBAAM,EAClC,aAAa,EACb,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,IAAA,qBAAO,EAAC,QAAQ,CAAC,QAAQ,CAAC;IAChC,KAAK,EAAE,IAAA,oBAAM,GAAE;CAChB,CAAC,CACH,CAAC;AAUW,QAAA,aAAa,GAAG,IAAA,oBAAM,EACjC,UAAU,EACV,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,IAAA,qBAAO,EAAC,QAAQ,CAAC,OAAO,CAAC;CAChC,CAAC,CACH,CAAC;AAOW,QAAA,aAAa,GAAG,IAAA,oBAAM,EACjC,aAAa,EACb,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,IAAA,qBAAO,EAAC,QAAQ,CAAC,OAAO,CAAC;IAC/B,KAAK,EAAE,IAAA,oBAAM,GAAE;CAChB,CAAC,CACH,CAAC;AAYW,QAAA,WAAW,GAAkB,IAAA,oBAAM,EAC9C,YAAY,EACZ,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,IAAA,qBAAO,EAAC,QAAQ,CAAC,KAAK,CAAC;CAC9B,CAAC,CACH,CAAC;AAYW,QAAA,aAAa,GAAG,IAAA,oBAAM,EACjC,UAAU,EACV,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,IAAA,qBAAO,EAAC,QAAQ,CAAC,OAAO,CAAC;CAChC,CAAC,CACH,CAAC;AAQW,QAAA,UAAU,GAAG,IAAA,oBAAM,EAC9B,aAAa,EACb,IAAA,oBAAM,EAAC;IACL,IAAI,EAAE,IAAA,qBAAO,EAAC,QAAQ,CAAC,IAAI,CAAC;IAC5B,KAAK,EAAE,IAAA,oBAAM,GAAE;IACf,QAAQ,EAAE,IAAA,sBAAQ,EAAC,IAAA,qBAAO,GAAE,CAAC;CAC9B,CAAC,CACH,CAAC;AAaW,QAAA,eAAe,GAAG,IAAA,mBAAK,EAAC;IACnC,sBAAc;IACd,qBAAa;IACb,qBAAa;IACb,mBAAW;IACX,qBAAa;IACb,kBAAU;CACX,CAAC,CAAC","sourcesContent":["import {\n  array,\n  assign,\n  boolean,\n  Infer,\n  lazy,\n  literal,\n  object,\n  optional,\n  string,\n  Struct,\n  union,\n  unknown,\n} from 'superstruct';\n\nconst NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type.\n *\n * @property type - The node type.\n */\nexport type Node = Infer<typeof NodeStruct>;\n\nconst ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node with children.\n *\n * @property type - The node type.\n * @property children - The children of this node.\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\nconst LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value.\n *\n * @property type - The node type.\n * @property value - The value of this node.\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  Text = 'text',\n}\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard.\n *\n * @property type - The type of the node, must be the string 'copyable'.\n * @property value - The text to be copied.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = { type: NodeType.Panel; children: Component[] };\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\nexport const ComponentStruct = union([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n"]}